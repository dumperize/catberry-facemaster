/*
 * catberry-example: 0.0.0
 * Build Date: Wed Jan 20 2016 12:53:57 GMT+0400 (SAMT)
 */

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

/**
 * This module is a template and it is used only with some string replaces
 * by BrowserBundleBuilder module. It does not work by itself.
 */

'use strict';

var stores = [

{name: 'Breadcrumps', constructor: require('./catberry_stores/Breadcrumps.js')},
{name: 'Head', constructor: require('./catberry_stores/Head.js')},
{name: 'Pages', constructor: require('./catberry_stores/Pages.js')},
{name: 'Paginator', constructor: require('./catberry_stores/Paginator.js')},
{name: 'Tag', constructor: require('./catberry_stores/Tag.js')},
{name: 'other/News', constructor: require('./catberry_stores/other/News.js')},
{name: 'other/NewsItem', constructor: require('./catberry_stores/other/NewsItem.js')},
{name: 'other/Recommendation', constructor: require('./catberry_stores/other/Recommendation.js')},
{name: 'other/Vacancy', constructor: require('./catberry_stores/other/Vacancy.js')},
{name: 'other/VacancyItem', constructor: require('./catberry_stores/other/VacancyItem.js')},
{name: 'rubrika/Rubrika', constructor: require('./catberry_stores/rubrika/Rubrika.js')},
{name: 'rubrika/Rubrikator', constructor: require('./catberry_stores/rubrika/Rubrikator.js')},
{name: 'rubrika/RubrikatorCompany', constructor: require('./catberry_stores/rubrika/RubrikatorCompany.js')},
{name: 'rubrika/RubrikatorParent', constructor: require('./catberry_stores/rubrika/RubrikatorParent.js')},
{name: 'rubrika/RubrikatorSale', constructor: require('./catberry_stores/rubrika/RubrikatorSale.js')},
{name: 'sale/SaleByRubrika', constructor: require('./catberry_stores/sale/SaleByRubrika.js')},
{name: 'master/MasterItem', constructor: require('./catberry_stores/master/MasterItem.js')},
{name: 'master/MasterList', constructor: require('./catberry_stores/master/MasterList.js')},
{name: 'master/MasterSovety', constructor: require('./catberry_stores/master/MasterSovety.js')},
{name: 'master/MasterVideo', constructor: require('./catberry_stores/master/MasterVideo.js')},
{name: 'master/Recommended', constructor: require('./catberry_stores/master/Recommended.js')}
];

var components = [

{name: 'breadcrumps', constructor: require('./catberry_components/breadcrumps/index.js'), properties: {"name":"breadcrumps","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "        <span class=\\"breadcrumbs__icon\\">\\n            "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "arrow-breadcrumbs", {"name":"icon","hash":{},"data":data})))\n    + "\\n        </span>\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.url : depth0), {"name":"if","hash":{},"fn":this.program(2, data),"inverse":this.program(7, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.links : depth0), {"name":"if","hash":{},"fn":this.program(9, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"2":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.links : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.program(5, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"3":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                <a class=\\"breadcrumbs__level breadcrumbs__level_link js-parent-rub\\">"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</a>\\n";\n},"5":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                <a class=\\"breadcrumbs__level breadcrumbs__level_link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</a>\\n";\n},"7":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "            <span class=\\"breadcrumbs__level\\">"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</span>\\n";\n},"9":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "            <div class=\\"breadcrumbs__list-container js-breadcrumbs-list\\">\\n                <ul class=\\"breadcrumbs__list\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.links : depth0), {"name":"each","hash":{},"fn":this.program(10, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                </ul>\\n            </div>\\n";\n},"10":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                        <li class=\\"breadcrumbs__list-item\\">\\n                            <span class=\\"breadcrumbs__icon\\"></span>\\n                            <a class=\\"breadcrumbs__level breadcrumbs__level_link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</a>\\n                        </li>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"breadcrumbs\\">\\n    <span class=\\"breadcrumbs__header\\">Вы находитесь: </span>\\n";\n  stack1 = helpers.each.call(depth0, depth0, {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</div>";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'catalog-list', constructor: require('./catberry_components/catalog-list/index.js'), properties: {"name":"catalog-list","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "        <li class=\\"catalog-list__item\\">\\n            <a class=\\"catalog-list__item-link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">\\n                <span class=\\"catalog-list__icon\\">\\n                    "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, (depth0 != null ? depth0.ico : depth0), {"name":"icon","hash":{},"data":data})))\n    + "\\n                </span>\\n                ";\n  stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n            </a>\\n        </li>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<ul class=\\"catalog-list_"\n    + escapeExpression(((helper = (helper = helpers[\'data-mod\'] || (depth0 != null ? depth0[\'data-mod\'] : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"data-mod","hash":{},"data":data}) : helper)))\n    + " catalog-list\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.catalogs : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</ul>\\n\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'document', constructor: require('./catberry_components/document/index.js'), properties: {"name":"document","template":"./template.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<!DOCTYPE html>\\n<html lang=\\"en\\">\\n<head cat-store=\\"Head\\"></head>\\n<body>\\n\t<cat-pages-header id=\\"pages-header\\" cat-store=\\"Pages\\"></cat-pages-header>\\n\t<cat-pages-content id=\\"pages-content\\" cat-store=\\"Pages\\"></cat-pages-content>\\n    <cat-pages-footer id=\\"pages-footer\\" cat-store=\\"Pages\\"></cat-pages-footer>\\n</body>\\n</html>\\n";\n  },"useData":true}', errorTemplateSource: null},
{name: 'head', constructor: require('./catberry_components/head/index.js'), properties: {"name":"head","template":"./template.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda;\n  return "<meta charset=\\"UTF-8\\">\\n<title>"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</title>\\n<meta content=\\""\n    + escapeExpression(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"description","hash":{},"data":data}) : helper)))\n    + "\\" name=\\"description\\">\\n<meta content=\\""\n    + escapeExpression(((helper = (helper = helpers.keywords || (depth0 != null ? depth0.keywords : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"keywords","hash":{},"data":data}) : helper)))\n    + "\\" name=\\"keywords\\">\\n<meta content=\\"telephone=no\\" name=\\"format-detection\\">\\n<meta name=\\"robots\\" content=\\"noodp, noydir\\">\\n\\n<meta name=\\"HandheldFriendly\\" content=\\"true\\">\\n<meta http-equiv=\\"X-UA-Compatible\\" content=\\"IE=edge\\">\\n<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1\\">\\n\\n<meta property=\\"og:title\\" content=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.social : depth0)) != null ? stack1.title : stack1), depth0))\n    + "\\">\\n<meta property=\\"og:url\\" content=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.social : depth0)) != null ? stack1.url : stack1), depth0))\n    + "\\">\\n<meta property=\\"og:description\\" content=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.social : depth0)) != null ? stack1.description : stack1), depth0))\n    + "\\">\\n<meta property=\\"og:image\\" content=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.social : depth0)) != null ? stack1.img : stack1), depth0))\n    + "\\">\\n<meta property=\\"og:image:type\\" content=\\"image/jpeg\\">\\n<meta property=\\"og:image:width\\" content=\\"500\\">\\n<meta property=\\"og:image:height\\" content=\\"300\\">\\n<meta property=\\"twitter:description\\" content=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.social : depth0)) != null ? stack1.description : stack1), depth0))\n    + "\\">\\n<link rel=\\"image_src\\" href=\\"\\">\\n<link rel=\\"icon\\" type=\\"image/png\\" href=\\"/img/icon.ico\\">\\n\\n<link href=\\"/css/main.css\\" rel=\\"stylesheet\\">\\n<link href=\\"/css/vendor.min.css\\" rel=\\"stylesheet\\">\\n<script src=\\"/vendor.min.js\\"></script>\\n<script src=\\"/bundle.js\\"></script>\\n<script>svg4everybody();</script>\\n\\n<!--[if lt IE 9 ]><!--<script src=\\"/separate-js/html5shiv-3.7.2.min.js\\" type=\\"text/javascript\\"></script><meta content=\\"no\\" http-equiv=\\"imagetoolbar\\">--><![endif]-->\\n";\n},"useData":true}', errorTemplateSource: null},
{name: 'loader', constructor: require('./catberry_components/loader/index.js'), properties: {"name":"loader","template":"./template.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"loading\\"></div>\\n\\n";\n  },"useData":true}', errorTemplateSource: null},
{name: 'sale', constructor: require('./catberry_components/sale/index.js'), properties: {"name":"sale","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "    <h2>Рубрикатор</h2>\\n\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.rubrikator : depth0), {"name":"each","hash":{},"fn":this.program(2, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "    <h2>Скидки</h2>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.sale : depth0), {"name":"each","hash":{},"fn":this.program(13, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "    <cat-common-paginator id=\\"common-paginator\\" cat-store=\\"Paginator\\" model=\\"sale/SaleByRubrika\\"></cat-common-paginator>\\n";\n},"2":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.active : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"3":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "            <p>"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + " "\n    + escapeExpression(((helper = (helper = helpers.saleCount || (depth0 != null ? depth0.saleCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"saleCount","hash":{},"data":data}) : helper)))\n    + "</p>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.children : depth0), {"name":"each","hash":{},"fn":this.program(4, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n";\n},"4":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.root : depth0), {"name":"if","hash":{},"fn":this.program(5, data),"inverse":this.program(10, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"5":function(depth0,helpers,partials,data) {\n  var stack1, helper, lambda=this.lambda, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing, buffer = "                    <p>---<a href=\\"/sale/catalog/"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.root : depth0)) != null ? stack1.id : stack1), depth0))\n    + "\\">"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.root : depth0)) != null ? stack1.name : stack1), depth0))\n    + "</a> "\n    + escapeExpression(((helper = (helper = helpers.saleCount || (depth0 != null ? depth0.saleCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"saleCount","hash":{},"data":data}) : helper)))\n    + "</p>\\n";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.root : depth0)) != null ? stack1.active : stack1), {"name":"if","hash":{},"fn":this.program(6, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"6":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.child : depth0), {"name":"each","hash":{},"fn":this.program(7, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"7":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "                            <p>\\n                                ------<a href=\\"/sale/catalog/"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</a> "\n    + escapeExpression(((helper = (helper = helpers.saleCount || (depth0 != null ? depth0.saleCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"saleCount","hash":{},"data":data}) : helper)))\n    + "\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.active : depth0), {"name":"if","hash":{},"fn":this.program(8, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                            </p>\\n";\n},"8":function(depth0,helpers,partials,data) {\n  return "                                    активная\\n";\n  },"10":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.child : depth0), {"name":"each","hash":{},"fn":this.program(11, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"11":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                        <p>---<a href=\\"/sale/catalog/"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</a> "\n    + escapeExpression(((helper = (helper = helpers.saleCount || (depth0 != null ? depth0.saleCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"saleCount","hash":{},"data":data}) : helper)))\n    + "</p>\\n";\n},"13":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "        <div>\\n            "\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "\\n        </div>\\n";\n},"15":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "\\n";\n  stack1 = helpers.each.call(depth0, depth0, {"name":"each","hash":{},"fn":this.program(16, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n";\n},"16":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "        <p>"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + " "\n    + escapeExpression(((helper = (helper = helpers.saleCount || (depth0 != null ? depth0.saleCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"saleCount","hash":{},"data":data}) : helper)))\n    + "</p>\\n        <div>\\n            <p>подрубрики:</p>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.children : depth0), {"name":"each","hash":{},"fn":this.program(17, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "        </div>\\n        <div>\\n            <p>акции</p>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.sale : depth0), {"name":"each","hash":{},"fn":this.program(20, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "        </div>\\n        <hr>\\n";\n},"17":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.root : depth0), {"name":"if","hash":{},"fn":this.program(18, data),"inverse":this.program(10, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"18":function(depth0,helpers,partials,data) {\n  var stack1, helper, lambda=this.lambda, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing;\n  return "                    <p>---<a href=\\"/sale/catalog/"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.root : depth0)) != null ? stack1.id : stack1), depth0))\n    + "\\">"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.root : depth0)) != null ? stack1.name : stack1), depth0))\n    + "</a> "\n    + escapeExpression(((helper = (helper = helpers.saleCount || (depth0 != null ? depth0.saleCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"saleCount","hash":{},"data":data}) : helper)))\n    + "</p>\\n";\n},"20":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                <p>"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</p>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "данный hbs сделан так для примера его можно разбить для удобства по блокам\\n\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.currentRubrika : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.program(15, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'search', constructor: require('./catberry_components/search/index.js'), properties: {"name":"search","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return " search_"\n    + escapeExpression(((helper = (helper = helpers.modificator || (depth0 != null ? depth0.modificator : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"modificator","hash":{},"data":data}) : helper)))\n    + " ";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class=\\"search ";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.modificator : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\">\\n    <form class=\\"search__form\\" action=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\" method=\\""\n    + escapeExpression(((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"method","hash":{},"data":data}) : helper)))\n    + "\\">\\n        <div class=\\"search__title\\">\\n            "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "search", {"name":"icon","hash":{},"data":data})))\n    + "\\n        </div>\\n        <div class=\\"search__field\\">\\n            <input class=\\"search__field-input input-text\\" type=\\"text\\" name=\\"search\\">\\n        </div>\\n        <div class=\\"search__button\\">\\n            <button class=\\"search__button-submit\\" type=\\"submit\\">найди услугу</button>\\n        </div>\\n    </form>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'service-request', constructor: require('./catberry_components/service-request/index.js'), properties: {"name":"service-request","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'social', constructor: require('./catberry_components/social/index.js'), properties: {"name":"social","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "    <li class=\\"social__item\\">\\n        <a class=\\"social__item-link link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\" target=\\"_blank\\">\\n            "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, (depth0 != null ? depth0.ico : depth0), "icon_white", {"name":"icon","hash":{},"data":data})))\n    + "\\n        </a>\\n    </li>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<ul class=\\"social\\">\\n";\n  stack1 = helpers.each.call(depth0, depth0, {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</ul>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'common-h1', constructor: require('./catberry_components/_common/common-h1/index.js'), properties: {"name":"common-h1","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "<h1 class=\\"h1 h1_style\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</h1>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'common-paginator', constructor: require('./catberry_components/_common/common-paginator/index.js'), properties: {"name":"common-paginator","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression, buffer = "    <div class=\\"paginator\\">\\n        <span class=\\"paginator__title\\">Перейти к странице: </span>\\n        <ul class=\\"paginator__list\\">\\n            <li class=\\"paginator__page paginator__page_previous\\">\\n                <a class=\\"paginator__number\\" href=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.start : depth0)) != null ? stack1.url : stack1), depth0))\n    + "\\">&lt;</a>\\n            </li>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.list : depth0), {"name":"each","hash":{},"fn":this.program(2, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "            <li class=\\"paginator__page paginator__page_next\\">\\n                <a class=\\"paginator__number\\" href=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.end : depth0)) != null ? stack1.url : stack1), depth0))\n    + "\\">&gt;</a>\\n            </li>\\n        </ul>\\n    </div>\\n";\n},"2":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0[\'is-selected\'] : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.program(5, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"3":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                    <li class=\\"paginator__page paginator__page_selected\\"><span class=\\"paginator__number\\">"\n    + escapeExpression(((helper = (helper = helpers.number || (depth0 != null ? depth0.number : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"number","hash":{},"data":data}) : helper)))\n    + "</span></li>\\n";\n},"5":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                    <li class=\\"paginator__page\\"><a class=\\"paginator__number\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.number || (depth0 != null ? depth0.number : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"number","hash":{},"data":data}) : helper)))\n    + "</a></li>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1;\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0[\'is-paginator\'] : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { return stack1; }\n  else { return \'\'; }\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-filter', constructor: require('./catberry_components/master/master-filter/index.js'), properties: {"name":"master-filter","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "        <div class=\\"filter-section\\">\\n            <a class=\\"filter-section__title filter-section__title_"\n    + escapeExpression(((helper = (helper = helpers.sectionName || (depth0 != null ? depth0.sectionName : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"sectionName","hash":{},"data":data}) : helper)))\n    + " ";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.openSection : depth0), {"name":"if","hash":{},"fn":this.program(2, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += " js-filter-toggle-btn\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">\\n                <div class=\\"filter-section__icon\\">\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.openSection : depth0), {"name":"if","hash":{},"fn":this.program(4, data),"inverse":this.program(6, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                </div>\\n\\n                "\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "\\n\\n                <div class=\\"filter-section__arrow\\">\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.openSection : depth0), {"name":"if","hash":{},"fn":this.program(8, data),"inverse":this.program(10, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                </div>\\n            </a>\\n\\n";\n  stack1 = helpers[\'with\'].call(depth0, (depth0 != null ? depth0.openSection : depth0), {"name":"with","hash":{},"fn":this.program(12, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "        </div>\\n";\n},"2":function(depth0,helpers,partials,data) {\n  return "active";\n  },"4":function(depth0,helpers,partials,data) {\n  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                        "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, (depth0 != null ? depth0.ico : depth0), "icon_white", {"name":"icon","hash":{},"data":data})))\n    + "\\n";\n},"6":function(depth0,helpers,partials,data) {\n  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                        "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, (depth0 != null ? depth0.ico : depth0), {"name":"icon","hash":{},"data":data})))\n    + "\\n";\n},"8":function(depth0,helpers,partials,data) {\n  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                        "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "strelka", "down", {"name":"icon","hash":{},"data":data})))\n    + "\\n";\n},"10":function(depth0,helpers,partials,data) {\n  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                        "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "strelka", {"name":"icon","hash":{},"data":data})))\n    + "\\n";\n},"12":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "                <div class=\\"filter-section__section js-filter-toggle-section\\">\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.sortBy : depth0), {"name":"if","hash":{},"fn":this.program(13, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.tagsGroup : depth0), {"name":"if","hash":{},"fn":this.program(15, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                </div>\\n";\n},"13":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "                        <div class=\\"sort-by\\">\\n                            <p class=\\"sort-by__title\\">Отсортировать: </p>\\n\\n                            <form class=\\"sort-by__form\\" action=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.sortBy : depth0)) != null ? stack1.url : stack1), depth0))\n    + "\\" method=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.sortBy : depth0)) != null ? stack1.method : stack1), depth0))\n    + "\\">\\n                                <div class=\\"filter-radio\\">\\n                                    <input class=\\"filter-radio__input\\" type=\\"radio\\" name=\\"sort-by\\" value=\\"name\\" id=\\"sort-by-name\\">\\n                                    <label class=\\"filter-radio__label\\" for=\\"sort-by-name\\">по фамилии по алфавиту</label>\\n                                </div>\\n                                <div class=\\"filter-radio\\">\\n                                    <input class=\\"filter-radio__input\\" type=\\"radio\\" name=\\"sort-by\\" value=\\"recommendation\\" id=\\"sort-by-recommendation\\">\\n                                    <label class=\\"filter-radio__label\\" for=\\"sort-by-recommendation\\">по количеству\\n                                        рекомендаций</label>\\n                                </div>\\n                            </form>\\n                        </div>\\n";\n},"15":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "                        <div class=\\"filter-by\\">\\n                            <p class=\\"filter-by__title\\">Отфильтровать:</p>\\n\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.tagsGroup : depth0), {"name":"each","hash":{},"fn":this.program(16, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n                        </div>\\n";\n},"16":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.title : depth0), {"name":"if","hash":{},"fn":this.program(17, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.tags : depth0), {"name":"each","hash":{},"fn":this.program(19, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"17":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                                    <p class=\\"filter-by__title\\">"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</p>\\n";\n},"19":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.isActive : depth0), {"name":"if","hash":{},"fn":this.program(20, data),"inverse":this.program(22, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"20":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                                        <span class=\\"filter-by__tag-active\\">\\n                                            "\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "\\n                                            <div class=\\"filter-by__close\\">\\n                                                <a class=\\"filter-by__close-link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.urlBack || (depth0 != null ? depth0.urlBack : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"urlBack","hash":{},"data":data}) : helper)))\n    + "\\">\\n                                                    <div class=\\"filter-by__close-icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "close", {"name":"icon","hash":{},"data":data})))\n    + "</div>\\n                                                </a>\\n                                            </div>\\n                                        </span>\\n";\n},"22":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                                        <a class=\\"filter-by__tag\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.path || (depth0 != null ? depth0.path : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"path","hash":{},"data":data}) : helper)))\n    + "\\">\\n                                            "\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "\\n                                        </a>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"filter\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.filterSection : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</div>";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-list', constructor: require('./catberry_components/master/master-list/index.js'), properties: {"name":"master-list","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "        <div class=\\"master-list__item\\">\\n            <cat-master-minicard id=\\"master-minicard-"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\" master-id=\\""\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\" cat-store=\\"master/MasterList\\"></cat-master-minicard>\\n        </div>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class=\\"master-list\\">\\n";\n  stack1 = helpers.each.call(depth0, depth0, {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "    <div class=\\"wait-spinner\\" id=\\"wait-spinner\\"><div class=\\"wait-spinner__animate\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "spinner", {"name":"icon","hash":{},"data":data})))\n    + "</div></div>\\n</div><!--master-list-->";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-page', constructor: require('./catberry_components/master/master-page/index.js'), properties: {"name":"master-page","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda;\n  return "                    <p class=\\"master-card-mp__company\\">\\n                        <span><img class=\\"master-card-mp__logo\\" src=\\""\n    + escapeExpression(((helpers.imgSrc || (depth0 && depth0.imgSrc) || helperMissing).call(depth0, ((stack1 = (depth0 != null ? depth0.company : depth0)) != null ? stack1.imgID : stack1), (depth0 != null ? depth0.null : depth0), 70, {"name":"imgSrc","hash":{},"data":data})))\n    + "\\" alt=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.company : depth0)) != null ? stack1.name : stack1), depth0))\n    + "\\"></span>\\n                        <span>"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.company : depth0)) != null ? stack1.name : stack1), depth0))\n    + "</span>\\n                    </p>\\n";\n},"3":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "                            "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.phone : stack1), depth0))\n    + "<br>\\n                            <span style=\\"color: red; font-weight: bold\\">workPhone - ERROR!</span>\\n";\n},"5":function(depth0,helpers,partials,data) {\n  return "                            не указано\\n";\n  },"7":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "                            <a class=\\"contacts-mp__anch\\" href=\\"mailto:"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.email : stack1), depth0))\n    + "\\">"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.email : stack1), depth0))\n    + "</a>\\n";\n},"9":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "                            "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.skype : stack1), depth0))\n    + "\\n";\n},"11":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "                            "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.icq : stack1), depth0))\n    + "\\n";\n},"13":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "                            "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.addr : stack1), depth0))\n    + "<br>\\n                            <span class=\\"contacts-mp__onmap\\"><a class=\\"contacts-mp__anch\\" href=\\"#\\">на карте</a> →</span>\\n";\n},"15":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.access : depth0), {"name":"if","hash":{},"fn":this.program(16, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"16":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "                <li>";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.active : depth0), {"name":"if","hash":{},"fn":this.program(17, data),"inverse":this.program(19, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</li>\\n";\n},"17":function(depth0,helpers,partials,data) {\n  var helper, lambda=this.lambda, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing;\n  return "<a href=\\"#master-block-"\n    + escapeExpression(lambda((data && data.key), depth0))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</a>";\n},"19":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "<span>"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</span>";\n},"21":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.access : depth0), {"name":"if","hash":{},"fn":this.program(22, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"22":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.active : depth0), {"name":"if","hash":{},"fn":this.program(23, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"23":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda;\n  return "                    <p class=\\"master-page__section-title\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</p>\\n\\n                    <div class=\\"master-page__section-cont\\">\\n                        <cat-master-block-"\n    + escapeExpression(lambda((data && data.key), depth0))\n    + " id=\\"master-block-"\n    + escapeExpression(lambda((data && data.key), depth0))\n    + "\\" cat-store=\\"master/MasterItem\\" master-page=\\"true\\"></cat-master-block-"\n    + escapeExpression(lambda((data && data.key), depth0))\n    + ">\\n                    </div>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", lambda=this.lambda, buffer = "<div class=\\"master-page\\"><!-- mp - master-page -->\\n    <div class=\\"master-page__row\\">\\n\\n        <div class=\\"master-page__master-card\\">\\n\\n            <div class=\\"master-page__avatar-cont\\">\\n                <img src=\\""\n    + escapeExpression(((helpers.imgSrc || (depth0 && depth0.imgSrc) || helperMissing).call(depth0, (depth0 != null ? depth0.imgID : depth0), {"name":"imgSrc","hash":{},"data":data})))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "\\">\\n                <i class=\\"master-page__like\\" style=\\"color: red; font-weight: bold\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "like", {"name":"icon","hash":{},"data":data})))\n    + " 129</i>\\n            </div>\\n\\n            <div class=\\"master-card-mp\\">\\n                <h1 class=\\"master-card-mp__name\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</h1>\\n\\n                <p class=\\"master-card-mp__spec\\">"\n    + escapeExpression(((helper = (helper = helpers.spec || (depth0 != null ? depth0.spec : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"spec","hash":{},"data":data}) : helper)))\n    + "</p>\\n\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.company : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "\\n\\n                <div class=\\"master-card-mp__master-number\\">\\n                    <p class=\\"master-number\\">\\n                        <span class=\\"master-number__title\\">личный номер Мастера</span>\\n                        <span class=\\"master-number__number\\">№"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.page : depth0)) != null ? stack1.number : stack1), depth0))\n    + "</span>\\n                        <span class=\\"master-number__print\\"><a class=\\"master-number__print\\" href=\\"#\\">распечатать визитку</a></span>\\n                    </p>\\n                </div>\\n            </div>\\n        </div>\\n\\n        <div class=\\"master-page__contact-cont\\">\\n            <div class=\\"contacts-mp\\">\\n                <div class=\\"contacts-mp__cap\\">\\n                    <p>\\n                        <i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "phone", {"name":"icon","hash":{},"data":data})))\n    + "</i><br>\\n                        <span>+7 *** ***-**-**</span>\\n                    </p>\\n\\n                    <a class=\\"contacts-mp__show-contact\\" href=\\"\\">Показать контакты</a>\\n                </div>\\n\\n\\n                <ul class=\\"contacts-mp__list\\">\\n\\n                    <li>\\n                        <i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "phone", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.phone : stack1), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.program(5, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                    </li>\\n\\n                    <li>\\n                        <i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "email", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.email : stack1), {"name":"if","hash":{},"fn":this.program(7, data),"inverse":this.program(5, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                    </li>\\n\\n                    <li><i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "skype", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.skype : stack1), {"name":"if","hash":{},"fn":this.program(9, data),"inverse":this.program(5, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                    </li>\\n\\n                    <li><i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "icq", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.icq : stack1), {"name":"if","hash":{},"fn":this.program(11, data),"inverse":this.program(5, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                    </li>\\n\\n                    <li><i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "placemark", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.addr : stack1), {"name":"if","hash":{},"fn":this.program(13, data),"inverse":this.program(5, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                    </li>\\n                </ul>\\n\\n                <a class=\\"contacts-mp__a-callback js-show-callback-popup\\" href=\\"#callback-request-popup\\">заказать\\n                    звонок</a>\\n            </div>\\n        </div>\\n    </div>\\n\\n    <div class=\\"callback-popup\\">\\n        <form class=\\"callback-popup__form\\" id=\\"callback-request-popup-form\\" method=\\"\\" action=\\"\\">\\n            <input class=\\"callback-popup__input-text\\" type=\\"text\\" placeholder=\\"Ваше имя\\" name=\\"callbackRequestForm[name]\\">\\n            <input class=\\"callback-popup__input-text\\" type=\\"text\\" placeholder=\\"Ваш телефон\\" name=\\"callbackRequestForm[phone]\\">\\n            <textarea class=\\"callback-popup__textarea\\" placeholder=\\"Ваш комментарий\\" name=\\"callbackRequestForm[text]\\"></textarea>\\n            <input class=\\"callback-popup__btn\\" type=\\"submit\\" value=\\"отправить заявку\\">\\n            <span style=\\"color: red; font-weight: bold\\">Отправка формы не работает - ERROR!</span>\\n        </form>\\n        <div class=\\"success_response\\">\\n            Ваша заявка отправлена Мастеру\\n        </div>\\n    </div>\\n\\n    <ul class=\\"menu-mp\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.isBlock : depth0), {"name":"each","hash":{},"fn":this.program(15, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "    </ul>\\n    <!-- menu-mp -->\\n\\n    <div class=\\"master-page__content\\">\\n\\n        <!-- Удалить когда заработают услуги -->\\n        <p class=\\"master-page__section-title\\">Услуги</p>\\n\\n        <div class=\\"master-page__section-cont\\">\\n            <cat-master-block-service id=\\"master-block-service\\" cat-store=\\"master/MasterItem\\" master-page=\\"true\\"></cat-master-block-service>\\n            <!-- ERROR -->\\n            <br>\\n            <p style=\\"color: red; font-weight: bold\\">------ ERROR! (Услуги) ------</p>\\n            !!переделает илья\\n            <!-- ERROR -->\\n        </div>\\n        <!-- Удалить когда заработают услуги - конец -->\\n\\n        <!-- Удалить когда заработают ссылки -->\\n        <p class=\\"master-page__section-title\\">Ссылки</p>\\n\\n        <div class=\\"master-page__section-cont\\">\\n            <cat-master-block-link id=\\"master-block-link\\" cat-store=\\"master/MasterItem\\" master-page=\\"true\\"></cat-master-block-link>\\n            <!-- ERROR -->\\n            <br>\\n            <p style=\\"color: red; font-weight: bold\\">------ ERROR! (Линки) ------</p>\\n            !!переделает илья\\n            <!-- ERROR -->\\n        </div>\\n        <!-- Удалить когда заработают ссылки - конец -->\\n\\n\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.isBlock : depth0), {"name":"each","hash":{},"fn":this.program(21, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "    </div>\\n</div>\\n<!-- master-page -->";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-recommended', constructor: require('./catberry_components/master/master-recommended/index.js'), properties: {"name":"master-recommended","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "    <div class=\\"master_recommended\\">\\n        <h2 class=\\"master_recommended__title\\">\\n            Этих<br>\\n            Мастеров<br>\\n            рекомендуют\\n        </h2>\\n\\n        <div class=\\"master_recommended__slider\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0[\'recommended-master\'] : depth0), {"name":"each","hash":{},"fn":this.program(2, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "        </div>\\n    </div>\\n";\n},"2":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                <a class=\\"master_recommended__master\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers[\'master-url\'] || (depth0 != null ? depth0[\'master-url\'] : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"master-url","hash":{},"data":data}) : helper)))\n    + "\\">\\n                    <img class=\\"master_recommended__master-photo\\" src=\\""\n    + escapeExpression(((helper = (helper = helpers.src || (depth0 != null ? depth0.src : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"src","hash":{},"data":data}) : helper)))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.alt || (depth0 != null ? depth0.alt : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"alt","hash":{},"data":data}) : helper)))\n    + "\\">\\n\\n                    <p class=\\"master_recommended__master-name\\">\\n                        "\n    + escapeExpression(((helper = (helper = helpers[\'master-name\'] || (depth0 != null ? depth0[\'master-name\'] : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"master-name","hash":{},"data":data}) : helper)))\n    + "\\n                    </p>\\n\\n                    <p class=\\"master_recommended__master-recommendations\\">\\n                        "\n    + escapeExpression(((helper = (helper = helpers[\'recommendation-number\'] || (depth0 != null ? depth0[\'recommendation-number\'] : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"recommendation-number","hash":{},"data":data}) : helper)))\n    + "\\n                    </p>\\n                </a>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1;\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0[\'is-recommended-masters\'] : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { return stack1; }\n  else { return \'\'; }\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-rubrika', constructor: require('./catberry_components/master/master-rubrika/index.js'), properties: {"name":"master-rubrika","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, buffer = "        <div class=\\"seo-text\\">\\n            <div class=\\"seo-text__text format\\">\\n                ";\n  stack1 = lambda(((stack1 = (depth0 != null ? depth0.currentSeo : depth0)) != null ? stack1.text : stack1), depth0);\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n            </div>\\n        </div>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, buffer = "<div class=\\"inner-top\\">\\n    <div class=\\"inner-top__title\\">\\n        <cat-common-h1 id=\\"common-h1\\" name=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.currentSeo : depth0)) != null ? stack1.pageTitle : stack1), depth0))\n    + "\\"></cat-common-h1>\\n    </div>\\n\\n    <div class=\\"inner-top__search\\">\\n        <cat-search id=\\"search\\" modificator=\\"inner\\"></cat-search>\\n    </div>\\n    <div class=\\"inner-top__callback\\">\\n        <a class=\\"request\\" href=\\"/request\\">\\n            <div class=\\"request__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "star-in-sun", {"name":"icon","hash":{},"data":data})))\n    + "</div>\\n            Отправить задание мастерам\\n        </a>\\n    </div>\\n</div>\\n<div class=\\"inner-content\\">\\n    <div class=\\"inner-content__left-side\\">\\n        <cat-master-filter id=\\"master-filter\\" cat-store=\\"Tag\\"></cat-master-filter>\\n        { {> banner/banner_side/banner_side banner_side} }\\n    </div>\\n    <div class=\\"inner-content__right-side\\">\\n        <cat-master-recommended id=\\"master-recommended\\" cat-store=\\"master/Recommended\\"></cat-master-recommended>\\n        <cat-master-list id=\\"master-list\\" cat-store=\\"master/MasterList\\"></cat-master-list>\\n    </div>\\n</div>\\n<div class=\\"row\\">\\n";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.currentSeo : depth0)) != null ? stack1.text : stack1), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</div>";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'other-news', constructor: require('./catberry_components/other/other-news/index.js'), properties: {"name":"other-news","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "        <div class=\\"news\\">\\n            <div class=\\"news__inner\\">\\n                <div class=\\"news__img-wr\\">\\n                    <img class=\\"news__img\\" src=\\""\n    + escapeExpression(((helper = (helper = helpers.src || (depth0 != null ? depth0.src : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"src","hash":{},"data":data}) : helper)))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "\\">\\n                </div>\\n                <div class=\\"news__content\\">\\n                    <p class=\\"news__title\\">"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</p>\\n\\n                    <p class=\\"news__intro\\">";\n  stack1 = ((helpers.stripTags || (depth0 && depth0.stripTags) || helperMissing).call(depth0, (depth0 != null ? depth0.preview : depth0), {"name":"stripTags","hash":{},"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</p>\\n\\n                    <p class=\\"news__date\\">"\n    + escapeExpression(((helpers.formatDate || (depth0 && depth0.formatDate) || helperMissing).call(depth0, (depth0 != null ? depth0.date : depth0), "%d %Z %Y", {"name":"formatDate","hash":{},"data":data})))\n    + "</p>\\n\\n                    <a class=\\"news__more\\" href=\\"/news/item/"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\">\\n                        подробнее\\n                        <i class=\\"news__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "strelka", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                    </a>\\n                </div>\\n                <div class=\\"news__autor\\">\\n                    <p>\\n                        Новость добавил: <br> ERROR\\n                        "\n    + escapeExpression(((helper = (helper = helpers.autor || (depth0 != null ? depth0.autor : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"autor","hash":{},"data":data}) : helper)))\n    + "\\n                    </p>\\n                </div>\\n            </div>\\n        </div>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"news-list\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.data : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'other-news-item', constructor: require('./catberry_components/other/other-news-item/index.js'), properties: {"name":"other-news-item","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "\\n<cat-common-h1 id=\\"common-h1\\" name=\\""\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "\\"></cat-common-h1>\\n"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\n"\n    + escapeExpression(((helper = (helper = helpers.img || (depth0 != null ? depth0.img : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"img","hash":{},"data":data}) : helper)))\n    + "\\n"\n    + escapeExpression(((helper = (helper = helpers.date || (depth0 != null ? depth0.date : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"date","hash":{},"data":data}) : helper)))\n    + "\\n"\n    + escapeExpression(((helper = (helper = helpers.preview || (depth0 != null ? depth0.preview : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"preview","hash":{},"data":data}) : helper)))\n    + "\\n";\n  stack1 = ((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'other-recommendation', constructor: require('./catberry_components/other/other-recommendation/index.js'), properties: {"name":"other-recommendation","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "        <div class=\\"recommendation\\">\\n            <div class=\\"recommendation__inner\\">\\n                <div class=\\"recommendation__img-wr\\">\\n                    <img class=\\"recommendation__img\\" src=\\""\n    + escapeExpression(((helper = (helper = helpers.photo || (depth0 != null ? depth0.photo : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"photo","hash":{},"data":data}) : helper)))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "\\">\\n                </div>\\n                <div class=\\"recommendation__content\\">\\n                    <p class=\\"recommendation__title\\">"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</p>\\n\\n                    <div class=\\"recommendation__intro\\">";\n  stack1 = ((helpers.stripStyle || (depth0 && depth0.stripStyle) || helperMissing).call(depth0, (depth0 != null ? depth0.text : depth0), {"name":"stripStyle","hash":{},"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</div>\\n\\n                    <p class=\\"recommendation__date\\">ERROR"\n    + escapeExpression(((helper = (helper = helpers.date || (depth0 != null ? depth0.date : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"date","hash":{},"data":data}) : helper)))\n    + "</p>\\n                </div>\\n            </div>\\n        </div>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"recommendation-list\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.data : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</div>";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "ERROR\\n";\n  },"useData":true}'},
{name: 'other-vacancy', constructor: require('./catberry_components/other/other-vacancy/index.js'), properties: {"name":"other-vacancy","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  return "    <p><strong>Сейчас открыты вакансии:</strong></p>\\n";\n  },"3":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "    <p><a href=\\"/vacancy/item/"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.post || (depth0 != null ? depth0.post : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"post","hash":{},"data":data}) : helper)))\n    + "</a></p>\\n";\n},"5":function(depth0,helpers,partials,data) {\n  return "    <p><strong>Сейчас открытых вакансий нет.</strong></p>\\n";\n  },"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.vacancy : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.vacancy : depth0), {"name":"each","hash":{},"fn":this.program(3, data),"inverse":this.program(5, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'other-vacancy-item', constructor: require('./catberry_components/other/other-vacancy-item/index.js'), properties: {"name":"other-vacancy-item","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class=\\"vacancy-one-page\\">\\n    <h1 class=\\"h1 h1_style\\">"\n    + escapeExpression(((helper = (helper = helpers.post || (depth0 != null ? depth0.post : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"post","hash":{},"data":data}) : helper)))\n    + "</h1>\\n    <img class=\\"vacancy-one-page__img\\" src=\\"/img/other/vacancy.png\\" alt=\\"Наши вакансии\\">\\n    <div class=\\"vacancy-one-page__text format\\">\\n        ";\n  stack1 = ((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "\\n    </div>\\n    <div class=\\"vacancy-one-page__contact format\\">\\n\\n        <!-- ERROR -->\\n        ";\n  stack1 = ((helper = (helper = helpers.contact || (depth0 != null ? depth0.contact : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"contact","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n        <p style=\\"color: red; font-weight: bold\\">------ ERROR! (нет поля contact) ------</p>\\n        <!-- ERROR -->\\n\\n    </div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-catalog', constructor: require('./catberry_components/page/page-catalog/index.js'), properties: {"name":"page-catalog","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"master-rubrikator-page master-rubrikator-page_collapsed\\">\\n\\n    <cat-common-h1 id=\\"common-h1\\" name=\\"Каталог услуг\\"></cat-common-h1>\\n\\n    <div class=\\"row\\">\\n        <div class=\\"master-rubrikator-page__rubriks-columns\\">\\n            <div class=\\"row\\">\\n                <cat-rubrikator-list id=\\"rubrikator-list\\" cat-store=\\"rubrika/Rubrikator\\"></cat-rubrikator-list>\\n            </div>\\n        </div>\\n        <div class=\\"master-rubrikator-page__dop\\">\\n            <p class=\\"master-rubrikator-page__dop-title\\">Другие возможности\\n                в подборе мастера</p>\\n\\n            <div class=\\"master-rubrikator-page__dop-catalogs\\">\\n                <cat-catalog-list id=\\"catalog-list\\" data-mod=\\"page_rubrikator\\"></cat-catalog-list>\\n            </div>\\n        </div>\\n    </div>\\n</div>\\n";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-contact', constructor: require('./catberry_components/page/page-contact/index.js'), properties: {"name":"page-contact","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "<div class=\\"contact-page\\">\\n    <h1 class=\\"h1 h1_style\\">Контакты</h1>\\n\\n    <div class=\\"contact-block\\">\\n        <p class=\\"contact-block__phone\\"><span class=\\"contact-block__name\\">Телефон:</span> "\n    + escapeExpression(((helper = (helper = helpers.phone || (depth0 != null ? depth0.phone : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"phone","hash":{},"data":data}) : helper)))\n    + "</p>\\n        <p class=\\"contact-block__email\\"><span class=\\"contact-block__name\\">E-mail:</span> <a href=\\"mailto:"\n    + escapeExpression(((helper = (helper = helpers.email || (depth0 != null ? depth0.email : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"email","hash":{},"data":data}) : helper)))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.email || (depth0 != null ? depth0.email : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"email","hash":{},"data":data}) : helper)))\n    + "</a></p>\\n        <p class=\\"contact-block__adress\\"><span class=\\"contact-block__name\\">Адрес:</span> "\n    + escapeExpression(((helper = (helper = helpers.adress || (depth0 != null ? depth0.adress : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"adress","hash":{},"data":data}) : helper)))\n    + "</p>\\n    </div>\\n\\n</div>";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-feedback', constructor: require('./catberry_components/page/page-feedback/index.js'), properties: {"name":"page-feedback","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "<div class=\\"feedback-page\\">\\n    <h1 class=\\"h1 h1_style\\">Обратная связь</h1>\\n\\n    <div class=\\"feedback-block\\">\\n        <form class=\\"feedback-block__form\\" id=\\"feedback-form\\" action=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\" method=\\""\n    + escapeExpression(((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"method","hash":{},"data":data}) : helper)))\n    + "\\">\\n            <label>\\n                <span>Ваше имя</span>\\n                <input type=\\"text\\" name=\\"feedback[name]\\" autofocus>\\n            </label>\\n\\n            <label>\\n                <span>Ваш e-mail</span>\\n                <input type=\\"text\\" name=\\"feedback[email]\\">\\n            </label>\\n\\n            <label>\\n                <span>Ваше сообщение</span>\\n                <textarea name=\\"feedback[text]\\"></textarea>\\n            </label>\\n\\n            <input class=\\"btn-accent\\" type=\\"submit\\" value=\\"Отправить\\">\\n        </form>\\n    </div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-login', constructor: require('./catberry_components/page/page-login/index.js'), properties: {"name":"page-login","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda;\n  return "<div class=\\"page-login\\">\\n    <h1 class=\\"h1 h1_style\\">Вход / регистрация</h1>\\n\\n    <form class=\\"login-form\\" method=\\""\n    + escapeExpression(((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"method","hash":{},"data":data}) : helper)))\n    + "\\" action=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">\\n        <input class=\\"login-form__input-text\\" type=\\"text\\" placeholder=\\"Эл. почта или телефон\\" name=\\"loginForm[login]\\">\\n        <input class=\\"login-form__input-text\\" type=\\"password\\" placeholder=\\"Пароль\\" name=\\"loginForm[password]\\">\\n        <label class=\\"login-form__label-checkbox\\"><input type=\\"checkbox\\" id=\\"remember-me\\"><span>Запомнить меня</span></label>\\n        <input class=\\"login-form__btn\\" type=\\"submit\\" value=\\"Войти\\">\\n\\n        <p class=\\"login-form__href-cont\\">\\n            <a class=\\"login-form__recovery\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers[\'recovery-url\'] || (depth0 != null ? depth0[\'recovery-url\'] : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"recovery-url","hash":{},"data":data}) : helper)))\n    + "\\">Забыли пароль?</a>\\n            <a class=\\"login-form__registration\\" href=\\"#\\" id=\\"reg-link\\">Регистрация</a>\\n            <br>\\n        </p>\\n    </form>\\n\\n    <form class=\\"registration-form\\" method=\\""\n    + escapeExpression(((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"method","hash":{},"data":data}) : helper)))\n    + "\\" action=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">\\n        <input class=\\"registration-form__input-text\\" type=\\"email\\" placeholder=\\"Эл. почта\\" name=\\"regForm[login]\\">\\n        <input class=\\"registration-form__input-text\\" type=\\"text\\" placeholder=\\"Имя Фамилия\\" name=\\"regForm[name]\\">\\n        <input class=\\"registration-form__input-text\\" type=\\"password\\" placeholder=\\"Пароль\\" name=\\"regForm[password]\\">\\n\\n        <div class=\\"registration-form__capcha registration-form__capcha_registration\\">\\n            <div class=\\"registration-form__code-img\\">\\n                <img src=\\"img/assets/recovery-password/captcha.png\\" alt=\\"capcha\\">\\n            </div>\\n            <a class=\\"registration-form__reload-link\\" href=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.capcha : depth0)) != null ? stack1[\'reload-url\'] : stack1), depth0))\n    + "\\">Получить новый код</a>\\n        </div>\\n\\n        <input class=\\"registration-form__input-text\\" type=\\"text\\" placeholder=\\"Код с картинки\\" name=\\"regForm[code]\\">\\n        <input class=\\"registration-form__btn registration-form__btn_long-text\\" type=\\"submit\\" value=\\"Зарегистрироваться\\">\\n        <p class=\\"registration-form__entry\\"><a href=\\"#\\" id=\\"entry-link\\">Войти</a></p>\\n    </form>\\n\\n    <form class=\\"recovery-pass-form\\" method=\\""\n    + escapeExpression(((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"method","hash":{},"data":data}) : helper)))\n    + "\\" action=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">\\n        <input class=\\"recovery-pass-form__input-text\\" type=\\"text\\" placeholder=\\"Эл. почта или телефон\\" name=\\"recovery-password[login]\\" autofocus>\\n\\n        <div class=\\"recovery-pass-form__capcha recovery-pass-form__capcha_registration\\">\\n            <div class=\\"recovery-pass-form__code-img\\">\\n                <img src=\\"img/assets/recovery-password/captcha.png\\" alt=\\"capcha\\">\\n            </div>\\n            <a class=\\"recovery-pass-form__reload-link\\" href=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.capcha : depth0)) != null ? stack1[\'reload-url\'] : stack1), depth0))\n    + "\\">Получить новый код</a>\\n        </div>\\n\\n        <input class=\\"recovery-pass-form__input-text\\" type=\\"text\\" placeholder=\\"Код с картинки\\" name=\\"recovery-password[code]\\">\\n        <input class=\\"recovery-pass-form__btn\\" type=\\"submit\\" value=\\"Восстановить\\">\\n    </form>\\n\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-main', constructor: require('./catberry_components/page/page-main/index.js'), properties: {"name":"page-main","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"main-page\\">\\n    <cat-main-function id=\\"main-function\\"></cat-main-function>\\n    <cat-dop-function id=\\"dop-function\\"></cat-dop-function>\\n</div>\\n";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-master-page', constructor: require('./catberry_components/page/page-master-page/index.js'), properties: {"name":"page-master-page","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<h1 class=\\"h1 h1_style\\">Страница Мастера</h1>\\n<cat-master-page id=\\"master-page\\" cat-store=\\"master/MasterItem\\"></cat-master-page>\\n";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-master-rubrika', constructor: require('./catberry_components/page/page-master-rubrika/index.js'), properties: {"name":"page-master-rubrika","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"container\\">\\n    <cat-master-rubrika id=\\"master-rubrika\\" cat-store=\\"Tag\\"></cat-master-rubrika>\\n</div>";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-news', constructor: require('./catberry_components/page/page-news/index.js'), properties: {"name":"page-news","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"page_oth_news\\">\\n    <cat-common-h1 id=\\"common-h1\\" name=\\"Новости\\"></cat-common-h1>\\n\\n    <div class=\\"page_oth_news__list\\">\\n        <cat-other-news id=\\"other-news\\" cat-store=\\"other/News\\"></cat-other-news>\\n        <cat-common-paginator id=\\"common-paginator\\" cat-store=\\"Paginator\\" model=\\"other/News\\"></cat-common-paginator>\\n    </div>\\n</div>";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-news-item', constructor: require('./catberry_components/page/page-news-item/index.js'), properties: {"name":"page-news-item","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"page_oth_news\\">\\n    <cat-other-news-item id=\\"other-news\\" cat-store=\\"other/NewsItem\\"></cat-other-news-item>\\n</div>";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-oferta', constructor: require('./catberry_components/page/page-oferta/index.js'), properties: {"name":"page-oferta","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"oferta-page\\">\\n\\n    <h1 class=\\"h1 h1_style\\">ОФЕРТА от 01.03.2015 </h1>\\n\\n    <div class=\\"oferta\\">\\n        <p><strong>на пользование Услугами Сайта www.facemaster.ru</strong></p>\\n\\n        <p>ЗАО «ФейсМастер.ру», именуемое в дальнейшем «Компания», предоставляет любому лицу услуги по использованию\\n            сайта Компании в личных целях посредством предоставления сервисов сайта на приведенных ниже условиях.</p>\\n\\n        <p>Безусловным принятием (акцептом) условий настоящей оферты считается пользование Сайтом <strong>http://www.facemaster.ru</strong>,\\n            включая просмотр страниц Сайта, не зависимо от прохождения процедуры Регистрации.</p>\\n\\n        <p>Настоящая Оферта может быть изменена по усмотрению Компании в любое время без какого-либо специального\\n            уведомления об этом Пользователя. Новая редакция Оферты, изменения и дополнения к ней вступают в силу с\\n            момента их размещения на Сайте. Регулярное ознакомление с действующей редакцией Оферты является обязанностью\\n            Пользователя. Пользование Сайтом после вступления в силу новой редакции Оферты, дополнений и изменений к ней\\n            означает согласие Пользователя со всеми такими изменениями или дополнениями, новой редакцией Оферты.</p>\\n\\n        <br>\\n\\n        <p><strong>1. ТЕРМИНЫ и ОБОЗНАЧЕНИЯ</strong></p>\\n\\n        <p><strong>Компания</strong> – ЗАО «ФейсМастер.ру»: ОГРН 1136320020825 ИНН 6321323406, Юридический адрес:\\n            445056, г.Тольятти, ул.Автостроителей, 41А, корп.1<br>\\n            <br>\\n            <strong>Пользователь/Клиент</strong> – дееспособное, в возрасте от 18 лет, физическое лицо/правоспособное\\n            юридическое лицо, прошедшие Регистрацию на сайте Компании, имеющие все правовые полномочия в соответствии с\\n            действующим законодательством РФ на заключение Оферты и иных сопутствующих документов для использования\\n            возможностей Сайта Компании.<br>\\n            <br>\\n            <strong>Сайт</strong> – Интернет-сайт, размещенный в сети Интернет по адресу: www.facemaster.ru, включающий\\n            в себя комплекс элементов: программы для ЭВМ, базы данных, интерфейс (дизайн), как в совокупности, так и\\n            отдельные элементы дизайна, и др.<br>\\n            <br>\\n            <strong>Гость</strong> – любое лицо, не прошедшее Регистрацию, имеющее возможность просматривать страницы\\n            Сайта и Информацию, размещенную Пользователями для общего доступа.<br>\\n            <br>\\n            <strong>Регистрация</strong> – комплекс действий по принятию оферты, размещенной на Сайте, созданию Личного\\n            кабинета, путем ввода учетных данных и иных необходимых сведений, и получению права на пользование Услугами\\n            Интернет-сайта.<br>\\n            <br>\\n            <strong>Учетные данные </strong>— уникальный логин (номер телефона) и пароль, создаваемые в процессе\\n            Регистрации на Сайте, используемые для доступа Пользователя/Клиента в Личный кабинет путем Авторизации.<br>\\n            <br>\\n            <strong>Авторизация</strong> — идентификация Пользователя/Клиента посредством введения в соответствующие\\n            поля на Сайте Учетных данных.<br>\\n            <br>\\n            <strong>Личный кабинет </strong>— персональная страница Пользователя/Клиента, формируемая после Регистрации,\\n            доступ к которой предоставляется Пользователю/Клиенту в результате Авторизации.<br>\\n            <br>\\n            <strong>Оферта</strong> – настоящее предложение Компании, адресованное неопределенному кругу лиц, содержащее\\n            правила и условия пользования Услугами Сайта, а также права и обязанности Пользователей/Клиентов\\n            обязательные для исполнения при размещении Информации на Сайте для общего доступа.<br>\\n            <br>\\n            <strong>Услуги</strong> - возможности (права), предоставляемые Компанией и позволяющие\\n            Пользователю/Клиенту/Гостю размещать, осуществлять поиск и просмотр Информации, а также любые иные\\n            возможности и функции, доступные на Сайте. <strong>Бесплатные услуги</strong> – базовый набор услуг,\\n            предоставляемый без взимания платы. <strong>Платные услуги</strong> – набор дополнительных услуг, за\\n            использование которых взимается плата согласно тарифам Компании.</p>\\n\\n        <p><strong>Информация – </strong>услуги и предложения Пользователя/Клиента, сведения о которых он размещает на\\n            Сайте, адресованные и доступные неопределенному кругу лиц (Гостям и/или другим Пользователям).<br>\\n            <br>\\n            <strong>Договор</strong> – соглашение, формируемое при Регистрации Пользователя/Клиента и вступающее в силу\\n            в момент оплаты первого счета за Услуги.</p>\\n\\n        <br>\\n\\n        <p><strong>2. ОБЩИЕ ПОЛОЖЕНИЯ</strong></p>\\n\\n        <p>2.1 Компания предоставляет Пользователю/Клиенту/Гостю на условиях настоящей Оферты, Договора и Дополнительных\\n            соглашений, приложений право на пользование Услугами Сайта с возможностью размещать, осуществлять поиск и\\n            просмотр Информации других Пользователей\\\Клиентов.<br>\\n            2.2 Все сделки: «Пользователь/Клиент – Пользователь/Клиент» либо «Пользователь/Клиент – Гость» заключаются\\n            напрямую. При этом, Компания не является участником таких сделок, а предоставляет лишь коммуникационную\\n            платформу для Информации Пользователей/Клиентов.<br>\\n            2.3 Услуги не предоставляются и не должны использоваться лицами младше 18 лет, лицами признанными\\n            недееспособными, а также ограниченно дееспособными лицами. Лица, не достигшие 18 лет, или лица, признанные\\n            недееспособными или ограничено дееспособными, могут пользоваться Услугами только с согласия своих законных\\n            представителей.</p>\\n\\n        <br>\\n\\n        <p><strong>3. ПРАВИЛА ПОЛЬЗОВАНИЯ САЙТОМ</strong></p>\\n\\n        <p>3.1. Гость вправе просматривать Информацию Пользователей/Клиентов, находящуюся в открытом доступе, и\\n            воспользоваться услугами, содержащимися в Информации, без Регистрации на Сайте.<br>\\n            3.2. Пользователь/Клиент получает право воспользоваться Услугами Сайта по размещению Информации для доступа\\n            к ней неопределенного круга лиц, после прохождения процедуры Регистрации – для Бесплатных Услуг, а также,\\n            дополнительно, после оформления Договора, листа заказа и оплаты счета - для Платных Услуг.<br>\\n            3.3. При Регистрации, а также оформлении договора и листа заказа Пользователь/Клиент заполняет все\\n            необходимые поля специальных форм. Не заполнение хотя бы одного обязательного поля (в т.ч. ввод некорректных\\n            данных) влечет недействительность регистрации либо листа заказа.<br>\\n            3.4. После прохождения Регистрации Пользователь/Клиент получает на указанный им номер мобильного телефона\\n            ПАРОЛЬ, который в дальнейшем используется Пользователем/Клиентом для Авторизации и входа в Личный\\n            кабинет.<br>\\n            3.5. Пользователь/Клиент несет полную ответственность за все действия с использованием его Логина (номер\\n            мобильного телефона) и Пароля. Пользователь/Клиент имеет право пользоваться Услугами Сайта только при помощи\\n            собственного номера мобильного телефона и пароля.<br>\\n            3.6. При пользовании Сайтом <strong>ЗАПРЕЩЕНО:</strong><br>\\n            - использовать автоматические программы для получения доступа на Сайт;<br>\\n            - использовать компьютерные программы, позволяющие размещать на Сайте Информацию, минуя обычный порядок\\n            размещения (к примеру использование программ по автозагрузке Информации);<br>\\n            - предпринимать какие-либо действия, которые могут привести к непропорционально большой нагрузке на\\n            инфраструктуру Сайта;<br>\\n            - копировать, воспроизводить, изменять, распространять и представлять общественности любую информацию,\\n            содержащуюся на Сайте (кроме Сведений, предоставленных самим Пользователем/Клиентом) без предварительного\\n            письменного разрешения Компании;<br>\\n            - препятствовать работе Сайта, а также препятствовать действию автоматических систем или процессов, с целью\\n            воспрепятствовать или ограничить доступ на Сайт;<br>\\n            - использовать сведения, предоставленные другим Пользователем/Клиентом, без письменного разрешения\\n            Пользователя/Клиента, разместившего такие сведения, или без подтверждения каким-либо другим способом права\\n            использовать такие сведения. Все сведения, полученные Пользователем/Клиентом о других Пользователях в связи\\n            с использованием Сайта, могут быть использованы только для совершения и исполнения сделок в отношении услуг,\\n            содержащихся в Информации Пользователей/Клиентов. Таким образом, Пользователю/Клиенту не разрешается\\n            использовать электронный адрес, ровно, как и номер телефона другого Пользователя/Клиента для целей прямой\\n            рекламной рассылки или другой рассылки нежелательных электронных сообщений, а также для иных противоправных\\n            действий или действий, совершаемых без ведома и/или согласия другой стороны;<br>\\n            - нарушать информационную безопасность Сайта;<br>\\n            - внедрять исполняемый код на стороне Пользователя/Клиента, любые внедряемые объекты, использовать frame и\\n            iframe, каскадные таблицы стилей, html-код;<br>\\n            - представляться чужим именем или от чужого имени — зарегистрированного на Сайте Пользователя/Клиента,\\n            сотрудника Компании. Вводить в заблуждение других Пользователей\\\Клиентов и администрацию Сайта относительно\\n            своей идентификации любым иным способом<br>\\n            - размещать дублирующую Информацию одного Пользователя/Клиента с использованием разных E-mail и номеров\\n            мобильных телефонов;<br>\\n            - использовать Услуги Сайта для незаконной деятельности либо деятельности, которая может привести к\\n            нарушению Компанией и/или Пользователем/Клиентом действующего законодательства РФ.</p>\\n\\n        <br>\\n\\n        <p><strong>4. ПРАВА И ОБЯЗАННОСТИ ПОЛЬЗОВАТЕЛЯ/КЛИЕНТА</strong></p>\\n\\n        <p>4.1.&nbsp;&nbsp;&nbsp; Пользователь/Клиент обязуется:<br>\\n            4.1.1. Соблюдать требования, определенные в настоящей Оферте, Договоре, листе заказа и иных документах,\\n            определяющих пользование Сайтом.<br>\\n            4.1.2. При Регистрации на Сайте использовать только реальные данные о себе и размещаемой Информации.<br>\\n            4.1.3. Следить за сохранностью своего Пароля и не раскрывать его посторонним лицам.<br>\\n            4.1.4. Не передавать или продавать свои Учетные данные для Авторизации на Сайте третьим лицам.<br>\\n            4.1.5. При размещении Информации соблюдать требования действующего законодательства РФ, в т.ч. ФЗ «О\\n            рекламе» от 13.03.2006г. № 38-ФЗ.<br>\\n            4.1.6. Предоставить, по требованию Компании, документально подтверждённые сведения о соответствии Информации\\n            требованиям действующего законодательства РФ, в том числе надлежащим образом заверенные копии дипломов,\\n            лицензий, сертификатов, свидетельств о регистрации, в случае если услуги подлежат лицензированию,\\n            обязательной сертификации, государственной регистрации.<br>\\n            4.1.7. Не размещать Информацию, входящую в «Список запрещенной к размещению Информации».<br>\\n            4.1.8. Не уничтожать и/или не изменять любые материалы на Сайте, автором которых Пользователь/Клиент не\\n            является.<br>\\n            4.1.9. Заполнить все необходимые формы и предоставить только свое Фото (Пользователя)/Логотип (Клиента).\\n            Информация, содержащая лицензируемые виды деятельности, должна содержать номер лицензии. 4.1.10. Размещать\\n            Информацию, соответствующую по содержанию выбранной Рубрике/подрубрике.<br>\\n            4.1.11. Оплачивать Платные Услуги Компании в порядке и сроки, определенные Офертой, Договором и листом\\n            заказа.<br>\\n            4.2.  Пользователь/Клиент имеет право:<br>\\n            4.2.1 Получать право воспользоваться Платными Услугами Сайта после полной оплаты счета, выставленного при\\n            оформлении листа заказа на данные Услуги.<br>\\n            4.2.2. Воспользоваться услугами менеджеров Компании для оказания помощи при Регистрации, как по телефону: +7\\n            (8482) 74-44-19, так и непосредственно при встрече.<br>\\n            4.2.3. Размещать Информацию об услугах, которые Пользователь/Клиент может оказывать, имея соответствующие\\n            навыки, образование и разрешения. 4.2.4. Разрешить оплату счета за Платные Услуги третьему лицу\\n            (Плательщику) с учетом требований действующего законодательства и оформленного договора. 4.3. Компания\\n            обязуется:<br>\\n            4.3.1. Предоставить Пользователю/Клиенту право пользоваться Услугами Сайта в порядке и сроки, определенными\\n            в Оферте, Договоре и листе заказа.<br>\\n            4.3.2. Предоставить возможность Пользователям/Клиентам управлять доступом к своим персональным данным и\\n            размещенной Информации.<br>\\n            4.4.&nbsp;&nbsp;&nbsp;  Компания имеет право:<br>\\n            4.4.1. Удалить Информацию, заблокировать доступ/удалить Учетные данные Пользователей/Клиентов, нарушивших\\n            положения настоящей Оферты, Договора и листа заказа, без извещения Пользователя/Клиента.</p>\\n\\n        <br>\\n\\n        <p><strong>5. ИНФОРМАЦИЯ, ЗАПРЕЩЕННАЯ К РАЗМЕЩЕНИЮ</strong></p>\\n\\n        <p>5.1. Пользователю/Клиенту запрещено размещать, а в случае размещения, подлежит удалению Информация,\\n            содержащая:</p>\\n\\n        <ul>\\n            <li>\\n                <p>ложные, неточные или вводящие в заблуждение сведения;</p>\\n            </li>\\n            <li>\\n                <p>сведения, способствующие мошенничеству, обману или злоупотреблению доверием;</p>\\n            </li>\\n            <li>\\n                <p>оскорбления чьей-либо чести, достоинства или деловой репутации, нарушения частной жизни;</p>\\n            </li>\\n            <li>\\n                <p>клевету или угрозы кому бы то ни было;</p>\\n            </li>\\n            <li>\\n                <p>нарушения интеллектуальных прав третьих лиц, прав на изображение гражданина, и иные права третьих\\n                    лиц;</p>\\n            </li>\\n            <li>\\n                <p>призывы к совершению преступления и разжиганию межнациональной розни;</p>\\n            </li>\\n            <li>\\n                <p>сведения, способствующие, поддерживающие или призывающие к террористической и экстремистской\\n                    деятельности;</p>\\n            </li>\\n            <li>\\n                <p>сведения непристойные, либо носящие характер порнографии;</p>\\n            </li>\\n            <li>\\n                <p>компьютерные вирусы, а также иные компьютерные программы, направленные, в частности, на нанесение\\n                    вреда, неуполномоченное вторжение, тайный перехват либо присвоение данных любой системы либо самой\\n                    системы, либо ее части, либо личной информации или иных данных (включая данные Компании);</p>\\n            </li>\\n            <li>\\n                <p>Сведения, причиняющие вред Компании, став причиной полной либо частичной потери Компанией услуг\\n                    провайдеров сети интернет, либо услуг любых иных лиц;</p>\\n            </li>\\n            <li>\\n                <p>сведения, иным образом нарушающие действующее законодательство РФ.</p>\\n            </li>\\n        </ul>\\n\\n        <p>5.2. Удаление Информации производится Компанией в любое время без извещения Пользователя/Клиента.</p>\\n\\n        <br>\\n\\n        <p><strong>6. ОПЛАТА ПЛАТНЫХ УСЛУГ</strong></p>\\n\\n        <p>6.1. После оформления листа заказа на пользование Платными Услугами Сайта Пользователь/Клиент либо Плательщик\\n            (при наличии), получает счет и выбирает способ его оплаты из предложенного на Сайте списка. Счет необходимо\\n            оплатить в указанный в нем срок. 6.2. Срок пользования Платными Услугами начинается с даты оплаты счета.\\n            Если при Регистрации не были заполнены обязательные поля или поля были заполнены некорректно, не была\\n            загружена фотография или иным образом нарушены правила Регистрации, Информация не отражается на Сайте до\\n            момента внесения соответствующих исправлений, при этом срок начала пользования Платными Услугами не\\n            продляется на срок, в течение которого Информация не отображалась на Сайте по вине Пользователя/Клиента.\\n            6.3. Каждый способ оплаты сопровождается подробной инструкцией, размещенной на Сайте. При этом Компания не\\n            несет ответственность за действия Пользователя/Клиента/Плательшика при оплате счета, в следствие которых\\n            денежные средства не поступили на счет Компании, и эти суммы Компания не компенсирует и не возвращает.<br>\\n            6.4. Оплата Услуг сайта производится в порядке 100% предоплаты. Услуги считаются оплаченными в момент\\n            извещения Компании об оплате счета. Валютой расчетов является Российский рубль.<br>\\n            6.5. В случае отказа Пользователя/Клиента от оплаченных Услуг Сайта до окончания срока пользования денежные\\n            средства не возвращаются.</p>\\n\\n        <br>\\n\\n        <p><strong>7. ОГРАНИЧЕНИЯ ОТВЕТСТВЕННОСТИ</strong></p>\\n\\n        <p>7.1. В соответствии с требованиями Федерального закона от 27.07.2006 г. № 152-ФЗ «О персональных данных»: в\\n            процессе пользования Услугами Сайта (в том числе при Регистрации, взаимодействии с другими\\n            Пользователями/Клиентами через интерфейс Сайта, размещении Информации, просмотре страниц Сайта и т.п.),\\n            Пользователь самостоятельно добровольно принимает решение о предоставлении Компании персональных и иных\\n            данных о Пользователе (фамилия, имя, отчество, адрес электронной почты, номер мобильного телефона, а также\\n            любая иная информация, предоставленная Пользователем, информация о действиях Пользователя на Сайте и пр.)\\n            для целей исполнения Оферты, а также настоящим заявляет о своем согласии на обработку и хранение Компанией\\n            персональных и иных данных Пользователя, их передачу для обработки другим Пользователям и/или третьим лицам,\\n            действующим по поручению Компании, в том числе для целей: получения статистических и аналитических данных\\n            для улучшения функционирования Сайта и/или Услуг, расширения спектра оказываемых Услуг, получения\\n            информационных и/или рекламных сообщений Компании или третьих лиц, предупреждения или пресечения незаконных\\n            и/или несанкционированных действий Пользователей или третьих лиц, обеспечения соблюдения требований\\n            действующего законодательства Российской Федерации. Компания принимает все необходимые меры для защиты\\n            персональных данных Пользователя от несанкционированного доступа третьих лиц<br>\\n            7.2. Компания не отвечает за возможное нецелевое использование информации с Сайта Пользователями/Клиентами\\n            или иными лицами и/или организациями, которое произошло без уведомления Компании с нарушением или без\\n            информационной безопасности Сайта.<br>\\n            7.3. Компания прилагает все возможные усилия для того, чтобы избежать несанкционированного использования\\n            третьими лицами персональных данных Пользователей/Клиентов. Но Компания также не несет ответственности за\\n            возможное нецелевое использование персональных данных пользователей/Клиентов, произошедшее в случае:<br>\\n            - технических неполадок в программном обеспечении, серверах или компьютерных сетях, находящихся вне контроля\\n            Компании;<br>\\n            - перебоев в работе Сайта, связанных с намеренным или ненамеренным использованием Сайта не по назначению\\n            третьими лицами;<br>\\n            - передачи паролей или информации с Сайта Пользователями/Клиентами другим лицам, не являющимися\\n            зарегистрированными пользователями Сайта или другим пользователям, не имеющим доступа к данной информации в\\n            силу условий регистрации и заключенных договоров с Компанией.<br>\\n            7.4. Каждый Пользователь/Клиент отвечает за Информацию, размещаемую от его имени, и за последствия этого\\n            размещения.<br>\\n            7.5. Пользователь/Клиент самостоятельно, по своему усмотрению и вне контроля со стороны Компании размещает\\n            Информацию на Сайте, Пользователь/Клиент несет ответственность как рекламодатель и рекламораспространитель в\\n            отношении всей размещенной им Информации в соответствии с ФЗ \\"О рекламе\\" и КоАП РФ.<br>\\n            7.6. Пользователь/Клиент самостоятельно несет ответственность за достоверность размещаемой Информации и\\n            качество предоставляемых им услуг, которые содержатся в Информации, а также освобождает Компанию от всех\\n            требований, обязательств, компенсаций по возмещению ущерба, убытков, затрат и издержек, включая судебные и\\n            иные расходы, возникшие в результате или в связи с требованиями третьих лиц.</p>\\n\\n        <br>\\n\\n        <p><strong>8. ЗАКЛЮЧИТЕЛЬНЫЕ ПОЛОЖЕНИЯ</strong></p>\\n\\n        <p>8.1 Пользователь/Клиент предоставляет Компании право использовать сведения, содержащиеся в Информации\\n            Пользователя/Клиента, для целей оказания Услуг, путем передачи Компании не эксклюзивного, действующего\\n            повсеместно, бессрочного права относительно авторских прав, торговых марок, логотипов, публикаций и баз\\n            данных, которое имеет Пользователь/Клиент и предоставленных им на всех известных или не известных\\n            информационных носителях.<br>\\n            8.2. Настоящая Оферта начинает действовать и, считается, безусловно принятой\\n            Пользователем\\\Клиентом\\\Гостем\\\плательщиком с момента начала пользования Услугам Сайта, независимо от факта\\n            Регистрации, и действует бессрочно.<br>\\n            8.3. Пользователь/Клиент вправе отказаться от пользования Услугами Сайта, после чего размещение Информации\\n            на Сайте от данного Пользователя/Клиента невозможно.<br>\\n            8.4. Компания оставляет за собой право по собственному усмотрению прекратить доступ к Услугам\\n            Пользователя/Клиента, нарушающего Оферту, Договор либо лист заказа. Пользователь/Клиент, доступ которого к\\n            Услугам был прекращен, или Информация которого перестала быть действительной, не имеет права\\n            регистрироваться повторно без соответствующего согласия Компании, а также такой Пользователь/Клиент не имеет\\n            права использовать для доступа на Сайт Учетные данные другого Пользователя/Клиента.<br>\\n            8.5. Споры, возникающие в ходе пользования Сайтом, разрешаются с соблюдением обязательного претензионного\\n            порядка. Срок ответа на претензию 15 дней со дня получения претензии. В случае неудовлетворения претензии\\n            полностью или в какой-либо части, а также в случае неполучения ответа на претензию в установленный срок,\\n            заинтересованная сторона вправе обратиться за разрешением спора в суд с территориальной подсудностью\\n            Компании.<br>\\n            8.6. В случае признания судом отдельных положений настоящей Оферты недействительными, остальные условия\\n            Оферты продолжают действовать.\\n        </p>\\n        <br>\\n    </div>\\n</div>\\n";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-recommendation', constructor: require('./catberry_components/page/page-recommendation/index.js'), properties: {"name":"page-recommendation","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"page_oht_recommendation\\">\\n    <cat-common-h1 id=\\"common-h1\\" name=\\"Мастера о сайте\\"></cat-common-h1>\\n\\n    <div class=\\"page_oht_recommendation__list\\">\\n\\n        <cat-other-recommendation id=\\"other-recommendation\\" cat-store=\\"other/Recommendation\\"></cat-other-recommendation>\\n        <cat-common-paginator id=\\"common-paginator\\" cat-store=\\"Paginator\\" model=\\"other/Recommendation\\"></cat-common-paginator>\\n\\n    </div>\\n</div>";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-registration', constructor: require('./catberry_components/page/page-registration/index.js'), properties: {"name":"page-registration","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<cat-registration-header id=\\"registration-header\\"></cat-registration-header>\\n<div id=\\"form1\\">\\n    <cat-registration-form id=\\"registration-form-1\\"></cat-registration-form>\\n</div>\\n<cat-registration-about id=\\"registration-about\\"></cat-registration-about>\\n<cat-registration-why-we id=\\"registration-why-we\\"></cat-registration-why-we>\\n<cat-registration-price id=\\"registration-price\\"></cat-registration-price>\\n<div id=\\"form2\\">\\n    <cat-registration-form id=\\"registration-form-2\\"></cat-registration-form>\\n</div>\\n<cat-registration-more-page id=\\"registration-more-page\\"></cat-registration-more-page>\\n<cat-registration-faq id=\\"registration-faq\\"></cat-registration-faq>\\n<div id=\\"form3\\">\\n    <cat-registration-form id=\\"registration-form-3\\"></cat-registration-form>\\n</div>";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-request', constructor: require('./catberry_components/page/page-request/index.js'), properties: {"name":"page-request","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "<div class=\\"callback_request\\">\\n<h1 class=\\"h1 h1_style\\">Заявка мастеру</h1>\\n\\n    <form class=\\"callback_request__form\\" method=\\""\n    + escapeExpression(((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"method","hash":{},"data":data}) : helper)))\n    + "\\" action=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\" id=\\"callback-request-form\\">\\n        <p class=\\"callback_request__intro\\">Опишите вашу задачу</p>\\n\\n        <div class=\\"callback_request__input\\">\\n            <textarea class=\\"textarea\\" placeholder=\\"Я хочу (отремонтировать, организовать, установить, доставить)\\" name=\\"callbackRequestForm[text]\\"></textarea>\\n        </div>\\n        <p class=\\"callback_request__intro\\">\\n            Оставьте ваши контакты\\n        </p>\\n\\n        <div class=\\"callback_request__input\\">\\n            <input class=\\"input-text\\" type=\\"text\\" placeholder=\\"Ваше имя\\" name=\\"callbackRequestForm[name]\\">\\n        </div>\\n        <div class=\\"callback_request__input\\">\\n            <input class=\\"input-text\\" type=\\"text\\" placeholder=\\"Ваш телефон\\" name=\\"callbackRequestForm[phone]\\">\\n        </div>\\n        <div class=\\"callback_request__input\\">\\n            <input class=\\"input-text\\" type=\\"text\\" placeholder=\\"Ваш email\\" name=\\"callbackRequestForm[email]\\">\\n        </div>\\n        <div class=\\"callback_request__submit\\">\\n            <input class=\\"btn-accent\\" type=\\"submit\\" value=\\"отправить заявку\\">\\n        </div>\\n    </form>\\n    <div class=\\"success_response\\">Ваша заявка отправлена</div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-sale', constructor: require('./catberry_components/page/page-sale/index.js'), properties: {"name":"page-sale","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<cat-sale id=\\"sale\\" cat-store=\\"sale/SaleByRubrika\\"></cat-sale>";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-sovety', constructor: require('./catberry_components/page/page-sovety/index.js'), properties: {"name":"page-sovety","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\nСоветы каталог";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-vacancy', constructor: require('./catberry_components/page/page-vacancy/index.js'), properties: {"name":"page-vacancy","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"vacancy-page\\">\\n    <h1 class=\\"h1 h1_style\\">Наши вакансии</h1>\\n    <img class=\\"vacancy-page__img\\" src=\\"/img/other/vacancy.png\\" alt=\\"Наши вакансии\\">\\n\\n    <p class=\\"vacancy-page__text\\">\\n        Мы - молодой коллектив единомышленников, если у Вас есть желание работать в нашей компании, то присоединяйтесь к\\n        нам, участвуйте в создании нового интересного продукта. Вместе с нами вы сможете воплотить свои самые смелые\\n        идеи, раскрыть свой творческий потенциал и реализоваться в карьерном плане. Мы ищем целеустремленных и уверенных\\n        специалистов, которые верят в свои силы и успех.\\n    </p>\\n\\n    <cat-other-vacancy id=\\"other-vacancy\\" cat-store=\\"other/Vacancy\\"></cat-other-vacancy>\\n</div>\\n";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-vacancy-item', constructor: require('./catberry_components/page/page-vacancy-item/index.js'), properties: {"name":"page-vacancy-item","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<cat-other-vacancy-item id=\\"other-vacancy-item\\" cat-store=\\"other/VacancyItem\\"></cat-other-vacancy-item>";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'page-video', constructor: require('./catberry_components/page/page-video/index.js'), properties: {"name":"page-video","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\nВидео каталог\\n\\n<cat-common-paginator id=\\"common-paginator\\" cat-store=\\"Paginator\\" model=\\"master/MasterVideo\\"></cat-common-paginator>";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'pages-content', constructor: require('./catberry_components/pages/pages-content/index.js'), properties: {"name":"pages-content","template":"./template.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  return "            <cat-breadcrumps id=\\"breadcrumps\\" cat-store=\\"Breadcrumps\\"></cat-breadcrumps>\\n";\n  },"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<div class=\\"page container\\">\\n    <div class=\\"page__row\\">\\n        <cat-loader id=\\"pages-content-loader\\"></cat-loader>\\n\\n";\n  stack1 = helpers.unless.call(depth0, ((stack1 = (depth0 != null ? depth0.isActive : depth0)) != null ? stack1.main : stack1), {"name":"unless","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n        <div class=\\"content\\">\\n            <cat-page-"\n    + escapeExpression(((helper = (helper = helpers.current || (depth0 != null ? depth0.current : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"current","hash":{},"data":data}) : helper)))\n    + " id=\\"page-current-"\n    + escapeExpression(((helper = (helper = helpers.current || (depth0 != null ? depth0.current : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"current","hash":{},"data":data}) : helper)))\n    + "\\"></cat-page-"\n    + escapeExpression(((helper = (helper = helpers.current || (depth0 != null ? depth0.current : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"current","hash":{},"data":data}) : helper)))\n    + ">\\n        </div>\\n    </div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: null},
{name: 'pages-footer', constructor: require('./catberry_components/pages/pages-footer/index.js'), properties: {"name":"pages-footer","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "                    <a class=\\"footer__links-a\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">";\n  stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</a>&nbsp;\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<footer class=\\"footer\\">\\n    <div class=\\"container\\">\\n\\n        <div class=\\"to-top\\">\\n            <a href=\\"\\"><span>↑</span> вверх</a>\\n        </div>\\n\\n\\n        <div class=\\"row\\">\\n            <div class=\\"footer__coordinator\\">Координатор сайта: "\n    + escapeExpression(((helper = (helper = helpers.phone || (depth0 != null ? depth0.phone : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"phone","hash":{},"data":data}) : helper)))\n    + "</div>\\n\\n            <div class=\\"footer__copyright\\">\\n                <p class=\\"footer__copyright-who\\">© FaceMaster — Фейсмастер</p>\\n                <p class=\\"footer__copyright-text\\">При полном или частичном воспроизведении информации\\n                    активная ссылка на Фейсмастер обязательна.</p>\\n            </div>\\n\\n\\n            <div class=\\"footer__links\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.links : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "            </div>\\n\\n\\n            <div class=\\"footer__counters\\">\\n                <!--{ { > footer/counters/counters counters} }-->\\n            </div>\\n        </div>\\n    </div>\\n</footer>";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'pages-header', constructor: require('./catberry_components/pages/pages-header/index.js'), properties: {"name":"pages-header","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  return "                    <div class=\\"login\\">\\n                        <a class=\\"login__btn btn\\" href=\\"/login\\">Вход для Мастеров</a>\\n                    </div>\\n";\n  },"3":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "                    <div class=\\"login\\">\\n                        <a class=\\"login__btn btn\\" href=\\"<!--ERROR-->\\"><!--ERROR - username--></a>\\n\\n                        <div class=\\"menu-user\\">\\n                            <ul class=\\"menu-user__ul\\">\\n                                <!--ERROR MENUUSER-->\\n";\n  stack1 = helpers.each.call(depth0, ((stack1 = (depth0 != null ? depth0.authData : depth0)) != null ? stack1.menuUser : stack1), {"name":"each","hash":{},"fn":this.program(4, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                            </ul>\\n                        </div>\\n                    </div>\\n";\n},"4":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "                                    <li class=\\"menu-user__item\\">\\n                                        <a class=\\"menu-user__item-link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">";\n  stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</a>\\n                                    </li>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "<header class=\\"header\\">\\n    <div class=\\"container\\">\\n        <div class=\\"row\\">\\n            <div class=\\"header__left-col\\">\\n                <div class=\\"logo\\">\\n                    <div class=\\"logo__img\\">\\n                        <a class=\\"logo__link\\" href=\\"/main\\">\\n                            <img alt=\\"Facemaster.ru Logo\\" src=\\"/img/logo.svg\\" width=\\"100%\\">\\n                        </a>\\n                    </div>\\n                    <div class=\\"visitor\\">\\n                        <p class=\\"visitor__count\\">"\n    + escapeExpression(((helper = (helper = helpers.visitCount || (depth0 != null ? depth0.visitCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"visitCount","hash":{},"data":data}) : helper)))\n    + "</p>\\n\\n                        <p class=\\"visitor__mera\\">в неделю</p>\\n                    </div>\\n                </div>\\n            </div>\\n            <div class=\\"header__title\\">\\n                <a class=\\"title\\" href=\\"/main\\">\\n                    <p class=\\"title__text h1\\">ПОИСК МАСТЕРОВ В СФЕРЕ УСЛУГ</p>\\n                </a>\\n            </div>\\n            <div class=\\"header__login\\">\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.isGuest : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.program(3, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "            </div>\\n            <div class=\\"header__menu\\">\\n                <cat-pages-navigation id=\\"pages-navigation\\"></cat-pages-navigation>\\n            </div>\\n            <div class=\\"header__social\\">\\n                <cat-social id=\\"social\\"></cat-social>\\n            </div>\\n        </div>\\n    </div>\\n</header>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'pages-navigation', constructor: require('./catberry_components/pages/pages-navigation/index.js'), properties: {"name":"pages-navigation","template":"./template.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "            <li class=\\"main-menu__item\\">\\n                <a class=\\"main-menu__item-link link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.link || (depth0 != null ? depth0.link : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"link","hash":{},"data":data}) : helper)))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</a>\\n            </li>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<nav class=\\"menu\\">\\n    <ul class=\\"main-menu\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.menu : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "    </ul>\\n</nav>\\n";\n},"useData":true}', errorTemplateSource: null},
{name: 'registration-about', constructor: require('./catberry_components/registration/registration-about/index.js'), properties: {"name":"registration-about","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "<div class=\\"about-wr\\">\\n    <div class=\\"container\\">\\n        <div class=\\"row\\">\\n            <section class=\\"about\\">\\n                <ul class=\\"about__list row\\">\\n                    <li class=\\"about-list-item\\">\\n                        <p class=\\"about-list-item__text\\">\\n                            <span class=\\"about-list-item__text-ver-al\\">\\n                                ЗАРЕГИСТРИРУЙСЯ<br>НА САЙТЕ\\n                            </span>\\n                        </p>\\n\\n                        <div class=\\"about-list-item__icon-wr\\">\\n                            "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "add-page", {"name":"icon","hash":{},"data":data})))\n    + "\\n                        </div>\\n\\n                        <div class=\\"about-list-item__arrow\\">\\n                            "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "arrow", {"name":"icon","hash":{},"data":data})))\n    + "\\n                        </div>\\n                    </li>\\n                    <li class=\\"about-list-item\\">\\n                        <p class=\\"about-list-item__text\\">\\n                            <span class=\\"about-list-item__text-ver-al\\">\\n                                ОПУБЛИКУЙСЯ\\n                            </span>\\n                        </p>\\n\\n                        <div class=\\"about-list-item__icon-wr\\">\\n                            "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "picture", {"name":"icon","hash":{},"data":data})))\n    + "\\n                        </div>\\n                        <div class=\\"about-list-item__arrow\\">\\n                            "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "arrow", {"name":"icon","hash":{},"data":data})))\n    + "\\n                        </div>\\n                    </li>\\n                    <li class=\\"about-list-item\\">\\n                        <p class=\\"about-list-item__text\\">\\n                            <span class=\\"about-list-item__text-ver-al\\">\\n                                ПОЛУЧАЙ<br>КЛИЕНТОВ\\n                            </span>\\n                        </p>\\n\\n                        <div class=\\"about-list-item__icon-wr\\">\\n                            "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "people", {"name":"icon","hash":{},"data":data})))\n    + "\\n                        </div>\\n                    </li>\\n                </ul>\\n            </section>\\n        </div>\\n    </div>\\n</div>";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'registration-faq', constructor: require('./catberry_components/registration/registration-faq/index.js'), properties: {"name":"registration-faq","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n<div class=\\"container corner corner_bg\\">\\n    <div class=\\"row\\">\\n        <section class=\\"faq\\">\\n            <p class=\\"page-title page-title_landing\\">Частые вопросы:</p>\\n\\n            <div class=\\"faq__block\\">\\n                <div class=\\"faq__item\\">\\n                    <p class=\\"faq__item-title\\"><span class=\\"faq__item-title-inner\\">Как оплатить сервис?</span></p>\\n\\n                    <p class=\\"faq__item-text\\">На данный момент, чтобы совершить оплату,\\n                        вам нужно приехать в наш офис по адресу Автостроителей 41А к.1 с 9:00 до 17:00 (пн-пт).\\n                        Менеджер предоставит вам всю необходимую информацию по выбору\\n                        тарифного плана и проведению оплаты. Также мы работаем над системой\\n                        электронных платежей.\\n                    </p>\\n                </div>\\n                <div class=\\"faq__item\\">\\n                    <p class=\\"faq__item-title\\"><span class=\\"faq__item-title-inner\\">Что будет, когда закончится месяц?</span></p>\\n\\n                    <p class=\\"faq__item-text\\">Вы получите уведомление на ваш e-mail, зарегистрированный в системе, с предложением продлить действующий тарифный план или перейти на новый. Если в течение 30 дней вы ни разу не совершили вход в кабинет сайта FaceMaster, то ваш кабинет будет удалён.</p>\\n                </div>\\n            </div>\\n            <div class=\\"faq__block\\">\\n                <div class=\\"faq__item\\">\\n                    <p class=\\"faq__item-title\\"><span class=\\"faq__item-title-inner\\">Могу ли я изменить тарифный план?</span></p>\\n\\n                    <p class=\\"faq__item-text\\">Если вы пользуетесь бесплатной мини-страницей, то получить все возможности эффективного продвижения на сайте FaceMaster вы можете в любое время, выбрав тарифный план и оплатив его. Если вы уже совершили оплату и хотите поменять один тарифный план на другой, то вам нужно подождать, пока закончится первый.</p>\\n                </div>\\n                <div class=\\"faq__item\\">\\n                    <p class=\\"faq__item-title\\"><span class=\\"faq__item-title-inner\\">У меня есть вопрос!</span></p>\\n\\n                    <p class=\\"faq__item-text\\">Будем рады представить вам\\n                        дополнительную информацию о работе платформы и о ценах по телефону (8482) 74-44-19.</p>\\n                </div>\\n            </div>\\n        </section>\\n    </div>\\n</div>\\n";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'registration-form', constructor: require('./catberry_components/registration/registration-form/index.js'), properties: {"name":"registration-form","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "<div class=\\"section-reg\\">\\n    <div class=\\"container\\">\\n        <div class=\\"row\\">\\n            <section class=\\"form form_reg-master\\">\\n                <div class=\\"form__cont\\">\\n                    <h2 class=\\"form__title\\">Начать регистрацию</h2>\\n\\n                    <form class=\\"form__form\\" action=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\" method=\\""\n    + escapeExpression(((helper = (helper = helpers.method || (depth0 != null ? depth0.method : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"method","hash":{},"data":data}) : helper)))\n    + "\\" data-url-lk=\\""\n    + escapeExpression(((helper = (helper = helpers.urlLK || (depth0 != null ? depth0.urlLK : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"urlLK","hash":{},"data":data}) : helper)))\n    + "\\">\\n                        <div class=\\"form__row\\">\\n                            <input type=\\"text\\" placeholder=\\"Как Вас зовут?\\" name=\\"regmaster[name]\\">\\n                        </div>\\n                        <div class=\\"form__row row\\">\\n                            <div class=\\"form__row_half\\">\\n                                <input type=\\"text\\" placeholder=\\"Укажите Ваш телефон\\" name=\\"regmaster[phone]\\">\\n                            </div>\\n                            <div class=\\"form__row_half\\">\\n                                <input type=\\"password\\" placeholder=\\"Придумайте пароль\\" name=\\"regmaster[password]\\">\\n                            </div>\\n                        </div>\\n                        <div class=\\"form__row\\">\\n                            <input class=\\"form__btn btn\\" type=\\"submit\\" value=\\"ЗАРАГИСТРИРОВАТЬСЯ\\">\\n                        </div>\\n                        <div class=\\"form__row\\">\\n                            <label><input type=\\"checkbox\\" checked value=\\"true\\">я согласен с <a href=\\"/oferta\\">условиями</a> </label>\\n                        </div>\\n                    </form>\\n                </div>\\n            </section>\\n        </div>\\n    </div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'registration-header', constructor: require('./catberry_components/registration/registration-header/index.js'), properties: {"name":"registration-header","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"container\\">\\n    <div class=\\"row\\">\\n        <section class=\\"landing-header\\">\\n            <h1 class=\\"page-title page-title_landing\\">FaceMaster — сайт поиска специалистов\\n                в сфере услуг в Тольятти</h1>\\n        </section>\\n    </div>\\n</div>";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'registration-more-page', constructor: require('./catberry_components/registration/registration-more-page/index.js'), properties: {"name":"registration-more-page","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "<div class=\\"more-page-wr\\">\\n    <div class=\\"container\\">\\n        <div class=\\"row\\">\\n            <section class=\\"more-page\\">\\n                <p class=\\"page-title page-title_landing\\">Подробнее о страницах:</p>\\n\\n                <div class=\\"more-page__item\\">\\n                    <div class=\\"more-page__pic\\">\\n                        <img class=\\"more-page__pic-img\\" alt=\\"страница и мини-страница\\" src=\\"/img/registration/1.png\\" width=\\"100%\\">\\n                    </div>\\n                    <div class=\\"more-page__text\\">\\n                        <div class=\\"more-page__text-title\\">\\n                            <div class=\\"more-page__text-title-count\\"></div>\\n                            <div class=\\"more-page__text-title-header more-page__text-title-header_no-valign\\">Каталог мастеров</div>\\n                            <div class=\\"more-page__text-title-sub-header\\">Мини-страница + личная страница</div>\\n                        </div>\\n                        <div class=\\"more-page__paragraph\\">\\n                            <p class=\\"more-page__paragraph-title\\">Личная страница</p>\\n\\n                            <p class=\\"more-page__paragraph-text\\">Личная страница – это ваше собственное информационное пространство для продвижения в Сети. Она может стать аналогом персонального сайта, либо, если у вас уже есть свой сайт, мы поможем расширить арсенал для привлечения на него клиентов. Личная страница даёт доступ к множеству сервисов, чтобы помочь специалисту и клиенту найти друг друга: написание статей, фотоальбомы, отзывы, продвижение в социальных сетях, видеокаталог, рубрика «Советы Мастеров», каталог фирм и многое другое.</p>\\n                        </div>\\n                        <div class=\\"more-page__paragraph\\">\\n                            <p class=\\"more-page__paragraph-title\\">Мини-страница</p>\\n\\n                            <p class=\\"more-page__paragraph-text\\">Мини-страница — это ваша визитка с контактной информацией. Зарегистрировавшись на нашем сайте бесплатно, вы получаете только место в общем каталоге Мастеров, где вашу визитку смогут увидеть посетители. Но вы всегда можете сделать из неё личную страницу и тем самым увеличить приток клиентов. Для этого вам нужно выбрать и оплатить один из тарифных планов.</p>\\n                        </div>\\n                    </div>\\n                </div>\\n                <div class=\\"more-page__item\\">\\n                    <div class=\\"more-page__pic\\">\\n                        <img class=\\"more-page__pic-img more-page__pic-img_offset-1\\" alt=\\"страница и мини-страница\\" src=\\"/img/registration/2.png\\" width=\\"100%\\">\\n                    </div>\\n                    <div class=\\"more-page__text\\">\\n\\n                        <div class=\\"more-page__text-title\\">\\n                            <div class=\\"more-page__text-title-count\\"></div>\\n                            <div class=\\"more-page__text-title-header\\">Каталог скидок и подарков</div>\\n                        </div>\\n                        <div class=\\"more-page__paragraph\\">\\n                            <p class=\\"more-page__paragraph-text\\">Устраивайте акции и скидки, получая ещё больше клиентов! Многие посетители регулярно отслеживают выгодные предложения в нашем каталоге «Скидки и подарки». Поэтому если вы размещаете в нём информацию о скидке, то шансы, что клиент заинтересуется вашим предложением, возрастают вдвое! Кроме того, самые актуальные и интересные акции мы регулярно освещаем в социальных сетях.</p>\\n                        </div>\\n                    </div>\\n                </div>\\n                <div class=\\"more-page__line\\"></div>\\n                <div class=\\"more-page__item\\">\\n                    <div class=\\"more-page__pic\\">\\n                        <img class=\\"more-page__pic-img more-page__pic-img_offset-1\\" alt=\\"страница и мини-страница\\" src=\\"/img/registration/3.png\\" width=\\"100%\\">\\n                    </div>\\n                    <div class=\\"more-page__text\\">\\n                        <div class=\\"more-page__text-title\\">\\n                            <div class=\\"more-page__text-title-count\\"></div>\\n                            <div class=\\"more-page__text-title-header\\">Каталог видео</div>\\n                        </div>\\n                        <div class=\\"more-page__paragraph\\">\\n                            <p class=\\"more-page__paragraph-text\\">В видеокаталоге уже собрана целая коллекция самых полезных роликов, найденных Мастерами на просторах Интернета. Многие специалисты не только отбирают лучшее, исходя из своих знаний и опыта, но и создают его! Вы можете заснять на видео себя, свою работу, довольных клиентов, показать, как что-то работает, или дать дельный совет из собственной практики. Видеоролики способны показать посетителю то, что порой сложно передать одними фотографиями, помогают сформировать интерес к какой-либо услуге или товару.</p>\\n                        </div>\\n                    </div>\\n                </div>\\n                <div class=\\"more-page__line\\"></div>\\n                <div class=\\"more-page__item\\">\\n                    <div class=\\"more-page__pic\\">\\n                        <img class=\\"more-page__pic-img more-page__pic-img_offset-1\\" alt=\\"страница и мини-страница\\" src=\\"/img/registration/4.png\\" width=\\"100%\\">\\n                    </div>\\n                    <div class=\\"more-page__text\\">\\n\\n                        <div class=\\"more-page__text-title\\">\\n                            <div class=\\"more-page__text-title-count\\"></div>\\n                            <div class=\\"more-page__text-title-header\\">Каталог советов мастеров</div>\\n                        </div>\\n                        <div class=\\"more-page__paragraph\\">\\n                            <p class=\\"more-page__paragraph-text\\">Рубрика «Секреты Мастеров» – это сборник статей от наших специалистов для помощи посетителям в самых различных жизненных ситуациях. Чтобы попасть в каталог «Секретов», вам нужно написать на личной странице статью. Интересный и полезный материал демонстрирует клиенту ваш богатый опыт и высокий уровень профессионализма. Когда статья будет опубликована на вашей странице, модераторы проверят, подходит ли она для каталога советов. Главными критериями являются практичность и понятность для посетителя, отсутствие прямой рекламы.</p>\\n                        </div>\\n                    </div>\\n                </div>\\n                <div class=\\"more-page__line\\"></div>\\n                <div class=\\"more-page__item\\">\\n                    <div class=\\"more-page__pic\\">\\n                        <img class=\\"more-page__pic-img more-page__pic-img_offset-1\\" alt=\\"страница и мини-страница\\" src=\\"/img/registration/5.png\\" width=\\"100%\\">\\n                    </div>\\n                    <div class=\\"more-page__text\\">\\n\\n                        <div class=\\"more-page__text-title\\">\\n                            <div class=\\"more-page__text-title-count\\"></div>\\n                            <div class=\\"more-page__text-title-header\\">Каталог фирм</div>\\n                        </div>\\n                        <div class=\\"more-page__paragraph\\">\\n                            <p class=\\"more-page__paragraph-text\\">Помимо перечня отдельных специалистов у нас также есть каталог компаний. На сегодняшний день в нём находится более 100 организаций, где работают наши Мастера. Все компании располагаются в соответствии с привычным рубрикатором в зависимости от того, в какой сфере посетитель ищет специалиста. Данный каталог помогает организовать эффективное продвижение не только для отдельного сотрудника, но и для целой компании. Каждая организация может иметь одного своего представителя на FaceMaster или больше. Также в каталоге фирм есть свой рейтинг рекомендаций. Он складывается из суммы «лайков», которые получили все Мастера из одной компании. Таким образом, чем популярнее сотрудники среди клиентов, тем выше рейтинг организации.</p>\\n                        </div>\\n                    </div>\\n                </div>\\n            </section>\\n        </div>\\n    </div>\\n</div>\\n";\n  },"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'registration-price', constructor: require('./catberry_components/registration/registration-price/index.js'), properties: {"name":"registration-price","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "<div class=\\"price-wr corner corner_bg\\">\\n    <div class=\\"container\\">\\n        <div class=\\"row\\">\\n            <section class=\\"price\\">\\n                <p class=\\"page-title page-title_landing\\">Сколько стоит предложение?</p>\\n\\n                <p class=\\"sub-title sub-title_landing\\">Выберите нужную закладку:</p>\\n\\n                <!--<div id=\\"horizontalTab\\">-->\\n                    <!--<ul block=\\"price-tabs-list\\" mix=\\"block:resp-tabs-list hor_1\\">-->\\n                        <!--<li elem=\\"item\\">Условия для физических лиц</li>-->\\n                        <!--<li elem=\\"item\\">Условия для юридических лиц</li>-->\\n                    <!--</ul>-->\\n                    <div class=\\"price-tabs\\">\\n                        <div class=\\"tab-content tab-content_active\\">\\n                            <div class=\\"tab-content__name\\">\\n                                "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "strelka", {"name":"icon","hash":{},"data":data})))\n    + "\\n                                Условия для физических лиц\\n                            </div>\\n                            <div class=\\"ofers-block\\">\\n                                <div class=\\"ofers-block__item\\">\\n                                    <div class=\\"description-tarif\\">\\n                                        <div class=\\"description-tarif__part-1\\">\\n                                            <div class=\\"description-tarif__medals\\">\\n                                                <div class=\\"ofers-block-medals\\">\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                            </div>\\n                                            <p class=\\"description-tarif__title\\">Старт</p>\\n\\n                                            <p class=\\"description-tarif__sub-title\\">Бесплатно</p>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-2\\">\\n                                            <div class=\\"ofers-block-plus ofers-block-plus_single\\">\\n                                                <div class=\\"ofers-block-plus__item ofers-block-plus__item_single\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "mini-page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Мини<br>страница</p>\\n                                                </div>\\n                                            </div>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-3\\">\\n                                            <div class=\\"description-tarif__btn\\">\\n                                                <a class=\\"btn btn_reg-plus js-scrollto\\" href=\\"#form2\\">Выбрать</a>\\n                                            </div>\\n                                        </div>\\n                                    </div>\\n                                </div>\\n                                <div class=\\"ofers-block__item\\">\\n                                    <div class=\\"description-tarif\\">\\n                                        <div class=\\"description-tarif__part-1\\">\\n                                            <div class=\\"description-tarif__medals\\">\\n                                                <div class=\\"ofers-block-medals\\">\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                            </div>\\n                                            <p class=\\"description-tarif__title\\">Специалист</p>\\n\\n                                            <p class=\\"description-tarif__sub-title\\">8 руб. в день</p>\\n                                        </div>\\n\\n                                        <div class=\\"description-tarif__part-2\\">\\n                                            <div class=\\"ofers-block-plus\\">\\n                                                <div class=\\"ofers-block-plus__item\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "mini-page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Мини<br>страница</p>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus__item\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Личная страница</p>\\n                                                </div>\\n                                            </div>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-3\\">\\n                                            <div class=\\"description-tarif__btn\\">\\n                                                <a class=\\"btn btn_reg-plus js-scrollto\\" href=\\"#form2\\">Выбрать</a>\\n                                            </div>\\n                                        </div>\\n                                    </div>\\n                                </div>\\n                                <div class=\\"ofers-block__item\\">\\n                                    <div class=\\"description-tarif\\">\\n                                        <div class=\\"description-tarif__part-1\\">\\n                                            <div class=\\"description-tarif__medals\\">\\n                                                <div class=\\"ofers-block-medals\\">\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                            </div>\\n                                            <p class=\\"description-tarif__title\\">Профессионал</p>\\n\\n                                            <p class=\\"description-tarif__sub-title\\">16 руб. в день</p>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-2\\">\\n                                            <div class=\\"ofers-block-plus ofers-block-plus_prof\\">\\n                                                <div class=\\"ofers-block-plus__item\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "mini-page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Мини<br>страница</p>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus__item\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Личная страница</p>\\n                                                </div>\\n                                            </div>\\n                                            <div class=\\"ofers-block-plus-dop\\">\\n                                                <div class=\\"ofers-block-plus-dop__item\\">\\n                                                    <i class=\\"ofers-block-plus-dop__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "video", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus-dop__item\\">\\n                                                    <i class=\\"ofers-block-plus-dop__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "gift", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus-dop__item\\">\\n                                                    <i class=\\"ofers-block-plus-dop__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "picture", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus-dop__item\\">\\n                                                    <i class=\\"ofers-block-plus-dop__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "dialog", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                            </div>\\n                                            <div class=\\"description-tarif__descr-text\\">\\n                                                Скидки + фото + видео + отзывы\\n                                            </div>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-3\\">\\n                                            <div class=\\"description-tarif__btn\\">\\n                                                <a class=\\"btn btn_reg-plus js-scrollto\\" href=\\"#form2\\">Выбрать</a>\\n                                            </div>\\n                                        </div>\\n                                    </div>\\n                                </div>\\n                            </div>\\n                            <table class=\\"price-table\\">\\n                                <thead class=\\"price-table__head\\">\\n                                <th class=\\"price-table__empty price-table-first-column\\">&nbsp;</th>\\n                                <th class=\\"price-table__head-text price-table-second-column\\">Новичок</th>\\n                                <th class=\\"price-table__head-text price-table-third-column\\">Специалист</th>\\n                                <th class=\\"price-table__head-text price-table-forth-column\\">Профессионал</th>\\n                                </thead>\\n                                <tbody class=\\"price-table__body\\">\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">90 дней</td>\\n                                    <td class=\\"price-table__td\\">Бесплатно</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">1 500 руб.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">180 дней</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">1 450 руб.</td>\\n                                    <td class=\\"price-table__td\\">2 700 руб.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">360дней</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">2 600 руб.</td>\\n                                    <td class=\\"price-table__td\\">4 800 руб.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Мини-страница</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Личная страница</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Ассортимент услуг</td>\\n                                    <td class=\\"price-table__td\\">5шт.</td>\\n                                    <td class=\\"price-table__td\\">8шт.</td>\\n                                    <td class=\\"price-table__td\\">8шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Скидки и подарки + размещение в каталоге \\"Скидки и подарки\\"</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">2шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Фотоальбом</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">3шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Видеоролик + размещение в каталоге Видео</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">2шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Статья + размещение в каталоге Советов Мастеров</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">2шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Лайки, отзывы, рекомендации</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">вкл.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">&nbsp;</td>\\n                                    <td class=\\"price-table__td\\"><a class=\\"price-table__btn js-scrollto\\" href=\\"#form2\\">Мне подходит!</a></td>\\n                                    <td class=\\"price-table__td\\"><a class=\\"price-table__btn js-scrollto\\" href=\\"#form2\\">Мне подходит!</a></td>\\n                                    <td class=\\"price-table__td\\"><a class=\\"price-table__btn js-scrollto\\" href=\\"#form2\\">Мне подходит!</a></td>\\n                                </tr>\\n                                </tbody>\\n                            </table>\\n                        </div>\\n                        <div class=\\"tab-content\\">\\n                            <div class=\\"tab-content__name\\">\\n                                "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "strelka", {"name":"icon","hash":{},"data":data})))\n    + "\\n                                Условия для юридических лиц\\n                            </div>\\n                            <div class=\\"ofers-block\\">\\n                                <div class=\\"ofers-block__item\\">\\n                                    <div class=\\"description-tarif description-tarif_long\\">\\n                                        <div class=\\"description-tarif__part-1\\">\\n                                            <div class=\\"description-tarif__medals\\">\\n                                                <div class=\\"ofers-block-medals\\">\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                            </div>\\n                                            <p class=\\"description-tarif__title\\">Старт<br>Бизнес</p>\\n\\n                                            <p class=\\"description-tarif__sub-title\\">16 руб. в день</p>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-2\\">\\n                                            <div class=\\"ofers-block-plus ofers-block-plus_single\\">\\n                                                <div class=\\"ofers-block-plus__item ofers-block-plus__item_single\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "mini-page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Мини<br>страница</p>\\n                                                </div>\\n                                            </div>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-3\\">\\n                                            <div class=\\"description-tarif__btn\\">\\n                                                <a class=\\"btn btn_reg-plus js-scrollto\\" href=\\"#form2\\">Выбрать</a>\\n                                            </div>\\n                                        </div>\\n                                    </div>\\n                                </div>\\n                                <div class=\\"ofers-block__item\\">\\n                                    <div class=\\"description-tarif description-tarif_long\\">\\n                                        <div class=\\"description-tarif__part-1\\">\\n                                            <div class=\\"description-tarif__medals\\">\\n                                                <div class=\\"ofers-block-medals\\">\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                            </div>\\n                                            <p class=\\"description-tarif__title\\">Специалист Бизнес</p>\\n\\n                                            <p class=\\"description-tarif__sub-title\\">25 руб. в день</p>\\n                                        </div>\\n\\n                                        <div class=\\"description-tarif__part-2\\">\\n                                            <div class=\\"ofers-block-plus\\">\\n                                                <div class=\\"ofers-block-plus__item\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "mini-page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Мини<br>страница</p>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus__item\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Личная страница</p>\\n                                                </div>\\n                                            </div>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-3\\">\\n                                            <div class=\\"description-tarif__btn\\">\\n                                                <a class=\\"btn btn_reg-plus js-scrollto\\" href=\\"#form2\\">Выбрать</a>\\n                                            </div>\\n                                        </div>\\n                                    </div>\\n                                </div>\\n                                <div class=\\"ofers-block__item\\">\\n                                    <div class=\\"description-tarif description-tarif_long\\">\\n                                        <div class=\\"description-tarif__part-1\\">\\n                                            <div class=\\"description-tarif__medals\\">\\n                                                <div class=\\"ofers-block-medals\\">\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                    <i class=\\"ofers-block-medals__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "medal_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                            </div>\\n                                            <p class=\\"description-tarif__title\\">Профессионал Бизнес</p>\\n\\n                                            <p class=\\"description-tarif__sub-title\\">33 руб. в день</p>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-2\\">\\n                                            <div class=\\"ofers-block-plus ofers-block-plus_prof\\">\\n                                                <div class=\\"ofers-block-plus__item\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "mini-page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Мини<br>страница</p>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus__item\\">\\n                                                    <i class=\\"ofers-block-plus__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "page_color", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                                                    <p class=\\"ofers-block-plus__text\\">Личная страница</p>\\n                                                </div>\\n                                            </div>\\n                                            <div class=\\"ofers-block-plus-dop\\">\\n                                                <div class=\\"ofers-block-plus-dop__item\\">\\n                                                    <i class=\\"ofers-block-plus-dop__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "video", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus-dop__item\\">\\n                                                    <i class=\\"ofers-block-plus-dop__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "gift", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus-dop__item\\">\\n                                                    <i class=\\"ofers-block-plus-dop__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "picture", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                                <div class=\\"ofers-block-plus-dop__item\\">\\n                                                    <i class=\\"ofers-block-plus-dop__icon\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "dialog", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n                                                </div>\\n                                            </div>\\n                                            <div class=\\"description-tarif__descr-text\\">\\n                                                Скидки + фото + видео + отзывы\\n                                            </div>\\n                                        </div>\\n                                        <div class=\\"description-tarif__part-3\\">\\n                                            <div class=\\"description-tarif__btn\\">\\n                                                <a class=\\"btn btn_reg-plus js-scrollto\\" href=\\"#form2\\">Выбрать</a>\\n                                            </div>\\n                                        </div>\\n                                    </div>\\n                                </div>\\n                            </div>\\n                            <table class=\\"price-table\\">\\n                                <thead class=\\"price-table__head\\">\\n                                <th class=\\"price-table__empty price-table-first-column\\">&nbsp;</th>\\n                                <th class=\\"price-table__head-text price-table-second-column\\">Старт<br>Бизнес</th>\\n                                <th class=\\"price-table__head-text price-table-third-column\\">Специалист Бизнес</th>\\n                                <th class=\\"price-table__head-text price-table-forth-column\\">Профессионал Бизнес</th>\\n                                </thead>\\n                                <tbody class=\\"price-table__body\\">\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">90 дней</td>\\n                                    <td class=\\"price-table__td\\">1 500 руб.</td>\\n                                    <td class=\\"price-table__td\\">2 250 руб.</td>\\n                                    <td class=\\"price-table__td\\">3 000 руб.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">180 дней</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">4 050 руб.</td>\\n                                    <td class=\\"price-table__td\\">5 400 руб.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">360дней</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">7 200 руб.</td>\\n                                    <td class=\\"price-table__td\\">9 600 руб.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Мини-страница</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Личная страница</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Ассортимент услуг</td>\\n                                    <td class=\\"price-table__td\\">5шт.</td>\\n                                    <td class=\\"price-table__td\\">8шт.</td>\\n                                    <td class=\\"price-table__td\\">8шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Логотип компании + размещение в каталоге компаний</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_green\\">+</span></td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Скидки и подарки + размещение в каталоге \\"Скидки и подарки\\"</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">2шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Фотоальбом</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">3шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Видеоролик + размещение в каталоге Видео</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">2шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Статья + размещение в каталоге Советов Мастеров</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">2шт.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">Лайки, отзывы, рекомендации</td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\"><span class=\\"price-table__round price-table__round_grey\\">-</span></td>\\n                                    <td class=\\"price-table__td\\">вкл.</td>\\n                                </tr>\\n                                <tr class=\\"price-table__tr\\">\\n                                    <td class=\\"price-table__td\\">&nbsp;</td>\\n                                    <td class=\\"price-table__td\\"><a class=\\"price-table__btn js-scrollto\\" href=\\"#form2\\">Мне подходит!</a></td>\\n                                    <td class=\\"price-table__td\\"><a class=\\"price-table__btn js-scrollto\\" href=\\"#form2\\">Мне подходит!</a></td>\\n                                    <td class=\\"price-table__td\\"><a class=\\"price-table__btn js-scrollto\\" href=\\"#form2\\">Мне подходит!</a></td>\\n                                </tr>\\n                                </tbody>\\n                            </table>\\n                        </div>\\n                    </div>\\n                <!--</div>-->\\n            </section>\\n        </div>\\n    </div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'registration-why-we', constructor: require('./catberry_components/registration/registration-why-we/index.js'), properties: {"name":"registration-why-we","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression, buffer = "<div class=\\"why-we-wr\\">\\n    <div class=\\"container\\">\\n        <div class=\\"row\\">\\n            <section class=\\"why-we\\">\\n                <p class=\\"page-title page-title_landing\\">Почему выбирают нас?</p>\\n                <div class=\\"why-we__list\\">\\n                    <div class=\\"row\\">\\n                        <div class=\\"our-plus\\">\\n                            <div class=\\"our-plus__round\\">\\n                                <p class=\\"our-plus__title\\">"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.count : depth0)) != null ? stack1.master : stack1), depth0))\n    + "</p>\\n\\n                                <p class=\\"our-plus__text\\">";\n  stack1 = lambda(((stack1 = (depth0 != null ? depth0.count : depth0)) != null ? stack1.masterName : stack1), depth0);\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</p>\\n                            </div>\\n                        </div>\\n                        <div class=\\"our-plus\\">\\n                            <div class=\\"our-plus__round\\">\\n                                <p class=\\"our-plus__title\\">"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.count : depth0)) != null ? stack1.visits : stack1), depth0))\n    + "</p>\\n\\n                                <p class=\\"our-plus__text\\">посещений<br>в неделю</p>\\n                            </div>\\n                        </div>\\n                        <div class=\\"our-plus\\">\\n                            <div class=\\"our-plus__round\\">\\n                                <p class=\\"our-plus__title\\">"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.count : depth0)) != null ? stack1.orders : stack1), depth0))\n    + "</p>\\n\\n                                <p class=\\"our-plus__text\\">поступивших<br>заявок</p>\\n                            </div>\\n                        </div>\\n                    </div>\\n                </div>\\n            </section>\\n        </div>\\n    </div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'rubrikator-list', constructor: require('./catberry_components/rubrikator/rubrikator-list/index.js'), properties: {"name":"rubrikator-list","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data,depths) {\n  var stack1, helper, helperMissing=helpers.helperMissing, lambda=this.lambda, escapeExpression=this.escapeExpression, functionType="function", buffer = "";\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, (data && data.index), "==", 7, {"name":"is","hash":{},"fn":this.program(2, data, depths),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "\\n";\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, (data && data.index), "==", 15, {"name":"is","hash":{},"fn":this.program(2, data, depths),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "\\n        <div class=\\"rubrika-list\\">\\n            <div class=\\"rubrika-list__title js-rubrika-list\\" style=\\"border-right-color: "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.el : depth0)) != null ? stack1.color : stack1), depth0))\n    + "\\">\\n                <p class=\\"rubrika-list__name\\">"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.el : depth0)) != null ? stack1.name : stack1), depth0))\n    + "</p>\\n\\n                <p class=\\"rubrika-list__count\\">"\n    + escapeExpression(((helper = (helper = helpers.count || (depth0 != null ? depth0.count : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"count","hash":{},"data":data}) : helper)))\n    + "</p>\\n            </div>\\n            <div class=\\"rubrika-list__list\\">\\n                <ul>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.podrubriks : depth0), {"name":"each","hash":{},"fn":this.program(4, data, depths),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                </ul>\\n            </div>\\n        </div>\\n";\n},"2":function(depth0,helpers,partials,data) {\n  return "        </div>\\n        <div class=\\"rubriks-column\\">\\n";\n  },"4":function(depth0,helpers,partials,data,depths) {\n  var stack1, helper, lambda=this.lambda, escapeExpression=this.escapeExpression, functionType="function", helperMissing=helpers.helperMissing;\n  return "                        <li class=\\"rubrika-list__list-li\\"><a class=\\"rubrika-list__list-a\\" href=\\"/"\n    + escapeExpression(lambda(((stack1 = (depths[1] != null ? depths[1].el : depths[1])) != null ? stack1.unique : stack1), depth0))\n    + "/"\n    + escapeExpression(((helper = (helper = helpers.unique || (depth0 != null ? depth0.unique : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"unique","hash":{},"data":data}) : helper)))\n    + "\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "\\n                            <span class=\\"rubrika-list__list-count\\">"\n    + escapeExpression(((helper = (helper = helpers.masterCount || (depth0 != null ? depth0.masterCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"masterCount","hash":{},"data":data}) : helper)))\n    + "</span></a></li>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data,depths) {\n  var stack1, buffer = "<div class=\\"rubriks-column\\">\\n    <div class=\\"rubrika-list rubrika-list_tool-collapsed js-rubrika-collapsed\\">\\n        <div class=\\"rubrika-list__title\\">\\n            <p class=\\"rubrika-list__name\\">Развернуть все рубрики</p>\\n            <i class=\\"rubrika-list__icon\\"></i>\\n        </div>\\n    </div>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.rubrikator : depth0), {"name":"each","hash":{},"fn":this.program(1, data, depths),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</div>\\n";\n},"useData":true,"useDepths":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-block-about', constructor: require('./catberry_components/master/master-block/master-block-about/index.js'), properties: {"name":"master-block-about","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, buffer = "        <p class=\\"about-md__text-caption\\">Образование:</p>\\n        <p class=\\"about-md__text\\">";\n  stack1 = ((helper = (helper = helpers.aboutEduc || (depth0 != null ? depth0.aboutEduc : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"aboutEduc","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</p>\\n";\n},"3":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, buffer = "        <p class=\\"about-md__text-caption\\">Опыт работы:</p>\\n        <p class=\\"about-md__text\\">";\n  stack1 = ((helper = (helper = helpers.aboutExp || (depth0 != null ? depth0.aboutExp : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"aboutExp","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</p>\\n";\n},"5":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, buffer = "        <p class=\\"about-md__text-caption\\">Дополнительная информация:</p>\\n        <p class=\\"about-md__text\\">";\n  stack1 = ((helper = (helper = helpers.aboutAddInfo || (depth0 != null ? depth0.aboutAddInfo : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"aboutAddInfo","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</p>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"about-md\\">\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.aboutEduc : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.aboutExp : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.aboutAddInfo : depth0), {"name":"if","hash":{},"fn":this.program(5, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</div><!-- about-md -->\\n\\n\\n\\n\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-block-article', constructor: require('./catberry_components/master/master-block/master-block-article/index.js'), properties: {"name":"master-block-article","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "        <div class=\\"article-cont-md__item-cont\\">\\n\\n            <div class=\\"article\\">\\n                <a class=\\"article__link js-open-article\\" href=\\"#"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\">\\n                    <div class=\\"article__pic\\">\\n                        <img class=\\"article__img\\" src=\\""\n    + escapeExpression(((helpers.imgSrc || (depth0 && depth0.imgSrc) || helperMissing).call(depth0, (depth0 != null ? depth0.imgID : depth0), {"name":"imgSrc","hash":{},"data":data})))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "\\">\\n                    </div>\\n                    <div class=\\"article__text\\">\\n                        <p>"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</p>\\n                    </div>\\n                    <p class=\\"article__author\\">"\n    + escapeExpression(((helper = (helper = helpers.author || (depth0 != null ? depth0.author : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"author","hash":{},"data":data}) : helper)))\n    + "</p>\\n                </a>\\n            </div>\\n\\n        </div>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"article-cont-md\\">\\n\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.articles : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-block-link', constructor: require('./catberry_components/master/master-block/master-block-link/index.js'), properties: {"name":"master-block-link","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda;\n  return "<div class=\\"link-mp\\">\\n    <a href=\\"https://vk.com/id1342347\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "vk", {"name":"icon","hash":{},"data":data})))\n    + "<span>https://vk.com/id1342347</span></a>\\n    <a href=\\"https://ok.com/id1342347\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "ok", {"name":"icon","hash":{},"data":data})))\n    + "<span>https://ok.com/id1342347</span></a>\\n    <a href=\\"http://my-site.ru\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "earth", {"name":"icon","hash":{},"data":data})))\n    + "<span>http://my-site.ru</span></a>\\n    "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.links : stack1), depth0))\n    + "\\n</div><!-- link-mp -->";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-block-photo', constructor: require('./catberry_components/master/master-block/master-block-photo/index.js'), properties: {"name":"master-block-photo","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "        <div class=\\"photo-md__album-cover js-select-album\\" id=\\"album-"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\">\\n            <a href=\\"/master-data-edit/json3.json\\">\\n                <img src=\\""\n    + escapeExpression(((helpers.imgSrc || (depth0 && depth0.imgSrc) || helperMissing).call(depth0, ((stack1 = ((stack1 = (depth0 != null ? depth0.photos : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.imgID : stack1), 200, {"name":"imgSrc","hash":{},"data":data})))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "\\"><br>\\n                <span>"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</span>\\n            </a>\\n        </div>\\n";\n},"3":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "            <div class=\\"photo-md__album-cont\\" id=\\"cont-album-"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\">\\n                <p class=\\"photo-md__album-title\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</p>\\n\\n                <div class=\\"photo-md__wrapper\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.photos : depth0), {"name":"each","hash":{},"fn":this.program(4, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                </div>\\n\\n            </div>\\n";\n},"4":function(depth0,helpers,partials,data) {\n  var helper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function";\n  return "                        <a class=\\"photo-md__img-prev\\" href=\\""\n    + escapeExpression(((helpers.imgSrc || (depth0 && depth0.imgSrc) || helperMissing).call(depth0, (depth0 != null ? depth0.imgID : depth0), {"name":"imgSrc","hash":{},"data":data})))\n    + "\\">\\n                            <img src=\\""\n    + escapeExpression(((helpers.imgSrc || (depth0 && depth0.imgSrc) || helperMissing).call(depth0, (depth0 != null ? depth0.imgID : depth0), 200, {"name":"imgSrc","hash":{},"data":data})))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.description || (depth0 != null ? depth0.description : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"description","hash":{},"data":data}) : helper)))\n    + "\\"><br>\\n                        </a>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"photo-md\\">\\n\\n    <!-- ERROR -->\\n    <p style=\\"color: red; font-weight: bold\\">------ ERROR! ------</p>\\n    !!!фото. API - недостаточно данных\\n    <br><br><br>\\n    <!-- ERROR -->\\n\\n    <div>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.albums : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "    </div>\\n\\n    <div>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.albums : depth0), {"name":"each","hash":{},"fn":this.program(3, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "    </div>\\n</div><!-- photo-md -->\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-block-review', constructor: require('./catberry_components/master/master-block/master-block-review/index.js'), properties: {"name":"master-block-review","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression, buffer = "            <p class=\\"recommendations__total\\">Мастера рекомендуют <span class=\\"recommendations__total-count\\">"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.vkLikes : depth0)) != null ? stack1.countLikes : stack1), depth0))\n    + " человек</span></p>\\n\\n            <div class=\\"recommendations__list\\">\\n";\n  stack1 = helpers.each.call(depth0, ((stack1 = (depth0 != null ? depth0.vkLikes : depth0)) != null ? stack1.data : stack1), {"name":"each","hash":{},"fn":this.program(2, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "            </div>\\n";\n},"2":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                    <a class=\\"recommendations__item\\" target=\\"_blank\\" href=\\"http://vk.com/id"\n    + escapeExpression(((helper = (helper = helpers.uid || (depth0 != null ? depth0.uid : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"uid","hash":{},"data":data}) : helper)))\n    + "\\">\\n                        <img src=\\""\n    + escapeExpression(((helper = (helper = helpers.photo_100 || (depth0 != null ? depth0.photo_100 : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"photo_100","hash":{},"data":data}) : helper)))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.first_name || (depth0 != null ? depth0.first_name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"first_name","hash":{},"data":data}) : helper)))\n    + " "\n    + escapeExpression(((helper = (helper = helpers.last_name || (depth0 != null ? depth0.last_name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"last_name","hash":{},"data":data}) : helper)))\n    + "\\">\\n                    </a>\\n";\n},"4":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "        <p class=\\"reviews-cont-md__title\\">Мои отзывы</p>\\n\\n        <div class=\\"reviews-cont-md__comments\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.comments : depth0), {"name":"each","hash":{},"fn":this.program(5, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "        </div>\\n";\n},"5":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                <div class=\\"reviews-cont-md__item-cont\\">\\n\\n                    <p class=\\"reviews-cont-md__name\\">"\n    + escapeExpression(((helper = (helper = helpers.authorName || (depth0 != null ? depth0.authorName : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"authorName","hash":{},"data":data}) : helper)))\n    + "<span class=\\"reviews-cont-md__date\\">"\n    + escapeExpression(((helpers.formatDate || (depth0 && depth0.formatDate) || helperMissing).call(depth0, (depth0 != null ? depth0.date : depth0), "%R | %d %Z %Y", {"name":"formatDate","hash":{},"data":data})))\n    + "</span></p>\\n\\n                    <p class=\\"reviews-cont-md__text\\">"\n    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))\n    + "</p>\\n\\n                </div>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", buffer = "<div class=\\"reviews-cont-md\\">\\n\\n    <div class=\\"recommendations\\">\\n";\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, ((stack1 = (depth0 != null ? depth0.vkLikes : depth0)) != null ? stack1.countLikes : stack1), ">", 0, {"name":"is","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "\\n        <div class=\\"recommendations__buttons-block\\">\\n            <p class=\\"recommendations__buttons-block-title\\">Порекомендуйте мастера:</p>\\n\\n            <div></div>\\n        </div>\\n    </div>\\n\\n    <p class=\\"reviews-cont-md__title\\">Оставить отзыв</p>\\n\\n    <div class=\\"reviews-cont-md__row\\">\\n        <form class=\\"add-comment\\" method=\\"POST\\" action=\\"\\">\\n            <input class=\\"add-comment__text-input\\" type=\\"text\\" placeholder=\\"Ваше имя\\" name=\\"comment_form[name]\\">\\n            <input class=\\"add-comment__text-input\\" type=\\"text\\" placeholder=\\"Ваш номер телефона\\" name=\\"comment_form[phone]\\">\\n            <textarea class=\\"add-comment__textarea\\" placeholder=\\"Текст отзыва\\" name=\\"comment_form[comment_text]\\"></textarea>\\n            <input class=\\"add-comment__btn\\" type=\\"submit\\" value=\\"отправить\\">\\n\\n            <p class=\\"add-comment__success\\">\\n                Ваш отзыв успешно отправлен, спасибо!\\n            </p>\\n        </form>\\n\\n        <div class=\\"social-links\\">\\n            <div class=\\"social-links__wrapper\\">\\n                <p class=\\"social-links__title\\">Разместить ссылку на&nbsp;стра&shy;ницу Мастера в&nbsp;соц.&nbsp;сети:</p>\\n\\n                <div class=\\"social-links__master\\">\\n                    <div class=\\"social-links__photo-cont\\">\\n                        <img src=\\""\n    + escapeExpression(((helpers.imgSrc || (depth0 && depth0.imgSrc) || helperMissing).call(depth0, (depth0 != null ? depth0.imgID : depth0), {"name":"imgSrc","hash":{},"data":data})))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "\\">\\n                    </div>\\n\\n                    <p class=\\"social-links__name\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</p>\\n                </div>\\n                <p class=\\"social-links__note\\">Порекомендуйте этого специалиста своим друзям в&nbsp;социальной сети</p>\\n\\n                <div class=\\"social-links__buttons\\">\\n                    <p style=\\"color:red\\">Ссылки! VK, OK, FB, TW</p>\\n                </div>\\n            </div>\\n        </div>\\n\\n    </div>\\n\\n\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.comments : depth0), {"name":"if","hash":{},"fn":this.program(4, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n</div><!--mde-reviews-->\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-block-sale', constructor: require('./catberry_components/master/master-block/master-block-sale/index.js'), properties: {"name":"master-block-sale","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "    <div class=\\"sale-cont-md__item-cont\\">\\n\\n        <div class=\\"sale\\">\\n            <a class=\\"sale__link js-open-sale\\" href=\\"#"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\">\\n                <p class=\\"sale__title\\">\\n";\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, (depth0 != null ? depth0.type : depth0), "==", 1, {"name":"is","hash":{},"fn":this.program(2, data),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, (depth0 != null ? depth0.type : depth0), "==", 2, {"name":"is","hash":{},"fn":this.program(4, data),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, (depth0 != null ? depth0.type : depth0), "==", 3, {"name":"is","hash":{},"fn":this.program(6, data),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                </p>\\n                <div class=\\"sale__pic\\">\\n                    <img class=\\"sale__img\\" src=\\""\n    + escapeExpression(((helpers.imgSrc || (depth0 && depth0.imgSrc) || helperMissing).call(depth0, (depth0 != null ? depth0.imgID : depth0), {"name":"imgSrc","hash":{},"data":data})))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))\n    + "\\">\\n                </div>\\n                <div class=\\"sale__text\\">\\n                    <p>"\n    + escapeExpression(((helper = (helper = helpers.text || (depth0 != null ? depth0.text : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"text","hash":{},"data":data}) : helper)))\n    + "</p>\\n                </div>\\n            </a>\\n        </div>\\n\\n    </div>\\n";\n},"2":function(depth0,helpers,partials,data) {\n  return "                        Подарок\\n";\n  },"4":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                        Скидка "\n    + escapeExpression(((helper = (helper = helpers.discount || (depth0 != null ? depth0.discount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"discount","hash":{},"data":data}) : helper)))\n    + "%\\n";\n},"6":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                        -"\n    + escapeExpression(((helper = (helper = helpers.discount || (depth0 != null ? depth0.discount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"discount","hash":{},"data":data}) : helper)))\n    + " руб.\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"sale-cont-md\\">\\n\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.sales : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n</div>";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-block-service', constructor: require('./catberry_components/master/master-block/master-block-service/index.js'), properties: {"name":"master-block-service","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "            <li>"\n    + escapeExpression(lambda(depth0, depth0))\n    + "</li>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"service-md\\">\\n    <ul class=\\"service-md__list\\">\\n";\n  stack1 = helpers.each.call(depth0, ((stack1 = (depth0 != null ? depth0.services : depth0)) != null ? stack1.part1 : stack1), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "    </ul>\\n\\n    <ul class=\\"service-md__list\\">\\n";\n  stack1 = helpers.each.call(depth0, ((stack1 = (depth0 != null ? depth0.services : depth0)) != null ? stack1.part2 : stack1), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "    </ul>\\n\\n    <br class=\\"service-md__clear\\">\\n</div><!--mde-service-->\\n\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-block-video', constructor: require('./catberry_components/master/master-block/master-block-video/index.js'), properties: {"name":"master-block-video","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda;\n  return "        <div class=\\"video-md__video-cont\\">\\n            <a class=\\"video-md__video-cover\\" href=\\"http://"\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">\\n                <span class=\\"video-md__title-prev\\">"\n    + escapeExpression(((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper)))\n    + "</span><br>\\n                <span class=\\"video-md__img-cont\\"><img src=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.prev : depth0)) != null ? stack1.src : stack1), depth0))\n    + "\\" alt=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.prev : depth0)) != null ? stack1.alt : stack1), depth0))\n    + "\\"></span>\\n            </a>\\n        </div>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"video-md\\">\\n\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.videos : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n</div><!-- video-md -->\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-block-work', constructor: require('./catberry_components/master/master-block/master-block-work/index.js'), properties: {"name":"master-block-work","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                <td>"\n    + escapeExpression(((helper = (helper = helpers.open || (depth0 != null ? depth0.open : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"open","hash":{},"data":data}) : helper)))\n    + "<br>"\n    + escapeExpression(((helper = (helper = helpers.close || (depth0 != null ? depth0.close : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"close","hash":{},"data":data}) : helper)))\n    + "</td>\\n";\n},"3":function(depth0,helpers,partials,data) {\n  var stack1, helperMissing=helpers.helperMissing, buffer = "";\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, (depth0 != null ? depth0.type : depth0), "==", 1, {"name":"is","hash":{},"fn":this.program(4, data),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"4":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "                        <li>"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</li>\\n";\n},"6":function(depth0,helpers,partials,data) {\n  var stack1, helperMissing=helpers.helperMissing, buffer = "";\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, (depth0 != null ? depth0.type : depth0), "==", 2, {"name":"is","hash":{},"fn":this.program(4, data),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer;\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression, buffer = "<div class=\\"time-and-work-mp\\">\\n\\n    <table class=\\"time-and-work-mp__timetable\\">\\n        <thead>\\n        <tr>\\n            <td class=\\"time-and-work-mp__day\\">Пн</td>\\n            <td class=\\"time-and-work-mp__day\\">Вт</td>\\n            <td class=\\"time-and-work-mp__day\\">Ср</td>\\n            <td class=\\"time-and-work-mp__day time-and-work-mp__day_today\\">Чт</td>\\n            <td class=\\"time-and-work-mp__day\\">Пт</td>\\n            <td class=\\"time-and-work-mp__day\\">Сб</td>\\n            <td class=\\"time-and-work-mp__day\\">Вс</td>\\n        </tr>\\n        </thead>\\n        <tbody>\\n        <tr>\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.schedule : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "        </tr>\\n        </tbody>\\n    </table>\\n\\n    <p class=\\"time-and-work-mp__list-caption\\">Выезд на дом</p>\\n    <ul class=\\"time-and-work-mp__list\\">\\n        <li>Бесплатно по городу</li>\\n        <li>Выезд за город платно</li>\\n    </ul>\\n\\n\\n    <div class=\\"time-and-work-mp__list-big-cont\\">\\n        <p class=\\"time-and-work-mp__list-caption\\">Районы обслуживания</p>\\n\\n        <div class=\\"time-and-work-mp__list-cont\\">\\n            <p class=\\"time-and-work-mp__list-caption time-and-work-mp__list-caption_mini\\">Город</p>\\n            <ul class=\\"time-and-work-mp__list\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.district : depth0), {"name":"each","hash":{},"fn":this.program(3, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "            </ul>\\n        </div><!--list-cont-->\\n\\n        <div class=\\"time-and-work-mp__list-cont\\">\\n            <p class=\\"time-and-work-mp__list-caption time-and-work-mp__list-caption_mini\\">Пригород</p>\\n            <ul class=\\"time-and-work-mp__list\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.district : depth0), {"name":"each","hash":{},"fn":this.program(6, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "            </ul>\\n        </div><!--list-cont-->\\n\\n        <br class=\\"time-and-work-mp__clear\\">\\n    </div><!--list-big-cont-->\\n\\n\\n    <div class=\\"time-and-work-mp__list-big-cont\\">\\n        <p class=\\"time-and-work-mp__list-caption\\">Оплата</p>\\n\\n\\n        <div class=\\"time-and-work-mp__list-cont\\">\\n            <p class=\\"time-and-work-mp__list-caption time-and-work-mp__list-caption_mini\\">Форма сотрудни&shy;чества</p>\\n            <ul class=\\"time-and-work-mp__list\\">\\n                <li>Предоплата</li>\\n                <li>По факту выполненных работ</li>\\n                <li>Рассрочка платежа</li>\\n            </ul>\\n        </div><!--list-cont-->\\n\\n        <div class=\\"time-and-work-mp__list-cont\\">\\n            <p class=\\"time-and-work-mp__list-caption time-and-work-mp__list-caption_mini\\">Способы оплаты</p>\\n            <ul class=\\"time-and-work-mp__list\\">\\n                <li>Наличный</li>\\n                <li>Безналичный\\n                    <ul>\\n                        <li>Оплата через электронные платежные системы</li>\\n                        <li>Оплата по кредитной/дебетовой карте</li>\\n                        <li>Оплата через терминалы</li>\\n                        <li>Банковский перевод</li>\\n                        <li>Предоставление рассрочки</li>\\n                    </ul>\\n                </li>\\n            </ul>\\n        </div><!--list-cont-->\\n        <br class=\\"time-and-work-mp__clear\\">\\n    </div><!--list-cont-->\\n    <br class=\\"time-and-work-mp__clear\\">\\n\\n    <!-- ERROR -->\\n    <p style=\\"color: red; font-weight: bold\\">------ ERROR! (условия - выезд на дом, оплата) ------</p>\\n    !!переделает илья\\n    Условия оплаты: "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.workCondition : depth0)) != null ? stack1.paymentForm : stack1), depth0))\n    + "\\n    Условия оплаты: "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.workCondition : depth0)) != null ? stack1.coopForm : stack1), depth0))\n    + "\\n    Выезд на дом: "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.workCondition : depth0)) != null ? stack1.comming : stack1), depth0))\n    + "\\n    <!-- ERROR -->\\n</div>";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-minicard', constructor: require('./catberry_components/master/master-minicard/master-minicard/index.js'), properties: {"name":"master-minicard","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  return "master-minicard_free";\n  },"3":function(depth0,helpers,partials,data) {\n  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda;\n  return "            <i class=\\"master-minicard__like\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "like", {"name":"icon","hash":{},"data":data})))\n    + " "\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.vkLikes : depth0)) != null ? stack1.countLikes : stack1), depth0))\n    + "</i>\\n";\n},"5":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;\n  return "            <a class=\\"master-minicard__to-page\\" href=\\"/"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.page : depth0)) != null ? stack1.number : stack1), depth0))\n    + "\\">На страницу мастера<i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "strelka", {"name":"icon","hash":{},"data":data})))\n    + "</i></a>\\n";\n},"7":function(depth0,helpers,partials,data) {\n  var stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda;\n  return "        <p class=\\"master-minicard__company\\">\\n            <span><img class=\\"master-minicard__logo\\" src=\\""\n    + escapeExpression(((helpers.imgSrc || (depth0 && depth0.imgSrc) || helperMissing).call(depth0, ((stack1 = (depth0 != null ? depth0.company : depth0)) != null ? stack1.imgID : stack1), (depth0 != null ? depth0.null : depth0), 70, {"name":"imgSrc","hash":{},"data":data})))\n    + "\\" alt=\\"\\"></span>\\n            <span>"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.company : depth0)) != null ? stack1.name : stack1), depth0))\n    + "</span>\\n        </p>\\n";\n},"9":function(depth0,helpers,partials,data) {\n  return "master-minicard__services_half";\n  },"11":function(depth0,helpers,partials,data) {\n  var lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "            <li>"\n    + escapeExpression(lambda(depth0, depth0))\n    + "</li>\\n";\n},"13":function(depth0,helpers,partials,data) {\n  var stack1, helper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda, functionType="function", buffer = "        <ul class=\\"master-content-widget\\">\\n            <li class=\\"";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.page : depth0)) != null ? stack1.sales : stack1), {"name":"if","hash":{},"fn":this.program(14, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += " master-content-widget__gift\\">\\n                <i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "gift", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                <div>\\n                    <p class=\\"master-content-widget__info\\"><span>\\n";\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, ((stack1 = ((stack1 = (depth0 != null ? depth0.sales : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.type : stack1), "==", 1, {"name":"is","hash":{},"fn":this.program(17, data),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, ((stack1 = ((stack1 = (depth0 != null ? depth0.sales : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.type : stack1), "==", 2, {"name":"is","hash":{},"fn":this.program(19, data),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  stack1 = ((helpers.is || (depth0 && depth0.is) || helperMissing).call(depth0, ((stack1 = ((stack1 = (depth0 != null ? depth0.sales : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.type : stack1), "==", 3, {"name":"is","hash":{},"fn":this.program(21, data),"inverse":this.noop,"data":data}));\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                    </span></p>\\n\\n                    <p class=\\"master-content-widget__text\\">"\n    + escapeExpression(lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.sales : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.title : stack1), depth0))\n    + "</p>\\n                </div>\\n            </li>\\n            <li class=\\"";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.page : depth0)) != null ? stack1.albums : stack1), {"name":"if","hash":{},"fn":this.program(23, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += " master-content-widget__photo\\">\\n                <i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "picture", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                <div>\\n                    <p class=\\"master-content-widget__info\\"><span>"\n    + escapeExpression(((helper = (helper = helpers.albumsCount || (depth0 != null ? depth0.albumsCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"albumsCount","hash":{},"data":data}) : helper)))\n    + " фотоальбомов</span></p>\\n\\n                    <p class=\\"master-content-widget__text\\">"\n    + escapeExpression(((helper = (helper = helpers.albumsTitle || (depth0 != null ? depth0.albumsTitle : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"albumsTitle","hash":{},"data":data}) : helper)))\n    + "</p>\\n                </div>\\n            </li>\\n            <li class=\\"";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.page : depth0)) != null ? stack1.videos : stack1), {"name":"if","hash":{},"fn":this.program(25, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += " master-content-widget__video\\">\\n                <i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "video", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                <div>\\n                    <p class=\\"master-content-widget__info\\"><span>"\n    + escapeExpression(((helper = (helper = helpers.imgID || (depth0 != null ? depth0.imgID : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"imgID","hash":{},"data":data}) : helper)))\n    + "</span></p>\\n\\n                    <p class=\\"master-content-widget__text\\">"\n    + escapeExpression(lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.videos : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.title : stack1), depth0))\n    + "</p>\\n                </div>\\n            </li>\\n            <li class=\\"";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.page : depth0)) != null ? stack1.comments : stack1), {"name":"if","hash":{},"fn":this.program(27, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + " master-content-widget__comment\\">\\n                <i>"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "dialog", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n\\n                <div>\\n                    <p class=\\"master-content-widget__info\\"><span>У Мастера:<br><strong>"\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.vkLikes : depth0)) != null ? stack1.countLikes : stack1), depth0))\n    + " рекомендация<br>"\n    + escapeExpression(((helper = (helper = helpers.commentsCount || (depth0 != null ? depth0.commentsCount : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"commentsCount","hash":{},"data":data}) : helper)))\n    + "\\n                        отзывов</strong></span></p>\\n\\n                    <p class=\\"master-content-widget__text\\">«"\n    + escapeExpression(lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.comments : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.text : stack1), depth0))\n    + "»</p>\\n                </div>\\n            </li>\\n        </ul>\\n";\n},"14":function(depth0,helpers,partials,data) {\n  var stack1;\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = ((stack1 = (depth0 != null ? depth0.sales : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.title : stack1), {"name":"if","hash":{},"fn":this.program(15, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { return stack1; }\n  else { return \'\'; }\n  },"15":function(depth0,helpers,partials,data) {\n  return "act";\n  },"17":function(depth0,helpers,partials,data) {\n  return "                            Подарок\\n";\n  },"19":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "                            Скидка "\n    + escapeExpression(lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.sales : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.discount : stack1), depth0))\n    + "%\\n";\n},"21":function(depth0,helpers,partials,data) {\n  var stack1, lambda=this.lambda, escapeExpression=this.escapeExpression;\n  return "                            -"\n    + escapeExpression(lambda(((stack1 = ((stack1 = (depth0 != null ? depth0.sales : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.discount : stack1), depth0))\n    + " руб.\\n";\n},"23":function(depth0,helpers,partials,data) {\n  var stack1;\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = ((stack1 = (depth0 != null ? depth0.albums : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.name : stack1), {"name":"if","hash":{},"fn":this.program(15, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { return stack1; }\n  else { return \'\'; }\n  },"25":function(depth0,helpers,partials,data) {\n  var stack1;\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = ((stack1 = (depth0 != null ? depth0.videos : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.title : stack1), {"name":"if","hash":{},"fn":this.program(15, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { return stack1; }\n  else { return \'\'; }\n  },"27":function(depth0,helpers,partials,data) {\n  var stack1;\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = ((stack1 = (depth0 != null ? depth0.comments : depth0)) != null ? stack1[\'0\'] : stack1)) != null ? stack1.text : stack1), {"name":"if","hash":{},"fn":this.program(15, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { return stack1; }\n  else { return \'\'; }\n  },"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, lambda=this.lambda, buffer = "<div class=\\"";\n  stack1 = helpers.unless.call(depth0, ((stack1 = (depth0 != null ? depth0.page : depth0)) != null ? stack1.id : stack1), {"name":"unless","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += " master-minicard\\">\\n\\n    <div class=\\"master-minicard__photo-cont\\">\\n        <img class=\\"master-minicard__photo\\" src=\\"http://api-fm.present-tlt.ru/files?key="\n    + escapeExpression(((helper = (helper = helpers.imgID || (depth0 != null ? depth0.imgID : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"imgID","hash":{},"data":data}) : helper)))\n    + "\\" alt=\\""\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "\\">\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.page : depth0), {"name":"if","hash":{},"fn":this.program(3, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "    </div>\\n\\n    <div class=\\"master-minicard__contact-wrap\\">\\n        <cat-master-phone-btn id=\\"master-phone-btn-"\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\" phone=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.contacts : depth0)) != null ? stack1.phone : stack1), depth0))\n    + "\\" page=\\""\n    + escapeExpression(lambda(((stack1 = (depth0 != null ? depth0.page : depth0)) != null ? stack1.number : stack1), depth0))\n    + "\\" owner=\\""\n    + escapeExpression(((helper = (helper = helpers.id || (depth0 != null ? depth0.id : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"id","hash":{},"data":data}) : helper)))\n    + "\\"></cat-master-phone-btn>\\n\\n";\n  stack1 = helpers[\'if\'].call(depth0, ((stack1 = (depth0 != null ? depth0.page : depth0)) != null ? stack1.number : stack1), {"name":"if","hash":{},"fn":this.program(5, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "        <a class=\\"master-minicard__show-services js-services-toggle\\" href=\\"#\\">Показать услуги</a>\\n    </div>\\n\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.company : depth0), {"name":"if","hash":{},"fn":this.program(7, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "\\n    <p class=\\"master-minicard__name\\">"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"name","hash":{},"data":data}) : helper)))\n    + "</p>\\n\\n    <p class=\\"master-minicard__spec\\">"\n    + escapeExpression(((helper = (helper = helpers.spec || (depth0 != null ? depth0.spec : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"spec","hash":{},"data":data}) : helper)))\n    + "</p>\\n\\n    <ul class=\\"";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.isWidget : depth0), {"name":"if","hash":{},"fn":this.program(9, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += " master-minicard__services js-minicard-services-cut\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.services : depth0), {"name":"each","hash":{},"fn":this.program(11, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "    </ul>\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.page : depth0), {"name":"if","hash":{},"fn":this.program(13, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n</div>\\n\\n\\n<div class=\\"frame callback\\">\\n\\n</div>\\n\\n\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'master-phone-btn', constructor: require('./catberry_components/master/master-minicard/master-phone-btn/index.js'), properties: {"name":"master-phone-btn","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;\n  return "            <a class=\\"phone-btn__url\\" href=\\"/"\n    + escapeExpression(((helper = (helper = helpers.page || (depth0 != null ? depth0.page : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"page","hash":{},"data":data}) : helper)))\n    + "\\">еще контакты</a>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, helper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", buffer = "<div class=\\"phone-btn\\">\\n    <p class=\\"phone-btn__tip js-master-phone-tip\\">\\n        Пожалуйста скажите мастеру что нашли его на нашем сайте\\n        <i class=\\"js-close-tip\\">"\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "close", {"name":"icon","hash":{},"data":data})))\n    + "</i>\\n    </p>\\n    <button class=\\"phone-btn__button js-show-phone\\" data-id=\\""\n    + escapeExpression(((helper = (helper = helpers.owner || (depth0 != null ? depth0.owner : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"owner","hash":{},"data":data}) : helper)))\n    + "\\">\\n        Показать телефон\\n    </button>\\n    <div class=\\"phone-btn__phone-details js-show-phone-details\\">\\n        <p class=\\"phone-btn__phone\\">"\n    + escapeExpression(((helper = (helper = helpers.phone || (depth0 != null ? depth0.phone : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"phone","hash":{},"data":data}) : helper)))\n    + "</p>\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.page : depth0), {"name":"if","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "    </div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'dop-function', constructor: require('./catberry_components/page/page-main/dop-function/index.js'), properties: {"name":"dop-function","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"1":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "                    <li class=\\"become-master__item\\">\\n";\n  stack1 = helpers[\'if\'].call(depth0, (depth0 != null ? depth0.icon : depth0), {"name":"if","hash":{},"fn":this.program(2, data),"inverse":this.program(4, data),"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                    </li>\\n";\n},"2":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "                        <a class=\\"become-master__item-link become-master__item-link_hover\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">\\n                            <span class=\\"become-master__icon\\"></span>\\n                            ";\n  stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "\\n                        </a>\\n";\n},"4":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "                        <a class=\\"become-master__item-link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">";\n  stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</a>\\n";\n},"6":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "                    <li class=\\"about-company__item\\">\\n                        <a class=\\"about-company__item-link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">";\n  stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</a>\\n                    </li>\\n";\n},"8":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "                    <li class=\\"bayda__item-cube\\">\\n";\n  stack1 = helpers.unless.call(depth0, (depth0 != null ? depth0.empty : depth0), {"name":"unless","hash":{},"fn":this.program(9, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                    </li>\\n";\n},"9":function(depth0,helpers,partials,data) {\n  var stack1, helper, functionType="function", helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, buffer = "                        <a class=\\"bayda__item-cube-link\\" href=\\""\n    + escapeExpression(((helper = (helper = helpers.url || (depth0 != null ? depth0.url : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"url","hash":{},"data":data}) : helper)))\n    + "\\">";\n  stack1 = ((helper = (helper = helpers.title || (depth0 != null ? depth0.title : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"title","hash":{},"data":data}) : helper));\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "</a>\\n";\n},"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var stack1, buffer = "<div class=\\"dop-function\\">\\n    <div class=\\"dop-function__inner\\">\\n        <div class=\\"become-master\\">\\n            <div class=\\"become-master__inner\\">\\n                <div class=\\"become-master__title dop-function-block-js\\">Мастерам</div>\\n                <ul class=\\"become-master__menu\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.menuMaster : depth0), {"name":"each","hash":{},"fn":this.program(1, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                </ul>\\n            </div>\\n        </div>\\n        <div class=\\"about-company\\">\\n            <div class=\\"about-company__inner\\">\\n                <div class=\\"about-company__title dop-function-block-js\\">О компании</div>\\n                <ul class=\\"about-company__menu\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.menuAbout : depth0), {"name":"each","hash":{},"fn":this.program(6, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  buffer += "                </ul>\\n            </div>\\n        </div>\\n        <div class=\\"bayda\\">\\n            <div class=\\"bayda__inner\\">\\n                <div class=\\"bayda__title dop-function-block-js\\">Развлечения</div>\\n                <ul class=\\"bayda__menu-cube\\">\\n";\n  stack1 = helpers.each.call(depth0, (depth0 != null ? depth0.menuBayda : depth0), {"name":"each","hash":{},"fn":this.program(8, data),"inverse":this.noop,"data":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + "                </ul>\\n            </div>\\n        </div>\\n    </div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'},
{name: 'main-function', constructor: require('./catberry_components/page/page-main/main-function/index.js'), properties: {"name":"main-function","template":"./template.hbs","errorTemplate":"./error.hbs","logic":"index.js"}, templateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  var helper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function";\n  return "<div class=\\"main-function\\">\\n    <div class=\\"main-function__inner\\">\\n        <cat-search id=\\"search\\"></cat-search>\\n        <div class=\\"or\\">или</div>\\n        <div class=\\"find-master js-find-master\\">\\n            <a class=\\"find-master__inner\\" href=\\"/catalog\\">\\n                <div class=\\"find-master__inner-rel\\">\\n                    <div class=\\"find-master__icon\\">\\n                        "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "man-in-sun", "icon_white", {"name":"icon","hash":{},"data":data})))\n    + "\\n                    </div>\\n\\n                    <p class=\\"find-master__title\\">Выбери Мастера</p>\\n                    <span class=\\"find-master__btn\\">У нас "\n    + escapeExpression(((helper = (helper = helpers.countMaster || (depth0 != null ? depth0.countMaster : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {"name":"countMaster","hash":{},"data":data}) : helper)))\n    + "</span>\\n                </div>\\n            </a>\\n        </div>\\n        <div class=\\"call-back\\">\\n            <a class=\\"call-back__inner\\" href=\\"/request\\">\\n                <div class=\\"call-back__inner-rel\\">\\n                    <div class=\\"call-back__icon\\">\\n                        "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "star-in-sun", {"name":"icon","hash":{},"data":data})))\n    + "\\n                        "\n    + escapeExpression(((helpers.icon || (depth0 && depth0.icon) || helperMissing).call(depth0, "star-line", {"name":"icon","hash":{},"data":data})))\n    + "\\n                    </div>\\n\\n                    <p class=\\"call-back__title\\">Закажи услугу</p>\\n\\n                    <p class=\\"call-back__text\\">Мы бесплатно отправим вашу заявку всем подходящим Мастерам</p>\\n                    <span class=\\"call-back__btn\\">Создать заявку</span>\\n                </div>\\n            </a>\\n        </div>\\n        <div class=\\"catalogs\\">\\n            <div class=\\"catalogs__inner\\">\\n                <div class=\\"catalogs__services\\">\\n                    <a class=\\"catalogs__services-link\\" href=\\"/catalog\\">Весь каталог услуг</a>\\n                </div>\\n                <div class=\\"catalogs__dop\\">\\n                    <cat-catalog-list id=\\"catalog-list\\" data-mod=\\"page_main\\"></cat-catalog-list>\\n                </div>\\n            </div>\\n        </div>\\n    </div>\\n</div>\\n";\n},"useData":true}', errorTemplateSource: '{"compiler":[6,">= 2.0.0-beta.1"],"main":function(depth0,helpers,partials,data) {\n  return "\\n";\n  },"useData":true}'}
];

var util = require('util'),
	routeDefinitions = require('./routes.js') || [],
	Catberry = require('./node_modules/catberry/browser/Catberry.js'),
	Logger = require('./node_modules/catberry/browser/Logger.js'),
	BootstrapperBase =
		require('./node_modules/catberry/lib/base/BootstrapperBase.js'),
	StoreDispatcher = require('./node_modules/catberry/lib/StoreDispatcher'),
	ModuleApiProvider =
		require('./node_modules/catberry/browser/providers/ModuleApiProvider'),
	CookieWrapper = require('./node_modules/catberry/browser/CookieWrapper');

var DEBUG_DOCUMENT_UPDATED = 'Document updated (%d store(s) changed)',
	DEBUG_COMPONENT_BOUND = 'Component "%s" is bound',
	DEBUG_COMPONENT_UNBOUND = 'Component "%s" is unbound';

util.inherits(Bootstrapper, BootstrapperBase);

/**
 * Creates new instance of the browser Catberry's bootstrapper.
 * @constructor
 * @extends BootstrapperBase
 */
function Bootstrapper() {
	BootstrapperBase.call(this, Catberry);
}

/**
 * Configures Catberry's service locator.
 * @param {Object} configObject Application config object.
 * @param {ServiceLocator} locator Service locator to configure.
 */
Bootstrapper.prototype.configure = function (configObject, locator) {
	BootstrapperBase.prototype.configure.call(this, configObject, locator);

	// if browser still does not have promises then add it.
	if (!('Promise' in window)) {
		window.Promise = locator.resolve('promise');
	}

	locator.register('storeDispatcher', StoreDispatcher, configObject, true);
	locator.register(
		'moduleApiProvider', ModuleApiProvider, configObject, true
	);
	locator.register('cookieWrapper', CookieWrapper, configObject, true);

	locator.registerInstance('window', window);

	var loggerConfig = configObject.logger || {},
		logger = new Logger(loggerConfig.levels);
	locator.registerInstance('logger', logger);
	window.onerror = function errorHandler(msg, uri, line) {
		logger.fatal(uri + ':' + line + ' ' + msg);
		return true;
	};
	var eventBus = locator.resolve('eventBus');
	this._wrapEventsWithLogger(configObject, eventBus, logger);

	routeDefinitions.forEach(function (routeDefinition) {
		locator.registerInstance('routeDefinition', routeDefinition);
	});

	stores.forEach(function (store) {
		locator.registerInstance('store', store);
	});

	components.forEach(function (component) {
		locator.registerInstance('component', component);
	});
};

/**
 * Wraps event bus with log messages.
 * @param {Object} config Application config.
 * @param {EventEmitter} eventBus Event emitter that implements event bus.
 * @param {Logger} logger Logger to write messages.
 * @protected
 */
Bootstrapper.prototype._wrapEventsWithLogger =
	function (config, eventBus, logger) {
		BootstrapperBase.prototype._wrapEventsWithLogger
			.call(this, config, eventBus, logger);

		var isRelease = Boolean(config.isRelease);
		if (isRelease) {
			return;
		}
		eventBus
			.on('documentUpdated', function (args) {
				logger.debug(util.format(DEBUG_DOCUMENT_UPDATED, args.length));
			})
			.on('componentBound', function (args) {
				logger.debug(util.format(
					DEBUG_COMPONENT_BOUND,
					args.element.tagName + (args.id ? '#' + args.id : '')
				));
			})
			.on('componentUnbound', function (args) {
				logger.debug(util.format(
					DEBUG_COMPONENT_UNBOUND,
					args.element.tagName + (args.id ? '#' + args.id : '')
				));
			});
	};

module.exports = new Bootstrapper();
},{"./catberry_components/_common/common-h1/index.js":3,"./catberry_components/_common/common-paginator/index.js":4,"./catberry_components/breadcrumps/index.js":5,"./catberry_components/catalog-list/index.js":6,"./catberry_components/document/index.js":7,"./catberry_components/head/index.js":8,"./catberry_components/loader/index.js":9,"./catberry_components/master/master-block/master-block-about/index.js":10,"./catberry_components/master/master-block/master-block-article/index.js":11,"./catberry_components/master/master-block/master-block-link/index.js":12,"./catberry_components/master/master-block/master-block-photo/index.js":13,"./catberry_components/master/master-block/master-block-review/index.js":14,"./catberry_components/master/master-block/master-block-sale/index.js":15,"./catberry_components/master/master-block/master-block-service/index.js":16,"./catberry_components/master/master-block/master-block-video/index.js":17,"./catberry_components/master/master-block/master-block-work/index.js":18,"./catberry_components/master/master-filter/index.js":19,"./catberry_components/master/master-list/index.js":20,"./catberry_components/master/master-minicard/master-minicard/index.js":21,"./catberry_components/master/master-minicard/master-phone-btn/index.js":22,"./catberry_components/master/master-page/index.js":23,"./catberry_components/master/master-recommended/index.js":24,"./catberry_components/master/master-rubrika/index.js":25,"./catberry_components/other/other-news-item/index.js":26,"./catberry_components/other/other-news/index.js":27,"./catberry_components/other/other-recommendation/index.js":28,"./catberry_components/other/other-vacancy-item/index.js":29,"./catberry_components/other/other-vacancy/index.js":30,"./catberry_components/page/page-catalog/index.js":31,"./catberry_components/page/page-contact/index.js":32,"./catberry_components/page/page-feedback/index.js":33,"./catberry_components/page/page-login/index.js":34,"./catberry_components/page/page-main/dop-function/index.js":35,"./catberry_components/page/page-main/index.js":36,"./catberry_components/page/page-main/main-function/index.js":37,"./catberry_components/page/page-master-page/index.js":38,"./catberry_components/page/page-master-rubrika/index.js":39,"./catberry_components/page/page-news-item/index.js":40,"./catberry_components/page/page-news/index.js":41,"./catberry_components/page/page-oferta/index.js":42,"./catberry_components/page/page-recommendation/index.js":43,"./catberry_components/page/page-registration/index.js":44,"./catberry_components/page/page-request/index.js":45,"./catberry_components/page/page-sale/index.js":46,"./catberry_components/page/page-sovety/index.js":47,"./catberry_components/page/page-vacancy-item/index.js":48,"./catberry_components/page/page-vacancy/index.js":49,"./catberry_components/page/page-video/index.js":50,"./catberry_components/pages/pages-content/index.js":51,"./catberry_components/pages/pages-footer/index.js":52,"./catberry_components/pages/pages-header/index.js":53,"./catberry_components/pages/pages-navigation/index.js":54,"./catberry_components/registration/registration-about/index.js":55,"./catberry_components/registration/registration-faq/index.js":56,"./catberry_components/registration/registration-form/index.js":57,"./catberry_components/registration/registration-header/index.js":58,"./catberry_components/registration/registration-more-page/index.js":59,"./catberry_components/registration/registration-price/index.js":60,"./catberry_components/registration/registration-why-we/index.js":61,"./catberry_components/rubrikator/rubrikator-list/index.js":62,"./catberry_components/sale/index.js":63,"./catberry_components/search/index.js":64,"./catberry_components/service-request/index.js":65,"./catberry_components/social/index.js":66,"./catberry_stores/Breadcrumps.js":67,"./catberry_stores/Head.js":68,"./catberry_stores/Pages.js":69,"./catberry_stores/Paginator.js":70,"./catberry_stores/Tag.js":71,"./catberry_stores/master/MasterItem.js":72,"./catberry_stores/master/MasterList.js":73,"./catberry_stores/master/MasterSovety.js":74,"./catberry_stores/master/MasterVideo.js":75,"./catberry_stores/master/Recommended.js":76,"./catberry_stores/other/News.js":77,"./catberry_stores/other/NewsItem.js":78,"./catberry_stores/other/Recommendation.js":79,"./catberry_stores/other/Vacancy.js":80,"./catberry_stores/other/VacancyItem.js":81,"./catberry_stores/rubrika/Rubrika.js":82,"./catberry_stores/rubrika/Rubrikator.js":83,"./catberry_stores/rubrika/RubrikatorCompany.js":84,"./catberry_stores/rubrika/RubrikatorParent.js":85,"./catberry_stores/rubrika/RubrikatorSale.js":86,"./catberry_stores/sale/SaleByRubrika.js":87,"./node_modules/catberry/browser/Catberry.js":92,"./node_modules/catberry/browser/CookieWrapper":93,"./node_modules/catberry/browser/Logger.js":95,"./node_modules/catberry/browser/providers/ModuleApiProvider":100,"./node_modules/catberry/lib/StoreDispatcher":104,"./node_modules/catberry/lib/base/BootstrapperBase.js":105,"./routes.js":149,"util":121}],2:[function(require,module,exports){
'use strict';

var catberry = require('catberry'),
// this config will be replaced by `./config/browser.json` when building
// because of `browser` field in `package.json`
    config = require('./config/environment.json'),
    templateEngine = require('./special_modules/catberry-handlebars'),
    helpers = require('./special_modules/catberry-handlebars-helpers'),
    cat = catberry.create(config);

// register template provider to Catberry Service Locator
templateEngine.register(cat.locator);
helpers.register(cat.locator)

cat.startWhenReady();


},{"./config/environment.json":88,"./special_modules/catberry-handlebars":156,"./special_modules/catberry-handlebars-helpers":153,"catberry":101}],3:[function(require,module,exports){
'use strict';

module.exports = CommonH1;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "common-h1" component.
 * @constructor
 */
function CommonH1() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
CommonH1.prototype.render = function () {
    return this.$context.attributes;
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
CommonH1.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
CommonH1.prototype.unbind = function () {

};

},{}],4:[function(require,module,exports){
'use strict';

module.exports = CommonPaginator;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "common-paginator" component.
 * @constructor
 */
function CommonPaginator() {
}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
CommonPaginator.prototype.render = function () {
    var self = this;
    var model = this.$context.attributes.model;
    if (!model)
        return {
            "is-paginator": false
        };

    return this.$context.sendAction("setModel", model)
        .then(function () {
            return self.$context.getStoreData();
        });
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
CommonPaginator.prototype.bind = function () {
    return {
        click: {
            '.paginator__number': this._handleClick
        }
    }
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
CommonPaginator.prototype.unbind = function () {

};
CommonPaginator.prototype._handleClick = function(){
    window.scrollTo(0,0);
};
},{}],5:[function(require,module,exports){
'use strict';

module.exports = Breadcrumps;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "breadcrumps" component.
 * @constructor
 */
function Breadcrumps() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
Breadcrumps.prototype.render = function () {
    return this.$context.getStoreData();
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
Breadcrumps.prototype.bind = function () {
    return {
        click: {
            '.js-parent-rub': this._clickHandler,
        }
    }
};


Breadcrumps.prototype._clickHandler = function (obj) {
    //var el = obj.target;
    var pos = $('.js-parent-rub').position().left + $('.js-parent-rub').width();
    $('.js-breadcrumbs-list').css('left', pos).toggle();
    return false;
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
Breadcrumps.prototype.unbind = function () {

};

},{}],6:[function(require,module,exports){
'use strict';

module.exports = DopCatalogs;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "dop-catalogs" component.
 * @constructor
 */
function DopCatalogs() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
DopCatalogs.prototype.render = function () {

    return {
        'data-mod': this.$context.attributes['data-mod'],
        catalogs: [
            {
                url: "/sale",
                ico: "gift",
                title: "Поиск по скидке"
            },
            {
                url: "/video",
                ico: "video",
                title: "Поиск по видео"
            },
            {
                url: "/sovety",
                ico: "qwestion",
                title: "Секреты Мастеров"
            },
            {
                url: "/company",
                ico: "case",
                title: "Каталог фирм"
            }
        ]
    };
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
DopCatalogs.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
DopCatalogs.prototype.unbind = function () {

};

},{}],7:[function(require,module,exports){
'use strict';

module.exports = Document;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "document" component.
 * @constructor
 */
function Document() { }

},{}],8:[function(require,module,exports){
'use strict';

module.exports = Head;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "head" component.
 * @constructor
 */
function Head() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
Head.prototype.render = function () {
	return this.$context.getStoreData();
};


},{}],9:[function(require,module,exports){
'use strict';

module.exports = Loader;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "loader" component.
 * @constructor
 */
function Loader() { }


},{}],10:[function(require,module,exports){
'use strict';

module.exports = MasterBlockAbout;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-block-about" component.
 * @constructor
 */
function MasterBlockAbout() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterBlockAbout.prototype.render = function () {
    if (this.$context.attributes['master-page']) {
        return this.$context.getStoreData()
            .then(function (data) {
                data.aboutEduc = data.aboutEduc.replace(/\n/g, "<br>");
                data.aboutExp = data.aboutExp.replace(/\n/g, "<br>");
                data.aboutAddInfo = data.aboutAddInfo.replace(/\n/g, "<br>");
                return {
                    aboutEduc: data.aboutEduc,
                    aboutExp: data.aboutExp,
                    aboutAddInfo: data.aboutAddInfo
                }
            });
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterBlockAbout.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterBlockAbout.prototype.unbind = function () {

};

},{}],11:[function(require,module,exports){
'use strict';

module.exports = MasterBlockArticle;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-block-article" component.
 * @constructor
 */
function MasterBlockArticle() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterBlockArticle.prototype.render = function () {
    if (this.$context.attributes['master-page']) {
        return this.$context.getStoreData()
            .then(function (data) {
                data.articles.forEach(function (item) {
                    item.author = data.name; //добавляем автора для каждой статьи
                });
                //console.log(data.articles);
                return {
                    articles: data.articles
                }
            });
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterBlockArticle.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterBlockArticle.prototype.unbind = function () {

};

},{}],12:[function(require,module,exports){
'use strict';

module.exports = MasterBlockLink;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-block-link" component.
 * @constructor
 */
function MasterBlockLink() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterBlockLink.prototype.render = function () {
    if (this.$context.attributes['master-page']) {
        return this.$context.getStoreData()
            .then(function (data) {
                //console.log(data.contacts);
                return {
                    contacts: data.contacts
                }
            });
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterBlockLink.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterBlockLink.prototype.unbind = function () {

};

},{}],13:[function(require,module,exports){
'use strict';

module.exports = MasterBlockPhoto;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-block-photo" component.
 * @constructor
 */
function MasterBlockPhoto() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterBlockPhoto.prototype.render = function () {
    if (this.$context.attributes['master-page']) {
        return this.$context.getStoreData()
            .then(function (data) {
                //console.log(data.albums);
                return {
                    albums: [
                        {
                            "id": 1991,
                            "ownerType": 1,
                            "ownerID": 1019,
                            "name": "Альбом №1",
                            "status": 1,
                            "photos": [
                                {
                                    "id": 63853,
                                    "albumID": 1991,
                                    "imgID": "5693458623041",
                                    "description": null
                                },
                                {
                                    "id": 63854,
                                    "albumID": 1991,
                                    "imgID": "569345868bbb3",
                                    "description": null
                                },
                                {
                                    "id": 63855,
                                    "albumID": 1991,
                                    "imgID": "5693458701367",
                                    "description": null
                                },
                                {
                                    "id": 63856,
                                    "albumID": 1991,
                                    "imgID": "5693458771840",
                                    "description": null
                                },
                                {
                                    "id": 63857,
                                    "albumID": 1991,
                                    "imgID": "56934587d8e05",
                                    "description": null
                                },
                                {
                                    "id": 63858,
                                    "albumID": 1991,
                                    "imgID": "5693458845eb4",
                                    "description": null
                                },
                                {
                                    "id": 63859,
                                    "albumID": 1991,
                                    "imgID": "56934588af766",
                                    "description": null
                                }
                            ]
                        },
                        {
                            "id": 1993,
                            "ownerType": 1,
                            "ownerID": 1058,
                            "name": "Сертификаты",
                            "status": 1,
                            "photos": [
                                {
                                    "id": 64068,
                                    "albumID": 1993,
                                    "imgID": "569345ba20dc9",
                                    "description": null
                                },
                                {
                                    "id": 64069,
                                    "albumID": 1993,
                                    "imgID": "569345ba80f84",
                                    "description": null
                                },
                                {
                                    "id": 64070,
                                    "albumID": 1993,
                                    "imgID": "569345baeb4d9",
                                    "description": ""
                                },
                                {
                                    "id": 64071,
                                    "albumID": 1993,
                                    "imgID": "569345bb5f92a",
                                    "description": null
                                },
                                {
                                    "id": 64072,
                                    "albumID": 1993,
                                    "imgID": "569345bc6aee8",
                                    "description": null
                                },
                                {
                                    "id": 88332,
                                    "albumID": 1993,
                                    "imgID": "5693503e61284",
                                    "description": null
                                },
                                {
                                    "id": 88333,
                                    "albumID": 1993,
                                    "imgID": "5693503ec5377",
                                    "description": null
                                },
                                {
                                    "id": 119761,
                                    "albumID": 1993,
                                    "imgID": "56936e0849ae9",
                                    "description": null
                                }
                            ]
                        }
                    ]
                }
            });
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterBlockPhoto.prototype.bind = function () {
    var album = $('.photo-md__album-cover');
    var albumCont = $('.photo-md__album-cont');
    var albumPhotos = $('.photo-md__img-prev');
    album.bind('click', showAlbum);
    albumPhotos.bind('click', showAlbumImg);
    album.first().addClass('act');

    function showAlbum() {
        albumCont.hide();
        album.removeClass('act');
        $(this).addClass('act');
        $('#cont-' + ($(this).attr('id'))).show();
        return false;
    }

    function showAlbumImg() {
        $.fancybox(albumPhotos, {
            type: 'image',
            index : albumPhotos.index(this),
            helpers: {
                overlay: {
                    locked: false
                }
            }
        });
        return false;
    }
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterBlockPhoto.prototype.unbind = function () {
    var album = $('.photo-md__album-cover');
    var albumPhotos = $('.photo-md__img-prev');

    album.unbind('click');
    albumPhotos.unbind('click');
};

},{}],14:[function(require,module,exports){
'use strict';

module.exports = MasterBlockReview;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-block-review" component.
 * @constructor
 */
function MasterBlockReview() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterBlockReview.prototype.render = function () {
    if (this.$context.attributes['master-page']) {
        return this.$context.getStoreData()
            .then(function (data) {
                data.vkLikes.data = JSON.parse(data.vkLikes.data);
                data.vkLikes.data.length = 9; //укорачиваем массив до 9 элементов
                //console.log(data.comments);
                return {
                    comments: data.comments.reverse(),
                    vkLikes: data.vkLikes,
                    name: data.name,
                    imgID: data.imgID
                }
            });
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterBlockReview.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterBlockReview.prototype.unbind = function () {

};

},{}],15:[function(require,module,exports){
'use strict';

module.exports = MasterBlockSale;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-block-sale" component.
 * @constructor
 */
function MasterBlockSale() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterBlockSale.prototype.render = function () {
    if (this.$context.attributes['master-page']) {
        return this.$context.getStoreData()
            .then(function (data) {
                //console.log(data.sales);
                return {
                    sales: data.sales
                }
            });
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterBlockSale.prototype.bind = function () {
    var sale = $('.sale');
    sale.find('a').bind('click', showSalePopup);

    function showSalePopup() {
        var tmp = $(this).parent().clone();
        tmp.addClass('popup');
        $.fancybox.open(tmp, {
            padding: 0,
            helpers: {
                overlay: {
                    locked: false
                }
            }
        });
        return false;
    }
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterBlockSale.prototype.unbind = function () {

};

},{}],16:[function(require,module,exports){
'use strict';

module.exports = MasterBlockService;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-block-service" component.
 * @constructor
 */
function MasterBlockService() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterBlockService.prototype.render = function () {
    if (this.$context.attributes['master-page']) {
        return this.$context.getStoreData()
            .then(function (data) {
                //console.log(data);
                data.services = [
                    'Эксперт по развитию (комфортных, надежных, благополучных, доверительных) семейных отношений',
                    'Психологическое сопровождение семьи от ЗАГСа и по жизни',
                    'Психология семейных отношений',
                    'Психотерапия (индивидуальная и групповая)',
                    'Личные проблемы – беспокойства и страхи, неуверенность в себе, депрессия',
                    'Одиночество, не складывается личная жизнь',
                    'Проблемы в общении – сложности во взаимоотношениях, непонимание',
                    'Психосоматические расстройства у детей и взрослых',
                    'Зависимость (алкогольная, никотиновая, игровая и т.д.)',
                    'Повышенная конфликтность, конфликты на работе и не только',
                    'Психология детско-родительских отношений',
                    'Психодиагностика',
                    'Финансовое благополучие семьи – деньги и семейные конфликты, мои взаимоотношения с деньгами, развитие финансовой грамотности, финансовый диагноз',
                    'Организационная психология и бизнес-тренинги',
                    'Вопросы воспитания и развития',
                    'Психологическое консультирование',
                    'Индивидуальная психотерапия',
                    'Групповая психотерапия',
                    'Детско-родительские отношения',
                    'Проблемы семейных отношений',
                    'Проблемы взаимоотношений',
                    'Личностные проблемы',
                    'Психосоматические расстройства',
                    'Экзистенциальные вопросы',
                    'Работа со снами и мифами'
                ];
                var fieldsValSum = 0;
                var fieldsValHalfSum = 0;
                var part1 = [];
                var part2 = [];

                data.services.forEach(function (item, i, arr) {
                    //var fieldsValHalfSum = 0;
                    var fieldsValLength;

                    fieldsValLength = item.length;
                    if (fieldsValLength < 30) {
                        fieldsValLength = 30;
                    }
                    fieldsValSum += fieldsValLength;
                });
                data.services.forEach(function (item, i, arr) {
                    var fieldsValLength;

                    fieldsValLength = item.length;
                    if (fieldsValHalfSum < fieldsValSum / 2) {
                        part1.push(item);
                    } else {
                        part2.push(item);
                    }
                    fieldsValHalfSum += fieldsValLength;
                });
                data.services = [];
                data.services.part1 = part1;
                data.services.part2 = part2;
                //console.log(data.services);
                return {
                    services: data.services
                }
            });
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterBlockService.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterBlockService.prototype.unbind = function () {

};

},{}],17:[function(require,module,exports){
'use strict';

module.exports = MasterBlockVideo;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-block-video" component.
 * @constructor
 */
function MasterBlockVideo() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterBlockVideo.prototype.render = function () {
    if (this.$context.attributes['master-page']) {
        return this.$context.getStoreData()
            .then(function (data) {
                //console.log(data.videos);
                return {
                    videos: data.videos
                }
            });
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterBlockVideo.prototype.bind = function () {
    var video = $('.video-md__video-cover');
    video.bind('click', showVideo);

    function showVideo() {
        $.fancybox.open(this, {
            padding: 0,
            type: 'iframe',
            helpers: {
                overlay: {
                    locked: false
                }
            }
        });
        return false;
    }
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterBlockVideo.prototype.unbind = function () {
    $('.video-md__video-cover').unbind('click');
};

},{}],18:[function(require,module,exports){
'use strict';

module.exports = MasterBlockWork;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-block-work" component.
 * @constructor
 */
function MasterBlockWork() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterBlockWork.prototype.render = function () {
    if (this.$context.attributes['master-page']) {
        return this.$context.getStoreData()
            .then(function (data) {
                var tempArr = new Array(7);
                data.schedule.forEach(function (item) {
                    item.open = item.open.substr(0, 5);
                    item.close = item.close.substr(0, 5);
                    tempArr[item.day - 1] = item;
                });
                data.schedule = tempArr;
                return {
                    schedule: data.schedule,
                    district: data.districts,
                    workCondition: data.workCondition
                }
            });
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterBlockWork.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterBlockWork.prototype.unbind = function () {

};

},{}],19:[function(require,module,exports){
'use strict';
module.exports = MasterFilter;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-filter" component.
 * @constructor
 */
function MasterFilter() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterFilter.prototype.render = function () {
    var self = this;
    var path, currentTag;
    var result = [];

    return this.$context.getStoreData()
        .then(function (data) {
            path = '/' + data.rubrika.parent.unique + '/' + data.rubrika.unique;

            return self.$context.getStoreData('master/MasterList')
                .then(function (master) {
                    if (Object.keys(master).length > 0)
                        result.push({
                            url: path,
                            sectionName: "master",
                            title: "Мастера",
                            ico: "man"
                        });
                })
                .then(function () {
                    return self.$context.getStoreData('master/MasterVideo')
                })
                .then(function (video) {
                    //if (Object.keys(master).length > 0)
                    result.push({
                        url: path + '/video',
                        sectionName: "video",
                        title: "Видео Мастеров",
                        ico: "video"
                    });
                })
                .then(function () {
                    //return self.$context.getStoreData('master/MasterVideo')
                })
                .then(function (sales) {
                    //if (Object.keys(master).length > 0)
                    result.push({
                        url: path + '/sale',
                        sectionName: "sale",
                        title: "Скидки Мастеров",
                        ico: "gift"
                    });
                })
                .then(function () {
                    //return self.$context.getStoreData('master/MasterVideo')
                })
                .then(function (secrets) {
                    //if (Object.keys(master).length > 0)
                    result.push({
                        url: path + '/sovety',
                        sectionName: "sovety",
                        title: "Секреты Мастеров",
                        ico: "qwestion"
                    });
                })
                .then(function () {
                    //return self.$context.getStoreData('master/MasterVideo')
                })
                .then(function (company) {
                    //if (Object.keys(master).length > 0)
                    result.push({
                        url: path + '/company',
                        sectionName: "company",
                        title: "Каталог фирм",
                        ico: "case"
                    });
                })
                .then(function () {
                    self._decoreOpenSection(result, data);
                    return {filterSection: result};
                })
        });
};
/**
 * Декарирование открытой секции (добавление тегов, ортировки)
 * @param result массив для декорирования
 * @param rubrika рубрика из стора
 * @private
 */
MasterFilter.prototype._decoreOpenSection = function (result, data) {
    var currentSection = data.section;

    for (var i = 0; i < result.length; ++i) {
        if (result[i].sectionName == currentSection) {

            var tags = this._getTags(data);
            result[i].openSection = {tagsGroup: tags};
            if (currentSection == 'masters') {
                result[i].openSection.sortBy = {
                    "url": "",
                    "method": "get"
                };
            }
            return;
        }
    }
};

/**
 * Перестройка тегов
 * @param tagsJson тэги из json
 * @param path абсолютный родительский путь для ссылок в тегах
 * @param currentTag текущий тег для выделения
 * @returns {Array} теги разбитые по группам
 * @private
 */
MasterFilter.prototype._getTags = function (data) {
    var path = '/' + data.rubrika.parent.unique + '/' + data.rubrika.unique;
    var tagsJson = data.rubrika.tags;
    var currentTag = data.tag.unique ;
    var currentSection = data.section;
    var tags = [];

    Object.keys(tagsJson)
        .forEach(function (n) {
            var tag = tagsJson[n];
            tag.isActive = false;

            if (!tags[tag.group])
                tags[tag.group] = [];

            if (tag.unique == currentTag) {
                tag.isActive = true;
                tag.urlBack = path;
            }
            if (currentSection == 'master') {
                tag.path = path + '/' + tag.unique;
            } else {
                tag.path = path + '/' + tag.unique + '/' + currentSection;
            }

            tags[tag.group].push(tag);
        });

    //сортируем
    var tagsGroup = [];
    Object.keys(tags).sort().forEach(function (key) {
        tagsGroup.push({
            title: key,
            tags: tags[key]
        });
    });
    return tagsGroup;
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterFilter.prototype.bind = function () {
    return {
        click: {
            '.js-filter-toggle-btn.active': this._clickSection
        }
    }
};

MasterFilter.prototype._clickSection = function (obj) {
    var dom = obj.target;
    var el;
    if (!($(dom).hasClass('js-filter-toggle-btn') && $(dom).hasClass('active')))
        el = $(dom).parents('.js-filter-toggle-btn');
    else
        el = $(dom);
    el.parent().find('.js-filter-toggle-section').slideToggle();
    el.find('.filter-section__arrow-icon').toggleClass('down');
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterFilter.prototype.unbind = function () {

};

},{}],20:[function(require,module,exports){
'use strict';

module.exports = MasterList;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-list" component.
 * @constructor
 */
function MasterList($serviceLocator) {
// we can use window from the locator in a browser only
    if (this.$context.isBrowser) {
        this._window = $serviceLocator.resolve('window');
        this._handleScroll = this._handleScroll.bind(this);
    }
}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterList.prototype.render = function () {
    return this.$context.getStoreData();
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterList.prototype.bind = function () {
    this._window.addEventListener('resize', this._allMinicardServicesCut);
    this._window.addEventListener('scroll', this._handleScroll);
};

MasterList.prototype.unbind = function () {
    this._window.removeEventListener('resize', this._allMinicardServicesCut);
    this._window.removeEventListener('scroll', this._handleScroll);
    this.$context.collectGarbage();
};

/**
 * Handles window scroll for infinite scroll loading.
 * @private
 */
MasterList.prototype._handleScroll = function () {
    var self = this;
    var windowHeight = this._window.innerHeight,
        scrollTop = this._window.pageYOffset,
        doc = this._window.document.documentElement;
    try {
        // when scroll to the bottom of the page load more items
        if (
            !this._isBusy &&
            (scrollTop >= (doc.scrollHeight - windowHeight * 2) ||
            doc.scrollHeight <= windowHeight)
        ) {
            this._isBusy = true;
            if (!this._isFinish) {
                $('#wait-spinner').show();
                this._loadMoreItems()
                    .then(function (finish) {
                        if (finish === null) {
                            self._isFinish = true;
                        }
                        self._isBusy = false;
                        $('#wait-spinner').fadeOut(800);
                    });
            }
        }
    } catch (e) {
        // do nothing
    }
};
MasterList.prototype._isBusy = false;
MasterList.prototype._isFinish = false;
/**
 * Loads more items to feed.
 * @private
 */
MasterList.prototype._loadMoreItems = function () {
    return this.$context.sendAction('getNextPage');
};

MasterList.prototype._allMinicardServicesCut = function () {
    $('.master-minicard').each(function () {
        var minicardServices = $(this).find('.master-minicard__services');
        var servicesList = minicardServices.find('li');
        var maxHeight =
            $(this).height() - ($(this).find('.master-minicard__name').height() + $(this).find('.master-minicard__spec').height());
        var servicesCount = minicardServices.find('li').length;

        if (minicardServices.height() > maxHeight) {
            while (minicardServices.height() > maxHeight && servicesCount >= 0) {
                $(servicesList[servicesCount - 1]).hide();
                servicesCount--;
            }
        } else if ((minicardServices.height() + 10) < maxHeight) {
            var i = 0;
            while (minicardServices.height() < maxHeight && i < servicesCount + 1) {
                $(servicesList[i]).show();
                i++;
            }
            if (minicardServices.height() > maxHeight) {
                $(servicesList[i - 1]).hide();
            }
        }
    });
};


},{}],21:[function(require,module,exports){
'use strict';

module.exports = MasterMinicard;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-minicard" component.
 * @constructor
 */
function MasterMinicard() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterMinicard.prototype.render = function () {
    var self = this;
    return this.$context.getStoreData()
        .then(function (data) {
            if (!data)
                return;
            var masterID = self.$context.attributes['master-id'];
            for (var i = 0; i < data.length; ++i) {
                if (data[i].id == masterID) {
                    return data[i];
                }
            }
        })
        .then(function (master) {
            if (!master)
                return;
            if (master.page && (
                    (master.page.sales && master.sales[0]) ||
                    (master.page.albums && master.albums[0]) ||
                    (master.page.videos && master.videos[0]) ||
                    (master.page.comments && master.comments[0])
                )) {
                master.isWidget = true;
            }
            if (master.page && master.page.albums && master.albums) {
                master.albumsCount = master.albums.length;
                master.albumsTitle = [];
                master.albums.forEach(function (el) {
                    master.albumsTitle.push(el.name);
                });
                master.albumsTitle = master.albumsTitle.join(', ');
            }
            if (master.page && master.page.comments && master.comments) {
                master.commentsCount = master.comments.length;
            }
            var servicesNormally = [];
            Object.keys(master.services).forEach(function (item, i, arr) {
                var service = master.services[item];
                service = service.replace(/\u00A0/g, " ");
                servicesNormally.push(service);
            });
            master.services = servicesNormally;
            //console.log(Object.keys(master.services));
            return master;
        });
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterMinicard.prototype.bind = function () {
    $('.master-content-widget li').bind('mouseenter', showWidgetTab);

    $('.master-content-widget').each(function () {
        $(this).find('.act').first().addClass('show');
    });
    function showWidgetTab() {
        if ($(this).hasClass('act')) {
            $(this).siblings().removeClass('show');
            $(this).addClass('show');
        }
    }

    this._minicardServicesCut();
    return {};
};
MasterMinicard.prototype._minicardServicesCut = function () {
    var minicard = $('#' + this.$context.element.id);
    var minicardServices = minicard.find('.master-minicard__services');
    var maxHeight =
        minicard.find('.master-minicard').height() - (minicard.find('.master-minicard__name').height() + minicard.find('.master-minicard__spec').height());
    var servicesCount = minicardServices.find('li').length;

    while (minicardServices.height() > maxHeight && servicesCount != 0) {
        $(minicardServices.find('li')[servicesCount]).hide();
        servicesCount--;
    }
};
/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterMinicard.prototype.unbind = function () {
    $('.master-content-widget li').unbind('mouseenter');
};

},{}],22:[function(require,module,exports){
'use strict';

module.exports = MasterPhoneBtn;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-phone-btn" component.
 * @constructor
 */
function MasterPhoneBtn() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterPhoneBtn.prototype.render = function () {
    return this.$context.attributes;
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterPhoneBtn.prototype.bind = function () {
    return {
        click: {
            '.js-show-phone': this._clickPhoneHandler,
            '.js-close-tip': this._clickCloseTipHandler
        }
    }
};

MasterPhoneBtn.prototype._clickPhoneHandler = function (obj) {
    var el = obj.target;
    $(el).hide();
    $(el).siblings('.js-show-phone-details').show();
    $(el).closest('.master-minicard').find('.js-master-phone-tip').fadeIn(400).delay(4000).fadeOut(500);
};
MasterPhoneBtn.prototype._clickCloseTipHandler = function (obj) {
    var el = obj.target;
    $(el).closest('.js-master-phone-tip').stop().fadeOut(500);
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterPhoneBtn.prototype.unbind = function () {

};

},{}],23:[function(require,module,exports){
'use strict';

module.exports = MasterPage;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-page" component.
 * @constructor
 */
function MasterPage() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterPage.prototype.render = function () {
    return this.$context.getStoreData().then(function (data) {
        //console.log(data.company);
        return data;
    });
};

MasterPage.prototype._ta = null;
/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterPage.prototype.bind = function () {
    var menu = $('.menu-mp');
    var menuOffset = menu.offset();
    var ta = $('textarea');

    $(window).bind('scroll', fixedSectionMenu);
    $(window).bind('scroll', menuHighlight);
    $('.menu-mp a').bind('click', scrollToSection);
    $('.contacts-mp__show-contact').bind('click', showContact);
    $('.js-show-callback-popup').bind('click', showCallbackPopup);
    autosize(ta);

    //показать контакты
    function showContact() {
        $(this).closest('.contacts-mp__cap').hide();
        return false;
    }

    //плавающего меню
    function fixedSectionMenu() {
        if ($(window).scrollTop() + 30 > menuOffset.top) {
            menu.addClass('fixed');
        } else {
            menu.removeClass('fixed');
        }
    }

    //скролл до секции
    function menuHighlight() {
        $('.master-page__section-cont').each(function () {
            if ($(window).scrollTop() + 50 > $(this).offset().top && $(window).scrollTop() + 30 < $(this).offset().top + $(this).innerHeight()) {
                menu.find('.act').removeClass('act');
                menu.find('[href=#' + $(this).children().attr('id') + ']').addClass('act');
            }
        });
    }

    //навигации внутри страницы мастера
    function scrollToSection() {
        $(window).unbind('scroll', menuHighlight);
        setTimeout(function () {
            $(window).bind('scroll', menuHighlight);
        }, 1050);
        menu.find('.act').removeClass('act');
        $(this).addClass('act');
        $('html, body').animate({
            scrollTop: $($(this).attr('href')).offset().top - 50
        }, 1000);
        return false;
    }

    //показать popup - заказать звонок
    function showCallbackPopup() {
        var form = $('.callback-popup');
        $.fancybox.open(form, {
            padding: 0
        });
        return false;
    }
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterPage.prototype.unbind = function () {
    var ta = document.querySelector('textarea');
    var evt = document.createEvent('Event');

    $(window).unbind('scroll');
    $('.menu-mp').find('a').unbind('click');
    $('.contacts-mp__show-contact').unbind('click');
    $('.js-show-callback-popup').unbind('click');
    evt.initEvent('autosize:destroy', true, false);
    ta.dispatchEvent(evt);
};
},{}],24:[function(require,module,exports){
'use strict';

module.exports = MasterRecommended;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-recommended" component.
 * @constructor
 */
function MasterRecommended() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterRecommended.prototype.render = function () {
    //return this.$context.getStoreData();
    return {
        "is-recommended-masters": true,
        "url-arrow-left": "404",
        "url-arrow-right": "404",
        "recommended-master": [
            {
                "master-url": "404",
                "src": "/img/assets/master_recommended/3720.jpg",
                "alt": "Князев А.Ю.",
                "master-name": "Князев А.Ю.",
                "recommendation-number": "27 человек"
            },
            {
                "master-url": "404",
                "src": "/img/assets/master_recommended/4617.jpg",
                "alt": "Хальзов А.",
                "master-name": "Хальзов А.",
                "recommendation-number": "6 человек"
            },
            {
                "master-url": "404",
                "src": "/img/assets/master_recommended/7428.jpg",
                "alt": "Булгаков В.А.",
                "master-name": "Булгаков В.А.",
                "recommendation-number": "5 человек"
            },
            {
                "master-url": "404",
                "src": "/img/assets/master_recommended/3720.jpg",
                "alt": "Князев А.Ю.",
                "master-name": "Князев А.Ю.",
                "recommendation-number": "27 человек"
            },
            {
                "master-url": "404",
                "src": "/img/assets/master_recommended/4617.jpg",
                "alt": "Хальзов А.",
                "master-name": "Хальзов А.",
                "recommendation-number": "6 человек"
            },
            {
                "master-url": "404",
                "src": "/img/assets/master_recommended/7428.jpg",
                "alt": "Булгаков В.А.",
                "master-name": "Булгаков В.А.",
                "recommendation-number": "5 человек"
            },
            {
                "master-url": "404",
                "src": "/img/assets/master_recommended/3720.jpg",
                "alt": "Князев А.Ю.",
                "master-name": "Князев А.Ю.",
                "recommendation-number": "27 человек"
            },
            {
                "master-url": "404",
                "src": "/img/assets/master_recommended/4617.jpg",
                "alt": "Хальзов А.",
                "master-name": "Хальзов А.",
                "recommendation-number": "6 человек"
            },
            {
                "master-url": "404",
                "src": "/img/assets/master_recommended/7428.jpg",
                "alt": "Булгаков В.А.",
                "master-name": "Булгаков В.А.",
                "recommendation-number": "5 человек"
            }
        ]
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterRecommended.prototype.bind = function () {
    this.bindSlick();
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterRecommended.prototype.unbind = function () {
    this.unbindSlick();
};

MasterRecommended.prototype.bindSlick = function () {
    $('.master_recommended__slider').slick({
        dots: false,
        infinite: false,
        speed: 700,
        slidesToShow: 4,
        slidesToScroll: 3,
        prevArrow: '<div class="slick-prev">' +
        '<svg class="icon icon_strelka" title="icon_strelka" role="img">' +
        '<use xlink:href="/icon-svg/svg-symbols.svg#icon_strelka"/>' +
        '</svg>' +
        '</div>',
        nextArrow: '<div class="slick-next">' +
        '<svg class="icon icon_strelka" title="icon_strelka" role="img">' +
        '<use xlink:href="/icon-svg/svg-symbols.svg#icon_strelka"/>' +
        '</svg>' +
        '</div>'
    });
};
MasterRecommended.prototype.unbindSlick = function () {
    $('.master_recommended__slider').slick("unslick");
};
},{}],25:[function(require,module,exports){
'use strict';

module.exports = MasterRubrika;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "master-rubrika" component.
 * @constructor
 */
function MasterRubrika() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MasterRubrika.prototype.render = function () {
    return this.$context.getStoreData();
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MasterRubrika.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MasterRubrika.prototype.unbind = function () {

};

},{}],26:[function(require,module,exports){
'use strict';

module.exports = OtherNewsItem;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "other-news-item" component.
 * @constructor
 */
function OtherNewsItem() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
OtherNewsItem.prototype.render = function () {
    return this.$context.getStoreData();
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
OtherNewsItem.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
OtherNewsItem.prototype.unbind = function () {

};

},{}],27:[function(require,module,exports){
'use strict';

module.exports = OtherNews;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "other-news" component.
 * @constructor
 */
function OtherNews() {
}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
OtherNews.prototype.render = function () {
    return this.$context.getStoreData();
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
OtherNews.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
OtherNews.prototype.unbind = function () {

};

},{}],28:[function(require,module,exports){
'use strict';

module.exports = OtherRecommendation;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "other-recommendation" component.
 * @constructor
 */
function OtherRecommendation() {
}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
OtherRecommendation.prototype.render = function () {
    return this.$context.getStoreData()
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
OtherRecommendation.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
OtherRecommendation.prototype.unbind = function () {

};

},{}],29:[function(require,module,exports){
'use strict';

module.exports = OtherVacancyItem;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "other-vacancy-item" component.
 * @constructor
 */
function OtherVacancyItem() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
OtherVacancyItem.prototype.render = function () {
    return this.$context.getStoreData();
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
OtherVacancyItem.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
OtherVacancyItem.prototype.unbind = function () {

};

},{}],30:[function(require,module,exports){
'use strict';

module.exports = OtherVacancy;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "other-vacancy" component.
 * @constructor
 */
function OtherVacancy() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
OtherVacancy.prototype.render = function () {
    return this.$context.getStoreData()
        .then (function (res) {
        return {
            vacancy: res
        }
    });
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
OtherVacancy.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
OtherVacancy.prototype.unbind = function () {

};

},{}],31:[function(require,module,exports){
'use strict';

module.exports = Rubikator;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "rubikator" component.
 * @constructor
 */
function Rubikator() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
Rubikator.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
Rubikator.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
Rubikator.prototype.unbind = function () {

};

},{}],32:[function(require,module,exports){
'use strict';

module.exports = PageContact;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-contact" component.
 * @constructor
 */
function PageContact() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageContact.prototype.render = function () {
    return {
        "phone": "(8482) 741-147",
        "email": "info@facemaster.ru",
        "adress": "г. Тольятти, ул. Автостроителей 41А-1"
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageContact.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageContact.prototype.unbind = function () {

};

},{}],33:[function(require,module,exports){
'use strict';

module.exports = PageFeedback;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-feedback" component.
 * @constructor
 */
function PageFeedback() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageFeedback.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageFeedback.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageFeedback.prototype.unbind = function () {

};

},{}],34:[function(require,module,exports){
'use strict';

module.exports = PageLogin;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-login" component.
 * @constructor
 */
function PageLogin() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageLogin.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageLogin.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageLogin.prototype.unbind = function () {

};

},{}],35:[function(require,module,exports){
'use strict';

module.exports = DopFunction;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "dop-function" component.
 * @constructor
 */
function DopFunction() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
DopFunction.prototype.render = function () {
    return {
        "menuMaster": [
            {
                "url": "/registration",
                "title": "Стать Мастером",
                "icon": true
            },
            {
                "url": "/recommendation",
                "title": "Мастера о сайте"
            }
        ],
        "menuAbout": [
            {
                "url": "/news",
                "title": "Новости"
            },
            {
                "url": "/vacancy",
                "title": "Вакансии"
            }
        ],
        "menuBayda": [
            {
                "url": "/404",
                "title": "Конкурсы газеты Презент"
            },
            {
                "url": "/404",
                "title": "Маршрутки Тольятти с 01.01.2015"
            },
            {
                "url": "/404",
                "title": "Дачные перевозки"
            },
            {
                "empty": true
            }
        ]
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
DopFunction.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
DopFunction.prototype.unbind = function () {

};

},{}],36:[function(require,module,exports){
'use strict';

module.exports = Main;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "main" component.
 * @constructor
 */
function Main() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
Main.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
Main.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
Main.prototype.unbind = function () {

};

},{}],37:[function(require,module,exports){
'use strict';

module.exports = MainFunction;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "main-function" component.
 * @constructor
 */
function MainFunction() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
MainFunction.prototype.render = function () {
  return {
    countMaster: '1 234 Мастера'
  }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
MainFunction.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
MainFunction.prototype.unbind = function () {

};

},{}],38:[function(require,module,exports){
'use strict';

module.exports = PageMasterPage;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-master-page" component.
 * @constructor
 */
function PageMasterPage() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageMasterPage.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageMasterPage.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageMasterPage.prototype.unbind = function () {

};

},{}],39:[function(require,module,exports){
'use strict';

module.exports = PageMasterRubrika;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-master-rubrika" component.
 * @constructor
 */
function PageMasterRubrika() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageMasterRubrika.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageMasterRubrika.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageMasterRubrika.prototype.unbind = function () {

};

},{}],40:[function(require,module,exports){
'use strict';

module.exports = PageNewsItem;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-news-item" component.
 * @constructor
 */
function PageNewsItem() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageNewsItem.prototype.render = function () {
    return this.$context.getStoreData();
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageNewsItem.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageNewsItem.prototype.unbind = function () {

};

},{}],41:[function(require,module,exports){
'use strict';

module.exports = PageNews;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-news" component.
 * @constructor
 */
function PageNews() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageNews.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageNews.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageNews.prototype.unbind = function () {

};

},{}],42:[function(require,module,exports){
'use strict';

module.exports = PageOferta;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-oferta" component.
 * @constructor
 */
function PageOferta() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageOferta.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageOferta.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageOferta.prototype.unbind = function () {

};

},{}],43:[function(require,module,exports){
'use strict';

module.exports = PageRecommendation;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-recommendation" component.
 * @constructor
 */
function PageRecommendation() {
}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageRecommendation.prototype.render = function () {
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageRecommendation.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageRecommendation.prototype.unbind = function () {

};

},{}],44:[function(require,module,exports){
'use strict';

module.exports = PageRegistration;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-registration" component.
 * @constructor
 */
function PageRegistration() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageRegistration.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageRegistration.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageRegistration.prototype.unbind = function () {

};

},{}],45:[function(require,module,exports){
'use strict';

module.exports = PageRequest;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-request" component.
 * @constructor
 */
function PageRequest() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageRequest.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageRequest.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageRequest.prototype.unbind = function () {

};

},{}],46:[function(require,module,exports){
'use strict';

module.exports = PageSaleCatalog;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-sale-catalog" component.
 * @constructor
 */
function PageSaleCatalog() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageSaleCatalog.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageSaleCatalog.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageSaleCatalog.prototype.unbind = function () {

};

},{}],47:[function(require,module,exports){
'use strict';

module.exports = PageSovetyCatalog;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-sovety-catalog" component.
 * @constructor
 */
function PageSovetyCatalog() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageSovetyCatalog.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageSovetyCatalog.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageSovetyCatalog.prototype.unbind = function () {

};

},{}],48:[function(require,module,exports){
'use strict';

module.exports = PageVacancyItem;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-vacancy-item" component.
 * @constructor
 */
function PageVacancyItem() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageVacancyItem.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageVacancyItem.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageVacancyItem.prototype.unbind = function () {

};

},{}],49:[function(require,module,exports){
'use strict';

module.exports = PageVacancy;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-vacancy" component.
 * @constructor
 */
function PageVacancy() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageVacancy.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageVacancy.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageVacancy.prototype.unbind = function () {

};

},{}],50:[function(require,module,exports){
'use strict';

module.exports = PageVideoCatalog;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "page-video-catalog" component.
 * @constructor
 */
function PageVideoCatalog() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PageVideoCatalog.prototype.render = function () {
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PageVideoCatalog.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PageVideoCatalog.prototype.unbind = function () {

};

},{}],51:[function(require,module,exports){
'use strict';

module.exports = PagesContent;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "pages-content" component.
 * @constructor
 */
function PagesContent() { }

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PagesContent.prototype.render = function () {
	return this.$context.getStoreData();
};

/**
 * Returns event binding settings for the component.
 */
PagesContent.prototype.bind = function () {
	this.hideLoader();
};

/**
 * Hides loader in template.
 */
PagesContent.prototype.hideLoader = function () {
	var loaders = this.$context.element.getElementsByTagName('cat-loader');
	for (var i = 0; i < loaders.length; i++) {
		loaders[i].style.display = 'none';
	}
	window.scrollTo(0,0);
};

},{}],52:[function(require,module,exports){
'use strict';

module.exports = Footer;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "pages-footer" component.
 * @constructor
 */
function Footer() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
Footer.prototype.render = function () {
    return {
        links: [
            {
                "url": "/oferta",
                "title": "Оферта"
            },
            {
                "url": "/contact",
                "title": "Контакты"
            },
            {
                "url": "/feedback",
                "title": "Обратная связь"
            }
        ]
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
Footer.prototype.bind = function () {
    var windowHeight = $(window).height();
    $('.to-top').children('a').bind('click', scrollToTop);
    $(window).bind('scroll', isVisibleToTop);

    function scrollToTop() {
        $('html, body').animate({
            scrollTop: 0
        }, 1000);
        return false;
    }

    function isVisibleToTop() {
        if (windowHeight / 2 > $(window).scrollTop()) {
            $('.to-top').fadeOut(400);
        } else {
            $('.to-top').fadeIn(400);
        }
    }
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
Footer.prototype.unbind = function () {
    $('.to-top').children('a').unbind('click');
    $(window).unbind('scroll');
};

},{}],53:[function(require,module,exports){
'use strict';

module.exports = PagesHeader;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "pages-header" component.
 * @constructor
 */
function PagesHeader() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PagesHeader.prototype.render = function () {
    return this.$context.getStoreData()
        .then(function (data) {
            return data.header;
        });
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
PagesHeader.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
PagesHeader.prototype.unbind = function () {

};

},{}],54:[function(require,module,exports){
'use strict';

var PAGES = require("../../../config/pages.json");

module.exports = PagesNavigation;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "pages-navigation" component.
 * @constructor
 */
function PagesNavigation() {
}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
PagesNavigation.prototype.render = function () {
    return {
        menu: [
            {
                link: '/catalog',
                name: PAGES.catalog.title
            },
            {
                link: '/request',
                name: PAGES.request.title
            },
            {
                link: '/registration',
                name: PAGES.registration.title
            }
        ]
    };
};

},{"../../../config/pages.json":89}],55:[function(require,module,exports){
'use strict';

module.exports = RegistrationAbout;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "registration-about" component.
 * @constructor
 */
function RegistrationAbout() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
RegistrationAbout.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
RegistrationAbout.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
RegistrationAbout.prototype.unbind = function () {

};

},{}],56:[function(require,module,exports){
'use strict';

module.exports = RegistrationFaq;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "registration-faq" component.
 * @constructor
 */
function RegistrationFaq() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
RegistrationFaq.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
RegistrationFaq.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
RegistrationFaq.prototype.unbind = function () {

};

},{}],57:[function(require,module,exports){
'use strict';

module.exports = RegistrationForm;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "registration-form" component.
 * @constructor
 */
function RegistrationForm() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
RegistrationForm.prototype.render = function () {
    return {
        url: "/reg-master/success.json",
        urlLK: "404",
        method: "get"
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
RegistrationForm.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
RegistrationForm.prototype.unbind = function () {

};

},{}],58:[function(require,module,exports){
'use strict';

module.exports = RegistrationHeader;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "registration-header" component.
 * @constructor
 */
function RegistrationHeader() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
RegistrationHeader.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
RegistrationHeader.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
RegistrationHeader.prototype.unbind = function () {

};

},{}],59:[function(require,module,exports){
'use strict';

module.exports = RegistrationMorePage;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "registration-more-page" component.
 * @constructor
 */
function RegistrationMorePage() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
RegistrationMorePage.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
RegistrationMorePage.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
RegistrationMorePage.prototype.unbind = function () {

};

},{}],60:[function(require,module,exports){
'use strict';

module.exports = RegistrationPrice;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "registration-price" component.
 * @constructor
 */
function RegistrationPrice() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
RegistrationPrice.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
RegistrationPrice.prototype.bind = function () {
    return {
        click: {
            '.tab-content__name': this._clickHandle
        }
    }
};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
RegistrationPrice.prototype.unbind = function () {

};

RegistrationPrice.prototype._clickHandle = function (obj) {
    var el = $(obj.target);
    if (!el.hasClass('tab-content__name'))
        el = el.parents('.tab-content__name');

    var parent = el.parents('.tab-content');
    if (parent.hasClass('tab-content_active'))
        return;
    $('.tab-content_active').removeClass('tab-content_active');
    parent.addClass('tab-content_active');
};

},{}],61:[function(require,module,exports){
'use strict';

module.exports = RegistrationWhyWe;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "registration-why-we" component.
 * @constructor
 */
function RegistrationWhyWe() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
RegistrationWhyWe.prototype.render = function () {
    return {
        count: {
            master: "1 000",
            masterName: "мастеров<br>на сайте",
            visits: "12 000",
            orders: "1 000"
        }
    }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
RegistrationWhyWe.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
RegistrationWhyWe.prototype.unbind = function () {

};

},{}],62:[function(require,module,exports){
'use strict';

module.exports = Catalog;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "catalog" component.
 * @constructor
 */
function Catalog() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
Catalog.prototype.render = function () {
    return this.$context.getStoreData()
        .then(function (data) {
            return {
                rubrikator: data
            }
        });
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
Catalog.prototype.bind = function () {
    return {
        click: {
            '.js-rubrika-list': this._clickHandler,
            '.js-rubrika-collapsed': this._clickAllHandler
        }
    }
};

Catalog.prototype._clickHandler = function (obj) {
    var el = obj.target;
    $(el).parents('.rubrika-list').find('.rubrika-list__list').toggle();
}

Catalog.prototype._clickAllHandler = function (obj) {
    var el = obj.target;
    var self = $(el).parents('.js-rubrika-collapsed');

    var cl = 'master-rubrikator-page';
    var cl_col = cl + '_collapsed';
    var el = $('.master-rubrikator-page');

    if (el.hasClass(cl_col)) {
        el.removeClass(cl_col);
        $('.rubrika-list__list').show();
        self.find('.rubrika-list__name').html('Свернуть все рубрики')
            .end().find('.rubrika-list__icon').addClass('rubrika-list__icon_rotate');
    } else {
        el.addClass(cl_col);
        $('.rubrika-list__list').hide();
        self.find('.rubrika-list__name').html('Развернуть все рубрики')
            .end().find('.rubrika-list__icon').removeClass('rubrika-list__icon_rotate');
    }
}
/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
Catalog.prototype.unbind = function () {

};



},{}],63:[function(require,module,exports){
'use strict';

module.exports = Sale;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "sale" component.
 * @constructor
 */
function Sale() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
Sale.prototype.render = function () {
    return this.$context.getStoreData();
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
Sale.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
Sale.prototype.unbind = function () {

};

},{}],64:[function(require,module,exports){
'use strict';

module.exports = Search;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "search" component.
 * @constructor
 */
function Search() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
Search.prototype.render = function () {
  return {
    modificator: this.$context.attributes.modificator,
    url: '',
    method: ''
  }
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
Search.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
Search.prototype.unbind = function () {

};

},{}],65:[function(require,module,exports){
'use strict';

module.exports = ServiceRequest;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "service-request" component.
 * @constructor
 */
function ServiceRequest() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
ServiceRequest.prototype.render = function () {

};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
ServiceRequest.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
ServiceRequest.prototype.unbind = function () {

};

},{}],66:[function(require,module,exports){
'use strict';

module.exports = Social;

/*
 * This is a Catberry Cat-component file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#cat-components
 */

/**
 * Creates new instance of the "social" component.
 * @constructor
 */
function Social() {

}

/**
 * Gets data context for template engine.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Data context
 * for template engine.
 */
Social.prototype.render = function () {
  return [
    {
      url: 'http://vk.com/fm_mf',
      ico: 'vk'
    },
    {
      url: 'http://www.facebook.com/face.mast',
      ico: 'fb'
    },
    {
      url: 'http://www.odnoklassniki.ru/facemaster',
      ico: 'ok'
    },
    {
      url: 'http://twitter.com/FacemasterRu',
      ico: 'tw'
    }
  ];
};

/**
 * Returns event binding settings for the component.
 * This method is optional.
 * @returns {Promise<Object>|Object|null|undefined} Binding settings.
 */
Social.prototype.bind = function () {

};

/**
 * Does cleaning for everything that have NOT been set by .bind() method.
 * This method is optional.
 * @returns {Promise|undefined} Promise or nothing.
 */
Social.prototype.unbind = function () {

};

},{}],67:[function(require,module,exports){
'use strict';

var PAGES = require("../config/pages.json");

module.exports = Breadcrumps;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "breadcrumps" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function Breadcrumps($uhr) {
    this._uhr = $uhr;
    this.$context.setDependency('Pages');
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
Breadcrumps.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
Breadcrumps.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
Breadcrumps.prototype.load = function () {
    var self = this;
    var brcrmp = [];
    return this.$context.getStoreData('Pages')
        .then(function (page) {
            if (page.current == "master-rubrika")
                return self._loadForRubrika();

            if (page.current == "news-item")
                return self._loadForNewsItem();

            brcrmp.push({
                title: PAGES[page.current].title
            });
            return brcrmp;
        });
};

Breadcrumps.prototype._loadForRubrika = function () {
    var self = this;
    return this.$context.getStoreData('Tag')
        .then(function (data) {
            var links;
            if (data.tag.unique) {
                links = self._getForTag(data);
            } else {
                links = self._getForRubrika(data);
            }
            return links;
        });
};

Breadcrumps.prototype._getForTag = function (data) {
    var links = this._getForRubAndTag(data);
    links.push({
        title: data.rubrika.name,
        url: '/' + data.rubrika.parent.unique + '/' + data.rubrika.unique
    });
    links.push({
        title: data.tag.name
    });
    return links;
};

Breadcrumps.prototype._getForRubrika = function (data) {
    var links = this._getForRubAndTag(data);
    links.push({
        title: data.rubrika.name
    });
    return links;
};

Breadcrumps.prototype._getForRubAndTag = function (data) {
    var podrubriks = data.rubrika.nearby;
    var linksPodrubriks = [];
    var links = [];

    Object.keys(podrubriks)
        .forEach(function (num) {
            if (podrubriks[num].status == 1)
                linksPodrubriks.push({
                    title: podrubriks[num].name,
                    url: '/' + data.rubrika.parent.unique + '/' + podrubriks[num].unique
                });
        });

    links.push({
        title: "Каталог услуг",
        url: "/catalog"
    });

    links.push({
        title: data.rubrika.parent.name,
        url: "/" + data.rubrika.parent.unique,
        links: linksPodrubriks
    });
    return links;
};

Breadcrumps.prototype._loadForNewsItem = function () {
    var self = this;
    return this.$context.getStoreData('other/NewsItem')
        .then(function (data) {
            var links = [];
            links.push({
                title: "Новости",
                url: "/news"
            });
            links.push({
                title: data.title
            });
            return links;
        });
};
/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
Breadcrumps.prototype.handleSomeAction = function () {
    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

},{"../config/pages.json":89}],68:[function(require,module,exports){
'use strict';

var PAGES = require("../config/pages.json");

module.exports = Head;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "head" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function Head($uhr) {
    this._uhr = $uhr;
    this.currentPage = "main";
    this.$context.setDependency('Pages');
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
Head.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
Head.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
Head.prototype.load = function () {
    var self = this;
    return this.$context.getStoreData('Pages')
        .then(function (page) {
            if (page.current == "master-rubrika")
                return self._loadForRubrika();
            if (page.current == "news-item")
                return self._loadForNewsItem();

            var data = PAGES[page.current];
            return {
                //title: data.title + '. FaceMaster.ru. Специалисты Тольятти',
                //description: data.description,
                //keywords: data.keywords
            }
        });
};

Head.prototype._loadForRubrika = function () {
    return this.$context.getStoreData('Tag')
        .then(function (data) {
            return {
                title: data.currentSeo.headTitle,
                description: data.currentSeo.description,
                keywords: data.currentSeo.keywords
            }
        });
};

Head.prototype._loadForNewsItem = function () {
    return this.$context.getStoreData('other/NewsItem')
        .then(function (data) {
            return {
                title: data.title,
                description: data.preview,
                keywords: 'новость, facemaster'
            }
        });
};
/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
Head.prototype.handleSetCurrentPage = function (page) {
    this.currentPage = page;
    this.$context.changed();
};

},{"../config/pages.json":89}],69:[function(require,module,exports){
'use strict';

var PAGES = require("../config/pages.json");

module.exports = Pages;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "Pages" store.
 * @param {Object} $config Application config.
 * @constructor
 */
function Pages($config) {
    this._config = $config;
    this.$context.setDependency('Tag');
}

/**
 * Current application config.
 * @type {Object}
 * @private
 */
Pages.prototype._config = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
Pages.prototype.$lifetime = 3600000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
Pages.prototype.load = function () {
    var self = this;
    var currentPage = self.$context.state.page;

    return Promise.resolve(1)
        .then(function () {
            if (currentPage == "master-rubrika")
                return self.$context.getStoreData('Tag');
            if (currentPage == "master-page")
                return self.$context.getStoreData('master/MasterItem');
            if (currentPage == "news-item")
                return self.$context.getStoreData('other/NewsItem');
            if (currentPage == "vacancy-item")
                return self.$context.getStoreData('other/VacancyItem');
        })
        .then(function () {
            if (!currentPage) {
                return self.$context.redirect('/main');
            }

            if (!PAGES.hasOwnProperty(currentPage)) {
                self.$context.notFound();
            }

            var result = {
                current: currentPage,
                isActive: {},

                header: self.getHeaderData(),
                footer: self.getFooterData()
            };
            Object.keys(PAGES)
                .forEach(function (page) {
                    result.isActive[page] = (currentPage === page);
                });
            return result;
        });
};

Pages.prototype.getHeaderData = function () {
    return {
        visitCount: '12 323 посещений',
        isGuest: true
    };
};

Pages.prototype.getFooterData = function () {
    return {
        phone: '(8482) 74-44-19'
    };
};
},{"../config/pages.json":89}],70:[function(require,module,exports){
'use strict';

module.exports = Paginator;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "Paginator" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function Paginator($uhr) {
    this._uhr = $uhr;
    this._model;
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
Paginator.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
Paginator.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
Paginator.prototype.load = function () {
    if (!this._model)
        return null;
    var self = this;
    var currentPage = this.$context.state.currentPage || 1;

    return Promise.resolve(1)
        .then(function () {
            return self.$context.getStoreData(self._model);
        })
        .then(function () {
            return self.$context.sendAction(self._model, "getPaginator")
        })
        .then(function (data) {
            if (data['is-paginator'] == false)
                return data;
            var start = data.current - 4 < 0 ? 1 : data.current - 4;
            var end = start + 9 < data.count ? start + 9 : data.count;
            var list = [];
            for (var i = start; i <= end; ++i) {
                list.push({
                    "is-selected": (data.current == i),
                    "url": data.url + i,
                    "number": i
                });
            }

            return {
                model: self._model,
                "is-paginator": true,
                start: {
                    url: data.url + 1
                },
                end: {
                    url: data.url + data.count
                },
                list: list
            }
        });
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
Paginator.prototype.handleSetModel = function (model) {
    this._model = model;
};
Paginator.prototype.handleGetCurrentPage = function () {
    return this.$context.state.currentPage || 1;
}

},{}],71:[function(require,module,exports){
'use strict';

module.exports = Tag;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "tag" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function Tag($uhr) {
    this._uhr = $uhr;
    this.$context.setDependency('rubrika/Rubrika');
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
Tag.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
Tag.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
Tag.prototype.load = function () {
    var self = this;
    var section = this.$context.state.section || 'master';
    var tag = this.$context.state.tag || '';
    var data = {};

    return this.$context.getStoreData("rubrika/Rubrika")
        .then(function (rubrika) {
            data.rubrika = rubrika;
        })
        .then(function () {
            if (tag) {
                var path = 'http://api-fm.present-tlt.ru/tag';
                var option = {
                    data: {
                        filter: '["and",["=", "unique", "' + tag + '"],["=","status","1"]]',
                        expand: 'seo'
                    }
                };
                return self._uhr.get(path, option)
                    .then(function (result) {
                        if (result.status.code >= 400 && result.status.code < 600) {
                            throw new Error(result.status.text);
                        }
                        return result.content[0];
                    });
            }

            return {};
        })
        .then(function (tagData) {
            if (tag && tagData == {})
                self.$context.notFound();

            data.tag = tagData;
            data.section = section;
            data.currentSeo = tag ? self._getCurrentSeo(data.tag, data.section) : self._getCurrentSeo(data.rubrika, data.section);
            return data;
        });
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
Tag.prototype.handleSomeAction = function () {
    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

Tag.prototype._getCurrentSeo = function (data, section) {
    var result;
    var seo = data.seo;

    Object.keys(seo)
        .forEach(function (key) {
            if (section == seo[key].section)
                result = seo[key];
        });
    if (!result)
        return {
            headTitle: data.name,
            pageTitle: data.name
        };
    return result;
};
},{}],72:[function(require,module,exports){
'use strict';

var dateFormat = require('../../lib/util/DateFormat');

module.exports = MasterItem;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "master/MasterItem" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function MasterItem($uhr) {
    this._uhr = $uhr;
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
MasterItem.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
MasterItem.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
MasterItem.prototype.load = function () {
    var self = this;
    var id = this.$context.state.item;
    if (!id)
        return;

    var now = Date.now();
    now = dateFormat(now, "yyyy-mm-dd");
    var path = 'http://api-fm.present-tlt.ru/master-page';
    var options = {
        data: {
            filter: '["and", ["=","number", "' + id + '"],["<=", "dateStart", "' + now + '"],[">=", "dateEnd", "' + now + '"]]'
        }
    };
    return this._uhr.get(path, options)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            if (result.content.length == 0)
                self.$context.notFound();

            return result.content[0];
        })
        .then(function (page) {
            var pathM = 'http://api-fm.present-tlt.ru/master';
            var optionM = {
                data: {
                    filter: '["and", ["=", "id", "' + page.masterID + '"],["=","publicStatus", "1"]]',
                    expand: 'contacts,articles,comments,districts,albums,sales,schedule,videos,workCondition,callbacks,vkLikes,rubrika,tags,company'
                }
            };
            return self._uhr.get(pathM, optionM)
                .then(function (result) {
                    if (result.status.code >= 400 && result.status.code < 600) {
                        throw new Error(result.status.text);
                    }
                    if (result.content.length == 0)
                        self.$context.notFound();

                    var data = result.content[0];
                    data.services = JSON.parse(data.services);
                    data.isBlock = {
                        service: {
                            access: page.services,
                            name: "Услуги",
                            active: true
                        },
                        work: {
                            access: true,
                            name: "Условия работы",
                            active: true
                        },
                        sale: {
                            access: page.sales,
                            name: "Скидки и подарки",
                            active: (data.sales.length > 0)
                        },
                        about: {
                            access: true,
                            name: "О себе",
                            active: data.aboutEduc || data.aboutExp ||data.aboutAddInfo
                        },
                        article: {
                            access: page.articles,
                            name: "Полезно почитать",
                            active: (data.articles.length > 0)
                        },
                        photo: {
                            access: page.albums,
                            name: "Фото",
                            active: (data.albums.length > 0)
                        },
                        video: {
                            access: page.videos,
                            name: "Видео",
                            active: (data.videos.length > 0)
                        },
                        link: {
                            access: page.links,
                            name: "Ссылки",
                            active: (data.links)
                        },
                        review: {
                            access: page.comments,
                            name: "Отзывы и рекомендации",
                            active: true
                        }
                    };
                    data.page = page;
                    return data;
                });
        });
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
MasterItem.prototype.handleSomeAction = function () {
    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

},{"../../lib/util/DateFormat":91}],73:[function(require,module,exports){
'use strict';

module.exports = MasterList;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "master/masterList" store.
 * @param {UHR} $uhr Universal HTTP request.this
 * @constructor
 */
function MasterList($uhr) {
    this._uhr = $uhr;
    this._currentFeed = [];
    this.$context.setDependency('Tag');
}

MasterList.prototype._currentFeed = null;
MasterList.prototype._currentPage = 1;
MasterList.prototype._isFinished = false;

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
MasterList.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
MasterList.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
MasterList.prototype.load = function () {
    var self = this;

    return this.$context.getStoreData('Tag')
        .then(function (tag) {
            if (!tag.rubrika)
                return;
            self._clearFeed(tag);
            return self._loadDataPerPage(self._currentPage, tag.rubrika.id, tag.tag.id);
        })
        .then(function (result) {
            if (!result || result.length === 0) {
                self._isFinished = true;
                return self._currentFeed;
            } else {
                self._strucrurResult(result);
            }
            self._currentFeed = self._currentFeed.concat(result);
            return self._currentFeed;
        });
};
MasterList.prototype._clearFeed = function (tag) {
    this._currentRubrika = this._currentRubrika || tag.rubrika.id;
    this._currentTag = this._currentTag || tag.tag.id;
    if (this._currentRubrika != tag.rubrika.id || this._currentTag != tag.tag.id) {
        this._currentFeed = [];
        this._currentPage = 1;
        this._isFinished = false;
        this._currentRubrika = tag.rubrika.id;
        this._currentTag = tag.tag.id;
    }
};
MasterList.prototype._loadDataPerPage = function (page, rubrikaID, tagID) {
    var self = this;
    var path = 'http://api-fm.present-tlt.ru/master/active';
    var options = {
        data: {
            filter: '["and",["=", "rubrikaID", "' + rubrikaID + '"]]',
            expand: 'comments,sales,videos,vkLikes,albums,contacts,page,company',
            order: 'sort',
            page: page
        }
    };
    if (tagID) {
        path = 'http://api-fm.present-tlt.ru/master/bytag/' + tagID;
    }

    return self._uhr.get(path, options)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            return result.content;
        });
};

MasterList.prototype._strucrurResult = function (result) {
    result.forEach(function (master) {
        master.services = JSON.parse(master.services);
        if (master.vkLikes) {
            master.vkLikes.countLikes = master.vkLikes.countLikes ? master.vkLikes.countLikes : 0;
        } else {
            master.vkLikes = {};
            master.vkLikes.countLikes = 0;
        }
    });
};
/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
MasterList.prototype.handleGetNextPage = function () {
    if (this._isFinished) {
        return null;
    }
    var self = this;
    return Promise.resolve()
        .then(function () {
            if (!self._currentFeed || self._currentFeed.length === 0) {
                return self.load();
            }
        })
        .then(function (d) {
            self._currentPage++;
            self.$context.changed();
        });

};

},{}],74:[function(require,module,exports){
'use strict';

module.exports = MasterSovety;

var util = require('util'),
		StorePaginator = require('../../lib/StorePaginator');

util.inherits(MasterSovety, StorePaginator);

function MasterSovety() {
	StorePaginator.call(this);
	this._path = 'http://api-fm.present-tlt.ru/article/active';
	this._options = {
		data: {
			order: 'id DESC'
		}
	};
	this._url = "/sovety/page/";
	this._catalog = this.$context.state.catalog;
	if (this._catalog) {
		this._options.data.filter = '[["=","rubrikaID","' + this._catalog + '"]]';
		this._url = "/sovety/catalog/" + this._catalog + "/page/";
	}
}
},{"../../lib/StorePaginator":90,"util":121}],75:[function(require,module,exports){
'use strict';

module.exports = MasterVideo;

var util = require('util'),
    StorePaginator = require('../../lib/StorePaginator');

util.inherits(MasterVideo, StorePaginator);

function MasterVideo() {
    StorePaginator.call(this);
    this._path = 'http://api-fm.present-tlt.ru/video/active';
    this._options = {
        data: {
            order: 'id DESC'
        }
    };
    this._url = "/video/page/";
    this._catalog = this.$context.state.catalog;
    if (this._catalog) {
        this._options.data.filter = '[["=","rubrikaID","' + this._catalog + '"]]';
        this._url = "/video/catalog/" + this._catalog + "/page/";
    }
}
},{"../../lib/StorePaginator":90,"util":121}],76:[function(require,module,exports){
'use strict';

module.exports = Recommended;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "master/Recommended" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function Recommended($uhr) {
	this._uhr = $uhr;
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
Recommended.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
Recommended.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
Recommended.prototype.load = function () {
	// Here you can do any HTTP requests using this._uhr.
	// Please read details here https://github.com/catberry/catberry-uhr.
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
Recommended.prototype.handleSomeAction = function () {
	// Here you can call this.$context.changed() if you know
	// that remote data source has been changed.
	// Also you can have many handle methods for other actions.
};

},{}],77:[function(require,module,exports){
'use strict';

module.exports = News;

var util = require('util'),
    StorePaginator = require('../../lib/StorePaginator');

util.inherits(News, StorePaginator);

function News() {
    StorePaginator.call(this);
    this._path = 'http://api-fm.present-tlt.ru/about-news';
    this._options = {
        data: {
            filter: '["and",["=","status","1"]]',
            order: 'date DESC'
        }
    };
    this._url = "/news/page/";
}
},{"../../lib/StorePaginator":90,"util":121}],78:[function(require,module,exports){
'use strict';

module.exports = NewsItem;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "other/NewsItem" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function NewsItem($uhr) {
    this._uhr = $uhr;
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
NewsItem.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
NewsItem.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
NewsItem.prototype.load = function () {
    var self = this;
    var item = this.$context.state.item;
    var path = 'http://api-fm.present-tlt.ru/about-news';
    if (!item)
        return;

    var option = {
        data: {
            filter: '["and",["=","id","' + item + '"],["=", "status", "1"]]'
        }
    };
    return this._uhr.get(path, option)
        .then(function (result) {
            console.log(result);
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            if (result.content.length == 0)
                self.$context.notFound();

            return result.content[0];
        });
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
NewsItem.prototype.handleSomeAction = function () {

    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

},{}],79:[function(require,module,exports){
'use strict';

module.exports = Recommendation;

var util = require('util'),
    StorePaginator = require('../../lib/StorePaginator');

util.inherits(Recommendation, StorePaginator);

function Recommendation() {
    StorePaginator.call(this);
    this._path = 'http://api-fm.present-tlt.ru/about-comment';
    this._url = "/recommendation/page/";
}
},{"../../lib/StorePaginator":90,"util":121}],80:[function(require,module,exports){
'use strict';
var dateFormat = require('../../lib/util/DateFormat');

module.exports = Vacancy;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "other/vacancy" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function Vacancy($uhr) {
    this._uhr = $uhr;
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
Vacancy.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
Vacancy.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
Vacancy.prototype.load = function () {
    var path = 'http://api-fm.present-tlt.ru/about-vacancy';
    var now = Date.now();
    now = dateFormat(now, "yyyy-mm-dd");
    now = "2014-03-20"; //для теста - убрать!

    var option = {
        data: {
            filter: '["and",["<=","createDate","' + now + '"],[">=", "endDate", "' + now + '"],["=", "status", "1"]]'
        }
    };
    return this._uhr.get(path, option)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }

            return result.content;
        });
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
Vacancy.prototype.handleSomeAction = function () {
    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

},{"../../lib/util/DateFormat":91}],81:[function(require,module,exports){
'use strict';

var dateFormat = require('../../lib/util/DateFormat');

module.exports = VacancyItem;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "other/vacancyItem" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function VacancyItem($uhr) {
    this._uhr = $uhr;
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
VacancyItem.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
VacancyItem.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
VacancyItem.prototype.load = function () {
    var self = this;
    var id = this.$context.state.item;
    if (!id)
        return;
    var path = 'http://api-fm.present-tlt.ru/about-vacancy';
    var now = Date.now();
    now = dateFormat(now, "yyyy-mm-dd");
    now = "2014-03-20"; //для теста - убрать!

    var option = {
        data: {
            filter: '["and",["=", "id", "' + id + '"],["<=","createDate","' + now + '"],[">=", "endDate", "' + now + '"],["=", "status", "1"]]'
        }
    };
    return this._uhr.get(path, option)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            if (result.content.length == 0)
                self.$context.notFound();
            console.log(result.content[0]);
            return result.content[0];
        });
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
VacancyItem.prototype.handleSomeAction = function () {
    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

},{"../../lib/util/DateFormat":91}],82:[function(require,module,exports){
'use strict';

module.exports = Rubrika;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "rubrika/Rubrika" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function Rubrika($uhr) {
    this._uhr = $uhr;
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
Rubrika.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
Rubrika.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
Rubrika.prototype.load = function () {
    var self = this;
    var rubrika = this.$context.state.rubrika;
    var podrubrika = this.$context.state.podrubrika;

    if (!podrubrika) {
        self.$context.notFound();
    }

    var url = 'http://api-fm.present-tlt.ru/rubrika';
    var options = {
        data: {
            filter: '["and", ["=", "unique", "' + podrubrika + '"],["=","status","1"]]',
            expand: "tags,parent,nearby,seo"
        }
    };
    return this._uhr.get(url, options)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            if (result.content.length == 0)
                self.$context.notFound();

            var data = result.content[0];

            if (data.parentID == 0)
                self.$context.notFound();

            if (rubrika != data.parent.unique)
                self.$context.notFound();

            data.podrubrika = podrubrika;
            data.rubrika = rubrika;
            return data;
        });
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
},{}],83:[function(require,module,exports){
'use strict';

module.exports = Rubrikator;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "rubrika/Rubrikator" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function Rubrikator($uhr) {
    this._uhr = $uhr;
    this._path = 'http://api-fm.present-tlt.ru/rubrika';
    this._options = {
        data: {
            filter: '["and",["=", "status", "1"]]',
            expand: 'masterCount',
            order: 'sort',
            limit: 300
        }
    };
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
Rubrikator.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
Rubrikator.prototype.$lifetime = 600000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */

Rubrikator.prototype.load = function () {
    return this._uhr.get(this._path, this._options)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            var data = result.content;
            var podrubriksTree = {};
            var rootTree = {};
            var rootTreeCount = {};

            Object.keys(data)
                .forEach(function (key) {
                    var el = data[key];
                    if (el.parentID == 0) {
                        rootTree[el.sort] = {el: el};
                    } else {
                        if (!podrubriksTree[el.parentID])
                            podrubriksTree[el.parentID] = [];
                        podrubriksTree[el.parentID].push(el);
                        rootTreeCount[el.parentID] = +el.masterCount + (rootTreeCount[el.parentID] ? rootTreeCount[el.parentID] :  0);
                    }
                });

            Object.keys(rootTree)
                .forEach(function (key) {
                    podrubriksTree[rootTree[key].el.id].sort(function (a, b) {
                        return a.name > b.name;
                    });
                    rootTree[key].podrubriks = podrubriksTree[rootTree[key].el.id];
                    rootTree[key].count = rootTreeCount[rootTree[key].el.id];
                });
            return rootTree;
        });
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
Rubrikator.prototype.handleSomeAction = function () {
    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

},{}],84:[function(require,module,exports){
'use strict';

module.exports = RubrikatorCompany;

var util = require('util'),
		Rubrikator = require('./Rubrikator');

util.inherits(RubrikatorCompany, Rubrikator);

function RubrikatorCompany() {
	Rubrikator.call(this);
	this._path = 'http://api-fm.present-tlt.ru/rubrika-company';
	this._options = {
		data: {
			filter: '["and",["=", "status", "1"]]',
			order: 'sort',
			limit: 200
		}
	};
}
},{"./Rubrikator":83,"util":121}],85:[function(require,module,exports){
'use strict';

module.exports = RubrikatorParent;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "rubrika/RubrikatorParent" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function RubrikatorParent($uhr) {
    this._uhr = $uhr;
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
RubrikatorParent.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
RubrikatorParent.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
RubrikatorParent.prototype.load = function () {
    var path = 'http://api-fm.present-tlt.ru/rubrika';
    var options = {
        data: {
            filter: '["and",["=", "parentID", "0"]]',
            order: 'name',
            limit: 200
        }
    };
    return this._uhr.get(path, options)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            return result.content;
        });
};

/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
RubrikatorParent.prototype.handleSomeAction = function () {
    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

},{}],86:[function(require,module,exports){
'use strict';

module.exports = RubrikatorSale;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "rubrika/rubrikatorSale" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function RubrikatorSale($uhr) {
    this._uhr = $uhr;
    this._path = 'http://api-fm.present-tlt.ru/rubrika';
    this._options = {
        data: {
            filter: '["and",["=", "status", "1"]]',
            expand: 'saleCount',
            order: 'sort',
            limit: 300
        }
    };
    this._groups = [
        {
            name: "Ремонт, строительство, интерьер",
            childrenID: [86, 87, 88, 102]
        },
        {
            name: "Здоровье, красота, мода",
            childrenID: [24, 143, 113, 27, 132]
        },
        {
            name: "Отдых и праздники",
            childrenID: [36, 103, 125, 149]
        },
        {
            name: "Консультации",
            childrenID: [5, 114]
        },
        {
            name: "Автоуслуги и доставка",
            childrenID: [19, 106]
        },
        {
            name: "Недвижимость",
            childrenID: [1]
        },
        {
            name: "Техника",
            childrenID: [42]
        },
        {
            name: "Дригие услуги",
            childrenID: []
        }
    ];
    this._parentToGroup = {};
    this.loadRubriks = false;
    var self = this;
    for (var i = 0; i < this._groups.length; ++i) {
        var el = this._groups[i];
        el.childrenID.forEach(function (id) {
            self._parentToGroup[id] = i;
        });
    }
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
RubrikatorSale.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
RubrikatorSale.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
RubrikatorSale.prototype.load = function () {
    var self = this;
    var currentRubrika = self.$context.state.catalog;

    if (self.loadRubriks) {
        return {
            active: currentRubrika,
            list: self._groups
        }
    }
    return this._loadData()
        .then(function () {
            self.loadRubriks = true;
            return {
                active: currentRubrika,
                list: self._groups
            }
        });
};
/**
 * Загрузка рубрикатора и перестройка под нужный формат
 * @returns {*}
 * @private
 */
RubrikatorSale.prototype._loadData = function () {
    var self = this;

    return this._uhr.get(this._path, this._options)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            var data = result.content;
            var dataLevel = {};

            //сначата выстраиваем древовидную структуру
            data.forEach(function (el) {
                if (el.parentID == 0) {
                    if (!dataLevel[el.id])
                        dataLevel[el.id] = {root: el, child: [], saleCount: 0};
                    dataLevel[el.id].root = el;

                    if (self._parentToGroup[el.id] == undefined) {
                        self._groups[self._groups.length - 1].childrenID.push(el.id);
                    }
                } else {
                    if (!dataLevel[el.parentID])
                        dataLevel[el.parentID] = {root: {}, child: [], saleCount: 0};

                    dataLevel[el.parentID].saleCount += +el.saleCount;
                    dataLevel[el.parentID].child.push(el);
                }
            });

            //затем прицепляем к главному дереву
            self._groups.forEach(function (el) {
                el.children = [];
                el.saleCount = 0;

                if (el.childrenID.length == 1) {
                    var id = el.childrenID[0];
                    el.saleCount = dataLevel[id].saleCount;
                    dataLevel[id].root = false;
                    el.children.push(dataLevel[id]);
                } else {
                    el.childrenID.forEach(function (id) {
                        el.saleCount += dataLevel[id].saleCount;
                        el.children.push(dataLevel[id]);
                    });
                }
            });
        });
};
/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
RubrikatorSale.prototype.handleSomeAction = function () {
    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

},{}],87:[function(require,module,exports){
'use strict';
module.exports = SaleByRubrika;

var util = require('util'),
    StorePaginator = require('../../lib/StorePaginator');
/**
 * наследуемся от пагинатора для постраничной навигации
 */
util.inherits(SaleByRubrika, StorePaginator);

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * Creates new instance of the "sale/SaleByRubrika" store.
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function SaleByRubrika($uhr) {
    StorePaginator.call(this);

    this.$context.setDependency("rubrika/RubrikatorSale");
    this._path = 'http://api-fm.present-tlt.ru/sale/active';
    this._options = {
        data: {
            expand: 'owner'
        }
    };
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
SaleByRubrika.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
SaleByRubrika.prototype.$lifetime = 60000;
/**
 * Хранилище для рубрикатора
 * @type {Array}
 * @private
 */
SaleByRubrika.prototype._rubrikator = [];

/**
 * Устанавливаем значение для url в пагинаторе
 * Вызовем этот метод, когда узнаем текущую рубрику
 * @param rubrika
 * @private
 */
SaleByRubrika.prototype._setUrlForPage = function (rubrika) {
    this._url = "/sale/catalog/" + rubrika + "/page/";
};

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
SaleByRubrika.prototype.load = function () {
    var self = this;
    return Promise.resolve(1)
        .then(function () {
            // выясним текущую страницу
            return self.$context.sendAction("Paginator", "getCurrentPage");
        })
        .then(function (page) {
            //установим значения для страницы
            self._currentPage = page;
            self._options.data.page = page;
            //выясним текущие данные по рубрике
            return self.$context.getStoreData("rubrika/RubrikatorSale")
        })
        .then(function (rubrikator) {
            //запомним весь рубрикатор в переменной
            self._rubrikator = rubrikator.list;
            //если нет активной рубрики значит это главная страница
            if (!rubrikator.active)
                return self._getDataForMainPage();//сформируем данные для главной страницы

            //иначее сформируем данные для рубрики
            //но для начала установим url для навигации по текущей рубрике
            self._setUrlForPage(rubrikator.active);
            return self._getDataForRubrikaPage(rubrikator.active);
        });
};
/**
 * Формирование данных для главной страницы каталога скидок
 * @returns {Promise}
 * @private
 */
SaleByRubrika.prototype._getDataForMainPage = function () {
    var self = this;
    var promises = [];//массив для промисов

    //Сформируем список id по группам рубрик, для того чтобы достать по 4 акции для каждой группы
    this._rubrikator.forEach(function (el) {
        var listID = [];
        el.children.forEach(function (child) {
            child.child.forEach(function (rubrika) {
                listID.push(rubrika.id);
            });
        });
        //для каждого делаем запрос к api
        promises.push(self._getSaleData(listID));
    });
    //ждем когда все промисы выполнятся
    return Promise.all(promises)
        //затем добавим к данным по рубрикам принадлежащие им скидки
        .then(function (sale) {
            for (var i = 0; i < self._rubrikator.length; i++) {
                self._rubrikator[i].sale = sale[i];
            }
            // и отдадим все это в hbs
            return self._rubrikator;
        });
};

/**
 * Формирование данных для страницы рубрики каталога скидок
 * @param currentRubrika текуая рубрика
 * @returns {Promise}
 * @private
 */
SaleByRubrika.prototype._getDataForRubrikaPage = function (currentRubrika) {
    var self = this;
    var listID = [];

    //переберем весь рубрикатор и отметим активностью те ветви которые необходимо открыть
    //также сразу подготовим список id для запроса по акциям
    this._rubrikator.forEach(function (el) {
        el.active = false;

        el.children.forEach(function (child) {
            if (child.root && child.root.id == currentRubrika) {
                el.active = true;
                child.root.active = true;
                currentRubrika = child.root;

                child.child.forEach(function (rubrika) {
                    rubrika.active = false;
                    listID.push(rubrika.id);
                });
            } else {
                child.child.forEach(function (rubrika) {
                    if (rubrika.id == currentRubrika) {
                        rubrika.active = true;
                        el.active = true;
                        child.root.active = true;
                        currentRubrika = rubrika;
                        listID.push(rubrika.id);
                    } else {
                        rubrika.active = false;
                        if (child.root)
                            child.root.active = false;
                    }
                });
            }
        });
    });

    this._options.data.filter = '["and", ["in", "rubrikaID",[' + listID.join(',') + ']]]';
    this._options.data.limit = 20;
    return this._uhr.get(this._path, this._options)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            self._pageCount = result.status.headers['x-pagination-page-count'];
            return result.content;
        })
        .then(function (sale) {
            return {
                currentPage: self._currentPage,
                currentRubrika: currentRubrika,
                rubrikator: self._rubrikator,
                sale: sale
            };
        });
};

/**
 * Возвращает список акций по списку id рубрики
 * @param id масиив список id рубрик
 * @returns {*}
 * @private
 */
SaleByRubrika.prototype._getSaleData = function (id) {
    this._options.data.filter = '["and", ["in", "rubrikaID",[' + id.join(',') + ']]]';
    this._options.data.limit = 4;
    return this._uhr.get(this._path, this._options)
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }
            return result.content;
        });
};


/**
 * Handles action named "some-action" from any component.
 * @returns {Promise<Object>|Object|null|undefined} Response to component.
 */
SaleByRubrika.prototype.handleSomeAction = function () {
    // Here you can call this.$context.changed() if you know
    // that remote data source has been changed.
    // Also you can have many handle methods for other actions.
};

},{"../../lib/StorePaginator":90,"util":121}],88:[function(require,module,exports){
module.exports={
	"title": "FaceMaster.ru",
	"isRelease": true
}

},{}],89:[function(require,module,exports){
module.exports={
  "main": {
    "title": "Поиск Мастеров в сфере услуг",
    "description": "Поиск Мастеров в сфере услуг",
    "keywords": "поиск услуг, мастера, специалисты Тольятти"
  },
  "catalog": {
    "title": "Каталог услуг",
    "description": "",
    "keywords": ""
  },
  "request": {
    "title": "Заказать услугу",
    "description": "",
    "keywords": ""
  },
  "registration": {
    "title": "Стать Мастером",
    "description": "",
    "keywords": ""
  },
  "login": {
    "title": "Вход для Мастеров",
    "description": "",
    "keywords": ""
  },
  "sale": {
    "title": " Каталог скидки и подарки",
    "description": "",
    "keywords": ""
  },
  "video": {
    "title": "Видео Мастеров",
    "description": "",
    "keywords": ""
  },
  "sovety": {
    "title": "Секреты мастеров",
    "description": "",
    "keywords": ""
  },
  "company": {
    "title": "Каталог компаний",
    "description": "",
    "keywords": ""
  },
  "recommendation": {
    "title": "Рекомендации Мастеров",
    "description": "Рекомендации Мастеров",
    "keywords": "отзывы, рекомендации"
  },
  "news": {
    "title": "Новости",
    "description": "",
    "keywords": ""
  },
  "vacancy": {
    "title": "Вакансии",
    "description": "",
    "keywords": ""
  },
  "oferta": {
    "title": "Оферта",
    "description": "",
    "keywords": ""
  },
  "contact": {
    "title": "Контакты",
    "description": "",
    "keywords": ""
  },
  "feedback": {
    "title": "Обратная связь",
    "description": "",
    "keywords": ""
  },
  "master-rubrika": {},
  "master-page": {},
  "news-item": {},
  "vacancy-item": {},
  "konkurs-item": {}
}
},{}],90:[function(require,module,exports){
'use strict';

module.exports = StorePaginator;

/*
 * This is a Catberry Store file.
 * More details can be found here
 * https://github.com/catberry/catberry/blob/master/docs/index.md#stores
 */

/**
 * @param {UHR} $uhr Universal HTTP request.
 * @constructor
 */
function StorePaginator() {
    this._uhr = this.$context.locator.resolve('uhr');
    this._pageCount = 1;
    this._currentPage = 1;
    this._path = '';
    this._options = {data: {}};
    this._url = '';

    this.$context.setDependency("Paginator");
}

/**
 * Current universal HTTP request to do it in isomorphic way.
 * @type {UHR}
 * @private
 */
StorePaginator.prototype._uhr = null;

/**
 * Current lifetime of data (in milliseconds) that is returned by this store.
 * @type {number} Lifetime in milliseconds.
 */
StorePaginator.prototype.$lifetime = 60000;

/**
 * Loads data from remote source.
 * @returns {Promise<Object>|Object|null|undefined} Loaded data.
 */
StorePaginator.prototype.load = function () {
    var self = this;
    var path = this._path;

    return Promise.resolve(1)
        .then(function () {
            return self.$context.sendAction("Paginator", "getCurrentPage");
        })
        .then(function (page) {
            self._currentPage = page;
            self._options.data.page = page;
            return self._uhr.get(path, self._options)
        })
        .then(function (result) {
            if (result.status.code >= 400 && result.status.code < 600) {
                throw new Error(result.status.text);
            }

            self._pageCount = result.status.headers['x-pagination-page-count'];
            return {
                currentPage: self._currentPage,
                data: result.content
            };
        });
};


StorePaginator.prototype.handleGetPaginator = function () {
    if (!this._pageCount || this._pageCount == 1) {
        return {
            "is-paginator": false
        }
    }
    return {
        "is-paginator": true,
        "url": this._url,
        "count": this._pageCount,
        "current": this._currentPage
    };
};
},{}],91:[function(require,module,exports){
/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

var dateFormat = function () {
    var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        timezoneClip = /[^-+\dA-Z]/g,
        pad = function (val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) val = "0" + val;
            return val;
        };

    // Regexes and supporting functions are cached through closure
    return function (date, mask, utc) {
        var dF = dateFormat;

        // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
        if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
            mask = date;
            date = undefined;
        }

        // Passing date through Date applies Date.parse, if necessary
        date = date ? new Date(date) : new Date;
        if (isNaN(date)) throw SyntaxError("invalid date");

        mask = String(dF.masks[mask] || mask || dF.masks["default"]);

        // Allow setting the utc argument via the mask
        if (mask.slice(0, 4) == "UTC:") {
            mask = mask.slice(4);
            utc = true;
        }

        var	_ = utc ? "getUTC" : "get",
            d = date[_ + "Date"](),
            D = date[_ + "Day"](),
            m = date[_ + "Month"](),
            y = date[_ + "FullYear"](),
            H = date[_ + "Hours"](),
            M = date[_ + "Minutes"](),
            s = date[_ + "Seconds"](),
            L = date[_ + "Milliseconds"](),
            o = utc ? 0 : date.getTimezoneOffset(),
            flags = {
                d:    d,
                dd:   pad(d),
                ddd:  dF.i18n.dayNames[D],
                dddd: dF.i18n.dayNames[D + 7],
                m:    m + 1,
                mm:   pad(m + 1),
                mmm:  dF.i18n.monthNames[m],
                mmmm: dF.i18n.monthNames[m + 12],
                yy:   String(y).slice(2),
                yyyy: y,
                h:    H % 12 || 12,
                hh:   pad(H % 12 || 12),
                H:    H,
                HH:   pad(H),
                M:    M,
                MM:   pad(M),
                s:    s,
                ss:   pad(s),
                l:    pad(L, 3),
                L:    pad(L > 99 ? Math.round(L / 10) : L),
                t:    H < 12 ? "a"  : "p",
                tt:   H < 12 ? "am" : "pm",
                T:    H < 12 ? "A"  : "P",
                TT:   H < 12 ? "AM" : "PM",
                Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };

        return mask.replace(token, function ($0) {
            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
        });
    };
}();

// Some common format strings
dateFormat.masks = {
    "default":      "ddd mmm dd yyyy HH:MM:ss",
    shortDate:      "m/d/yy",
    mediumDate:     "mmm d, yyyy",
    longDate:       "mmmm d, yyyy",
    fullDate:       "dddd, mmmm d, yyyy",
    shortTime:      "h:MM TT",
    mediumTime:     "h:MM:ss TT",
    longTime:       "h:MM:ss TT Z",
    isoDate:        "yyyy-mm-dd",
    isoTime:        "HH:MM:ss",
    isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};

// Internationalization strings
dateFormat.i18n = {
    dayNames: [
        "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
        "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
    ],
    monthNames: [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
        "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
    ]
};



module.exports = dateFormat;
},{}],92:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = Catberry;

var util = require('util'),
	CatberryBase = require('../lib/base/CatberryBase');

util.inherits(Catberry, CatberryBase);

/**
 * Creates new instance of the browser version of Catberry.
 * @constructor
 * @extends CatberryBase
 */
function Catberry() {
	CatberryBase.call(this);
}

/**
 * Current request router.
 * @type {RequestRouter}
 * @private
 */
Catberry.prototype._router = null;

/**
 * Wraps current HTML document with Catberry event handlers.
 */
Catberry.prototype.wrapDocument = function () {
	this._router = this.locator.resolve('requestRouter');
};

/**
 * Starts Catberry application when DOM is ready.
 * @returns {Promise} Promise for nothing.
 */
Catberry.prototype.startWhenReady = function () {
	if (window.catberry) {
		return Promise.resolve();
	}
	var self = this;

	return new Promise(function (fulfill) {
		window.document.addEventListener('DOMContentLoaded', function () {
			self.wrapDocument();
			window.catberry = self;
			fulfill();
		});
	});
};
},{"../lib/base/CatberryBase":106,"util":121}],93:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = CookieWrapper;

var util = require('util'),
	CookieWrapperBase = require('../lib/base/CookieWrapperBase');

util.inherits(CookieWrapper, CookieWrapperBase);

/**
 * Creates new instance of the browser cookie wrapper.
 * @param {Window} $window Window object.
 * @constructor
 */
function CookieWrapper($window) {
	CookieWrapperBase.call(this);
	this._window = $window;
}

/**
 * Current browser window.
 * @type {Window}
 * @private
 */
CookieWrapper.prototype._window = null;

/**
 * Gets current cookie string.
 * @returns {string} Cookie string.
 */
CookieWrapper.prototype.getCookieString = function () {
	return this._window.document.cookie ?
		this._window.document.cookie.toString() :
		'';
};

/**
 * Sets cookie to this wrapper.
 * @param {Object} cookieSetup Cookie setup object.
 * @param {string} cookieSetup.key Cookie key.
 * @param {string} cookieSetup.value Cookie value.
 * @param {number?} cookieSetup.maxAge Max cookie age in seconds.
 * @param {Date?} cookieSetup.expires Expire date.
 * @param {string?} cookieSetup.path URI path for cookie.
 * @param {string?} cookieSetup.domain Cookie domain.
 * @param {boolean?} cookieSetup.secure Is cookie secured.
 * @param {boolean?} cookieSetup.httpOnly Is cookie HTTP only.
 * @returns {string} Cookie setup string.
 */
CookieWrapper.prototype.set = function (cookieSetup) {
	var cookie = this._convertToCookieSetup(cookieSetup);
	this._window.document.cookie = cookie;
	return cookie;
};
},{"../lib/base/CookieWrapperBase":107,"util":121}],94:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2015 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = DocumentRenderer;

var util = require('util'),
	morphdom = require('morphdom'),
	errorHelper = require('../lib/helpers/errorHelper'),
	moduleHelper = require('../lib/helpers/moduleHelper'),
	hrTimeHelper = require('../lib/helpers/hrTimeHelper'),
	DocumentRendererBase = require('../lib/base/DocumentRendererBase');

util.inherits(DocumentRenderer, DocumentRendererBase);

var WARN_ID_NOT_SPECIFIED = 'Component "%s" does not have an ID, skipping...',
	WARN_SAME_ID =
		'The duplicated ID "%s" has been found, skipping component "%s"...';

var SPECIAL_IDS = {
		$$head: '$$head',
		$$document: '$$document'
	},
	TAG_NAMES = {
		TITLE: 'TITLE',
		HTML: 'HTML',
		HEAD: 'HEAD',
		BASE: 'BASE',
		STYLE: 'STYLE',
		SCRIPT: 'SCRIPT',
		NOSCRIPT: 'NOSCRIPT',
		META: 'META',
		LINK: 'LINK'
	},
	NODE_TYPES = {
		ELEMENT_NODE: 1,
		TEXT_NODE: 3,
		PROCESSING_INSTRUCTION_NODE: 7,
		COMMENT_NODE: 8
	},
	ERROR_CREATE_WRONG_ARGUMENTS = 'Tag name should be a string ' +
		'and attributes should be an object',
	ERROR_CREATE_WRONG_NAME = 'Component for tag "%s" not found',
	ERROR_CREATE_WRONG_ID = 'The ID is not specified or already used',
	// http://www.w3.org/TR/2015/WD-uievents-20150319/#event-types-list
	NON_BUBBLING_EVENTS = {
		abort: true,
		blur: true,
		error: true,
		focus: true,
		load: true,
		mouseenter: true,
		mouseleave: true,
		resize: true,
		unload: true
	};

/**
 * Creates new instance of the document renderer.
 * @param {ServiceLocator} $serviceLocator Locator to resolve dependencies.
 * @constructor
 * @extends DocumentRendererBase
 */
function DocumentRenderer($serviceLocator) {
	DocumentRendererBase.call(this, $serviceLocator);
	this._componentInstances = Object.create(null);
	this._componentElements = Object.create(null);
	this._componentBindings = Object.create(null);
	this._currentChangedStores = Object.create(null);
	this._window = $serviceLocator.resolve('window');
	this._logger = $serviceLocator.resolve('logger');
	this._config = $serviceLocator.resolve('config');
	this._storeDispatcher = $serviceLocator.resolve('storeDispatcher');

	var self = this;

	this._eventBus.on('storeChanged', function (storeName) {
		self._currentChangedStores[storeName] = true;
		if (self._isStateChanging) {
			return;
		}
		self._updateStoreComponents();
	});
}

/**
 * Current application config.
 * @type {Object}
 * @private
 */
DocumentRenderer.prototype._config = null;

/**
 * Current logger.
 * @type {Logger}
 * @private
 */
DocumentRenderer.prototype._logger = null;

/**
 * Current store dispatcher.
 * @type {StoreDispatcher}
 * @protected
 */
DocumentRenderer.prototype._storeDispatcher = null;

/**
 * Current set of component instances by unique keys.
 * @type {Object}
 * @private
 */
DocumentRenderer.prototype._componentInstances = null;

/**
 * Current set of component elements by unique keys.
 * @type {Object}
 * @private
 */
DocumentRenderer.prototype._componentElements = null;

/**
 * Current set of component bindings by unique keys.
 * @type {Object}
 * @private
 */
DocumentRenderer.prototype._componentBindings = null;

/**
 * Current routing context.
 * @type {Object}
 * @private
 */
DocumentRenderer.prototype._currentRoutingContext = null;

/**
 * Current set of changed stores.
 * @type {Object}
 * @private
 */
DocumentRenderer.prototype._currentChangedStores = null;

/**
 * Current promise for rendered page.
 * @type {Promise}
 * @private
 */
DocumentRenderer.prototype._renderedPromise = null;

/**
 * Current state of updating components.
 * @type {boolean}
 * @private
 */
DocumentRenderer.prototype._isUpdating = false;

/**
 * Current awaiting routing.
 * @type {{state: Object, routingContext: Object}}
 * @private
 */
DocumentRenderer.prototype._awaitingRouting = null;

/**
 * Sets the initial state of the application.
 * @param {Object} state New state of application.
 * @param {Object} routingContext Routing context.
 * @returns {Promise} Promise for nothing.
 */
DocumentRenderer.prototype.initWithState = function (state, routingContext) {
	var self = this;
	return self._getPromiseForReadyState()
		.then(function () {
			self._currentRoutingContext = routingContext;
			return self._storeDispatcher.setState(state, routingContext);
		})
		.then(function () {
			var components = self._componentLoader.getComponentsByNames(),
				elements = self._findComponents(
					self._window.document.body, components, true
				);
			elements.unshift(self._window.document.head);
			elements.unshift(self._window.document.documentElement);
			return self._initialWrap(components, elements);
		});
};

/**
 * Renders new state of application.
 * @param {Object} state New state of application.
 * @param {Object} routingContext Routing context.
 * @returns {Promise} Promise for nothing.
 */
DocumentRenderer.prototype.render = function (state, routingContext) {
	this._awaitingRouting = {
		state: state,
		routingContext: routingContext
	};
	if (this._isStateChanging) {
		return this._renderedPromise;
	}

	// we should set this flag to avoid "storeChanged"
	// event handling for now
	this._isStateChanging = true;

	var self = this;
	self._renderedPromise = this._getPromiseForReadyState()
		.then(function () {
			// and then we update all components of these stores in a batch.
			return self._updateStoreComponents();
		})
		.catch(function (reason) {
			self._eventBus.emit('error', reason);
		})
		.then(function () {
			self._isStateChanging = false;
		});

	return this._renderedPromise;
};

/**
 * Renders component into HTML element.
 * @param {Element} element HTML element of component
 * @param {Object?} renderingContext Rendering context for group rendering.
 */
DocumentRenderer.prototype.renderComponent =
	function (element, renderingContext) {
		var self = this;
		return this._getPromiseForReadyState()
			.then(function () {
				var id = self._getId(element);
				if (!id) {
					self._logger.warn(
						util.format(WARN_ID_NOT_SPECIFIED, componentName)
					);
					return;
				}

				if (!renderingContext) {
					renderingContext = self._createRenderingContext([]);
					renderingContext.rootIds[id] = true;
				}

				var componentName = moduleHelper.getOriginalComponentName(
						element.tagName
					),
					hadChildren = element.hasChildNodes(),
					component = renderingContext.components[componentName],
					instance = self._componentInstances[id];

				if (!component) {
					return;
				}

				if (id in renderingContext.renderedIds) {
					self._logger.warn(
						util.format(WARN_SAME_ID, id, componentName)
					);
					return;
				}

				renderingContext.renderedIds[id] = true;

				if (!instance) {
					component.constructor.prototype.$context =
						self._getComponentContext(component, element);
					instance = self._serviceLocator.resolveInstance(
						component.constructor, renderingContext.config
					);
					instance.$context = component.constructor.prototype.$context;
					self._componentInstances[id] = instance;
				}

				var eventArgs = {
					name: componentName,
					context: instance.$context
				};

				self._componentElements[id] = element;

				var startTime = hrTimeHelper.get();
				self._eventBus.emit('componentRender', eventArgs);

				return Promise.resolve()
					.then(function () {
						// we need unbind the whole hierarchy only at
						// the beginning and not for new elements
						if (!(id in renderingContext.rootIds) ||
							!hadChildren) {
							return;
						}

						return self._unbindAll(element, renderingContext);
					})
					.catch(function (reason) {
						self._eventBus.emit('error', reason);
					})
					.then(function () {
						if (instance.$context.element !== element) {
							instance.$context = self._getComponentContext(
								component, element
							);
						}
						var renderMethod = moduleHelper.getMethodToInvoke(
							instance, 'render'
						);
						return moduleHelper.getSafePromise(renderMethod);
					})
					.then(function (dataContext) {
						return component.template.render(dataContext);
					})
					.catch(function (reason) {
						return self._handleRenderError(
							element, component, reason
						);
					})
					.then(function (html) {
						var isHead = element.tagName === TAG_NAMES.HEAD;
						if (html === '' && isHead) {
							return;
						}
						var tmpElement = self._createTemporaryElement(element);
						tmpElement.innerHTML = html;

						if (isHead) {
							self._mergeHead(element, tmpElement);
							return;
						}

						morphdom(element, tmpElement, {
							onBeforeMorphElChildren: function (foundElement) {
								return foundElement === element ||
									!self._isComponent(
										renderingContext.components,
										foundElement
									);
							}
						});

						var promises = self._findComponents(
							element, renderingContext.components, false
						)
							.map(function (innerComponent) {
								return self.renderComponent(
									innerComponent, renderingContext
								);
							});
						return Promise.all(promises);
					})
					.then(function () {
						eventArgs.hrTime = hrTimeHelper.get(startTime);
						eventArgs.time = hrTimeHelper.toMilliseconds(
							eventArgs.hrTime
						);
						self._eventBus.emit('componentRendered', eventArgs);
						return self._bindComponent(element);
					})
					.then(function () {
						// collecting garbage only when
						// the entire rendering is finished
						if (!(id in renderingContext.rootIds) ||
							!hadChildren) {
							return;
						}
						self._collectRenderingGarbage(renderingContext);
					})
					.catch(function (reason) {
						self._eventBus.emit('error', reason);
					});
			});
	};

/**
 * Gets component instance by ID.
 * @param {string} id Component ID.
 * @returns {Object|null} Component instance.
 */
DocumentRenderer.prototype.getComponentById = function (id) {
	return this._componentInstances[id] || null;
};

/**
 * Gets component instance by a DOM element.
 * @param {Element} element Component's Element.
 * @returns {Object|null} Component instance.
 */
DocumentRenderer.prototype.getComponentByElement = function (element) {
	if (!element) {
		return null;
	}
	var id = element.getAttribute(moduleHelper.ATTRIBUTE_ID);
	return this.getComponentById(id);
};

/**
 * Checks that every instance of component has element on the page and
 * removes all references to components removed from DOM.
 * @returns {Promise} Promise for nothing.
 */
DocumentRenderer.prototype.collectGarbage = function () {
	var self = this;
	return this._getPromiseForReadyState()
		.then(function () {
			var promises = [];
			Object.keys(self._componentElements)
				.forEach(function (id) {
					if (SPECIAL_IDS.hasOwnProperty(id)) {
						return;
					}
					var element = self._window.document.getElementById(id);
					if (element) {
						return;
					}

					var promise = self._unbindComponent(self._componentElements[id])
						.then(function () {
							self._removeComponent(id);
						});
					promises.push(promise);
				});
			return Promise.all(promises);
		});
};

/**
 * Creates and renders component element.
 * @param {string} tagName Name of HTML tag.
 * @param {Object} attributes Element attributes.
 * @returns {Promise<Element>} Promise for HTML element with rendered component.
 */
DocumentRenderer.prototype.createComponent = function (tagName, attributes) {
	if (typeof (tagName) !== 'string' || !attributes ||
		typeof (attributes) !== 'object') {
		return Promise.reject(
			new Error(ERROR_CREATE_WRONG_ARGUMENTS)
		);
	}

	var self = this;
	return this._getPromiseForReadyState()
		.then(function () {
			var components = self._componentLoader.getComponentsByNames(),
				componentName = moduleHelper.getOriginalComponentName(tagName);

			if (moduleHelper.isHeadComponent(componentName) ||
				moduleHelper.isDocumentComponent(componentName) ||
				!(componentName in components)) {
				return Promise.reject(
					new Error(util.format(ERROR_CREATE_WRONG_NAME, tagName))
				);
			}

			var safeTagName = moduleHelper.getTagNameForComponentName(componentName);

			var id = attributes[moduleHelper.ATTRIBUTE_ID];
			if (!id || id in self._componentInstances) {
				return Promise.reject(new Error(ERROR_CREATE_WRONG_ID));
			}

			var element = self._window.document.createElement(safeTagName);
			Object.keys(attributes)
				.forEach(function (attributeName) {
					element.setAttribute(attributeName, attributes[attributeName]);
				});

			return self.renderComponent(element)
				.then(function () {
					return element;
				});
		});
};

/**
 * Clears all references to removed components during rendering process.
 * @param {Object} renderingContext Context of rendering.
 * @private
 */
DocumentRenderer.prototype._collectRenderingGarbage =
	function (renderingContext) {
		var self = this;
		Object.keys(renderingContext.unboundIds)
			.forEach(function (id) {
				// this component has been rendered again and we do not need to
				// remove it.
				if (id in renderingContext.renderedIds) {
					return;
				}

				// if someone added an element with the same ID during the
				// rendering process
				if (self._window.document.getElementById(id) !== null) {
					return;
				}

				self._removeComponent(id);
			});
	};

/**
 * Unbinds all event handlers from specified component and all it's descendants.
 * @param {Element} element Component HTML element.
 * @param {Object} renderingContext Context of rendering.
 * @returns {Promise} Promise for nothing.
 * @private
 */
DocumentRenderer.prototype._unbindAll = function (element, renderingContext) {
	var self = this,
		rootId = this._getId(element),
		promises = [];

	self._findComponents(element, renderingContext.components, true)
		.forEach(function (innerElement) {
			var id = self._getId(innerElement);
			renderingContext.unboundIds[id] = true;
			promises.push(self._unbindComponent(innerElement));
		});

	renderingContext.unboundIds[rootId] = true;
	promises.push(this._unbindComponent(element));

	return Promise.all(promises);
};

/**
 * Unbinds all event handlers from specified component.
 * @param {Element} element Component HTML element.
 * @returns {Promise} Promise for nothing.
 * @private
 */
DocumentRenderer.prototype._unbindComponent = function (element) {
	var id = this._getId(element),
		self = this,
		instance = this._componentInstances[id];
	if (!instance) {
		return Promise.resolve();
	}
	if (id in this._componentBindings) {
		Object.keys(this._componentBindings[id])
			.forEach(function (eventName) {
				element.removeEventListener(
					eventName,
					self._componentBindings[id][eventName].handler,
					NON_BUBBLING_EVENTS.hasOwnProperty(eventName)
				);
			});
		delete this._componentBindings[id];
	}
	var unbindMethod = moduleHelper.getMethodToInvoke(instance, 'unbind');
	return moduleHelper.getSafePromise(unbindMethod)
		.then(function () {
			self._eventBus.emit('componentUnbound', {
				element: element,
				id: !SPECIAL_IDS.hasOwnProperty(id) ? id : null
			});
		})
		.catch(function (reason) {
			self._eventBus.emit('error', reason);
		});
};

/**
 * Removes component from the list.
 * @param {string} id Component's ID
 * @private
 */
DocumentRenderer.prototype._removeComponent = function (id) {
	delete this._componentElements[id];
	delete this._componentInstances[id];
	delete this._componentBindings[id];
};

/**
 * Binds all required event handlers to component.
 * @param {Element} element Component HTML element.
 * @returns {Promise} Promise for nothing.
 * @private
 */
DocumentRenderer.prototype._bindComponent = function (element) {
	var id = this._getId(element),
		self = this,
		instance = this._componentInstances[id];
	if (!instance) {
		return Promise.resolve();
	}

	var bindMethod = moduleHelper.getMethodToInvoke(instance, 'bind');
	return moduleHelper.getSafePromise(bindMethod)
		.then(function (bindings) {
			if (!bindings || typeof (bindings) !== 'object') {
				self._eventBus.emit('componentBound', {
					element: element,
					id: !SPECIAL_IDS.hasOwnProperty(id) ? id : null
				});
				return;
			}
			self._componentBindings[id] = Object.create(null);
			Object.keys(bindings)
				.forEach(function (eventName) {
					eventName = eventName.toLowerCase();
					if (eventName in self._componentBindings[id]) {
						return;
					}
					var selectorHandlers = Object.create(null);
					Object.keys(bindings[eventName])
						.forEach(function (selector) {
							var handler = bindings[eventName][selector];
							if (typeof (handler) !== 'function') {
								return;
							}
							selectorHandlers[selector] = handler.bind(instance);
						});
					self._componentBindings[id][eventName] = {
						handler: self._createBindingHandler(
							element, selectorHandlers
						),
						selectorHandlers: selectorHandlers
					};
					element.addEventListener(
						eventName,
						self._componentBindings[id][eventName].handler,
						NON_BUBBLING_EVENTS.hasOwnProperty(eventName)
					);
				});
			self._eventBus.emit('componentBound', {
				element: element,
				id: id
			});
		});
};

/**
 * Creates universal event handler for delegated events.
 * @param {Element} componentRoot Root element of component.
 * @param {Object} selectorHandlers Map of event handlers by CSS selectors.
 * @returns {Function} Universal event handler for delegated events.
 * @private
 */
DocumentRenderer.prototype._createBindingHandler =
	function (componentRoot, selectorHandlers) {
		var selectors = Object.keys(selectorHandlers);
		return function (event) {
			var dispatchedEvent = createCustomEvent(event, function () {
					return element;
				}),
				element = event.target,
				targetMatches = getMatchesMethod(element),
				isHandled = selectors.some(function (selector) {
					if (targetMatches(selector)) {
						selectorHandlers[selector](dispatchedEvent);
						return true;
					}
					return false;
				});
			if (isHandled || !event.bubbles) {
				return;
			}

			while (element.parentElement && element !== componentRoot) {
				element = element.parentElement;
				targetMatches = getMatchesMethod(element);
				for (var i = 0; i < selectors.length; i++) {
					if (!targetMatches(selectors[i])) {
						continue;
					}
					isHandled = true;
					selectorHandlers[selectors[i]](dispatchedEvent);
					break;
				}

				if (isHandled) {
					break;
				}
			}
		};
	};

/**
 * Checks if the element is a component.
 * @param {Object} components Current components.
 * @param {Element} element DOM element.
 * @private
 */
DocumentRenderer.prototype._isComponent = function (components, element) {
	var currentNodeName = element.nodeName;
	return moduleHelper.COMPONENT_PREFIX_REGEXP.test(currentNodeName) &&
		(moduleHelper.getOriginalComponentName(currentNodeName) in components);
};

/**
 * Finds all descendant components of specified component element.
 * @param {Element} element Root component HTML element to begin search with.
 * @param {Object} components Map of components by names.
 * @param {boolean} goInComponents Go inside nested components.
 * @private
 */
DocumentRenderer.prototype._findComponents =
	function (element, components, goInComponents) {
		var elements = [],
			queue = [element],
			currentChildren, i;

		while (queue.length > 0) {
			currentChildren = queue.shift().childNodes;
			for (i = 0; i < currentChildren.length; i++) {
				// we need only Element nodes
				if (currentChildren[i].nodeType !== 1) {
					continue;
				}

				// and they should be components
				if (!this._isComponent(components, currentChildren[i])) {
					queue.push(currentChildren[i]);
					continue;
				}

				if (goInComponents) {
					queue.push(currentChildren[i]);
				}
				elements.push(currentChildren[i]);
			}
		}

		return elements;
	};

/**
 * Handles error while rendering.
 * @param {Element} element Component HTML element.
 * @param {Object} component Component instance.
 * @param {Error} error Error to handle.
 * @returns {Promise<string>} Promise for HTML string.
 * @private
 */
DocumentRenderer.prototype._handleRenderError =
	function (element, component, error) {
		this._eventBus.emit('error', error);

		// do not corrupt existed HEAD when error occurs
		if (element.tagName === TAG_NAMES.HEAD) {
			return Promise.resolve('');
		}

		if (!this._config.isRelease && error instanceof Error) {
			return Promise.resolve(errorHelper.prettyPrint(
				error, this._window.navigator.userAgent
			));
		} else if (component.errorTemplate) {
			return component.errorTemplate.render(error);
		}

		return Promise.resolve('');
	};

/**
 * Updates all components that depend on current set of changed stores.
 * @returns {Promise} Promise for nothing.
 * @private
 */
DocumentRenderer.prototype._updateStoreComponents = function () {
	if (this._isUpdating) {
		return Promise.resolve();
	}

	var self = this;

	// if document component is changed we should reload the page
	var documentStore = this._window.document.documentElement.getAttribute(
		moduleHelper.ATTRIBUTE_STORE
	);
	if (documentStore in this._currentChangedStores) {
		var newLocation = this._currentRoutingContext.location.toString();
		if (newLocation === this._window.location.toString()) {
			this._window.location.reload();
			return Promise.resolve();
		}
		this._window.location.assign(newLocation);
		return Promise.resolve();
	}

	this._isUpdating = true;

	// if we have awaiting routing we should apply state to the stores
	if (this._awaitingRouting) {
		var components = this._componentLoader.getComponentsByNames(),
			changedByState = this._storeDispatcher.setState(
				this._awaitingRouting.state,
				this._awaitingRouting.routingContext
			);

		changedByState.forEach(function (name) {
			self._currentChangedStores[name] = true;
		});

		// we should update contexts of the stores with the new routing context
		this._currentRoutingContext = this._awaitingRouting.routingContext;
		Object.keys(this._componentInstances)
			.forEach(function (id) {
				var instance = self._componentInstances[id];
				instance.$context = self._getComponentContext(
					components[instance.$context.name],
					instance.$context.element
				);
			});
		this._awaitingRouting = null;
	}

	var changedStores = Object.keys(this._currentChangedStores);
	if (changedStores.length === 0) {
		this._isUpdating = false;
		return Promise.resolve();
	}

	this._currentChangedStores = Object.create(null);

	var renderingContext = this._createRenderingContext(changedStores),
		promises = renderingContext.roots.map(function (root) {
			renderingContext.rootIds[self._getId(root)] = true;
			return self.renderComponent(root, renderingContext);
		});

	return Promise.all(promises)
		.catch(function (reason) {
			self._eventBus.emit('error', reason);
		})
		.then(function () {
			self._isUpdating = false;
			self._eventBus.emit('documentUpdated', changedStores);
			return self._updateStoreComponents();
		});
};

/**
 * Merges new and existed head elements and change only difference.
 * @param {Element} head HEAD DOM element.
 * @param {Element} newHead New head element.
 * @private
 */
/*jshint maxcomplexity:false */
DocumentRenderer.prototype._mergeHead = function (head, newHead) {
	if (!newHead) {
		return;
	}
	var self = this;

	var map = this._getHeadMap(head.childNodes),
		current, i, key, oldKey, oldItem,
		sameMetaElements = Object.create(null);

	for (i = 0; i < newHead.childNodes.length; i++) {
		current = newHead.childNodes[i];

		if (!(current.nodeName in map)) {
			map[current.nodeName] = Object.create(null);
		}

		switch (current.nodeName) {
			// these elements can be only replaced
			case TAG_NAMES.TITLE:
			case TAG_NAMES.BASE:
			case TAG_NAMES.NOSCRIPT:
				key = this._getNodeKey(current);
				oldItem = head.getElementsByTagName(current.nodeName)[0];
				if (oldItem) {
					oldKey = this._getNodeKey(oldItem);
					head.replaceChild(current, oldItem);
				} else {
					head.appendChild(current);
				}
				// when we do replace or append current is removed from newHead
				// therefore we need to decrement index
				i--;
				break;

			// these elements can not be deleted from head
			// therefore we just add new elements that differs from existed
			case TAG_NAMES.STYLE:
			case TAG_NAMES.LINK:
			case TAG_NAMES.SCRIPT:
				key = self._getNodeKey(current);
				if (!(key in map[current.nodeName])) {
					head.appendChild(current);
					i--;
				}
				break;
			// meta and other elements can be deleted
			// but we should not delete and append same elements
			default:
				key = self._getNodeKey(current);
				if (key in map[current.nodeName]) {
					sameMetaElements[key] = true;
				} else {
					head.appendChild(current);
					i--;
				}
				break;
		}
	}

	if (TAG_NAMES.META in map) {
		// remove meta tags which a not in a new head state
		Object.keys(map[TAG_NAMES.META])
			.forEach(function (metaKey) {
				if (metaKey in sameMetaElements) {
					return;
				}

				head.removeChild(map[TAG_NAMES.META][metaKey]);
			});
	}
};

/**
 * Gets map of all HEAD's elements.
 * @param {NodeList} headChildren Head children DOM nodes.
 * @returns {Object} Map of HEAD elements.
 * @private
 */
DocumentRenderer.prototype._getHeadMap = function (headChildren) {
	// Create map of <meta>, <link>, <style> and <script> tags
	// by unique keys that contain attributes and content
	var map = Object.create(null),
		i, current,
		self = this;

	for (i = 0; i < headChildren.length; i++) {
		current = headChildren[i];
		if (!(current.nodeName in map)) {
			map[current.nodeName] = Object.create(null);
		}
		map[current.nodeName][self._getNodeKey(current)] = current;
	}
	return map;
};

/**
 * Gets unique element key using element's attributes and its content.
 * @param {Node} node HTML element.
 * @returns {string} Unique key for element.
 * @private
 */
DocumentRenderer.prototype._getNodeKey = function (node) {
	var current, i,
		attributes = [];

	if (node.nodeType !== NODE_TYPES.ELEMENT_NODE) {
		return node.nodeValue || '';
	}

	if (node.hasAttributes()) {
		for (i = 0; i < node.attributes.length; i++) {
			current = node.attributes[i];
			attributes.push(current.name + '=' + current.value);
		}
	}

	return attributes
			.sort()
			.join('|') + '>' + node.textContent;
};

/**
 * Does initial wrapping for every component on the page.
 * @param {Array} components Current components list.
 * @param {Array} element Elements list.
 * @private
 */
DocumentRenderer.prototype._initialWrap = function (components, elements) {
	var self = this,
		current = elements.pop();

	return Promise.resolve()
		.then(function () {
			var id = self._getId(current);
			if (!id) {
				return;
			}

			var componentName = moduleHelper.getOriginalComponentName(
					current.nodeName
				);
			if (!(componentName in components)) {
				return;
			}
			var constructor = components[componentName].constructor;
			constructor.prototype.$context = self._getComponentContext(
				components[componentName], current
			);

			var instance = self._serviceLocator.resolveInstance(
				constructor, self._config
			);
			instance.$context = constructor.prototype.$context;
			self._componentElements[id] = current;
			self._componentInstances[id] = instance;
			// initialize the store of the component
			self._storeDispatcher.getStore(
				current.getAttribute(moduleHelper.ATTRIBUTE_STORE)
			);
			self._eventBus.emit('componentRendered', {
				name: componentName,
				attributes: instance.$context.attributes,
				context: instance.$context
			});
			return self._bindComponent(current);
		})
		.then(function () {
			if (elements.length > 0) {
				return self._initialWrap(components, elements);
			}

			self._eventBus.emit(
				'documentRendered', self._currentRoutingContext
			);
		});
};

/**
 * Gets component context using basic context.
 * @param {Object} component Component details.
 * @param {Element} element DOM element of component.
 * @returns {Object} Component context.
 * @private
 */
DocumentRenderer.prototype._getComponentContext =
	function (component, element) {
		var self = this,
			storeName = element.getAttribute(moduleHelper.ATTRIBUTE_STORE),
			componentContext = Object.create(this._currentRoutingContext);

		// initialize the store of the component
		this._storeDispatcher.getStore(storeName);

		Object.defineProperties(componentContext, {
			name: {
				get: function () {
					return component.name;
				},
				enumerable: true
			},
			attributes: {
				get: function () {
					return attributesToObject(element.attributes);
				},
				enumerable: true
			}
		});

		componentContext.element = element;
		componentContext.getComponentById = function (id) {
			return self.getComponentById(id);
		};
		componentContext.getComponentByElement = function (element) {
			return self.getComponentByElement(element);
		};
		componentContext.createComponent = function (tagName, attributes) {
			return self.createComponent(tagName, attributes);
		};
		componentContext.collectGarbage = function () {
			return self.collectGarbage();
		};
		componentContext.getStoreData = function () {
			var currentStoreName = element
				.getAttribute(moduleHelper.ATTRIBUTE_STORE);
			return self._storeDispatcher
				.getStoreData(currentStoreName);
		};
		componentContext.sendAction = function (name, args) {
			var currentStoreName = element
				.getAttribute(moduleHelper.ATTRIBUTE_STORE);
			return self._storeDispatcher
				.sendAction(currentStoreName, name, args);
		};
		componentContext.sendBroadcastAction = function (name, args) {
			return self._storeDispatcher
				.sendBroadcastAction(name, args);
		};

		return Object.freeze(componentContext);
	};

/**
 * Finds all rendering roots on page for all changed stores.
 * @param {Array} changedStoreNames List of store names which has been changed.
 * @returns {Array<Element>} HTML elements that are rendering roots.
 * @private
 */
DocumentRenderer.prototype._findRenderingRoots = function (changedStoreNames) {
	var self = this,
		headStore = this._window.document.head.getAttribute(
			moduleHelper.ATTRIBUTE_STORE
		),
		components = this._componentLoader.getComponentsByNames(),
		componentsElements = Object.create(null),
		storeNamesSet = Object.create(null),
		rootsSet = Object.create(null),
		roots = [];

	// we should find all components and then looking for roots
	changedStoreNames
		.forEach(function (storeName) {
			storeNamesSet[storeName] = true;
			componentsElements[storeName] = self._window.document
				.querySelectorAll(
					'[' +
					moduleHelper.ATTRIBUTE_ID +
					']' +
					'[' +
					moduleHelper.ATTRIBUTE_STORE +
					'="' +
					storeName +
					'"]'
				);
		});

	if (moduleHelper.HEAD_COMPONENT_NAME in components &&
		headStore in storeNamesSet) {
		rootsSet[this._getId(this._window.document.head)] = true;
		roots.push(this._window.document.head);
	}

	changedStoreNames
		.forEach(function (storeName) {
			var current, currentId,
				lastRoot, lastRootId,
				currentStore, currentComponentName;

			for (var i = 0; i < componentsElements[storeName].length; i++) {
				current = componentsElements[storeName][i];
				currentId = componentsElements[storeName][i]
					.getAttribute(moduleHelper.ATTRIBUTE_ID);
				lastRoot = current;
				lastRootId = currentId;
				currentComponentName = moduleHelper.getOriginalComponentName(
					current.tagName
				);

				while (current.parentElement) {
					current = current.parentElement;
					currentId = self._getId(current);
					currentStore = current.getAttribute(
						moduleHelper.ATTRIBUTE_STORE
					);

					// store did not change state
					if (!currentStore || !(currentStore in storeNamesSet)) {
						continue;
					}

					// is not an active component
					if (!(currentComponentName in components)) {
						continue;
					}

					lastRoot = current;
					lastRootId = currentId;
				}
				if (lastRootId in rootsSet) {
					continue;
				}
				rootsSet[lastRootId] = true;
				roots.push(lastRoot);
			}
		});

	return roots;
};

/**
 * Creates rendering context.
 * @param {Array?} changedStores Names of changed stores.
 * @returns {{
 *   config: Object,
 *   renderedIds: {},
 *   unboundIds: {},
 *   isHeadRendered: boolean,
 *   bindMethods: Array,
 *   routingContext: Object,
 *   components: Object,
 *   roots: Array.<Element>
 * }} The context object.
 * @private
 */
DocumentRenderer.prototype._createRenderingContext = function (changedStores) {
	var components = this._componentLoader.getComponentsByNames();

	return {
		config: this._config,
		renderedIds: Object.create(null),
		unboundIds: Object.create(null),
		isHeadRendered: false,
		bindMethods: [],
		routingContext: this._currentRoutingContext,
		components: components,
		rootIds: Object.create(null),
		roots: changedStores ? this._findRenderingRoots(changedStores) : []
	};
};

/**
 * Gets ID of the element.
 * @param {Element} element HTML element of component.
 * @returns {string} ID.
 */
DocumentRenderer.prototype._getId = function (element) {
	if (element === this._window.document.documentElement) {
		return SPECIAL_IDS.$$document;
	}
	if (element === this._window.document.head) {
		return SPECIAL_IDS.$$head;
	}
	return element.getAttribute(moduleHelper.ATTRIBUTE_ID);
};

/**
 * Creates temporary clone of the element.
 * @param {Element} element DOM element.
 * @returns {Element} clone.
 * @private
 */
DocumentRenderer.prototype._createTemporaryElement = function (element) {
	var tmp = this._window.document.createElement(element.tagName),
		attributes = element.attributes;
	for (var i = 0; i < attributes.length; i++) {
		tmp.setAttribute(attributes[i].name, attributes[i].value);
	}
	return tmp;
};

/**
 * Converts NamedNodeMap of Attr items to key-value object map.
 * @param {NamedNodeMap} attributes List of Element attributes.
 * @returns {Object} Map of attribute values by names.
 */
function attributesToObject(attributes) {
	var result = Object.create(null);
	for (var i = 0; i < attributes.length; i++) {
		result[attributes[i].name] = attributes[i].value;
	}
	return result;
}

/**
 * Gets cross-browser "matches" method for the element.
 * @param {Element} element HTML element.
 * @returns {Function} "matches" method.
 */
function getMatchesMethod(element) {
	var method = (element.matches ||
		element.webkitMatchesSelector ||
		element.mozMatchesSelector ||
		element.oMatchesSelector ||
		element.msMatchesSelector);

	return method.bind(element);
}

/**
 * Creates imitation of original Event object but with specified currentTarget.
 * @param {Event} event Original event object.
 * @param {Function} currentTargetGetter Getter for currentTarget.
 * @returns {Event} Wrapped event.
 */
function createCustomEvent(event, currentTargetGetter) {
	var catEvent = Object.create(event),
		keys = [],
		properties = {};
	for (var key in event) {
		keys.push(key);
	}
	keys.forEach(function (key) {
		if (typeof (event[key]) === 'function') {
			properties[key] = {
				get: function () {
					return event[key].bind(event);
				}
			};
			return;
		}

		properties[key] = {
			get: function () {
				return event[key];
			},
			set: function (value) {
				event[key] = value;
			}
		};
	});

	properties.currentTarget = {
		get: currentTargetGetter
	};
	Object.defineProperties(catEvent, properties);
	Object.seal(catEvent);
	Object.freeze(catEvent);
	return catEvent;
}
},{"../lib/base/DocumentRendererBase":108,"../lib/helpers/errorHelper":111,"../lib/helpers/hrTimeHelper":97,"../lib/helpers/moduleHelper":112,"morphdom":133,"util":121}],95:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = Logger;

var LEVELS = {
	DEBUG: 'debug',
	TRACE: 'trace',
	INFO: 'info',
	WARN: 'warn',
	ERROR: 'error',
	FATAL: 'fatal'
};

/**
 * Creates browser logger.
 * @param {Object|string} levels Levels to log.
 * @constructor
 */
function Logger(levels) {
	if (typeof (levels) === 'object') {
		this._levels = levels;
	}

	if (typeof (levels) === 'string') {
		this._levels = {};
		Object.keys(LEVELS)
			.forEach(function (level) {
				this._levels[LEVELS[level]] =
					(levels.search(LEVELS[level]) !== -1);
			}, this);
	}

	this.debug = this.debug.bind(this);
	this.trace = this.trace.bind(this);
	this.info = this.info.bind(this);
	this.warn = this.warn.bind(this);
	this.error = this.error.bind(this);
	this.fatal = this.fatal.bind(this);
}

/**
 * Current levels of logging.
 * @type {Object}
 * @private
 */
Logger.prototype._levels = {
	debug: true,
	trace: true,
	info: true,
	warn: true,
	error: true,
	fatal: true
};

/**
 * Logs trace message.
 * @param {string} message Trace message.
 */
Logger.prototype.trace = function (message) {
	if (!this._levels.trace) {
		return;
	}

	if (console.log) {
		console.log(message);
	}
};

/**
 * Logs trace message.
 * @param {string} message Trace message.
 */
Logger.prototype.debug = function (message) {
	if (!this._levels.debug) {
		return;
	}

	if (console.log) {
		console.log(message);
	}
};

/**
 * Logs info message.
 * @param {string} message Information message.
 */
Logger.prototype.info = function (message) {
	if (!this._levels.info) {
		return;
	}

	if (console.info) {
		console.info(message);
	}
};

/**
 * Logs warn message.
 * @param {string} message Warning message.
 */
Logger.prototype.warn = function (message) {
	if (!this._levels.warn) {
		return;
	}

	if (console.warn) {
		console.warn(message);
	}
};
/**
 * Logs error message.
 * @param {string|Error} error Error object or message.
 */
Logger.prototype.error = function (error) {
	if (!this._levels.error) {
		return;
	}

	writeError(error);
};

/**
 * Logs error message.
 * @param {string|Error} error Error object or message.
 */
Logger.prototype.fatal = function (error) {
	if (!this._levels.fatal) {
		return;
	}
	writeError(error);
};

/**
 * Writes error to console.
 * @param {Error|string} error Error to write.
 */
function writeError(error) {
	try {
		if (!(error instanceof Error)) {
			error = typeof (error) === 'string' ? new Error(error) : new Error();
		}
		if (console.error) {
			console.error(error);
		}
	} catch (e) {
		writeError(e);
	}
}
},{}],96:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = RequestRouter;

var util = require('util'),
	URI = require('catberry-uri').URI;

var MOUSE_PRIMARY_KEY = 0,
	HREF_ATTRIBUTE_NAME = 'href',
	TARGET_ATTRIBUTE_NAME = 'target',
	A_TAG_NAME = 'A',
	BODY_TAG_NAME = 'BODY';

/**
 * Creates new instance of the browser request router.
 * @param {ServiceLocator} $serviceLocator Service locator to resolve services.
 * @constructor
 */
function RequestRouter($serviceLocator) {
	this._eventBus = $serviceLocator.resolve('eventBus');
	this._window = $serviceLocator.resolve('window');
	this._documentRenderer = $serviceLocator.resolve('documentRenderer');
	this._stateProvider = $serviceLocator.resolve('stateProvider');
	this._contextFactory = $serviceLocator.resolve('contextFactory');

	this._isHistorySupported = this._window.history &&
		this._window.history.pushState instanceof Function;
	var self = this;

	// add event handlers
	self._wrapDocument();

	// set initial state from current URI
	this._changeState(new URI(this._window.location.toString()))
		.catch(function (reason) {
			self._handleError(reason);
		});
}

/**
 * Current initialization flag.
 * @type {boolean}
 * @private
 */
RequestRouter.prototype._isStateInitialized = false;

/**
 * Current referrer.
 * @type {URI}
 * @private
 */
RequestRouter.prototype._referrer = '';

/**
 * Current location.
 * @type {URI}
 * @private
 */
RequestRouter.prototype._location = null;

/**
 * Current event bus.
 * @type {EventEmitter}
 * @private
 */
RequestRouter.prototype._eventBus = null;

/**
 * Current context factory.
 * @type {ContextFactory}
 * @private
 */
RequestRouter.prototype._contextFactory = null;

/**
 * Current state provider.
 * @type {StateProvider}
 * @private
 */
RequestRouter.prototype._stateProvider = null;

/**
 * Current document renderer.
 * @type {DocumentRenderer}
 * @private
 */
RequestRouter.prototype._documentRenderer = null;

/**
 * Current browser window.
 * @type {Window}
 * @private
 */
RequestRouter.prototype._window = null;

/**
 * True if current browser supports history API.
 * @type {boolean}
 * @private
 */
RequestRouter.prototype._isHistorySupported = false;

/**
 * Routes browser render request.
 * @returns {Promise} Promise for nothing.
 */
RequestRouter.prototype.route = function () {
	var self = this;
	// because now location was not change yet and
	// different browsers handle `popstate` differently
	// we need to do route in next iteration of event loop
	return Promise.resolve()
		.then(function () {
			var newLocation = new URI(self._window.location.toString()),
				newAuthority = newLocation.authority ?
					newLocation.authority.toString() : null,
				currentAuthority = self._location.authority ?
					self._location.authority.toString() : null;

			if (newLocation.scheme !== self._location.scheme ||
				newAuthority !== currentAuthority) {
				return;
			}

			// if only URI fragment is changed
			var newQuery = newLocation.query ?
					newLocation.query.toString() : null,
				currentQuery = self._location.query ?
					self._location.query.toString() : null;
			if (newLocation.path === self._location.path &&
				newQuery === currentQuery) {
				self._location = newLocation;
				return;
			}
			return self._changeState(newLocation);
		});
};

/**
 * Sets application state to specified URI.
 * @param {string} locationString URI to go.
 * @returns {Promise} Promise for nothing.
 */
RequestRouter.prototype.go = function (locationString) {
	var self = this;
	return Promise.resolve()
		.then(function () {
			var location = new URI(locationString);
			location = location.resolveRelative(self._location);
			locationString = location.toString();

			var currentAuthority = self._location.authority ?
					self._location.authority.toString() : null,
				newAuthority = location.authority ?
					location.authority.toString() : null;

			// we must check if this is an external link before map URI
			// to internal application state
			if (!self._isHistorySupported ||
				location.scheme !== self._location.scheme ||
				newAuthority !== currentAuthority) {
				self._window.location.assign(locationString);
				return;
			}

			var state = self._stateProvider.getStateByUri(location);
			if (!state) {
				self._window.location.assign(locationString);
				return;
			}

			self._window.history.pushState(state, '', locationString);
			return self.route();
		});
};

/**
 * Changes current application state with new location.
 * @param {URI} newLocation New location.
 * @returns {Promise} Promise for nothing.
 * @private
 */
RequestRouter.prototype._changeState = function (newLocation) {
	var self = this;
	return Promise.resolve()
		.then(function () {
			self._location = newLocation;
			var state = self._stateProvider.getStateByUri(newLocation),
				routingContext = self._contextFactory.create({
					referrer: self._referrer || self._window.document.referrer,
					location: self._location,
					userAgent: self._window.navigator.userAgent
				});

			if (!self._isStateInitialized) {
				self._isStateInitialized = true;
				return self._documentRenderer.initWithState(
					state, routingContext
				);
			}

			if (state === null) {
				window.location.reload();
				return;
			}

			return self._documentRenderer
				.render(state, routingContext);
		})
		.then(function () {
			self._referrer = self._location;
		});
};

/**
 * Wraps document with required events to route requests.
 * @private
 */
RequestRouter.prototype._wrapDocument = function () {
	var self = this;

	if (!this._isHistorySupported) {
		return;
	}

	this._window.addEventListener('popstate', function () {
		self.route().catch(self._handleError.bind(self));
	});

	this._window.document.body.addEventListener('click', function (event) {
		if (event.defaultPrevented) {
			return;
		}
		if (event.target.tagName === A_TAG_NAME) {
			self._linkClickHandler(event, event.target);
		} else {
			var link = closestLink(event.target);
			if (!link) {
				return;
			}
			self._linkClickHandler(event, link);
		}
	});
};

/**
 * Handles link click on the page.
 * @param {Event} event Event-related object.
 * @param {Element} element Link element.
 * @private
 */
RequestRouter.prototype._linkClickHandler = function (event, element) {
	var targetAttribute = element.getAttribute(TARGET_ATTRIBUTE_NAME);
	if (targetAttribute) {
		return;
	}

	// if middle mouse button was clicked
	if (event.button !== MOUSE_PRIMARY_KEY ||
		event.ctrlKey || event.altKey || event.shiftKey) {
		return;
	}

	var locationString = element.getAttribute(HREF_ATTRIBUTE_NAME);
	if (!locationString) {
		return;
	}
	if (locationString[0] === '#') {
		return;
	}

	event.preventDefault();
	this.go(locationString)
		.catch(this._handleError.bind(this));
};

/**
 * Handles all errors.
 * @param {Error} error Error to handle.
 * @private
 */
RequestRouter.prototype._handleError = function (error) {
	this._eventBus.emit('error', error);
};

/**
 * Finds the closest ascending "A" element node.
 * @param {Node} element DOM element.
 * @returns {Node|null} The closest "A" element or null.
 */
function closestLink(element) {
	while (element && element.nodeName !== A_TAG_NAME &&
		element.nodeName !== BODY_TAG_NAME) {
		element = element.parentNode;
	}
	return element && element.nodeName === A_TAG_NAME ? element : null;
}
},{"catberry-uri":127,"util":121}],97:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2015 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = {
	/**
	 * Gets the high resolution time or the difference between
	 * previous and current time.
	 * @param {Array?} Previous high resolution timestamp.
	 * @returns {Array} The high resolution time.
	 */
	get: require('browser-process-hrtime'),
	/**
	 * Converts the high resolution timestamp to text message.
	 * @param {Array}
	 * @returns {string} Time message.
	 */
	toMessage: require('pretty-hrtime'),
	/**
	 * Converts high resolution time to milliseconds number.
	 * @param {Array} hrTime High resolution time tuple.
	 */
	toMilliseconds: function (hrTime) {
		return hrTime[0] * 1e3 + Math.round(hrTime[1] / 1e6);
	}
};
},{"browser-process-hrtime":116,"pretty-hrtime":134}],98:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2015 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = ComponentLoader;

var moduleHelper = require('../../lib/helpers/moduleHelper'),
	util = require('util'),
	LoaderBase = require('../../lib/base/LoaderBase');

util.inherits(ComponentLoader, LoaderBase);

/**
 * Creates new instance of the component loader.
 * @param {ServiceLocator} $serviceLocator Locator to resolve dependencies.
 * @constructor
 * @extends LoaderBase
 */
function ComponentLoader($serviceLocator) {
	this._serviceLocator = $serviceLocator;
	this._eventBus = $serviceLocator.resolve('eventBus');
	this._templateProvider = $serviceLocator.resolve('templateProvider');
	LoaderBase.call(this, $serviceLocator.resolveAll('componentTransform'));
}

/**
 * Current event bus.
 * @type {EventEmitter}
 * @private
 */
ComponentLoader.prototype._eventBus = null;

/**
 * Current service locator.
 * @type {ServiceLocator}
 * @private
 */
ComponentLoader.prototype._serviceLocator = null;

/**
 * Current template provider.
 * @type {TemplateProvider}
 * @private
 */
ComponentLoader.prototype._templateProvider = null;

/**
 * Current map of loaded components by names.
 * @type {Object} Map of components by names.
 * @private
 */
ComponentLoader.prototype._loadedComponents = null;

/**
 * Loads components when it is in a browser.
 * @returns {Promise} Promise for nothing.
 */
ComponentLoader.prototype.load = function () {
	if (this._loadedComponents) {
		return Promise.resolve(this._loadedComponents);
	}

	this._loadedComponents = Object.create(null);

	var self = this;
	return Promise.resolve()
		.then(function () {
			var components = self._serviceLocator.resolveAll('component'),
				componentPromises = [];

			// the list is a stack, we should reverse it
			components.forEach(function (component) {
				componentPromises.unshift(
					self._processComponent(component)
				);
			});
			return Promise.all(componentPromises);
		})
		.then(function (components) {
			components.forEach(function (component) {
				if (!component || typeof (component) !== 'object') {
					return;
				}
				self._loadedComponents[component.name] = component;
			});
			self._eventBus.emit('allComponentsLoaded', components);
			return self._loadedComponents;
		});
};

/**
 * Processes component and apply required operations.
 * @param {Object} componentDetails Loaded component details.
 * @returns {Object} Component object.
 * @private
 */
ComponentLoader.prototype._processComponent = function (componentDetails) {
	var self = this,
		component = Object.create(componentDetails);

	return this._applyTransforms(component)
		.then(function (transformed) {
			component = transformed;
			self._templateProvider.registerCompiled(
				component.name, component.templateSource
			);
			component.template = {
				render: function (dataContext) {
					return self._templateProvider.render(
						component.name, dataContext
					);
				}
			};
			if (typeof (component.errorTemplateSource) === 'string') {
				var errorTemplateName = moduleHelper.getNameForErrorTemplate(
					component.name
				);
				self._templateProvider.registerCompiled(
					errorTemplateName, component.errorTemplateSource
				);
				component.errorTemplate = {
					render: function (dataContext) {
						return self._templateProvider.render(
							errorTemplateName, dataContext
						);
					}
				};
			}
			self._eventBus.emit('componentLoaded', component);
			return component;
		})
		.catch(function (reason) {
			self._eventBus.emit('error', reason);
			return null;
		});
};

/**
 * Gets map of components by names.
 * @returns {Object} Map of components by names.
 */
ComponentLoader.prototype.getComponentsByNames = function () {
	return this._loadedComponents || Object.create(null);
};
},{"../../lib/base/LoaderBase":109,"../../lib/helpers/moduleHelper":112,"util":121}],99:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2015 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = StoreLoader;

var util = require('util'),
	LoaderBase = require('../../lib/base/LoaderBase');

util.inherits(StoreLoader, LoaderBase);

/**
 * Creates instance of the store loader.
 * @param {ServiceLocator} $serviceLocator Locator to resolve stores.
 * @constructor
 * @extends LoaderBase
 */
function StoreLoader($serviceLocator) {
	this._serviceLocator = $serviceLocator;
	this._eventBus = $serviceLocator.resolve('eventBus');
	LoaderBase.call(this, $serviceLocator.resolveAll('storeTransform'));
}

/**
 * Current event bus.
 * @type {EventEmitter}
 * @private
 */
StoreLoader.prototype._eventBus = null;

/**
 * Current service locator.
 * @type {ServiceLocator}
 * @private
 */
StoreLoader.prototype._serviceLocator = null;

/**
 * Current set of loaded stores.
 * @type {Object}
 * @private
 */
StoreLoader.prototype._loadedStores = null;

/**
 * Loads all stores when it is in a browser.
 * @returns {Promise} Promise for nothing.
 */
StoreLoader.prototype.load = function () {
	if (this._loadedStores) {
		return Promise.resolve(this._loadedStores);
	}

	this._loadedStores = Object.create(null);
	var self = this;

	return Promise.resolve()
		.then(function () {
			var stores = self._serviceLocator.resolveAll('store'),
				storePromises = [];

			// the list is a stack, we should reverse it
			stores.forEach(function (store) {
				storePromises.unshift(
					self._getStore(store)
				);
			});

			return Promise.all(storePromises);
		})
		.then(function (stores) {
			stores.forEach(function (store) {
				if (!store || typeof (store) !== 'object') {
					return;
				}
				self._loadedStores[store.name] = store;
			});
			self._eventBus.emit('allStoresLoaded', self._loadedStores);
			return Promise.resolve(self._loadedStores);
		});
};

/**
 * Gets the store from store details.
 * @param {Object} storeDetails Store details.
 * @returns {Promise<Object>} Promise for store.
 * @private
 */
StoreLoader.prototype._getStore = function (storeDetails) {
	var self = this;
	return this._applyTransforms(storeDetails)
		.then(function (transformed) {
			self._eventBus.emit('storeLoaded', transformed);
			return transformed;
		})
		.catch(function (reason) {
			self._eventBus.emit('error', reason);
			return null;
		});
};

/**
 * Gets stores map by names.
 * @returns {Object} Map of stores by names.
 */
StoreLoader.prototype.getStoresByNames = function () {
	return this._loadedStores || Object.create(null);
};
},{"../../lib/base/LoaderBase":109,"util":121}],100:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = ModuleApiProvider;

var util = require('util'),
	propertyHelper = require('../../lib/helpers/propertyHelper'),
	ModuleApiProviderBase = require('../../lib/base/ModuleApiProviderBase');

util.inherits(ModuleApiProvider, ModuleApiProviderBase);

/**
 * Creates new instance of the module API provider.
 * @param {ServiceLocator} $serviceLocator Service locator
 * to resolve dependencies.
 * @constructor
 * @extends ModuleApiProviderBase
 */
function ModuleApiProvider($serviceLocator) {
	ModuleApiProviderBase.call(this, $serviceLocator);
	propertyHelper.defineReadOnly(this, 'isBrowser', true);
	propertyHelper.defineReadOnly(this, 'isServer', false);
}

/**
 * Reloads the page for handling "not found" error.
 * @returns {Promise} Promise for nothing.
 */
ModuleApiProvider.prototype.notFound = function () {
	var window = this.locator.resolve('window');
	window.location.reload();
	return Promise.resolve();
};

/**
 * Redirects current page to specified URI.
 * @param {string} uriString URI to redirect.
 * @returns {Promise} Promise for nothing.
 */
ModuleApiProvider.prototype.redirect = function (uriString) {
	var requestRouter = this.locator.resolve('requestRouter');
	return requestRouter.go(uriString);
};

/**
 * Clears current location URI's fragment.
 * @returns {Promise} Promise for nothing.
 */
ModuleApiProvider.prototype.clearFragment = function () {
	var window = this.locator.resolve('window'),
		position = window.document.body.scrollTop;
	window.location.hash = '';
	window.document.body.scrollTop = position;
	return Promise.resolve();
};
},{"../../lib/base/ModuleApiProviderBase":110,"../../lib/helpers/propertyHelper":113,"util":121}],101:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = require('./lib/Bootstrapper');

},{"./lib/Bootstrapper":1}],102:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = ContextFactory;

var propertyHelper = require('./helpers/propertyHelper');

/**
 * Creates new instance of the context factory.
 * @param {ServiceLocator} $serviceLocator Locator to resolve dependencies.
 * @constructor
 */
function ContextFactory($serviceLocator) {
	this._serviceLocator = $serviceLocator;
}

/**
 * Current service locator.
 * @type {ServiceLocator}
 * @private
 */
ContextFactory.prototype._serviceLocator = null;

/**
 * Creates new context for modules.
 * @param {Object} additional Additional parameters.
 * @param {URI} additional.referrer Current referrer.
 * @param {URI} additional.location Current location.
 * @param {string} additional.userAgent Current user agent.
 */
ContextFactory.prototype.create = function (additional) {
	var apiProvider = this._serviceLocator.resolve('moduleApiProvider'),
		context = Object.create(apiProvider);
	Object.keys(additional)
		.forEach(function (key) {
			propertyHelper.defineReadOnly(context, key, additional[key]);
		});
	return context;
};
},{"./helpers/propertyHelper":113}],103:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2015 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = SerialWrapper;

var events = require('events');

var ERROR_NO_SUCH_METHOD = 'There is no such registered method';

/**
 * Creates new instance of the serial wrapper for promises.
 * @constructor
 */
function SerialWrapper() {
	this._emitter = new events.EventEmitter();
	this._emitter.setMaxListeners(0);
	this._toInvoke = Object.create(null);
	this._inProgress = Object.create(null);
}

/**
 * Current event emitter.
 * @type {EventEmitter}
 * @private
 */
SerialWrapper.prototype._emitter = null;

/**
 * Current set of named methods to invoke.
 * @type {Object}
 * @private
 */
SerialWrapper.prototype._toInvoke = null;

/**
 * Current set of flags if the method is in progress.
 * @type {Object}
 * @private
 */
SerialWrapper.prototype._inProgress = null;

/**
 * Adds method to the set.
 * @param {string} name Method name.
 * @param {Function} toInvoke Function that returns promise.
 */
SerialWrapper.prototype.add = function (name, toInvoke) {
	this._toInvoke[name] = toInvoke;
};

/**
 * Returns true if method with such name was registered to the set.
 * @param {string} name Name of method.
 * @returns {boolean} True if method name is registered.
 */
SerialWrapper.prototype.isRegistered = function (name) {
	return typeof (this._toInvoke[name]) === 'function';
};

/**
 * Invokes method without concurrency.
 * @param {string} name Method name.
 * @returns {Promise<Object>} Promise for result.
 */
SerialWrapper.prototype.invoke = function (name) {
	var self = this;

	if (!this.isRegistered(name)) {
		return Promise.reject(new Error(ERROR_NO_SUCH_METHOD));
	}

	if (this._inProgress[name]) {
		return new Promise(function (fulfill, reject) {
			self._emitter.once(name, fulfill);
			self._emitter.once(name + '--error', reject);
		});
	}

	this._inProgress[name] = true;
	this._toInvoke[name]()
		.then(function (result) {
			self._emitter.emit(name, result);
			self._inProgress[name] = null;
		})
		.catch(function (reason) {
			self._emitter.emit(name + '--error', reason);
			self._inProgress[name] = null;
		});

	return this.invoke(name);
};
},{"events":117}],104:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2015 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = StoreDispatcher;

var util = require('util'),
	SerialWrapper = require('./SerialWrapper'),
	moduleHelper = require('./helpers/moduleHelper');

var ERROR_STORE_NOT_FOUND = 'Store "%s" not found',
	ERROR_STATE = 'State should be set before any request',
	DEFAULT_LIFETIME = 60000;

/**
 * Creates new instance of store dispatcher.
 * @param {ServiceLocator} $serviceLocator Locator to resolve dependencies.
 * @param {StoreLoader} $storeLoader Store loader to load stores.
 * @param {EventEmitter} $eventBus Event bus to emit events.
 * @constructor
 */
function StoreDispatcher($serviceLocator, $storeLoader, $eventBus) {
	this._serviceLocator = $serviceLocator;
	this._storeLoader = $storeLoader;
	this._eventBus = $eventBus;
	this._storeInstances = Object.create(null);
	this._lastData = Object.create(null);
	this._dependants = Object.create(null);
	this._serialWrapper = new SerialWrapper();
}

/**
 * Current service locator.
 * @type {ServiceLocator}
 * @private
 */
StoreDispatcher.prototype._serviceLocator = null;

/**
 * Current event bus.
 * @type {EventEmitter}
 * @private
 */
StoreDispatcher.prototype._eventBus = null;

/**
 * Current store loader.
 * @type {StoreLoader}
 * @private
 */
StoreDispatcher.prototype._storeLoader = null;

/**
 * Current map of all store instances.
 * @type {null}
 * @private
 */
StoreDispatcher.prototype._storeInstances = null;

/**
 * Current map of last data for each store.
 * @type {Object}
 * @private
 */
StoreDispatcher.prototype._lastData = null;

/**
 * Current map of last state of store dispatcher.
 * @type {Object}
 * @private
 */
StoreDispatcher.prototype._lastState = null;

/**
 * Current serial wrapper.
 * @type {SerialWrapper}
 * @private
 */
StoreDispatcher.prototype._serialWrapper = null;

/**
 * Current basic context for all store contexts.
 * @type {Object}
 * @private
 */
StoreDispatcher.prototype._currentBasicContext = null;

/**
 * Current set of store dependency graph.
 * @type {Object}
 * @private
 */
StoreDispatcher.prototype._dependants = null;

/**
 * Gets store data and creates store instance if required.
 * @param {string} storeName Name of store.
 * @returns {Object} Store's data.
 */
StoreDispatcher.prototype.getStoreData = function (storeName) {
	if (!this._lastState) {
		return Promise.reject(new Error(ERROR_STATE));
	}
	if (typeof (storeName) !== 'string') {
		return Promise.resolve(null);
	}
	if (storeName in this._lastData) {
		var existTime = Date.now() - this._lastData[storeName].createdAt;
		if (existTime <= this._lastData[storeName].lifetime) {
			return Promise.resolve(this._lastData[storeName].data);
		}
		delete this._lastData[storeName];
	}
	var self = this,
		lifetime = DEFAULT_LIFETIME;
	self._eventBus.emit('storeDataLoad', {
		name: storeName
	});
	var store = this.getStore(storeName);
	if (!store) {
		return Promise.reject(new Error(
				util.format(ERROR_STORE_NOT_FOUND, storeName))
		);
	}
	if (typeof (store.$lifetime) === 'number') {
		lifetime = store.$lifetime;
	}
	return self._serialWrapper.invoke(storeName)
		.then(function (data) {
			self._lastData[storeName] = {
				data: data,
				lifetime: lifetime,
				createdAt: Date.now()
			};
			self._eventBus.emit('storeDataLoaded', {
				name: storeName,
				data: data,
				lifetime: lifetime
			});
			return data;
		});
};

/**
 * Sends action to specified store and resolves promises in serial mode.
 * @param {string} storeName Name of the store.
 * @param {string} actionName Name of the action.
 * @param {Object} args Action arguments.
 * @returns {Promise<*>} Promise for action handling result.
 */
StoreDispatcher.prototype.sendAction = function (storeName, actionName, args) {
	if (!this._lastState) {
		return Promise.reject(new Error(ERROR_STATE));
	}
	var self = this,
		actionDetails = {
			storeName: storeName,
			actionName: actionName,
			args: args
		};
	this._eventBus.emit('actionSend', actionDetails);
	var store = this.getStore(storeName);
	if (!store) {
		return Promise.reject(new Error(
			util.format(ERROR_STORE_NOT_FOUND, storeName))
		);
	}
	var handleMethod = moduleHelper.getMethodToInvoke(
		store, 'handle', actionName
	);
	return moduleHelper.getSafePromise(function () {
		return handleMethod(args);
	})
		.then(function (result) {
			self._eventBus.emit('actionSent', actionDetails);
			return result;
		});
};

/**
 * Sends action to every store that has handle method for such action.
 * @param {string} actionName Name of the action.
 * @param {Object} arg Action arguments.
 * @returns {Promise<Array<*>>} Promise for the action handling result.
 */
StoreDispatcher.prototype.sendBroadcastAction = function (actionName, arg) {
	var promises = [],
		self = this,
		storesByNames = this._storeLoader.getStoresByNames(),
		methodName = moduleHelper.getCamelCaseName('handle', actionName);
	Object.keys(storesByNames)
		.forEach(function (storeName) {
			var store = storesByNames[storeName],
				protoMethod = store.constructor.prototype[methodName];
			if (typeof (protoMethod) !== 'function') {
				return;
			}
			var sendActionPromise = self.sendAction(
				store.name, actionName, arg
			);
			promises.push(sendActionPromise);
		});
	return Promise.all(promises);
};

/**
 * Sets new state to store dispatcher and invokes "changed" method for all
 * stores which state have been changed.
 * @param {Object} parameters Map of new parameters.
 * @param {Object} basicContext Basic context for all stores.
 * @returns {Array<string>} Names of stores that have been changed.
 */
StoreDispatcher.prototype.setState = function (parameters, basicContext) {
	parameters = parameters || Object.create(null);
	if (!this._lastState) {
		this._currentBasicContext = basicContext;
		this._lastState = parameters;
		return [];
	}

	// some store's parameters can be removed since last time
	var self = this,
		changed = Object.create(null);

	Object.keys(this._lastState)
		.filter(function (storeName) {
			return !(storeName in parameters);
		})
		.forEach(function (name) {
			changed[name] = true;
		});

	Object.keys(parameters)
		.forEach(function (storeName) {
			// new parameters were set for store
			if (!(storeName in self._lastState)) {
				changed[storeName] = true;
				return;
			}

			// new and last parameters has different values
			var lastParameterNames =
					Object.keys(self._lastState[storeName]),
				currentParameterNames =
					Object.keys(parameters[storeName]);

			if (currentParameterNames.length !==
				lastParameterNames.length) {
				changed[storeName] = true;
				return;
			}

			currentParameterNames.every(function (parameterName) {
				if (parameters[storeName][parameterName] !==
					self._lastState[storeName][parameterName]) {
					changed[storeName] = true;
					return false;
				}
				return true;
			});
		});

	this._lastState = parameters;
	if (this._currentBasicContext !== basicContext) {
		this._currentBasicContext = basicContext;
		Object.keys(this._storeInstances)
			.forEach(function (storeName) {
				self._storeInstances[storeName].$context =
					self._getStoreContext(storeName);
			});
	}

	var changedStoreNames = Object.create(null);
	Object.keys(changed)
		.forEach(function (storeName) {
			var store = self.getStore(storeName);
			if (!store) {
				return;
			}
			store.$context.changed()
				.forEach(function (name) {
					changedStoreNames[name] = true;
				});
		});

	this._eventBus.emit('stateChanged', {
		oldState: this._lastState,
		newState: parameters
	});
	return Object.keys(changedStoreNames);
};

/**
 * Gets context for store using component's context as a prototype.
 * @param {string} storeName Name of store.
 * @returns {Object} Store context.
 * @private
 */
StoreDispatcher.prototype._getStoreContext = function (storeName) {
	var self = this,
		storeContext = Object.create(this._currentBasicContext);
	storeContext.name = storeName;
	storeContext.state = this._lastState[storeName] || Object.create(null);
	storeContext.changed = function () {
		var walked = Object.create(null),
			current,
			toChange = [storeName];

		while (toChange.length > 0) {
			current = toChange.shift();
			if (current in walked) {
				continue;
			}
			walked[current] = true;
			if (current in self._dependants) {
				toChange = toChange.concat(
					Object.keys(self._dependants[current])
				);
			}
			delete self._lastData[current];
			self._eventBus.emit('storeChanged', current);
		}
		return Object.keys(walked);
	};
	storeContext.getStoreData = function (sourceStoreName) {
		if (sourceStoreName === storeName) {
			return Promise.resolve(null);
		}
		return self.getStoreData(sourceStoreName);
	};
	storeContext.setDependency = function (name) {
		if (!(name in self._dependants)) {
			self._dependants[name] = Object.create(null);
		}
		self._dependants[name][storeName] = true;
	};
	storeContext.unsetDependency = function (name) {
		if (!(name in self._dependants)) {
			return;
		}
		delete self._dependants[name][storeName];
	};
	storeContext.sendAction = function (storeName, name, args) {
		return self.sendAction(storeName, name, args);
	};
	storeContext.sendBroadcastAction = function (name, args) {
		return self.sendBroadcastAction(name, args);
	};

	return storeContext;
};

/**
 * Gets store instance and creates it if required.
 * @param {string} storeName Name of store.
 * @returns {Promise<Object>} Promise for store.
 */
StoreDispatcher.prototype.getStore = function (storeName) {
	if (!storeName) {
		return null;
	}
	var store = this._storeInstances[storeName];
	if (store) {
		return store;
	}
	var self = this;

	var stores = self._storeLoader.getStoresByNames(),
		config = self._serviceLocator.resolve('config');
	if (!(storeName in stores)) {
		return null;
	}

	var constructor = stores[storeName].constructor;
	constructor.prototype.$context = self._getStoreContext(storeName);
	self._storeInstances[storeName] = self._serviceLocator
		.resolveInstance(constructor, config);
	self._storeInstances[storeName].$context = constructor.prototype.$context;

	self._serialWrapper.add(storeName, function () {
		var loadMethod = moduleHelper.getMethodToInvoke(
			self._storeInstances[storeName], 'load'
		);
		return moduleHelper.getSafePromise(loadMethod);
	});
	return self._storeInstances[storeName];
};
},{"./SerialWrapper":103,"./helpers/moduleHelper":112,"util":121}],105:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = BootstrapperBase;

var util = require('util'),
	moduleHelper = require('../helpers/moduleHelper'),
	hrTimeHelper = require('../helpers/hrTimeHelper'),
	uhr = require('catberry-uhr'),
	Promise = require('promise'),
	StateProvider = require('../providers/StateProvider'),
	StoreLoader = require('../loaders/StoreLoader'),
	ComponentLoader = require('../loaders/ComponentLoader'),
	DocumentRenderer = require('../DocumentRenderer'),
	RequestRouter = require('../RequestRouter'),
	ModuleApiProviderBase = require('../base/ModuleApiProviderBase'),
	ContextFactory = require('../ContextFactory'),
	EventEmitter = require('events').EventEmitter;

var INFO_COMPONENT_LOADED = 'Component "%s" loaded',
	INFO_STORE_LOADED = 'Store "%s" loaded',
	INFO_ALL_STORES_LOADED = 'All stores loaded',
	INFO_ALL_COMPONENTS_LOADED = 'All components loaded',
	DEBUG_DOCUMENT_RENDERED = 'Document rendered for URI %s',
	DEBUG_RENDER_COMPONENT = 'Component "%s%s" is being rendered...',
	DEBUG_COMPONENT_RENDERED = 'Component "%s%s" rendered%s';

/**
 * Creates new instance of base Catberry bootstrapper.
 * @param {Function} catberryConstructor Constructor
 * of the Catberry's main module.
 * @constructor
 */
function BootstrapperBase(catberryConstructor) {
	this._catberryConstructor = catberryConstructor;
}

/**
 * Current constructor of the Catberry's main module.
 * @type {Function}
 * @private
 */
BootstrapperBase.prototype._catberryConstructor = null;

/**
 * Creates new full-configured instance of the Catberry application.
 * @param {Object?} configObject Configuration object.
 * @returns {Catberry} Catberry application instance.
 */
BootstrapperBase.prototype.create = function (configObject) {
	var currentConfig = configObject || {},
		catberry = new this._catberryConstructor();

	this.configure(currentConfig, catberry.locator);
	catberry.events = catberry.locator.resolveInstance(ModuleApiProviderBase);
	return catberry;
};

/**
 * Configures locator with all required type registrations.
 * @param {Object} configObject Configuration object.
 * @param {ServiceLocator} locator Service locator to configure.
 */
BootstrapperBase.prototype.configure = function (configObject, locator) {
	var eventBus = new EventEmitter();
	eventBus.setMaxListeners(0);
	locator.registerInstance('promise', Promise);
	locator.registerInstance('eventBus', eventBus);
	locator.registerInstance('config', configObject);
	locator.register('stateProvider', StateProvider, configObject, true);
	locator.register('contextFactory', ContextFactory, configObject, true);
	locator.register('storeLoader', StoreLoader, configObject, true);
	locator.register('componentLoader', ComponentLoader, configObject, true);
	locator.register('documentRenderer', DocumentRenderer, configObject, true);
	locator.register('requestRouter', RequestRouter, configObject, true);

	uhr.register(locator);
};

/**
 * Wraps event bus with log messages.
 * @param {Object} config Application config.
 * @param {EventEmitter} eventBus Event emitter that implements event bus.
 * @param {Logger} logger Logger to write messages.
 * @protected
 */
BootstrapperBase.prototype._wrapEventsWithLogger =
	function (config, eventBus, logger) {
		var isRelease = Boolean(config.isRelease);
		eventBus
			.on('componentLoaded', function (args) {
				logger.info(util.format(INFO_COMPONENT_LOADED, args.name));
			})
			.on('storeLoaded', function (args) {
				logger.info(util.format(INFO_STORE_LOADED, args.name));
			})
			.on('allStoresLoaded', function () {
				logger.info(INFO_ALL_STORES_LOADED);
			})
			.on('allComponentsLoaded', function () {
				logger.info(INFO_ALL_COMPONENTS_LOADED);
			})
			.on('error', function (error) {
				logger.error(error);
			});

		if (isRelease) {
			return;
		}
		eventBus
			.on('componentRender', function (args) {
				var id = args.context.attributes[moduleHelper.ATTRIBUTE_ID];
				logger.debug(util.format(DEBUG_RENDER_COMPONENT,
					moduleHelper.getTagNameForComponentName(args.name),
					id ? '#' + id : ''
				));
			})
			.on('componentRendered', function (args) {
				var id = args.context.attributes[moduleHelper.ATTRIBUTE_ID];
				logger.debug(util.format(
					DEBUG_COMPONENT_RENDERED,
					moduleHelper.getTagNameForComponentName(args.name),
					id ? '#' + id : '',
					util.isArray(args.hrTime) ?
						' (' + hrTimeHelper.toMessage(args.hrTime) + ')' : ''
				));
			})
			.on('documentRendered', function (args) {
				logger.debug(util.format(
					DEBUG_DOCUMENT_RENDERED, args.location.toString()
				));
			});
	};
},{"../ContextFactory":102,"../DocumentRenderer":94,"../RequestRouter":96,"../base/ModuleApiProviderBase":110,"../helpers/hrTimeHelper":97,"../helpers/moduleHelper":112,"../loaders/ComponentLoader":98,"../loaders/StoreLoader":99,"../providers/StateProvider":115,"catberry-uhr":125,"events":117,"promise":135,"util":121}],106:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = CatberryBase;

var ServiceLocator = require('catberry-locator');

/**
 * Creates new instance of the basic Catberry application module.
 * @constructor
 */
function CatberryBase() {
	this.locator = new ServiceLocator();
	this.locator.registerInstance('serviceLocator', this.locator);
	this.locator.registerInstance('catberry', this);
}

/**
 * Current version of catberry.
 */
CatberryBase.prototype.version = '7.0.3';

/**
 * Current object with events.
 * @type {ModuleApiProvider}
 */
CatberryBase.prototype.events = null;

/**
 * Current service locator.
 * @type {ServiceLocator}
 */
CatberryBase.prototype.locator = null;
},{"catberry-locator":123}],107:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = CookieWrapperBase;

var util = require('util');

/**
 * Creates new instance of the basic cookie wrapper.
 * @constructor
 */
function CookieWrapperBase() {
}

/**
 * Gets map of cookie values by name.
 * @returns {Object} Cookies map by names.
 */
CookieWrapperBase.prototype.getAll = function () {
	var string = this.getCookieString();
	return this._parseCookieString(string);
};

/**
 * Gets cookie value by name.
 * @param {string} name Cookie name.
 * @returns {string} Cookie value.
 */
CookieWrapperBase.prototype.get = function (name) {
	if (typeof (name) !== 'string') {
		return '';
	}

	return this.getAll()[name] || '';
};

/**
 * Parses cookie string into map of cookie key/value pairs.
 * @param {string} string Cookie string.
 * @returns {Object} Object with cookie values by keys.
 * @protected
 */
CookieWrapperBase.prototype._parseCookieString = function (string) {
	var cookie = Object.create(null);

	if (typeof (string) !== 'string') {
		return cookie;
	}
	string
		.split(/; */)
		.forEach(function (cookiePair) {
			var equalsIndex = cookiePair.indexOf('=');
			if (equalsIndex < 0) {
				return;
			}

			var key = cookiePair.substr(0, equalsIndex).trim(),
				value = cookiePair.substr(
					equalsIndex + 1, cookiePair.length
				).trim();

			value = value.replace(/^"|"$/g, '');
			cookie[key] = value;
		});

	return cookie;
};

/**
 * Converts cookie setup object to cookie string.
 * @param {Object} cookieSetup Cookie setup object.
 * @param {string} cookieSetup.key Cookie key.
 * @param {string} cookieSetup.value Cookie value.
 * @param {number?} cookieSetup.maxAge Max cookie age in seconds.
 * @param {Date?} cookieSetup.expires Expire date.
 * @param {string?} cookieSetup.path URI path for cookie.
 * @param {string?} cookieSetup.domain Cookie domain.
 * @param {boolean?} cookieSetup.secure Is cookie secured.
 * @param {boolean?} cookieSetup.httpOnly Is cookie HTTP only.
 * @returns {string} Cookie string.
 * @protected
 */
CookieWrapperBase.prototype._convertToCookieSetup = function (cookieSetup) {
	if (typeof (cookieSetup.key) !== 'string' ||
		typeof (cookieSetup.value) !== 'string') {
		throw new Error('Wrong key or value');
	}

	var cookie = cookieSetup.key + '=' + cookieSetup.value;

	// http://tools.ietf.org/html/rfc6265#section-4.1.1
	if (typeof (cookieSetup.maxAge) === 'number') {
		cookie += '; Max-Age=' + cookieSetup.maxAge.toFixed();
		if (!cookieSetup.expires) {
			// by default expire date = current date + max-age in seconds
			cookieSetup.expires = new Date(Date.now() +
				cookieSetup.maxAge * 1000);
		}
	}
	if (cookieSetup.expires instanceof Date) {
		cookie += '; Expires=' + cookieSetup.expires.toUTCString();
	}
	if (typeof (cookieSetup.path) === 'string') {
		cookie += '; Path=' + cookieSetup.path;
	}
	if (typeof (cookieSetup.domain) === 'string') {
		cookie += '; Domain=' + cookieSetup.domain;
	}
	if (typeof (cookieSetup.secure) === 'boolean' &&
		cookieSetup.secure) {
		cookie += '; Secure';
	}
	if (typeof (cookieSetup.httpOnly) === 'boolean' &&
		cookieSetup.httpOnly) {
		cookie += '; HttpOnly';
	}

	return cookie;
};
},{"util":121}],108:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2015 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = DocumentRendererBase;

/**
 * Creates new instance of the basic document renderer.
 * @param {ServiceLocator} $serviceLocator Locator to resolve dependencies.
 * @constructor
 */
function DocumentRendererBase($serviceLocator) {
	var self = this;
	this._serviceLocator = $serviceLocator;
	this._contextFactory = $serviceLocator.resolve('contextFactory');
	this._componentLoader = $serviceLocator.resolve('componentLoader');
	this._eventBus = $serviceLocator.resolve('eventBus');

	var storeLoader = $serviceLocator.resolve('storeLoader');
	this._loading = Promise.all([
		this._componentLoader.load(),
		storeLoader.load()
	])
		.then(function () {
			self._loading = null;
			self._eventBus.emit('ready');
		})
		.catch(function (reason) {
			self._eventBus.emit('error', reason);
		});
}

/**
 * Current service locator.
 * @type {ServiceLocator}
 * @protected
 */
DocumentRendererBase.prototype._serviceLocator = null;

/**
 * Current component loader.
 * @type {ComponentLoader}
 * @protected
 */
DocumentRendererBase.prototype._componentLoader = null;

/**
 * Current module loading promise.
 * @type {Promise}
 * @protected
 */
DocumentRendererBase.prototype._loading = null;

/**
 * Current context factory.
 * @type {ContextFactory}
 * @protected
 */
DocumentRendererBase.prototype._contextFactory = null;

/**
 * Gets promise for ready state when it will be able handle requests.
 * @returns {Promise} Promise for nothing.
 * @protected
 */
DocumentRendererBase.prototype._getPromiseForReadyState = function () {
	return this._loading ?
		this._loading :
		Promise.resolve();
};
},{}],109:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2015 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = LoaderBase;

/**
 * Create basic implementation of a module loader.
 * @param {Array} transforms Array of module transformations.
 * @constructor
 */
function LoaderBase(transforms) {
	this._transforms = transforms;
}

/**
 * Current list of component transforms.
 * @type {Array}
 * @private
 */
LoaderBase.prototype._transforms = null;

/**
 * Applies all transformations registered in Service Locator.
 * @param {Object} module Loaded module.
 * @param {number?} index Transformation index in a list.
 * @returns {Promise<Object>} Transformed module.
 * @protected
 */
LoaderBase.prototype._applyTransforms = function (module, index) {
	if (index === undefined) {
		// the list is a stack, we should reverse it
		index = this._transforms.length - 1;
	}

	if (index < 0) {
		return Promise.resolve(module);
	}

	var self = this,
		transformation = this._transforms[index];

	return Promise.resolve()
		.then(function () {
			return transformation.transform(module);
		})
		.then(function (transformedModule) {
			return self._applyTransforms(transformedModule, index - 1);
		});
};
},{}],110:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = ModuleApiProviderBase;

var ERROR_EVENT_NAME = 'Event name should be a string',
	ERROR_EVENT_HANDLER = 'Event handler should be a function';

/**
 * Creates new instance of the basic API provider.
 * @param {ServiceLocator} $serviceLocator Service locator
 * to resolve dependencies.
 * @constructor
 */
function ModuleApiProviderBase($serviceLocator) {
	this.locator = $serviceLocator;
	this.cookie = $serviceLocator.resolve('cookieWrapper');
	this._eventBus = $serviceLocator.resolve('eventBus');
}

/**
 * Current cookie provider.
 * @type {CookieWrapper}
 */
ModuleApiProviderBase.prototype.cookie = null;

/**
 * Current service locator.
 * @type {ServiceLocator}
 * @protected
 */
ModuleApiProviderBase.prototype.locator = null;

/**
 * Current event bus.
 * @type {EventEmitter}
 * @private
 */
ModuleApiProviderBase.prototype._eventBus = null;

/**
 * Subscribes on the specified event in Catberry.
 * @param {string} eventName Name of the event.
 * @param {Function} handler Event handler.
 * @returns {ModuleApiProviderBase} This object for chaining.
 */
ModuleApiProviderBase.prototype.on = function (eventName, handler) {
	checkEventNameAndHandler(eventName, handler);
	this._eventBus.on(eventName, handler);
	return this;
};

/**
 * Subscribes on the specified event in Catberry to handle once.
 * @param {string} eventName Name of the event.
 * @param {Function} handler Event handler.
 * @returns {ModuleApiProviderBase} This object for chaining.
 */
ModuleApiProviderBase.prototype.once = function (eventName, handler) {
	checkEventNameAndHandler(eventName, handler);
	this._eventBus.once(eventName, handler);
	return this;
};

/**
 * Removes the specified handler from the specified event.
 * @param {string} eventName Name of the event.
 * @param {Function} handler Event handler.
 * @returns {ModuleApiProviderBase} This object for chaining.
 */
ModuleApiProviderBase.prototype.removeListener = function (eventName, handler) {
	checkEventNameAndHandler(eventName, handler);
	this._eventBus.removeListener(eventName, handler);
	return this;
};

/**
 * Removes all handlers from the specified event in Catberry.
 * @param {string} eventName Name of the event.
 * @returns {ModuleApiProviderBase} This object for chaining.
 */
ModuleApiProviderBase.prototype.removeAllListeners = function (eventName) {
	checkEventNameAndHandler(eventName, dummy);
	this._eventBus.removeAllListeners(eventName);
	return this;
};

/**
 * Checks if event name is a string and handler is a function.
 * @param {*} eventName Name of the event to check.
 * @param {*} handler The event handler to check.
 */
function checkEventNameAndHandler(eventName, handler) {
	if (typeof (eventName) !== 'string') {
		throw new Error(ERROR_EVENT_NAME);
	}

	if (typeof (handler) !== 'function') {
		throw new Error(ERROR_EVENT_HANDLER);
	}
}

/**
 * Does nothing. It is used as a default callback.
 */
function dummy() {}

},{}],111:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

var util = require('util');

var TITLE = 'Catberry@7.0.3 (' +
		'<a href="https://github.com/catberry/catberry/issues" ' +
		'target="_blank">' +
		'report an issue' +
		'</a>' +
		')',
	AMP = /&/g,
	LT = /</g,
	GT = />/g,
	QUOT = /\"/g,
	SINGLE_QUOT = /\'/g,
	ERROR_MESSAGE_REGEXP = /^(?:[\w$]+): (?:.+)\r?\n/i,
	ERROR_MESSAGE_FORMAT = '<span ' +
		'style="color: red; font-size: 16pt; font-weight: bold;">' +
		'%s%s' +
		'</span>',
	NEW_LINE = /\r?\n/g;

module.exports = {
	/**
	 * Prints error with pretty formatting.
	 * @param {Error} error Error to print.
	 * @param {string} userAgent User agent information.
	 * @returns {string} HTML with all information about error.
	 */
	prettyPrint: function (error, userAgent) {
		if (!error || typeof (error) !== 'object') {
			return '';
		}
		var dateString = (new Date()).toUTCString() + ';<br/>',
			userAgentString = (userAgent ? (userAgent + ';<br/>') : ''),
			name = (typeof (error.name) === 'string' ? error.name + ': ' : ''),
			message = String(error.message || ''),
			stack = String(error.stack || '').replace(ERROR_MESSAGE_REGEXP, ''),
			fullMessage = util.format(
				ERROR_MESSAGE_FORMAT, escape(name), escape(message)
			);

		return '<div style="background-color: white; font-size: 12pt;">' +
			dateString +
			userAgentString +
			TITLE + '<br/><br/>' +
			fullMessage + '<br/><br/>' +
			escape(stack) +
			'</div>';
	}
};

/**
 * Escapes error text.
 * @param {string} value Error text.
 * @returns {string} escaped and formatted string.
 */
function escape(value) {
	return value
		.replace(AMP, '&amp;')
		.replace(LT, '&lt;')
		.replace(GT, '&gt;')
		.replace(QUOT, '&quot;')
		.replace(SINGLE_QUOT, '&#39;')
		.replace(NEW_LINE, '<br/>');
}
},{"util":121}],112:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

var helper = {
	COMPONENT_PREFIX: 'cat-',
	COMPONENT_PREFIX_REGEXP: /^cat-/i,
	COMPONENT_ERROR_TEMPLATE_POSTFIX: '--error',
	DOCUMENT_COMPONENT_NAME: 'document',
	DOCUMENT_ELEMENT_NAME: 'html',
	HEAD_COMPONENT_NAME: 'head',
	ATTRIBUTE_ID: 'id',
	ATTRIBUTE_STORE: 'cat-store',
	DEFAULT_LOGIC_FILENAME: 'index.js',

	/**
	 * Creates name for error template of component.
	 * @param {string} componentName name of component.
	 * @returns {string} Name of error template of the component.
	 */
	getNameForErrorTemplate: function (componentName) {
		if (typeof (componentName) !== 'string') {
			return '';
		}
		return componentName + helper.COMPONENT_ERROR_TEMPLATE_POSTFIX;
	},

	/**
	 * Determines if specified component name is the "document" component name.
	 * @param {string} componentName Name of the component.
	 * @returns {boolean} True if specified component is the "document" component.
	 */
	isDocumentComponent: function (componentName) {
		return componentName.toLowerCase() === helper.DOCUMENT_COMPONENT_NAME;
	},
	/**
	 * Determines if specified component name is the "head" component name.
	 * @param {string} componentName Name of the component.
	 * @returns {boolean} True if specified component is the "head" component.
	 */
	isHeadComponent: function (componentName) {
		return componentName.toLowerCase() === helper.HEAD_COMPONENT_NAME;
	},

	/**
	 * Gets the original component name without prefix.
	 * @param {string} fullComponentName Full component name (tag name).
	 * @returns {string} The original component name without prefix.
	 */
	getOriginalComponentName: function (fullComponentName) {
		if (typeof (fullComponentName) !== 'string') {
			return '';
		}
		fullComponentName = fullComponentName.toLowerCase();
		if (fullComponentName === helper.HEAD_COMPONENT_NAME) {
			return fullComponentName;
		}
		if (fullComponentName === helper.DOCUMENT_COMPONENT_NAME ||
			fullComponentName === helper.DOCUMENT_ELEMENT_NAME) {
			return helper.DOCUMENT_COMPONENT_NAME;
		}
		return fullComponentName.replace(helper.COMPONENT_PREFIX_REGEXP, '');
	},

	/**
	 * Gets valid tag name for component.
	 * @param {string} componentName Name of the component.
	 * @returns {string} Name of the tag.
	 */
	getTagNameForComponentName: function (componentName) {
		if (typeof (componentName) !== 'string') {
			return '';
		}
		var upperComponentName = componentName.toUpperCase();
		if (componentName === helper.HEAD_COMPONENT_NAME) {
			return upperComponentName;
		}
		if (componentName === helper.DOCUMENT_COMPONENT_NAME) {
			return helper.DOCUMENT_ELEMENT_NAME.toUpperCase();
		}
		return helper.COMPONENT_PREFIX.toUpperCase() + upperComponentName;
	},

	/**
	 * Gets method of the module that can be invoked.
	 * @param {Object} module Module implementation.
	 * @param {string} prefix Method prefix (i.e. handle).
	 * @param {string?} name Name of the entity to invoke method for
	 * (will be converted to camel casing).
	 * @returns {Function} Method to invoke.
	 */
	getMethodToInvoke: function (module, prefix, name) {
		if (!module || typeof (module) !== 'object') {
			return defaultPromiseMethod;
		}
		var methodName = helper.getCamelCaseName(prefix, name);
		if (typeof (module[methodName]) === 'function') {
			return module[methodName].bind(module);
		}
		if (typeof (module[prefix]) === 'function') {
			return module[prefix].bind(module, name);
		}

		return defaultPromiseMethod;
	},

	/**
	 * Gets name in camel casing for everything.
	 * @param {string} prefix Prefix for the name.
	 * @param {string} name Name to convert.
	 */
	getCamelCaseName: function (prefix, name) {
		if (!name) {
			return '';
		}
		var parts = name.split(/[^a-z0-9]/i),
			camelCaseName = String(prefix || '');

		parts.forEach(function (part) {
			if (!part) {
				return;
			}

			// first character in method name must be in lowercase
			camelCaseName += camelCaseName ?
				part[0].toUpperCase() :
				part[0].toLowerCase();
			camelCaseName += part.substring(1);
		});

		return camelCaseName;
	},

	/**
	 * Gets safe promise resolved from action.
	 * @param {Function} action Action to wrap with safe promise.
	 * @returns {Promise} Promise for done action.
	 */
	getSafePromise: function (action) {
		var result;
		try {
			result = action();
		} catch (e) {
			return Promise.reject(e);
		}
		return Promise.resolve(result);
	}
};

module.exports = helper;

/**
 * Just returns resolved promise.
 * @returns {Promise} Promise for nothing.
 */
function defaultPromiseMethod() {
	return Promise.resolve();
}
},{}],113:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = {
	/**
	 * Defines read-only property.
	 * @param {Object} object Object to define property in.
	 * @param {string} name Name of the property.
	 * @param {*} value Property value.
	 */
	defineReadOnly: function (object, name, value) {
		Object.defineProperty(object, name, {
			enumerable: false,
			configurable: false,
			writable: false,
			value: value
		});
	}
};
},{}],114:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

var util = require('util'),
	URI = require('catberry-uri').URI;

var URI_PATH_REPLACEMENT_REG_EXP_SOURCE = '([^\\/\\\\]*)',
	URI_QUERY_REPLACEMENT_REG_EXP_SOURCE = '([^&?=]*)';

var PATH_END_SLASH_REG_EXP = /(.+)\/($|\?|#)/,
	EXPRESSION_ESCAPE_REG_EXP = /[\-\[\]\{\}\(\)\*\+\?\.\\\^\$\|]/g,
	IDENTIFIER_REG_EXP_SOURCE = '[$A-Z_][\\dA-Z_$]*',
	STORE_LIST_REG_EXP_SOURCE = '(?:(?:\\\\[[ ]*' +
		'[^\\[\\],]+' +
		'([ ]*,[ ]*' +
		'[^\\[\\],]+' +
		')*[ ]*\\\\])|(?:\\\\[[ ]*\\\\]))?',
	PARAMETER_REG_EXP = new RegExp(
			':' +
			IDENTIFIER_REG_EXP_SOURCE +
			STORE_LIST_REG_EXP_SOURCE, 'gi'),
	SLASHED_BRACKETS_REG_EXP = /\\\[|\\\]/,
	STORE_LIST_SEPARATOR = ',';

module.exports = {
	/**
	 * Removes slash from the end of URI path.
	 * @param {string} uriPath URI path to process.
	 * @returns {string} URI without end slash.
	 */
	removeEndSlash: function (uriPath) {
		if (!uriPath || typeof (uriPath) !== 'string') {
			return '';
		}
		if (uriPath === '/') {
			return uriPath;
		}
		return uriPath.replace(PATH_END_SLASH_REG_EXP, '$1$2');
	},
	/**
	 * Gets URI mapper from the route expression like
	 * /some/:id[store1, store2, store3]/details?filter=:filter[store3].
	 * @param {URI} routeUri Expression that defines route.
	 * @returns {{expression: RegExp, map: Function}?} URI mapper object.
	 * URI mapper object.
	 */
	compileRoute: function (routeUri) {
		if (!routeUri) {
			return null;
		}

		// escape regular expression characters
		var escaped = routeUri.path.replace(
			EXPRESSION_ESCAPE_REG_EXP, '\\$&'
		);

		// get all occurrences of routing parameters in URI path
		var regExpSource = '^' + escaped.replace(
					PARAMETER_REG_EXP,
					URI_PATH_REPLACEMENT_REG_EXP_SOURCE) + '$',
			expression = new RegExp(regExpSource, 'i'),
			queryMapper,
			pathMapper,
			pathParameterMatches = escaped.match(
				PARAMETER_REG_EXP
			),
			pathParameters = pathParameterMatches ?
				pathParameterMatches.map(getParameterDescriptor) : null;

		if (pathParameters) {
			pathMapper = createUriPathMapper(expression, pathParameters);
		}

		if (routeUri.query) {
			var queryParameters = Object.create(null);
			Object.keys(routeUri.query.values)
				.forEach(function (name) {
					// arrays in routing definitions are not supported
					if (util.isArray(routeUri.query.values[name])) {
						return;
					}

					// escape regular expression characters
					var escaped = routeUri.query.values[name].replace(
						EXPRESSION_ESCAPE_REG_EXP, '\\$&'
					);

					// get all occurrences of routing parameters in URI path
					var regExpSource = '^' + escaped.replace(
							PARAMETER_REG_EXP,
							URI_QUERY_REPLACEMENT_REG_EXP_SOURCE) + '$';
					var queryParameterMatches = escaped.match(
							PARAMETER_REG_EXP
						);
					if (!queryParameterMatches ||
						queryParameterMatches.length === 0) {
						return;
					}

					var parameter = getParameterDescriptor(
						queryParameterMatches[queryParameterMatches.length - 1]
					);
					var expression = new RegExp(regExpSource, 'i');
					parameter.map = createUriQueryValueMapper(expression);
					queryParameters[name] = parameter;
				});
			queryMapper = createUriQueryMapper(queryParameters);
		}

		return {
			expression: expression,
			map: function (uri) {
				var state = Object.create(null);
				if (pathMapper) {
					pathMapper(uri.path, state);
				}

				if (queryMapper && uri.query) {
					queryMapper(uri.query.values, state);
				}

				return state;
			}
		};
	}
};

/**
 * Creates new URI path-to-state object mapper.
 * @param {RegExp} expression Regular expression to match URI path.
 * @param {Array} parameters List of parameter descriptors.
 * @returns {Function} URI mapper function.
 */
function createUriPathMapper(expression, parameters) {
	return function (uriPath, state) {
		var matches = uriPath.match(expression);
		if (!matches || matches.length < 2) {
			return state;
		}

		// start with second match because first match is always
		// the whole URI path
		matches = matches.splice(1);

		parameters.forEach(function (parameter, index) {
			var value = matches[index];
			try {
				value = decodeURIComponent(value);
			} catch (e) {
				// nothing to do
			}
			parameter.storeNames.forEach(function (storeName) {
				if (!state[storeName]) {
					state[storeName] = Object.create(null);
				}
				state[storeName][parameter.name] = value;
			});
		});
	};
}

/**
 * Creates new URI query-to-state object mapper.
 * @param {Object} parameters List of possible query parameter descriptors by
 * query parameter names.
 * @returns {Function} URI mapper function.
 */
function createUriQueryMapper(parameters) {
	return function (queryValues, state) {
		queryValues = queryValues || Object.create(null);

		Object.keys(queryValues)
			.forEach(function (queryKey) {
				var parameter = parameters[queryKey];
				if (!parameter) {
					return;
				}

				var value = util.isArray(queryValues[queryKey]) ?
						queryValues[queryKey]
							.map(parameter.map)
							.filter(function (value) {
								return value !== null;
							}) :
						parameter.map(queryValues[queryKey]);

				if (value === null) {
					return;
				}
				parameter.storeNames.forEach(function (storeName) {
					if (!state[storeName]) {
						state[storeName] = Object.create(null);
					}
					state[storeName][parameter.name] = value;
				});
			});
	};
}

/**
 * Maps query parameter value using the parameters expression.
 * @param {RegExp} expression Regular expression to get parameter value.
 * @returns {Function} URI query string parameter value mapper function.
 */
function createUriQueryValueMapper(expression) {
	return function (value) {
		value = value
			.toString()
			// we have to temporary encode these characters for not breaking
			// expression parsing, because it's terminated by query separator
			.replace(/=/g, '%3D')
			.replace(/\?/g, '%3F')
			.replace(/&/g, '%26');
		var matches = value.match(expression);
		if (!matches || matches.length === 0) {
			return null;
		}

		// the value is the second item, the first is a whole string
		var mappedValue = matches[matches.length - 1];
		try {
			mappedValue = decodeURIComponent(mappedValue);
		} catch (e) {
			// nothing to do
		}

		return mappedValue;
	};
}

/**
 * Gets description of parameters from its expression.
 * @param {string} parameter Parameter expression.
 * @returns {{name: string, storeNames: Array}} Parameter descriptor.
 */
function getParameterDescriptor(parameter) {
	var parts = parameter.split(SLASHED_BRACKETS_REG_EXP);

	return {
		name: parts[0]
			.trim()
			.substring(1),
		storeNames: (parts[1] ? parts[1] : '')
			.split(STORE_LIST_SEPARATOR)
			.map(function (storeName) {
				return storeName.trim();
			})
			.filter(function (storeName) {
				return storeName.length > 0;
			})
	};
}
},{"catberry-uri":127,"util":121}],115:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = StateProvider;

var routeHelper = require('./../helpers/routeHelper'),
	catberryUri = require('catberry-uri'),
	URI = catberryUri.URI;

/**
 * Create new instance of the state provider.
 * @param {ServiceLocator} $serviceLocator Service locator
 * to resolve URI mappers.
 * @constructor
 */
function StateProvider($serviceLocator) {
	this._uriMappers = getUriMappers($serviceLocator);
}

/**
 * Current list of URI mappers.
 * @type {Array}
 * @private
 */
StateProvider.prototype._uriMappers = null;

/**
 * Gets state by specified location URI.
 * @param {URI} location URI location.
 * @returns {Object?} State object.
 */
StateProvider.prototype.getStateByUri = function (location) {
	if (this._uriMappers.length === 0) {
		return null;
	}

	location = location.clone();

	location.path = routeHelper.removeEndSlash(location.path);
	var state = getState(this._uriMappers, location);

	if (!state) {
		return null;
	}

	// make state object immutable
	Object.keys(state)
		.forEach(function (storeName) {
			Object.freeze(state[storeName]);
		});
	Object.freeze(state);

	return state;
};

/**
 * Gets list of URI mappers.
 * @param {ServiceLocator} serviceLocator Service locator to get route
 * definitions.
 * @returns {Array} List of URI mappers.
 */
function getUriMappers(serviceLocator) {
	var uriMappers = [];

	serviceLocator.resolveAll('routeDefinition')
		.forEach(function (route) {
			// just colon-parametrized string
			if (typeof (route) === 'string') {
				var routeUri = new URI(route);
				routeUri.path = routeHelper.removeEndSlash(routeUri.path);
				uriMappers.push(routeHelper.compileRoute(routeUri));
				return;
			}

			// extended colon-parametrized mapper
			if (typeof (route) === 'object' &&
				(typeof (route.expression) === 'string') &&
				(route.map instanceof Function)) {
				var mapperUri = new URI(route.expression);
				mapperUri.path = routeHelper.removeEndSlash(mapperUri.path);
				var mapper = routeHelper.compileRoute(mapperUri);
				uriMappers.push({
					expression: mapper.expression,
					map: function (uri) {
						var state = mapper.map(uri);
						return route.map(state);
					}
				});
				return;
			}

			// regular expression mapper
			if (typeof (route) === 'object' &&
				(route.expression instanceof RegExp) &&
				(route.map instanceof Function)) {
				uriMappers.push(route);
			}
		});
	return uriMappers;
}

/**
 * Gets state.
 * @param {Array} uriMappers List of URI mappers.
 * @param {URI} location URI that describes the state.
 * @returns {Object|null} The state from URI.
 */
function getState(uriMappers, location) {
	var state = null;

	uriMappers.some(function (mapper) {
		if (mapper.expression.test(location.path)) {
			state = mapper.map(location) || Object.create(null);
			return true;
		}
		return false;
	});

	return state;
}
},{"./../helpers/routeHelper":114,"catberry-uri":127}],116:[function(require,module,exports){
(function (process,global){
module.exports = process.hrtime || hrtime

// polyfil for window.performance.now
var performance = global.performance || {}
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() }

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3
  var seconds = Math.floor(clocktime)
  var nanoseconds = Math.floor((clocktime%1)*1e9)
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0]
    nanoseconds = nanoseconds - previousTimestamp[1]
    if (nanoseconds<0) {
      seconds--
      nanoseconds += 1e9
    }
  }
  return [seconds,nanoseconds]
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":119}],117:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],118:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],119:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],120:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],121:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":120,"_process":119,"inherits":118}],122:[function(require,module,exports){
/*
 * catberry-locator
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry-locator's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This license applies to all parts of catberry-locator that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = ConstructorTokenizer;

var STATES = {
	ILLEGAL: -1,
	NO: 0,
	IDENTIFIER: 1,
	FUNCTION: 2,
	PARENTHESES_OPEN: 3,
	PARENTHESES_CLOSE: 4,
	COMMA: 5,
	END: 6
};
ConstructorTokenizer.STATES = STATES;

var KEYWORDS = {
	FUNCTION: 'function'
};

var WHITESPACE_TEST = /^\s$/,
	IDENTIFIER_TEST = /^[\$\w]$/;

function ConstructorTokenizer(constructorSource) {
	this._source = String(constructorSource || '');
}

/**
 * Current source code of constructor.
 * @type {string}
 * @private
 */
ConstructorTokenizer.prototype._source = '';

/**
 * Current index in source code.
 * @type {number}
 * @private
 */
ConstructorTokenizer.prototype._currentIndex = 0;

/**
 * Current index in source code.
 * @type {number}
 * @private
 */
ConstructorTokenizer.prototype._currentEnd = 0;

/**
 * Current state.
 * @type {number}
 * @private
 */
ConstructorTokenizer.prototype._currentState = STATES.NO;

/**
 * Gets next token in source.
 * @returns {{state: (number), start: number, end: number}} Token descriptor.
 */
ConstructorTokenizer.prototype.next = function () {
	if (this._currentState === STATES.ILLEGAL ||
		this._currentState === STATES.END) {
		return {
			state: this._currentState,
			start: this._currentIndex,
			end: this._currentIndex + 1
		};
	}

	var start = this._currentIndex,
		state = this._currentState;

	switch (this._currentState) {
		case STATES.PARENTHESES_OPEN:
			this.parenthesesOpenState();
			break;
		case STATES.PARENTHESES_CLOSE:
			this.parenthesesCloseState();
			break;
		case STATES.IDENTIFIER:
			this.identifierState();
			break;
		case STATES.COMMA:
			this.commaState();
			break;
		case STATES.FUNCTION:
			this.functionState();
			break;
		default:
			this.skipWhitespace();
			var expected = this._source.substr(
				this._currentIndex, KEYWORDS.FUNCTION.length
			);
			if (expected === KEYWORDS.FUNCTION) {
				this._currentState = STATES.FUNCTION;
				return this.next();
			}

			state = STATES.ILLEGAL;
	}

	return {
		state: state,
		start: start,
		end: this._currentEnd
	};
};

/**
 * Skips all whitespace characters.
 */
ConstructorTokenizer.prototype.skipWhitespace = function () {
	while (
		this._currentIndex < this._source.length &&
		WHITESPACE_TEST.test(this._source[this._currentIndex])) {
		this._currentIndex++;
	}
};

/**
 * Describes PARENTHESES_OPEN state of machine.
 */
ConstructorTokenizer.prototype.parenthesesOpenState = function () {
	this._currentIndex++;
	this._currentEnd = this._currentIndex;

	this.skipWhitespace();
	if (IDENTIFIER_TEST.test(this._source[this._currentIndex])) {
		this._currentState = STATES.IDENTIFIER;
	} else if (this._source[this._currentIndex] === ')') {
		this._currentState = STATES.PARENTHESES_CLOSE;
	} else {
		this._currentState = STATES.ILLEGAL;
	}
};

/**
 * Describes PARENTHESES_CLOSE state of machine.
 */
ConstructorTokenizer.prototype.parenthesesCloseState = function () {
	this._currentIndex++;
	this._currentEnd = this._currentIndex;
	this._currentState = STATES.END;
};

/**
 * Describes FUNCTION state of machine.
 */
ConstructorTokenizer.prototype.functionState = function () {
	this._currentIndex += KEYWORDS.FUNCTION.length;
	this._currentEnd = this._currentIndex;

	this.skipWhitespace();

	if (this._source[this._currentIndex] === '(') {
		this._currentState = STATES.PARENTHESES_OPEN;
	} else if (IDENTIFIER_TEST.test(this._source[this._currentIndex])) {
		this._currentState = STATES.IDENTIFIER;
	} else {
		this._currentState = STATES.ILLEGAL;
	}
};

/**
 * Describes IDENTIFIER state of machine.
 */
ConstructorTokenizer.prototype.identifierState = function () {
	while (
		this._currentIndex < this._source.length &&
		IDENTIFIER_TEST.test(this._source[this._currentIndex])) {
		this._currentIndex++;
	}

	this._currentEnd = this._currentIndex;

	this.skipWhitespace();
	if (this._source[this._currentIndex] === '(') {
		this._currentState = STATES.PARENTHESES_OPEN;
	} else if (this._source[this._currentIndex] === ')') {
		this._currentState = STATES.PARENTHESES_CLOSE;
	} else if (this._source[this._currentIndex] === ',') {
		this._currentState = STATES.COMMA;
	} else {
		this._currentState = STATES.ILLEGAL;
	}
};

/**
 * Describes COMMA state of machine.
 */
ConstructorTokenizer.prototype.commaState = function () {
	this._currentIndex++;
	this._currentEnd = this._currentIndex;

	this.skipWhitespace();
	if (IDENTIFIER_TEST.test(this._source[this._currentIndex])) {
		this._currentState = STATES.IDENTIFIER;
		return;
	}
	this._currentState = STATES.ILLEGAL;
};
},{}],123:[function(require,module,exports){
/*
 * catberry-locator
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry-locator's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This license applies to all parts of catberry-locator that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = ServiceLocator;

var util = require('util'),
	ConstructorTokenizer = require('./ConstructorTokenizer');

var DEPENDENCY_REGEXP = /^\$\w+/,
	ERROR_CONSTRUCTOR_SHOULD_BE_FUNCTION = 'Constructor should be a function',
	ERROR_TYPE_NOT_REGISTERED = 'Type "%s" not registered',
	ERROR_TYPE_SHOULD_BE_STRING = 'Type name "%s" should be a string';

/**
 * Creates new instance of service locator.
 * @constructor
 */
function ServiceLocator() {
	this._registrations = Object.create(null);
}

/**
 * Current type registrations.
 * @type {Object}
 * @protected
 */
ServiceLocator.prototype._registrations = null;

/**
 * Registers new type in service locator.
 * @param {string} type Type name, which will be alias in other constructors.
 * @param {Function} constructor Constructor which
 * initializes instance of specified type.
 * @param {Object?} parameters Set of named parameters
 * which will be also injected.
 * @param {boolean?} isSingleton If true every resolve will return
 * the same instance.
 */
ServiceLocator.prototype.register =
	function (type, constructor, parameters, isSingleton) {
		throwIfNotFunction(constructor);
		throwIfNotString(type);

		initializeRegistration(type, this);
		var parameterNames = getParameterNames(constructor);

		this._registrations[type].unshift({
			constructor: constructor,
			parameters: parameters || {},
			parameterNames: parameterNames,
			isSingleton: Boolean(isSingleton),
			singleInstance: null
		});
	};

/**
 * Registers single instance for specified type.
 * @param {string} type Type name.
 * @param {Object} instance Instance to register.
 */
ServiceLocator.prototype.registerInstance = function (type, instance) {
	throwIfNotString(type);
	initializeRegistration(type, this);

	this._registrations[type].unshift({
		constructor: instance.constructor,
		parameters: {},
		parameterNames: [],
		isSingleton: true,
		singleInstance: instance
	});
};

/**
 * Resolves last registered implementation by type name
 * including all its dependencies recursively.
 * @param {string} type Type name.
 * @returns {Object} Instance of specified type.
 */
ServiceLocator.prototype.resolve = function (type) {
	throwIfNotString(type);
	throwIfNoType(this._registrations, type);
	var firstRegistration = this._registrations[type][0];
	return createInstance(firstRegistration, this);
};

/**
 * Resolves all registered implementations by type name
 * including all dependencies recursively.
 * @param {string} type Type name.
 * @returns {Array} Array of instances specified type.
 */
ServiceLocator.prototype.resolveAll = function (type) {
	throwIfNotString(type);
	try {
		throwIfNoType(this._registrations, type);
	} catch (e) {
		return [];
	}
	return this._registrations[type].map(function (registration) {
		return createInstance(registration, this);
	}, this);
};

/**
 * Resolves instance of specified constructor including dependencies.
 * @param {Function} constructor Constructor for instance creation.
 * @param {Object?} parameters Set of its parameters values.
 * @returns {Object} Instance of specified constructor.
 */
ServiceLocator.prototype.resolveInstance = function (constructor, parameters) {
	return createInstance({
		constructor: constructor,
		parameters: parameters || {},
		parameterNames: getParameterNames(constructor),
		isSingleton: false,
		singleInstance: null
	}, this);
};

/**
 * Unregisters all registrations of specified type.
 * @param {string} type Type name.
 */
ServiceLocator.prototype.unregister = function (type) {
	throwIfNotString(type);
	delete this._registrations[type];
};

/**
 * Initializes registration array for specified type.
 * @param {string} type Type name.
 * @param {ServiceLocator} context Context of execution.
 */
function initializeRegistration(type, context) {
	if (!(type in context._registrations)) {
		context._registrations[type] = [];
	}
}

/**
 * Throws error if specified registration is not found.
 * @param {Object} registrations Current registrations set.
 * @param {string} type Type to check.
 */
function throwIfNoType(registrations, type) {
	if (!(type in registrations) || registrations[type].length === 0) {
		throw new Error(util.format(ERROR_TYPE_NOT_REGISTERED, type));
	}
}

/**
 * Throws error if specified constructor is not a function.
 * @param {Function} constructor Constructor to check.
 */
function throwIfNotFunction(constructor) {
	if (constructor instanceof Function) {
		return;
	}

	throw new Error(ERROR_CONSTRUCTOR_SHOULD_BE_FUNCTION);
}

/**
 * Throws error if specified type name is not a string.
 * @param {string} type Type name to check.
 */
function throwIfNotString(type) {
	if (typeof (type) === 'string') {
		return;
	}

	throw new Error(util.format(ERROR_TYPE_SHOULD_BE_STRING, type));
}

/**
 * Creates instance of type specified and parameters in registration.
 * @param {Object} registration Specified registration of type.
 * @param {ServiceLocator} context Context of execution.
 * @returns {Object} Instance of type specified in registration.
 */
function createInstance(registration, context) {
	if (registration.isSingleton && registration.singleInstance !== null) {
		return registration.singleInstance;
	}

	var instanceParameters = getParameters(registration, context),
		instance = Object.create(registration.constructor.prototype);
	registration.constructor.apply(instance, instanceParameters);

	if (registration.isSingleton) {
		registration.singleInstance = instance;
	}

	return instance;
}

/**
 * Gets constructor parameters specified in type constructor.
 * @param {Object} registration Type registration.
 * @param {ServiceLocator} context Context of execution.
 * @returns {Array} Array of resolved dependencies to inject.
 */
function getParameters(registration, context) {
	return registration.parameterNames.map(function (parameterName) {
		var dependencyName = getDependencyName(parameterName);
		return dependencyName === null ?
			registration.parameters[parameterName] :
			this.resolve(dependencyName);
	}, context);
}

/**
 * Gets name of dependency type.
 * @param {string} parameterName Name of constructor parameter.
 * @returns {string|null} Name of dependency type.
 */
function getDependencyName(parameterName) {
	if (!DEPENDENCY_REGEXP.test(parameterName)) {
		return null;
	}

	return parameterName.substr(1, parameterName.length - 1);
}

/**
 * Gets all parameter names used in constructor function.
 * @param {Function} constructor Constructor function.
 * @returns {Array<string>} Array of parameter names.
 */
function getParameterNames(constructor) {
	var source = constructor.toString(),
		tokenizer = new ConstructorTokenizer(source),
		result = [],
		token = {
			state: ConstructorTokenizer.STATES.NO,
			start: 0,
			end: 0
		},
		areParametersStarted = false;

	while (
		token.state !== ConstructorTokenizer.STATES.END &&
		token.state !== ConstructorTokenizer.STATES.ILLEGAL) {
		token = tokenizer.next();
		if (token.state === ConstructorTokenizer.STATES.PARENTHESES_OPEN) {
			areParametersStarted = true;
		}

		if (areParametersStarted &&
			token.state === ConstructorTokenizer.STATES.IDENTIFIER) {
			result.push(source.substring(token.start, token.end));
		}
	}
	return result;
}
},{"./ConstructorTokenizer":122,"util":121}],124:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = UHR;

var UHRBase = require('../lib/UHRBase'),
	Promise = require('promise'),
	URI = require('catberry-uri').URI,
	util = require('util');

// if browser still does not have promises then add it.
if (!('Promise' in window)) {
	window.Promise = Promise;
}

util.inherits(UHR, UHRBase);

var NON_SAFE_HEADERS = {
	cookie: true,
	'accept-charset': true
};

var ERROR_CONNECTION = 'Connection error',
	ERROR_TIMEOUT = 'Request timeout',
	ERROR_ABORTED = 'Request aborted';

/**
 * Creates new instance of client-side HTTP(S) request implementation.
 * @param {Window} $window Current window object.
 * @constructor
 */
function UHR($window) {
	UHRBase.call(this);
	this.window = $window;
}

/**
 * Current instance of window.
 * @type {Window}
 */
UHR.prototype.window = null;

/**
 * Does request with specified parameters using protocol implementation.
 * @param {Object} parameters Request parameters.
 * @param {string} parameters.method HTTP method.
 * @param {string} parameters.url URL for request.
 * @param {URI} parameters.uri URI object.
 * @param {Object} parameters.headers HTTP headers to send.
 * @param {string|Object} parameters.data Data to send.
 * @param {number} parameters.timeout Request timeout.
 * @param {boolean} parameters.unsafeHTTPS If true then requests to servers with
 * invalid HTTPS certificates are allowed.
 * @returns {Promise<Object>} Promise for result with status object and content.
 * @protected
 */
UHR.prototype._doRequest = function (parameters) {
	var self = this;

	Object.keys(parameters.headers)
		.forEach(function (name) {
			if (NON_SAFE_HEADERS.hasOwnProperty(name.toLowerCase())) {
				delete parameters.headers[name];
			}
		});

	return new Promise(function (fulfill, reject) {
		var requestError = null,
			xhr = new self.window.XMLHttpRequest();

		xhr.onabort = function () {
			requestError = new Error(ERROR_ABORTED);
			reject(requestError);
		};
		xhr.ontimeout = function () {
			requestError = new Error(ERROR_TIMEOUT);
			reject(requestError);
		};
		xhr.onerror = function () {
			requestError = new Error(xhr.statusText || ERROR_CONNECTION);
			reject(requestError);
		};
		xhr.onreadystatechange = function () {
			if (xhr.readyState !== 4) {
				return;
			}
			if (requestError) {
				return;
			}
			var statusObject = getStatusObject(xhr),
				content = self.convertResponse(
					statusObject.headers,
					xhr.responseText
				);
			fulfill({
				status: statusObject,
				content: content
			});
		};

		var user = parameters.uri.authority.userInfo ?
				parameters.uri.authority.userInfo.user : null,
			password = parameters.uri.authority.userInfo ?
				parameters.uri.authority.userInfo.password : null;
		xhr.open(
			parameters.method, parameters.uri.toString(), true,
			user || undefined, password || undefined
		);
		xhr.timeout = parameters.timeout;

		if (parameters.withCredentials) {
			xhr.withCredentials = true;
		}

		Object.keys(parameters.headers)
			.forEach(function (headerName) {
				xhr.setRequestHeader(
					headerName, parameters.headers[headerName]
				);
			});

		xhr.send(parameters.data);
	});
};

/**
 * Gets state object for specified jQuery XHR object.
 * @param {Object?} xhr XHR object.
 * @returns {{code: number, text: string, headers: Object}} Status object.
 */
function getStatusObject(xhr) {
	var headers = {};

	if (!xhr) {
		return {
			code: 0,
			text: '',
			headers: headers
		};
	}

	xhr
		.getAllResponseHeaders()
		.split('\n')
		.forEach(function (header) {
			var delimiterIndex = header.indexOf(':');
			if (delimiterIndex <= 0) {
				return;
			}
			var headerName = header
				.substring(0, delimiterIndex)
				.trim()
				.toLowerCase();
			headers[headerName] = header
				.substring(delimiterIndex + 1)
				.trim();
		});

	return {
		// handle IE9 bug: http://goo.gl/idspSr
		code: xhr.status === 1223 ? 204 : xhr.status,
		text: xhr.status === 1223 ? 'No Content' : xhr.statusText,
		headers: headers
	};
}
},{"../lib/UHRBase":126,"catberry-uri":127,"promise":135,"util":121}],125:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

var UHR = require('./lib/UHR');

module.exports = {
	/**
	 * Registers UHR in server-side service locator.
	 * @param {ServiceLocator} locator Catberry's service locator.
	 */
	register: function (locator) {
		var config = locator.resolve('config');
		locator.register('uhr', UHR, config, true);
	},
	UHR: UHR
};
},{"./lib/UHR":124}],126:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = UHRBase;

var catberryUri = require('catberry-uri'),
	Query = catberryUri.Query,
	URI = catberryUri.URI;

var ERROR_UNSUPPORTED_PROTOCOL = 'Protocol is unsupported',
	ERROR_PARAMETERS_SHOULD_BE_OBJECT = 'Request parameters should be object',
	ERROR_URL_IS_REQUIRED = 'URL is required parameter',
	ERROR_METHOD_IS_REQUIRED = 'Request method is required parameter',
	ERROR_HOST_IS_REQUIRED = 'Host in URL is required',
	ERROR_SCHEME_IS_REQUIRED = 'Scheme in URL is required',
	ERROR_TIMEOUT_SHOULD_BE_NUMBER = 'Timeout should be a number',
	DEFAULT_TIMEOUT = 30000,
	HTTP_PROTOCOL_REGEXP = /^(http)s?$/i;

var METHODS = {
	GET: 'GET',
	HEAD: 'HEAD',
	POST: 'POST',
	PUT: 'PUT',
	PATCH: 'PATCH',
	DELETE: 'DELETE',
	OPTIONS: 'OPTIONS',
	TRACE: 'TRACE',
	CONNECT: 'CONNECT'
};

UHRBase.TYPES = {
	URL_ENCODED: 'application/x-www-form-urlencoded',
	JSON: 'application/json',
	PLAIN_TEXT: 'text/plain',
	HTML: 'text/html'
};

UHRBase.CHARSET = 'UTF-8';

UHRBase.DEFAULT_GENERAL_HEADERS = {
	Accept: UHRBase.TYPES.JSON + '; q=0.7, ' +
		UHRBase.TYPES.HTML + '; q=0.2, ' +
		UHRBase.TYPES.PLAIN_TEXT + '; q=0.1',
	'Accept-Charset': UHRBase.CHARSET + '; q=1'
};

UHRBase.CHARSET_PARAMETER = '; charset=' + UHRBase.CHARSET;
UHRBase.URL_ENCODED_ENTITY_CONTENT_TYPE = UHRBase.TYPES.URL_ENCODED +
	UHRBase.CHARSET_PARAMETER;

UHRBase.JSON_ENTITY_CONTENT_TYPE = UHRBase.TYPES.JSON +
	UHRBase.CHARSET_PARAMETER;

UHRBase.PLAIN_TEXT_ENTITY_CONTENT_TYPE = UHRBase.TYPES.PLAIN_TEXT +
	UHRBase.CHARSET_PARAMETER;

// This module were developed using HTTP/1.1v2 RFC 2616
// (http://www.w3.org/Protocols/rfc2616/)
/**
 * Creates new instance of Basic Universal HTTP(S) Request implementation.
 * @constructor
 */
function UHRBase() { }

/**
 * Does GET request to HTTP server.
 * @param {string} url URL to request.
 * @param {Object?} options Request parameters.
 * @param {Object?} options.headers HTTP headers to send.
 * @param {(string|Object)?} options.data Data to send.
 * @param {number?} options.timeout Request timeout.
 * @param {boolean?} options.unsafeHTTPS If true then requests to servers with
 * invalid HTTPS certificates are allowed.
 * @returns {Promise<Object>} Promise for result with status object and content.
 */
UHRBase.prototype.get = function (url, options) {
	options = options || {};
	var parameters = Object.create(options);
	parameters.method = METHODS.GET;
	parameters.url = url;
	return this.request(parameters);
};

/**
 * Does POST request to HTTP server.
 * @param {string} url URL to request.
 * @param {Object?} options Request parameters.
 * @param {Object?} options.headers HTTP headers to send.
 * @param {(string|Object)?} options.data Data to send.
 * @param {number?} options.timeout Request timeout.
 * @param {boolean?} options.unsafeHTTPS If true then requests to servers with
 * invalid HTTPS certificates are allowed.
 * @returns {Promise<Object>} Promise for result with status object and content.
 */
UHRBase.prototype.post = function (url, options) {
	options = options || {};
	var parameters = Object.create(options);
	parameters.method = METHODS.POST;
	parameters.url = url;
	return this.request(parameters);
};

/**
 * Does PUT request to HTTP server.
 * @param {string} url URL to request.
 * @param {Object?} options Request parameters.
 * @param {Object?} options.headers HTTP headers to send.
 * @param {(string|Object)?} options.data Data to send.
 * @param {number?} options.timeout Request timeout.
 * @param {boolean?} options.unsafeHTTPS If true then requests to servers with
 * invalid HTTPS certificates are allowed.
 * @returns {Promise<Object>} Promise for result with status object and content.
 */
UHRBase.prototype.put = function (url, options) {
	options = options || {};
	var parameters = Object.create(options);
	parameters.method = METHODS.PUT;
	parameters.url = url;
	return this.request(parameters);
};

/**
 * Does PATCH request to HTTP server.
 * @param {string} url URL to request.
 * @param {Object?} options Request parameters.
 * @param {Object?} options.headers HTTP headers to send.
 * @param {(string|Object)?} options.data Data to send.
 * @param {number?} options.timeout Request timeout.
 * @param {boolean?} options.unsafeHTTPS If true then requests to servers with
 * invalid HTTPS certificates are allowed.
 * @returns {Promise<Object>} Promise for result with status object and content.
 */
UHRBase.prototype.patch = function (url, options) {
	options = options || {};
	var parameters = Object.create(options);
	parameters.method = METHODS.PATCH;
	parameters.url = url;
	return this.request(parameters);
};

/**
 * Does DELETE request to HTTP server.
 * @param {string} url URL to request.
 * @param {Object?} options Request parameters.
 * @param {Object?} options.headers HTTP headers to send.
 * @param {(string|Object)?} options.data Data to send.
 * @param {number?} options.timeout Request timeout.
 * @param {boolean?} options.unsafeHTTPS If true then requests to servers with
 * invalid HTTPS certificates are allowed.
 * @returns {Promise<Object>} Promise for result with status object and content.
 */
UHRBase.prototype.delete = function (url, options) {
	var parameters = Object.create(options);
	parameters.method = METHODS.DELETE;
	parameters.url = url;
	return this.request(parameters);
};

/**
 * Does request with specified parameters.
 * @param {Object} parameters Request parameters.
 * @param {string} parameters.method HTTP method.
 * @param {string} parameters.url URL for request.
 * @param {Object?} parameters.headers HTTP headers to send.
 * @param {(string|Object)?} parameters.data Data to send.
 * @param {number?} parameters.timeout Request timeout.
 * @param {boolean?} parameters.unsafeHTTPS If true then requests
 * to servers with invalid HTTPS certificates are allowed.
 * @returns {Promise<Object>} Promise for result with status object and content.
 */
UHRBase.prototype.request = function (parameters) {
	var self = this;
	return this._validateRequest(parameters)
		.then(function (validated) {
			return self._doRequest(validated);
		});
};

/**
 * Validates UHR parameters.
 * @param {Object} parameters Request parameters.
 * @param {string} parameters.method HTTP method.
 * @param {string} parameters.url URL for request.
 * @param {Object?} parameters.headers HTTP headers to send.
 * @param {(string|Object)?} parameters.data Data to send.
 * @param {number?} parameters.timeout Request timeout.
 * @param {boolean?} parameters.unsafeHTTPS If true then requests
 * to servers with invalid HTTPS certificates are allowed.
 * @returns {Promise} Promise for nothing.
 * @private
 */
/*jshint maxcomplexity:false */
UHRBase.prototype._validateRequest = function (parameters) {
	if (!parameters || typeof (parameters) !== 'object') {
		return Promise.reject(new Error(ERROR_PARAMETERS_SHOULD_BE_OBJECT));
	}

	var validated = Object.create(parameters);

	if (typeof (parameters.url) !== 'string') {
		return Promise.reject(new Error(ERROR_URL_IS_REQUIRED));
	}
	validated.uri = new URI(validated.url);
	if (!validated.uri.scheme) {
		return Promise.reject(new Error(ERROR_SCHEME_IS_REQUIRED));
	}
	if (!HTTP_PROTOCOL_REGEXP.test(validated.uri.scheme)) {
		return Promise.reject(new Error(ERROR_UNSUPPORTED_PROTOCOL));
	}
	if (!validated.uri.authority || !validated.uri.authority.host) {
		return Promise.reject(new Error(ERROR_HOST_IS_REQUIRED));
	}
	if (typeof (validated.method) !== 'string' ||
		!(validated.method in METHODS)) {
		return Promise.reject(new Error(ERROR_METHOD_IS_REQUIRED));
	}

	validated.timeout = validated.timeout || DEFAULT_TIMEOUT;
	if (typeof (validated.timeout) !== 'number') {
		return Promise.reject(new Error(ERROR_TIMEOUT_SHOULD_BE_NUMBER));
	}

	validated.headers = this._createHeaders(validated.headers);

	if (!this._isUpstreamRequest(parameters.method) &&
		validated.data && typeof (validated.data) === 'object') {

		var dataKeys = Object.keys(validated.data);

		if (dataKeys.length > 0 && !validated.uri.query) {
			validated.uri.query = new Query('');
		}

		dataKeys.forEach(function (key) {
			validated.uri.query.values[key] = validated.data[key];
		});
		validated.data = null;
	} else {
		var dataAndHeaders = this._getDataToSend(
			validated.headers, validated.data
		);
		validated.headers = dataAndHeaders.headers;
		validated.data = dataAndHeaders.data;
	}

	return Promise.resolve(validated);
};

/**
 * Gets data for sending via HTTP request using Content Type HTTP header.
 * @param {Object} headers HTTP headers.
 * @param {Object|string} data Data to send.
 * @returns {{headers: Object, data: Object|string}} Data and headers to send.
 * @private
 */
UHRBase.prototype._getDataToSend = function (headers, data) {
	var found = findContentType(headers),
		contentTypeHeader = found.name,
		contentType = found.type;

	if (!data || typeof (data) !== 'object') {
		data = data ? String(data) : '';
		if (!contentType) {
			headers[contentTypeHeader] = UHRBase.PLAIN_TEXT_ENTITY_CONTENT_TYPE;
		}
		return {
			headers: headers,
			data: data
		};
	}

	if (contentType === UHRBase.TYPES.JSON) {
		return {
			headers: headers,
			data: JSON.stringify(data)
		};
	}

	// otherwise object will be sent with
	// application/x-www-form-urlencoded
	headers[contentTypeHeader] = UHRBase.URL_ENCODED_ENTITY_CONTENT_TYPE;

	var query = new Query();
	query.values = data;
	return {
		headers: headers,
		data: query.toString()
			.replace(/\+/g, '%2B')
			.replace(/%20/g, '+')
	};
};

/**
 * Creates HTTP headers for request using defaults and current parameters.
 * @param {Object} parameterHeaders HTTP headers of UHR.
 * @protected
 */
UHRBase.prototype._createHeaders = function (parameterHeaders) {
	if (!parameterHeaders || typeof (parameterHeaders) !== 'object') {
		parameterHeaders = {};
	}
	var headers = {};

	Object.keys(UHRBase.DEFAULT_GENERAL_HEADERS)
		.forEach(function (headerName) {
			headers[headerName] = UHRBase.DEFAULT_GENERAL_HEADERS[headerName];
		});

	Object.keys(parameterHeaders)
		.forEach(function (headerName) {
			if (parameterHeaders[headerName] === null ||
				parameterHeaders[headerName] === undefined) {
				delete headers[headerName];
				return;
			}
			headers[headerName] = parameterHeaders[headerName];
		});

	return headers;
};

/**
 * Does request with specified parameters using protocol implementation.
 * @param {Object} parameters Request parameters.
 * @param {string} parameters.method HTTP method.
 * @param {string} parameters.url URL for request.
 * @param {URI} parameters.uri URI object.
 * @param {Object} parameters.headers HTTP headers to send.
 * @param {string|Object} parameters.data Data to send.
 * @param {number} parameters.timeout Request timeout.
 * @param {boolean} parameters.unsafeHTTPS If true then requests to servers with
 * invalid HTTPS certificates are allowed.
 * @returns {Promise<Object>} Promise for result with status object and content.
 * @protected
 * @abstract
 */
// jscs:disable disallowUnusedParams
UHRBase.prototype._doRequest = function (parameters) { };

/**
 * Converts response data according content type.
 * @param {Object} headers HTTP headers.
 * @param {string} responseData Data from response.
 * @returns {string|Object} Converted data.
 */
UHRBase.prototype.convertResponse = function (headers, responseData) {
	if (typeof (responseData) !== 'string') {
		responseData = '';
	}
	var found = findContentType(headers),
		contentType = found.type || UHRBase.TYPES.PLAIN_TEXT;

	switch (contentType) {
		case UHRBase.TYPES.JSON:
			var json;
			try {
				json = JSON.parse(responseData);
			} catch (e) {
				// nothing to do
			}
			return json || {};
		case UHRBase.TYPES.URL_ENCODED:
			var object;
			try {
				var query = new Query(responseData.replace('+', '%20'));
				object = query.values;
			} catch (e) {
				// nothing to do
			}
			return object || {};
		default:
			return responseData;
	}
};

/**
 * Determines is current query needs to use upstream.
 * @param {string} method HTTP method.
 * @returns {boolean} Is current HTTP method means upstream usage.
 * @protected
 */
UHRBase.prototype._isUpstreamRequest = function (method) {
	return (
		method === METHODS.POST ||
		method === METHODS.PUT ||
		method === METHODS.PATCH
		);
};

/**
 * Finds content type header in headers object.
 * @param {Object} headers HTTP headers.
 * @returns {{name: string, type: string}} Name of header and content type.
 */
function findContentType(headers) {
	var contentTypeString = '',
		contentTypeHeader = 'Content-Type';

	Object.keys(headers)
		.forEach(function (key) {
			if (key.toLowerCase() !== 'content-type') {
				return;
			}
			contentTypeHeader = key;
			contentTypeString = headers[key];
		});

	var typeAndParameters = contentTypeString.split(';'),
		contentType = typeAndParameters[0].toLowerCase();
	return {
		name: contentTypeHeader,
		type: contentType
	};
}

},{"catberry-uri":127}],127:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = {
	URI: require('./lib/URI'),
	Authority: require('./lib/Authority'),
	UserInfo: require('./lib/UserInfo'),
	Query: require('./lib/Query')
};
},{"./lib/Authority":128,"./lib/Query":129,"./lib/URI":130,"./lib/UserInfo":131}],128:[function(require,module,exports){
/*
 * catberry-uri
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry-uri's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry-uri that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = Authority;

var UserInfo = require('./UserInfo'),
	percentEncodingHelper = require('./percentEncodingHelper');

var PORT_REGEXP = /^\d+$/,
	ERROR_PORT = 'URI authority port must satisfy expression ' +
		PORT_REGEXP.toString();

/**
 * Creates new instance of URI authority component parser.
 * https://tools.ietf.org/html/rfc3986#section-3.2
 * @param {string?} authorityString URI authority component string.
 * @constructor
 */
function Authority(authorityString) {
	if (typeof (authorityString) === 'string' && authorityString.length > 0) {
		var firstAtIndex = authorityString.indexOf('@');
		if (firstAtIndex !== -1) {
			var userInfoString = authorityString.substring(0, firstAtIndex);
			this.userInfo = new UserInfo(userInfoString);
			authorityString = authorityString.substring(firstAtIndex + 1);
		}

		var lastColonIndex = authorityString.lastIndexOf(':');
		if (lastColonIndex !== -1) {
			var portString = authorityString.substring(lastColonIndex + 1);
			if (lastColonIndex === authorityString.length - 1) {
				this.port = '';
				authorityString = authorityString.substring(0, lastColonIndex);
			} else if (PORT_REGEXP.test(portString)) {
				this.port = portString;
				authorityString = authorityString.substring(0, lastColonIndex);
			}
		}

		this.host = percentEncodingHelper.decode(authorityString);
	}
}

/**
 * Current user information.
 * https://tools.ietf.org/html/rfc3986#section-3.2.1
 * @type {UserInfo}
 */
Authority.prototype.userInfo = null;

/**
 * Current host.
 * https://tools.ietf.org/html/rfc3986#section-3.2.2
 * @type {string}
 */
Authority.prototype.host = null;

/**
 * Current port.
 * https://tools.ietf.org/html/rfc3986#section-3.2.3
 * @type {string}
 */
Authority.prototype.port = null;

/**
 * Clones current authority.
 * @returns {Authority} New clone of current object.
 */
Authority.prototype.clone = function () {
	var authority = new Authority();
	if (this.userInfo) {
		authority.userInfo = this.userInfo.clone();
	}
	if (typeof (this.host) === 'string') {
		authority.host = this.host;
	}
	if (typeof (this.port) === 'string') {
		authority.port = this.port;
	}
	return authority;
};

/**
 * Recombine all authority components into authority string.
 * @returns {string} Authority component string.
 */
Authority.prototype.toString = function () {
	var result = '';
	if (this.userInfo) {
		result += this.userInfo.toString() + '@';
	}
	if (this.host !== undefined && this.host !== null) {
		var host = String(this.host);
		result += percentEncodingHelper.encodeHost(host);
	}
	if (this.port !== undefined && this.port !== null) {
		var port = String(this.port);
		if (port.length > 0 && !PORT_REGEXP.test(port)) {
			throw new Error(ERROR_PORT);
		}
		result += ':' + port;
	}
	return result;
};
},{"./UserInfo":131,"./percentEncodingHelper":132}],129:[function(require,module,exports){
/*
 * catberry-uri
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry-uri's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry-uri that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = Query;

var percentEncodingHelper = require('./percentEncodingHelper');

/**
 * Creates new instance of URI query component parser.
 * https://tools.ietf.org/html/rfc3986#section-3.4
 * @param {string?} queryString URI query component string.
 * @constructor
 */
function Query(queryString) {
	if (typeof (queryString) === 'string') {
		this.values = {};

		queryString
			.split('&')
			.forEach(function (pair) {
				var parts = pair.split('='),
					key = percentEncodingHelper.decode(parts[0]);
				if (!key) {
					return;
				}
				if (key in this.values &&
					!(this.values[key] instanceof Array)) {
					this.values[key] = [this.values[key]];
				}

				var value = typeof (parts[1]) === 'string' ?
					percentEncodingHelper.decode(parts[1]) : null;

				if (this.values[key] instanceof Array) {
					this.values[key].push(value);
				} else {
					this.values[key] = value;
				}
			}, this);
	}
}

/**
 * Current set of values of query.
 * @type {Object}
 */
Query.prototype.values = null;

/**
 * Clones current query to a new object.
 * @returns {Query} New clone of current object.
 */
Query.prototype.clone = function () {
	var query = new Query();
	if (this.values) {
		query.values = {};
		Object.keys(this.values)
			.forEach(function (key) {
				query.values[key] = this.values[key];
			}, this);
	}
	return query;
};

/**
 * Converts current set of query values to string.
 * @returns {string} Query component string.
 */
Query.prototype.toString = function () {
	if (!this.values) {
		return '';
	}

	var queryString = '';
	Object.keys(this.values)
		.forEach(function (key) {
			var values = this.values[key] instanceof Array ?
				this.values[key] : [this.values[key]];

			values.forEach(function (value) {
				queryString += '&' + percentEncodingHelper
					.encodeQuerySubComponent(key);
				if (value === undefined || value === null) {
					return;
				}
				value = String(value);
				queryString += '=' +
					percentEncodingHelper.encodeQuerySubComponent(value);
			});
		}, this);

	return queryString.replace(/^&/, '');
};
},{"./percentEncodingHelper":132}],130:[function(require,module,exports){
/*
 * catberry
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = URI;

var Authority = require('./Authority'),
	percentEncodingHelper = require('./percentEncodingHelper'),
	Query = require('./Query');

// https://tools.ietf.org/html/rfc3986#appendix-B
var URI_PARSE_REGEXP = new RegExp(
		'^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?'
	),
	// https://tools.ietf.org/html/rfc3986#section-3.1
	SCHEME_REGEXP = /^[a-z]+[a-z\d\+\.-]*$/i,
	ERROR_SCHEME = 'URI scheme must satisfy expression ' +
		SCHEME_REGEXP.toString(),
	ERROR_BASE_SCHEME = 'Scheme component is required to be present ' +
		'in a base URI';

/**
 * Creates new instance of URI according to RFC 3986.
 * @param {string?} uriString URI string to parse components.
 * @constructor
 */
function URI(uriString) {
	if (typeof (uriString) !== 'string') {
		uriString = '';
	}

	// https://tools.ietf.org/html/rfc3986#appendix-B
	var matches = uriString.match(URI_PARSE_REGEXP);

	if (matches) {
		if (typeof (matches[2]) === 'string') {
			this.scheme = percentEncodingHelper.decode(matches[2]);
		}
		if (typeof (matches[4]) === 'string') {
			this.authority = new Authority(matches[4]);
		}
		if (typeof (matches[5]) === 'string') {
			this.path = percentEncodingHelper.decodePath(matches[5]);
		}
		if (typeof (matches[7]) === 'string') {
			this.query = new Query(matches[7]);
		}
		if (typeof (matches[9]) === 'string') {
			this.fragment = percentEncodingHelper.decode(matches[9]);
		}
	}
}

/**
 * Current URI scheme.
 * https://tools.ietf.org/html/rfc3986#section-3.1
 * @type {string}
 */
URI.prototype.scheme = null;

/**
 * Current URI authority.
 * https://tools.ietf.org/html/rfc3986#section-3.2
 * @type {Authority}
 */
URI.prototype.authority = null;

/**
 * Current URI path.
 * https://tools.ietf.org/html/rfc3986#section-3.3
 * @type {string}
 */
URI.prototype.path = null;

/**
 * Current URI query.
 * https://tools.ietf.org/html/rfc3986#section-3.4
 * @type {Query}
 */
URI.prototype.query = null;

/**
 * Current URI fragment.
 * https://tools.ietf.org/html/rfc3986#section-3.5
 * @type {string}
 */
URI.prototype.fragment = null;

/**
 * Converts a URI reference that might be relative to a given base URI
 * into the reference's target URI.
 * https://tools.ietf.org/html/rfc3986#section-5.2
 * @param {URI} baseUri Base URI.
 * @returns {URI} Resolved URI.
 */
URI.prototype.resolveRelative = function (baseUri) {
	if (!baseUri.scheme) {
		throw new Error(ERROR_BASE_SCHEME);
	}

	return transformReference(baseUri, this);
};

/**
 * Clones current URI to a new object.
 * @returns {URI} New clone of current object.
 */
URI.prototype.clone = function () {
	var uri = new URI();

	if (typeof (this.scheme) === 'string') {
		uri.scheme = this.scheme;
	}

	if (this.authority) {
		uri.authority = this.authority.clone();
	}

	if (typeof (this.path) === 'string') {
		uri.path = this.path;
	}

	if (this.query) {
		uri.query = this.query.clone();
	}

	if (typeof (this.fragment) === 'string') {
		uri.fragment = this.fragment;
	}

	return uri;
};

/**
 * Recomposes URI components to URI string,
 * https://tools.ietf.org/html/rfc3986#section-5.3
 * @returns {string} URI string.
 */
URI.prototype.toString = function () {
	var result = '';

	if (this.scheme !== undefined && this.scheme !== null) {
		var scheme = String(this.scheme);
		if (!SCHEME_REGEXP.test(scheme)) {
			throw new Error(ERROR_SCHEME);
		}
		result += scheme + ':';
	}

	if (this.authority) {
		result += '//' + this.authority.toString();
	}

	var path = this.path === undefined || this.path === null ?
		'' : String(this.path);
	result += percentEncodingHelper.encodePath(path);

	if (this.query) {
		result += '?' + this.query.toString();
	}

	if (this.fragment !== undefined && this.fragment !== null) {
		var fragment = String(this.fragment);
		result += '#' + percentEncodingHelper.encodeFragment(fragment);
	}

	return result;
};

/**
 * Transforms reference for relative resolution.
 * Whole algorithm has been taken from
 * https://tools.ietf.org/html/rfc3986#section-5.2.2
 * @param {URI} baseUri Base URI for resolution.
 * @param {URI} referenceUri Reference URI to resolve.
 * @returns {URI} Components of target URI.
 */
/*jshint maxdepth:false */
/*jshint maxcomplexity:false */
function transformReference(baseUri, referenceUri) {
	var targetUri = new URI('');

	if (referenceUri.scheme) {
		targetUri.scheme = referenceUri.scheme;
		targetUri.authority = referenceUri.authority ?
			referenceUri.authority.clone() : referenceUri.authority;
		targetUri.path = removeDotSegments(referenceUri.path);
		targetUri.query = referenceUri.query ?
			referenceUri.query.clone() : referenceUri.query;
	} else {
		if (referenceUri.authority) {
			targetUri.authority = referenceUri.authority ?
				referenceUri.authority.clone() : referenceUri.authority;
			targetUri.path = removeDotSegments(referenceUri.path);
			targetUri.query = referenceUri.query ?
				referenceUri.query.clone() : referenceUri.query;
		} else {
			if (referenceUri.path === '') {
				targetUri.path = baseUri.path;
				if (referenceUri.query) {
					targetUri.query = referenceUri.query.clone();
				} else {
					targetUri.query = baseUri.query ?
						baseUri.query.clone() : baseUri.query;
				}
			} else {
				if (referenceUri.path[0] === '/') {
					targetUri.path =
						removeDotSegments(referenceUri.path);
				} else {
					targetUri.path =
						merge(baseUri, referenceUri);
					targetUri.path =
						removeDotSegments(targetUri.path);
				}
				targetUri.query = referenceUri.query ?
					referenceUri.query.clone() : referenceUri.query;
			}
			targetUri.authority = baseUri.authority ?
				baseUri.authority.clone() : baseUri.authority;
		}
		targetUri.scheme = baseUri.scheme;
	}

	targetUri.fragment = referenceUri.fragment;
	return targetUri;
}

/**
 * Merges a relative-path reference with the path of the base URI.
 * https://tools.ietf.org/html/rfc3986#section-5.2.3
 * @param {URI} baseUri Components of base URI.
 * @param {URI} referenceUri Components of reference URI.
 * @returns {string} Merged path.
 */
function merge(baseUri, referenceUri) {
	if (baseUri.authority && baseUri.path === '') {
		return '/' + referenceUri.path;
	}

	var segmentsString = baseUri.path.indexOf('/') !== -1 ?
		baseUri.path.replace(/\/[^\/]+$/, '/') : '';

	return segmentsString + referenceUri.path;
}

/**
 * Removes dots segments from URI path.
 * https://tools.ietf.org/html/rfc3986#section-5.2.4
 * @param {string} uriPath URI path with possible dot segments.
 * @returns {string} URI path without dot segments.
 */
function removeDotSegments(uriPath) {
	if (!uriPath) {
		return '';
	}

	var inputBuffer = uriPath,
		newBuffer = '',
		nextSegment = '',
		outputBuffer = '';

	while (inputBuffer.length !== 0) {

		// If the input buffer begins with a prefix of "../" or "./",
		// then remove that prefix from the input buffer
		newBuffer = inputBuffer.replace(/^\.?\.\//, '');
		if (newBuffer !== inputBuffer) {
			inputBuffer = newBuffer;
			continue;
		}

		// if the input buffer begins with a prefix of "/./" or "/.",
		// where "." is a complete path segment, then replace that
		// prefix with "/" in the input buffer
		newBuffer = inputBuffer.replace(/^((\/\.\/)|(\/\.$))/, '/');
		if (newBuffer !== inputBuffer) {
			inputBuffer = newBuffer;
			continue;
		}

		// if the input buffer begins with a prefix of "/../" or "/..",
		// where ".." is a complete path segment, then replace that
		// prefix with "/" in the input buffer and remove the last
		// segment and its preceding "/" (if any) from the output
		// buffer
		newBuffer = inputBuffer.replace(/^((\/\.\.\/)|(\/\.\.$))/, '/');
		if (newBuffer !== inputBuffer) {
			outputBuffer = outputBuffer.replace(/\/[^\/]+$/, '');
			inputBuffer = newBuffer;
			continue;
		}

		// if the input buffer consists only of "." or "..", then remove
		// that from the input buffer
		if (inputBuffer === '.' || inputBuffer === '..') {
			break;
		}

		// move the first path segment in the input buffer to the end of
		// the output buffer, including the initial "/" character (if
		// any) and any subsequent characters up to, but not including,
		// the next "/" character or the end of the input buffer
		nextSegment = /^\/?[^\/]*(\/|$)/.exec(inputBuffer)[0];
		nextSegment = nextSegment.replace(/([^\/])(\/$)/, '$1');
		inputBuffer = inputBuffer.substring(nextSegment.length);
		outputBuffer += nextSegment;
	}

	return outputBuffer;
}
},{"./Authority":128,"./Query":129,"./percentEncodingHelper":132}],131:[function(require,module,exports){
/*
 * catberry-uri
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry-uri's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry-uri that are not externally
 * maintained libraries.
 */

'use strict';

module.exports = UserInfo;

var percentEncodingHelper = require('./percentEncodingHelper');

/**
 * Creates new instance of user information component parser.
 * https://tools.ietf.org/html/rfc3986#section-3.2.1
 * @param {string?} userInfoString User information component string.
 * @constructor
 */
function UserInfo(userInfoString) {
	if (typeof (userInfoString) === 'string' && userInfoString.length > 0) {
		var parts = userInfoString.split(':');
		if (typeof (parts[0]) === 'string') {
			this.user = percentEncodingHelper.decode(parts[0]);
		}
		if (typeof (parts[1]) === 'string') {
			this.password = percentEncodingHelper.decode(parts[1]);
		}
	}
}

/**
 * Current user component.
 * @type {string}
 */
UserInfo.prototype.user = null;

/**
 * Current password.
 * @type {string}
 */
UserInfo.prototype.password = null;

/**
 * Clones current user information.
 * @returns {UserInfo} New clone of current object.
 */
UserInfo.prototype.clone = function () {
	var userInfo = new UserInfo();
	if (typeof (this.user) === 'string') {
		userInfo.user = this.user;
	}
	if (typeof (this.password) === 'string') {
		userInfo.password = this.password;
	}
	return userInfo;
};

/**
 * Recombines user information components to userInfo string.
 * @returns {string} User information component string.
 */
UserInfo.prototype.toString = function () {
	var result = '';
	if (this.user !== undefined && this.user !== null) {
		var user = String(this.user);
		result += percentEncodingHelper
			.encodeUserInfoSubComponent(user);
	}
	if (this.password !== undefined && this.password !== null) {
		var password = String(this.password);
		result += ':' + percentEncodingHelper
			.encodeUserInfoSubComponent(password);
	}

	return result;
};
},{"./percentEncodingHelper":132}],132:[function(require,module,exports){
/*
 * catberry-uri
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry-uri's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry-uri that are not externally
 * maintained libraries.
 */

'use strict';

// https://tools.ietf.org/html/rfc3986#section-2.1

module.exports = {
	// \uD800-\uDBFF \uDC00-\uDFFF
	// surrogates pairs like emoji we should ignore
	/**
	 * Encodes authority user information sub-component according to RFC 3986.
	 * @param {string} string Component to encode.
	 * @returns {string} Encoded component.
	 */
	encodeUserInfoSubComponent: function (string) {
		return string.replace(
			// https://tools.ietf.org/html/rfc3986#section-3.2.1
			/[^\w\.~\-!\$&'\(\)\*\+,;=\uD800-\uDBFF\uDC00-\uDFFF]/g,
			encodeURIComponent
		);
	},
	/**
	 * Encodes authority host component according to RFC 3986.
	 * @param {string} string Component to encode.
	 * @returns {string} Encoded component.
	 */
	encodeHost: function (string) {
		return string.replace(
			// https://tools.ietf.org/html/rfc3986#section-3.2.2
			/[^\w\.~\-!\$&'\(\)\*\+,;=:\[\]\uD800-\uDBFF\uDC00-\uDFFF]/g,
			encodeURIComponent
		);
	},
	/**
	 * Encodes URI path component according to RFC 3986.
	 * @param {string} string Component to encode.
	 * @returns {string} Encoded component.
	 */
	encodePath: function (string) {
		return string.split(/%2f/i)
			.map(function (part) {
				return part.replace(
					// https://tools.ietf.org/html/rfc3986#section-3.3
					/[^\w\.~\-!\$&'\(\)\*\+,;=:@\/\uD800-\uDBFF\uDC00-\uDFFF]/g,
					encodeURIComponent
				);
			})
			.reduce(function (prev, current) {
				if (!prev) {
					return current;
				}
				if (!current) {
					return prev;
				}
				return prev + '%2F' + current;
			}, '');
	},
	/**
	 * Encodes query sub-component according to RFC 3986.
	 * @param {string} string Component to encode.
	 * @returns {string} Encoded component.
	 */
	encodeQuerySubComponent: function (string) {
		return string.replace(
			// https://tools.ietf.org/html/rfc3986#section-3.4
			/[^\w\.~\-!\$'\(\)\*\+,;:@\/\?\uD800-\uDBFF\uDC00-\uDFFF]/g,
			encodeURIComponent
		);
	},

	/**
	 * Encodes URI fragment component according to RFC 3986.
	 * @param {string} string Component to encode.
	 * @returns {string} Encoded component.
	 */
	encodeFragment: function (string) {
		return string.replace(
			// https://tools.ietf.org/html/rfc3986#section-3.5
			/[^\w\.~\-!\$&'\(\)\*\+,;=:@\/\?\uD800-\uDBFF\uDC00-\uDFFF]/g,
			encodeURIComponent
		);
	},

	/**
	 * Decodes percent encoded component.
	 * @param {string} string Component to decode.
	 * @returns {string} Decoded component.
	 */
	decode: function (string) {
		return decodeURIComponent(string);
	},

	/**
	 * Decodes percent encoded path component.
	 * @param {string} string Component to decode.
	 * @returns {string} Decoded path component.
	 */
	decodePath: function (string) {
		return string.split(/%2f/i)
			.map(decodeURIComponent)
			.reduce(function (prev, current) {
				if (!prev) {
					return current;
				}
				if (!current) {
					return prev;
				}
				return prev + '%2F' + current;
			}, '');
	}
};
},{}],133:[function(require,module,exports){
// Create a range object for efficently rendering strings to elements.
var range;

function empty(o) {
    for (var k in o) {
        if (o.hasOwnProperty(k)) {
            return false;
        }
    }

    return true;
}
function toElement(str) {
    if (!range) {
        range = document.createRange();
        range.selectNode(document.body);
    }

    var fragment;
    if (range.createContextualFragment) {
        fragment = range.createContextualFragment(str);
    } else {
        fragment = document.createElement('body');
        fragment.innerHTML = str;
    }
    return fragment.childNodes[0];
}

var specialElHandlers = {
    /**
     * Needed for IE. Apparently IE doesn't think
     * that "selected" is an attribute when reading
     * over the attributes using selectEl.attributes
     */
    OPTION: function(fromEl, toEl) {
        if ((fromEl.selected = toEl.selected)) {
            fromEl.setAttribute('selected', '');
        } else {
            fromEl.removeAttribute('selected', '');
        }
    },
    /**
     * The "value" attribute is special for the <input> element
     * since it sets the initial value. Changing the "value"
     * attribute without changing the "value" property will have
     * no effect since it is only used to the set the initial value.
     * Similar for the "checked" attribute.
     */
    INPUT: function(fromEl, toEl) {
        fromEl.checked = toEl.checked;

        if (fromEl.value != toEl.value) {
            fromEl.value = toEl.value;
        }

        if (!toEl.hasAttribute('checked')) {
            fromEl.removeAttribute('checked');
        }

        if (!toEl.hasAttribute('value')) {
            fromEl.removeAttribute('value');
        }
    },

    TEXTAREA: function(fromEl, toEl) {
        var newValue = toEl.value;
        if (fromEl.value != newValue) {
            fromEl.value = newValue;
        }

        if (fromEl.firstChild) {
            fromEl.firstChild.nodeValue = newValue;
        }
    }
};

function noop() {}

/**
 * Loop over all of the attributes on the target node and make sure the
 * original DOM node has the same attributes. If an attribute
 * found on the original node is not on the new node then remove it from
 * the original node
 * @param  {HTMLElement} fromNode
 * @param  {HTMLElement} toNode
 */
function morphAttrs(fromNode, toNode) {
    var attrs = toNode.attributes;
    var i;
    var attr;
    var attrName;
    var attrValue;
    var foundAttrs = {};

    for (i=attrs.length-1; i>=0; i--) {
        attr = attrs[i];
        if (attr.specified !== false) {
            attrName = attr.name;
            attrValue = attr.value;
            foundAttrs[attrName] = true;

            if (fromNode.getAttribute(attrName) !== attrValue) {
                fromNode.setAttribute(attrName, attrValue);
            }
        }
    }

    // Delete any extra attributes found on the original DOM element that weren't
    // found on the target element.
    attrs = fromNode.attributes;

    for (i=attrs.length-1; i>=0; i--) {
        attr = attrs[i];
        if (attr.specified !== false) {
            attrName = attr.name;
            if (!foundAttrs.hasOwnProperty(attrName)) {
                fromNode.removeAttribute(attrName);
            }
        }
    }
}

/**
 * Copies the children of one DOM element to another DOM element
 */
function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while(curChild) {
        var nextChild = curChild.nextSibling;
        toEl.appendChild(curChild);
        curChild = nextChild;
    }
    return toEl;
}

function defaultGetNodeKey(node) {
    return node.id;
}

function morphdom(fromNode, toNode, options) {
    if (!options) {
        options = {};
    }

    if (typeof toNode === 'string') {
        toNode = toElement(toNode);
    }

    var savedEls = {}; // Used to save off DOM elements with IDs
    var unmatchedEls = {};
    var getNodeKey = options.getNodeKey || defaultGetNodeKey;
    var onNodeDiscarded = options.onNodeDiscarded || noop;
    var onBeforeMorphEl = options.onBeforeMorphEl || noop;
    var onBeforeMorphElChildren = options.onBeforeMorphElChildren || noop;
    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
    var childrenOnly = options.childrenOnly === true;
    var movedEls = [];

    function removeNodeHelper(node, nestedInSavedEl) {
        var id = getNodeKey(node);
        // If the node has an ID then save it off since we will want
        // to reuse it in case the target DOM tree has a DOM element
        // with the same ID
        if (id) {
            savedEls[id] = node;
        } else if (!nestedInSavedEl) {
            // If we are not nested in a saved element then we know that this node has been
            // completely discarded and will not exist in the final DOM.
            onNodeDiscarded(node);
        }

        if (node.nodeType === 1) {
            var curChild = node.firstChild;
            while(curChild) {
                removeNodeHelper(curChild, nestedInSavedEl || id);
                curChild = curChild.nextSibling;
            }
        }
    }

    function walkDiscardedChildNodes(node) {
        if (node.nodeType === 1) {
            var curChild = node.firstChild;
            while(curChild) {


                if (!getNodeKey(curChild)) {
                    // We only want to handle nodes that don't have an ID to avoid double
                    // walking the same saved element.

                    onNodeDiscarded(curChild);

                    // Walk recursively
                    walkDiscardedChildNodes(curChild);
                }

                curChild = curChild.nextSibling;
            }
        }
    }

    function removeNode(node, parentNode, alreadyVisited) {
        if (onBeforeNodeDiscarded(node) === false) {
            return;
        }

        parentNode.removeChild(node);
        if (alreadyVisited) {
            if (!getNodeKey(node)) {
                onNodeDiscarded(node);
                walkDiscardedChildNodes(node);
            }
        } else {
            removeNodeHelper(node);
        }
    }

    function morphEl(fromEl, toEl, alreadyVisited, childrenOnly) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
            // If an element with an ID is being morphed then it is will be in the final
            // DOM so clear it out of the saved elements collection
            delete savedEls[toElKey];
        }

        if (!childrenOnly) {
            if (onBeforeMorphEl(fromEl, toEl) === false) {
                return;
            }

            morphAttrs(fromEl, toEl);

            if (onBeforeMorphElChildren(fromEl, toEl) === false) {
                return;
            }
        }

        if (fromEl.tagName != 'TEXTAREA') {
            var curToNodeChild = toEl.firstChild;
            var curFromNodeChild = fromEl.firstChild;
            var curToNodeId;

            var fromNextSibling;
            var toNextSibling;
            var savedEl;
            var unmatchedEl;

            outer: while(curToNodeChild) {
                toNextSibling = curToNodeChild.nextSibling;
                curToNodeId = getNodeKey(curToNodeChild);

                while(curFromNodeChild) {
                    var curFromNodeId = getNodeKey(curFromNodeChild);
                    fromNextSibling = curFromNodeChild.nextSibling;

                    if (!alreadyVisited) {
                        if (curFromNodeId && (unmatchedEl = unmatchedEls[curFromNodeId])) {
                            unmatchedEl.parentNode.replaceChild(curFromNodeChild, unmatchedEl);
                            morphEl(curFromNodeChild, unmatchedEl, alreadyVisited);
                            curFromNodeChild = fromNextSibling;
                            continue;
                        }
                    }

                    var curFromNodeType = curFromNodeChild.nodeType;

                    if (curFromNodeType === curToNodeChild.nodeType) {
                        var isCompatible = false;

                        if (curFromNodeType === 1) { // Both nodes being compared are Element nodes
                            if (curFromNodeChild.tagName === curToNodeChild.tagName) {
                                // We have compatible DOM elements
                                if (curFromNodeId || curToNodeId) {
                                    // If either DOM element has an ID then we handle
                                    // those differently since we want to match up
                                    // by ID
                                    if (curToNodeId === curFromNodeId) {
                                        isCompatible = true;
                                    }
                                } else {
                                    isCompatible = true;
                                }
                            }

                            if (isCompatible) {
                                // We found compatible DOM elements so transform the current "from" node
                                // to match the current target DOM node.
                                morphEl(curFromNodeChild, curToNodeChild, alreadyVisited);
                            }
                        } else if (curFromNodeType === 3) { // Both nodes being compared are Text nodes
                            isCompatible = true;
                            // Simply update nodeValue on the original node to change the text value
                            curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                        }

                        if (isCompatible) {
                            curToNodeChild = toNextSibling;
                            curFromNodeChild = fromNextSibling;
                            continue outer;
                        }
                    }

                    // No compatible match so remove the old node from the DOM and continue trying
                    // to find a match in the original DOM
                    removeNode(curFromNodeChild, fromEl, alreadyVisited);
                    curFromNodeChild = fromNextSibling;
                }

                if (curToNodeId) {
                    if ((savedEl = savedEls[curToNodeId])) {
                        morphEl(savedEl, curToNodeChild, true);
                        curToNodeChild = savedEl; // We want to append the saved element instead
                    } else {
                        // The current DOM element in the target tree has an ID
                        // but we did not find a match in any of the corresponding
                        // siblings. We just put the target element in the old DOM tree
                        // but if we later find an element in the old DOM tree that has
                        // a matching ID then we will replace the target element
                        // with the corresponding old element and morph the old element
                        unmatchedEls[curToNodeId] = curToNodeChild;
                    }
                }

                // If we got this far then we did not find a candidate match for our "to node"
                // and we exhausted all of the children "from" nodes. Therefore, we will just
                // append the current "to node" to the end
                fromEl.appendChild(curToNodeChild);

                if (curToNodeChild.nodeType === 1 && (curToNodeId || curToNodeChild.firstChild)) {
                    // The element that was just added to the original DOM may have
                    // some nested elements with a key/ID that needs to be matched up
                    // with other elements. We'll add the element to a list so that we
                    // can later process the nested elements if there are any unmatched
                    // keyed elements that were discarded
                    movedEls.push(curToNodeChild);
                }

                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
            }

            // We have processed all of the "to nodes". If curFromNodeChild is non-null then
            // we still have some from nodes left over that need to be removed
            while(curFromNodeChild) {
                fromNextSibling = curFromNodeChild.nextSibling;
                removeNode(curFromNodeChild, fromEl, alreadyVisited);
                curFromNodeChild = fromNextSibling;
            }
        }

        var specialElHandler = specialElHandlers[fromEl.tagName];
        if (specialElHandler) {
            specialElHandler(fromEl, toEl);
        }
    } // END: morphEl(...)

    var morphedNode = fromNode;
    var morphedNodeType = morphedNode.nodeType;
    var toNodeType = toNode.nodeType;

    if (!childrenOnly) {
        // Handle the case where we are given two DOM nodes that are not
        // compatible (e.g. <div> --> <span> or <div> --> TEXT)
        if (morphedNodeType === 1) {
            if (toNodeType === 1) {
                if (fromNode.tagName !== toNode.tagName) {
                    onNodeDiscarded(fromNode);
                    morphedNode = moveChildren(fromNode, document.createElement(toNode.tagName));
                }
            } else {
                // Going from an element node to a text node
                morphedNode = toNode;
            }
        } else if (morphedNodeType === 3) { // Text node
            if (toNodeType === 3) {
                morphedNode.nodeValue = toNode.nodeValue;
                return morphedNode;
            } else {
                // Text node to something else
                morphedNode = toNode;
            }
        }
    }

    if (morphedNode === toNode) {
        // The "to node" was not compatible with the "from node"
        // so we had to toss out the "from node" and use the "to node"
        onNodeDiscarded(fromNode);
    } else {
        morphEl(morphedNode, toNode, false, childrenOnly);

        /**
         * What we will do here is walk the tree for the DOM element
         * that was moved from the target DOM tree to the original
         * DOM tree and we will look for keyed elements that could
         * be matched to keyed elements that were earlier discarded.
         * If we find a match then we will move the saved element
         * into the final DOM tree
         */
        var handleMovedEl = function(el) {
            var curChild = el.firstChild;
            while(curChild) {
                var nextSibling = curChild.nextSibling;

                var key = getNodeKey(curChild);
                if (key) {
                    var savedEl = savedEls[key];
                    if (savedEl && (curChild.tagName === savedEl.tagName)) {
                        curChild.parentNode.replaceChild(savedEl, curChild);
                        morphEl(savedEl, curChild, true /* already visited the saved el tree */);
                        curChild = nextSibling;
                        if (empty(savedEls)) {
                            return false;
                        }
                        continue;
                    }
                }

                if (curChild.nodeType === 1) {
                    handleMovedEl(curChild);
                }

                curChild = nextSibling;
            }
        };

        // The loop below is used to possibly match up any discarded
        // elements in the original DOM tree with elemenets from the
        // target tree that were moved over without visiting their
        // children
        if (!empty(savedEls)) {
            handleMovedElsLoop:
            while (movedEls.length) {
                var movedElsTemp = movedEls;
                movedEls = [];
                for (var i=0; i<movedElsTemp.length; i++) {
                    if (handleMovedEl(movedElsTemp[i]) === false) {
                        // There are no more unmatched elements so completely end
                        // the loop
                        break handleMovedElsLoop;
                    }
                }
            }
        }

        // Fire the "onNodeDiscarded" event for any saved elements
        // that never found a new home in the morphed DOM
        for (var savedElId in savedEls) {
            if (savedEls.hasOwnProperty(savedElId)) {
                var savedEl = savedEls[savedElId];
                onNodeDiscarded(savedEl);
                walkDiscardedChildNodes(savedEl);
            }
        }
    }

    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        // If we had to swap out the from node with a new node because the old
        // node was not compatible with the target node then we need to
        // replace the old DOM node in the original DOM tree. This is only
        // possible if the original DOM node was part of a DOM tree which
        // we know is the case if it has a parent node.
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
    }

    return morphedNode;
}

module.exports = morphdom;

},{}],134:[function(require,module,exports){
/*jshint node:true */

"use strict";

var minimalDesc = ['h', 'min', 's', 'ms', 'μs', 'ns'];
var verboseDesc = ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];
var convert = [60*60, 60, 1, 1e6, 1e3, 1];

module.exports = function (source, opts) {
	var verbose, precise, i, spot, sourceAtStep, valAtStep, decimals, strAtStep, results;

	verbose = false;
	precise = false;
	if (opts) {
		verbose = opts.verbose || false;
		precise = opts.precise || false;
	}

	if (!Array.isArray(source) || source.length !== 2) {
		return '';
	}
	if (typeof source[0] !== 'number' || typeof source[1] !== 'number') {
		return '';
	}

	results = '';

	// foreach unit
	for (i = 0; i < 6; i++) {
		spot = i < 3 ? 0 : 1; // grabbing first or second spot in source array
		sourceAtStep = source[spot];
		if (i !== 3 && i !== 0) {
			sourceAtStep = sourceAtStep % convert[i-1]; // trim off previous portions
		}
		if (i === 2) {
			sourceAtStep += source[1]/1e9; // get partial seconds from other portion of the array
		}
		valAtStep = sourceAtStep / convert[i]; // val at this unit
		if (valAtStep >= 1) {
			if (verbose) {
				valAtStep = Math.floor(valAtStep); // deal in whole units, subsequent laps will get the decimal portion
			}
			if (!precise) {
				// don't fling too many decimals
				decimals = valAtStep >= 10 ? 0 : 2;
				strAtStep = valAtStep.toFixed(decimals);
			} else {
				strAtStep = valAtStep.toString();
			}
			if (strAtStep.indexOf('.') > -1 && strAtStep[strAtStep.length-1] === '0') {
				strAtStep = strAtStep.replace(/\.?0+$/,''); // remove trailing zeros
			}
			if (results) {
				results += ' '; // append space if we have a previous value
			}
			results += strAtStep; // append the value
			// append units
			if (verbose) {
				results += ' '+verboseDesc[i];
				if (strAtStep !== '1') {
					results += 's';
				}
			} else {
				results += ' '+minimalDesc[i];
			}
			if (!verbose) {
				break; // verbose gets as many groups as necessary, the rest get only one
			}
		}
	}

	return results;
};

},{}],135:[function(require,module,exports){
'use strict';

module.exports = require('./lib')

},{"./lib":140}],136:[function(require,module,exports){
'use strict';

var asap = require('asap/raw');

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}
function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

module.exports = Promise;

function Promise(fn) {
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('not a function');
  }
  this._45 = 0;
  this._81 = 0;
  this._65 = null;
  this._54 = null;
  if (fn === noop) return;
  doResolve(fn, this);
}
Promise._10 = null;
Promise._97 = null;
Promise._61 = noop;

Promise.prototype.then = function(onFulfilled, onRejected) {
  if (this.constructor !== Promise) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise(noop);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
};
function handle(self, deferred) {
  while (self._81 === 3) {
    self = self._65;
  }
  if (Promise._10) {
    Promise._10(self);
  }
  if (self._81 === 0) {
    if (self._45 === 0) {
      self._45 = 1;
      self._54 = deferred;
      return;
    }
    if (self._45 === 1) {
      self._45 = 2;
      self._54 = [self._54, deferred];
      return;
    }
    self._54.push(deferred);
    return;
  }
  handleResolved(self, deferred);
}

function handleResolved(self, deferred) {
  asap(function() {
    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._81 === 1) {
        resolve(deferred.promise, self._65);
      } else {
        reject(deferred.promise, self._65);
      }
      return;
    }
    var ret = tryCallOne(cb, self._65);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}
function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(
      self,
      new TypeError('A promise cannot be resolved with itself.')
    );
  }
  if (
    newValue &&
    (typeof newValue === 'object' || typeof newValue === 'function')
  ) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (
      then === self.then &&
      newValue instanceof Promise
    ) {
      self._81 = 3;
      self._65 = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._81 = 1;
  self._65 = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._81 = 2;
  self._65 = newValue;
  if (Promise._97) {
    Promise._97(self, newValue);
  }
  finale(self);
}
function finale(self) {
  if (self._45 === 1) {
    handle(self, self._54);
    self._54 = null;
  }
  if (self._45 === 2) {
    for (var i = 0; i < self._54.length; i++) {
      handle(self, self._54[i]);
    }
    self._54 = null;
  }
}

function Handler(onFulfilled, onRejected, promise){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) return;
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) return;
    done = true;
    reject(promise, reason);
  })
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

},{"asap/raw":144}],137:[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this;
  self.then(null, function (err) {
    setTimeout(function () {
      throw err;
    }, 0);
  });
};

},{"./core.js":136}],138:[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js');

module.exports = Promise;

/* Static Functions */

var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');

function valuePromise(value) {
  var p = new Promise(Promise._61);
  p._81 = 1;
  p._65 = value;
  return p;
}
Promise.resolve = function (value) {
  if (value instanceof Promise) return value;

  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex);
      });
    }
  }
  return valuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          while (val._81 === 3) {
            val = val._65;
          }
          if (val._81 === 1) return res(i, val._65);
          if (val._81 === 2) reject(val._65);
          val.then(function (val) {
            res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

},{"./core.js":136}],139:[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype['finally'] = function (f) {
  return this.then(function (value) {
    return Promise.resolve(f()).then(function () {
      return value;
    });
  }, function (err) {
    return Promise.resolve(f()).then(function () {
      throw err;
    });
  });
};

},{"./core.js":136}],140:[function(require,module,exports){
'use strict';

module.exports = require('./core.js');
require('./done.js');
require('./finally.js');
require('./es6-extensions.js');
require('./node-extensions.js');
require('./synchronous.js');

},{"./core.js":136,"./done.js":137,"./es6-extensions.js":138,"./finally.js":139,"./node-extensions.js":141,"./synchronous.js":142}],141:[function(require,module,exports){
'use strict';

// This file contains then/promise specific extensions that are only useful
// for node.js interop

var Promise = require('./core.js');
var asap = require('asap');

module.exports = Promise;

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  if (
    typeof argumentCount === 'number' && argumentCount !== Infinity
  ) {
    return denodeifyWithCount(fn, argumentCount);
  } else {
    return denodeifyWithoutCount(fn);
  }
}

var callbackFn = (
  'function (err, res) {' +
  'if (err) { rj(err); } else { rs(res); }' +
  '}'
);
function denodeifyWithCount(fn, argumentCount) {
  var args = [];
  for (var i = 0; i < argumentCount; i++) {
    args.push('a' + i);
  }
  var body = [
    'return function (' + args.join(',') + ') {',
    'var self = this;',
    'return new Promise(function (rs, rj) {',
    'var res = fn.call(',
    ['self'].concat(args).concat([callbackFn]).join(','),
    ');',
    'if (res &&',
    '(typeof res === "object" || typeof res === "function") &&',
    'typeof res.then === "function"',
    ') {rs(res);}',
    '});',
    '};'
  ].join('');
  return Function(['Promise', 'fn'], body)(Promise, fn);
}
function denodeifyWithoutCount(fn) {
  var fnLength = Math.max(fn.length - 1, 3);
  var args = [];
  for (var i = 0; i < fnLength; i++) {
    args.push('a' + i);
  }
  var body = [
    'return function (' + args.join(',') + ') {',
    'var self = this;',
    'var args;',
    'var argLength = arguments.length;',
    'if (arguments.length > ' + fnLength + ') {',
    'args = new Array(arguments.length + 1);',
    'for (var i = 0; i < arguments.length; i++) {',
    'args[i] = arguments[i];',
    '}',
    '}',
    'return new Promise(function (rs, rj) {',
    'var cb = ' + callbackFn + ';',
    'var res;',
    'switch (argLength) {',
    args.concat(['extra']).map(function (_, index) {
      return (
        'case ' + (index) + ':' +
        'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +
        'break;'
      );
    }).join(''),
    'default:',
    'args[argLength] = cb;',
    'res = fn.apply(self, args);',
    '}',
    
    'if (res &&',
    '(typeof res === "object" || typeof res === "function") &&',
    'typeof res.then === "function"',
    ') {rs(res);}',
    '});',
    '};'
  ].join('');

  return Function(
    ['Promise', 'fn'],
    body
  )(Promise, fn);
}

Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    var callback =
      typeof args[args.length - 1] === 'function' ? args.pop() : null;
    var ctx = this;
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx);
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) {
          reject(ex);
        });
      } else {
        asap(function () {
          callback.call(ctx, ex);
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this;

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value);
    });
  }, function (err) {
    asap(function () {
      callback.call(ctx, err);
    });
  });
}

},{"./core.js":136,"asap":143}],142:[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.enableSynchronous = function () {
  Promise.prototype.isPending = function() {
    return this.getState() == 0;
  };

  Promise.prototype.isFulfilled = function() {
    return this.getState() == 1;
  };

  Promise.prototype.isRejected = function() {
    return this.getState() == 2;
  };

  Promise.prototype.getValue = function () {
    if (this._81 === 3) {
      return this._65.getValue();
    }

    if (!this.isFulfilled()) {
      throw new Error('Cannot get a value of an unfulfilled promise.');
    }

    return this._65;
  };

  Promise.prototype.getReason = function () {
    if (this._81 === 3) {
      return this._65.getReason();
    }

    if (!this.isRejected()) {
      throw new Error('Cannot get a rejection reason of a non-rejected promise.');
    }

    return this._65;
  };

  Promise.prototype.getState = function () {
    if (this._81 === 3) {
      return this._65.getState();
    }
    if (this._81 === -1 || this._81 === -2) {
      return 0;
    }

    return this._81;
  };
};

Promise.disableSynchronous = function() {
  Promise.prototype.isPending = undefined;
  Promise.prototype.isFulfilled = undefined;
  Promise.prototype.isRejected = undefined;
  Promise.prototype.getValue = undefined;
  Promise.prototype.getReason = undefined;
  Promise.prototype.getState = undefined;
};

},{"./core.js":136}],143:[function(require,module,exports){
"use strict";

// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":144}],144:[function(require,module,exports){
(function (global){
"use strict";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.js’s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],145:[function(require,module,exports){
/**
 * digits <https://github.com/jonschlinkert/digits>
 *
 * Copyright (c) 2013-2015 Jon Schlinkert
 * Licensed under the MIT License (MIT)
 */

'use strict';

var pad = require('pad-left');
var longest = require('longest');

/**
 * Expose `digits`
 */

module.exports = digits;

/**
 * Left pad the given `value` with the specified `number` of zeros
 * or alternate `character`.
 *
 * ```js
 * digits('abc', 10);
 * //=> '0000000000abc'
 *
 * digits('abc', 10, '~');
 * //=> '~~~~~~~~~~abc'
 * ```
 *
 * @param {String} `value`
 * @param {String} `number`
 * @return {String} `character`
 * @api public
 */

function digits(val, num, ch) {
  return pad(val, num - val.length, ch);
}

/**
 * Pad left pad each value in the given `array` to align with the
 * longest item/number in the array. Zeros are used by default, but
 * a custom `character` can be passed as the second argument.
 *
 * **Example**
 *
 * ```js
 * digits.each([1, 100, 1000])
 * //=> ['0001', '0100', '1000']
 *
 * digits.each([a, bb, ccc], ' ')
 * //=> ['  a', ' bb', 'ccc']
 * ```
 *
 * @param {Number} `arr` The array of values to pad.
 * @param {Number} `len` Amount to pad the number.
 * @return {String} Padded number
 * @api public
 */

digits.each = function(arr, ch) {
  var len = longest(arr).length;

  return arr.map(function(ele) {
    return digits(ele, len, ch);
  });
};

/**
 * Strip leading digits from a string
 *
 * ```js
 * digits.stripleft('010foo.md');
 * // => "foo.md"
 * ```
 *
 * @param  {String} `str`
 * @return {String}
 */

digits.stripleft = function(str) {
  return str.replace(/^\d+\-?/g, '');
};

/**
 * Strip trailing digits from a string
 *
 * ```js
 * digits.stripright('bar010.md');
 * // => "bar.md"
 * ```
 * @param  {String} `str`
 * @return {String}
 */

digits.stripright = function(str) {
  return str.replace(/\-?\d+$/g, '');
};

/**
 * Count digits on the left side of a string
 *
 * ```js
 * digits.countleft('001-foo.md');
 * //=> 3
 * ```
 *
 * @param  {String} `str`
 * @return {String}
 */

digits.countleft = function(str) {
  return String(str.match(/^\d+/g)).length;
};

/**
 * Count digits on the right side of a string
 *
 * ```js
 * digits.countleft('foo-001.md');
 * //=> 3
 * ```
 * @param  {String} `str`
 * @return {String}
 */

digits.countright = function(str) {
  return String(str.match(/\d+$/g)).length;
};

},{"longest":146,"pad-left":147}],146:[function(require,module,exports){
/**
 * longest item in an array
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */

'use strict';

module.exports = function(arr) {
  var c = 0,
    len = 0,
    l = 0,
    idx = arr.length;
  if (idx) {
    while (idx--) {
      len = arr[idx].length;
      if (len > c) {
        l = idx;
        c = len;
      }
    }
  }
  return arr[l];
};
},{}],147:[function(require,module,exports){
/*!
 * pad-left <https://github.com/jonschlinkert/pad-left>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT license.
 */

'use strict';

var repeat = require('repeat-string');

module.exports = function padLeft(val, num, str) {
  return repeat(str || '0', num) + val;
};

},{"repeat-string":148}],148:[function(require,module,exports){
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */

'use strict';

module.exports = function repeat(str, count) {
  if (typeof str !== 'string') {
    throw new TypeError('repeat-string expects a string.');
  }

  if (count < 1) {
    return '';
  }

  var result = '';
  while (count > 0) {
    if (count & 1) {
      result += str;
    }
    count >>= 1;
    str += str;
  }
  return result;
};

},{}],149:[function(require,module,exports){
'use strict';

// jscs:disable maximumLineLength
// This file contains definitions of rules how location URLs are translated
// to "render" methods of catberry's modules.
//
// Format:
// /some/:parameter[module1,module2,module3]
//
// More details here:
// https://github.com/catberry/catberry/blob/master/docs/index.md#url-route-definition

module.exports = [
    '/:page[Pages]',
    //id мастера
    {
        expression: /\/([\/\d]+)$/i,
        map: function (urlPath) {
            var matches = urlPath.path.match(/\/([\/\d]+)$/i);
            return {
                'master/MasterItem': {
                    item: matches[1]
                },
                Pages: {
                    page: "master-page"
                }
            }
        }
    },
    //статья мастера
    {
        expression: '/\/([\/\d]+)\/article\/([\/\d]+)$/i',
        map: function (urlPath) {
            return {
                Pages: {
                    page: "master-article"
                }
            }
        }
    },
    // путь: рубрика/подрубрика
    // путь: рубрика/подрубрика/тег
    // путь: рубрика/подрубрика/секция
    // путь: рубрика/подрубрика/тег/секция
    {
        expression: /^\/([^\/\d]+)\/([^\/\d]+)\/?((?!video|sale|sovety|company)[^\/\d]+)?\/?(video|sale|sovety|company)?$/i,
        map: function (urlPath) {
            var matches = urlPath.path.match(/^\/([^\/\d]+)\/([^\/\d]+)\/?((?!video|sale|sovety|company)[^\/\d]+)?\/?(video|sale|sovety|company)?$/i);
            return {
                'rubrika/Rubrika': {
                    rubrika: matches[1],
                    podrubrika: matches[2]
                },
                Tag: {
                    tag: matches[3],
                    section: matches[4]
                },
                Pages: {
                    page: "master-rubrika"
                }
            }
        }
    },
    // путь: /__/page/:id
    {
        expression: /^\/([^\/\d]+)\/page\/(\d+)/i,
        map: function (urlPath) {
            var matches = urlPath.path.match(/^\/([^\/\d]+)\/page\/(\d+)/i);
            return {
                Pages: {
                    page: matches[1]
                },
                Paginator: {
                    currentPage: matches[2]
                }
            };
        }
    },
    // путь: /sale
    // путь: /sovety
    // путь: /video
    // путь: /__/page/:id
    // путь: /__/category/:id
    // путь: /__/category/:id/page/:id
    {
        expression: /^\/(sale|sovety|video)(\/catalog\/(\d+))?(\/page\/(\d+))?$/i,
        map: function (urlPath) {
            var matches = urlPath.path.match(/^\/(sale|sovety|video)(\/catalog\/(\d+))?(\/page\/(\d+))?$/i);
            var nameCapitalizeFirstLetter = matches[1].charAt(0).toUpperCase() + matches[1].slice(1);
            var state = {};

            state.Pages = {
                page: matches[1]
            };
            state['rubrika/Rubrikator' + nameCapitalizeFirstLetter] = {
                catalog: matches[3]
            };
            state.Paginator = {
                currentPage: matches[5]
            };
            return state;
        }
    },
    // путь: /news/item/:id
    // путь: /vacancy/item/:id
    // путь: /konkurs/item/:id
    {
        expression: /^\/(news|vacancy|konkurs)\/item\/(\d+)$/i,
        map: function (urlPath) {
            var matches = urlPath.path.match(/^\/(news|vacancy|konkurs)\/item\/(\d+)$/i);
            var state = {};

            var string = matches[1];

            state.Pages = {
                page: string + "-item"
            };
            state['other/' + string.charAt(0).toUpperCase() + string.slice(1) + "Item"] = {
                item: matches[2]
            };
            return state;
        }
    }
];

},{}],150:[function(require,module,exports){
'use strict';

var digits = require('digits');

var Dates = require('./utils/dates');
var Utils = require('./utils/utils');

module.exports = function (Handlebars) {

    return {
        /**
         * Repeat  helper
         * @param  {Number} n       number of iterations
         * @param  {[type]} options [description]
         * @return {[type]}         [description]
         */
        repeat: function (n, options) {
            options = options || {};
            var _data = {},
                content = '',
                count = n - 1;

            if (options._data) {
                _data = Handlebars.createFrame(options._data);
            }

            for (var i = 0; i <= count; i++) {
                _data = {
                    index: digits.pad((i + 1), {auto: n})
                };
                content += options.fn(this, {data: _data});
            }
            return new Handlebars.SafeString(content);
        },

        /**
         * If helper with params
         * @param  {[type]} a        [description]
         * @param  {[type]} b        [description]
         * @param  {String} options  operation
         * @return {[type]}          [description]
         */
        is: function (leftOperand, operation, rightOperand, options) {
            var a = leftOperand || false,
                b = rightOperand || false;

            if (operation && typeof operation === 'string') {
                switch (operation) {

                    // Not strictly equal
                    case '==':
                        if (a == b) {
                            return options.fn(this);
                        } else {
                            return options.inverse(this);
                        }
                        break;

                    // Strictly equal
                    case '===':
                        if (a === b) {
                            return options.fn(this);
                        } else {
                            return options.inverse(this);
                        }
                        break;

                    // a > b checking
                    case '>':
                        if (a > b) {
                            return options.fn(this);
                        } else {
                            return options.inverse(this);
                        }
                        break;

                    // a >= b checking
                    case '>=':
                        if (a >= b) {
                            return options.fn(this);
                        } else {
                            return options.inverse(this);
                        }
                        break;

                    // a < b checking
                    case '<':
                        if (a < b) {
                            return options.fn(this);
                        } else {
                            return options.inverse(this);
                        }
                        break;

                    // a <= b checking
                    case '<=':
                        if (a <= b) {
                            return options.fn(this);
                        } else {
                            return options.inverse(this);
                        }
                        break;

                    // Action, if operation is unknown
                    default:
                        throw new Error(
                            'Operation is unknown!\n"is" helper supports only:\n' +
                            '"==",\n' +
                            '"===",\n' +
                            '">",\n' +
                            '">=",\n' +
                            '"<",\n' +
                            '"<=",\n'
                        );
                }
            } else {
                throw new Error('Operation have to be recived and have to be a string');
            }

        },

        /**
         * Str to lower case
         * @param  {String} str [description]
         * @return {[type]}     [description]
         */
        toLowerCase: function (str) {
            if (typeof str != 'string') {
                str.toString();
            }

            return str.toLowerCase();
        },

        /**
         * Str to upper case
         * @param  {String} str [description]
         * @return {[type]}     [description]
         */
        toUpperCase: function (str) {
            if (typeof str != 'string') {
                str.toString();
            }

            return str.toUpperCase();
        },

        /**
         * Capitalize first symbol of str
         * @param  {String} str [description]
         * @return {[type]}     [description]
         */
        capitalizeFirst: function (str) {
            if (typeof str != 'string') {
                str.toString();
            }

            return str.charAt(0).toUpperCase() + str.slice(1);
        },

        /**
         * Remove whitespaces from recived data to helper
         * @param  {[type]} options [description]
         * @return {[type]}         [description]
         */
        strip: function (options) {
            options = options || {};

            var _data = {},
                content = '';

            if (options._data) {
                _data = Handlebars.createFrame(options._data);
            }

            content = options.fn(this, {data: _data}).replace(/>(\s+)</g, '><');

            return new Handlebars.SafeString(content);
        },

        stripTags: function (str) {
            str = str.replace(/<!--[^]*-->/g, '');
            return str.replace(/<\/?[^>]+>/gi, '');
        },

        stripStyle: function (str) {
            return str.replace(/ style="[^"]*"/g, '')
        },

        /**
         * {{formatData}}
         * Port of formatDate-js library (http://bit.ly/18eo2xw)
         * @param  {[type]} date   [description]
         * @param  {[type]} format [description]
         * @return {[type]}        [description]
         */
        formatDate: function (date, format) {
            date = new Date(date);
            return Dates.format(date, format);
        },

        /**
         * {{now}}
         * @param  {[type]} format [description]
         * @return {[type]}        [description]
         */
        now: function (format) {
            var date = new Date();
            if (Utils.isUndefined(format)) {
                return date;
            } else {
                return Dates.format(date, format);
            }
        },

        /**
         * {{i18n}}
         * @author: Laurent Goderre <https://github.com/LaurentGoderrre>
         * @param  {String} context
         * @param  {Object} options
         * @return {String}
         * @example: <https://github.com/assemble/buttons> (See the "button-i18n" example)
         */
        i18n: function (context, options) {
            var language = void 0;

            if (typeof context !== 'string') {
                throw 'Key must be of type \'string\'';
            }

            language = (typeof options.hash.language === 'string' ? options.hash.language : this.language);

            if (typeof language === 'undefined') {
                throw 'The \'language\' parameter is not defined';
            }

            if (typeof this[language] === "undefined") {
                throw 'No strings found for language \'" + language + "\'';
            }

            if (typeof this[language][context] === "undefined") {
                throw 'No string for key \'" + context + "\' for language \'" + language + "\'';
            }

            return this[language][context];
        },
        icon: function (name, selector, sys) {
            var cl = 'icon icon_' + name;

            if (typeof selector == "string") {
                cl += " " + selector;
            }

            return new Handlebars.SafeString(
                '<svg role="img" title="icon_' + name + '" class="' + cl + '">' +
                '<use xlink:href="/icon-svg/svg-symbols.svg#icon_' + name + '"/>' +
                '</svg>'
            );
        },
        imgSrc: function (imgId, width, height) {
            var imgSrc = 'http://api-fm.present-tlt.ru/files?key=' + imgId;

            if (typeof(width) != "undefined" && typeof(width) == "number") {
                imgSrc = imgSrc + '&width=' + width;
            }
            if (typeof(height) != "undefined" && typeof(height) == "number") {
                imgSrc = imgSrc + '&height=' + height;
            }
            //console.log(imgSrc);
            return new Handlebars.SafeString(imgSrc);
        }
    };
};
},{"./utils/dates":151,"./utils/utils":152,"digits":145}],151:[function(require,module,exports){
/**
 * Handlebars Helpers Utils
 * http://github.com/assemble/handlebars-helpers
 * Copyright (c) 2013 Jon Schlinkert, Brian Woodward, contributors
 * Licensed under the MIT License (MIT).
 */
'use strict';

var Dates = module.exports = {};

Dates.padNumber = function (num, count, padCharacter) {

    if (typeof padCharacter === 'undefined') {
        padCharacter = '0';
    }

    var lenDiff = count - String(num).length;
    var padding = '';

    if (lenDiff > 0) {
        while (lenDiff--) {
            padding += padCharacter;
        }
    }
    return padding + num;
};

Dates.dayOfYear = function (date) {
    var oneJan = new Date(date.getFullYear(), 0, 1);

    return Math.ceil((date - oneJan) / 86400000);
};

Dates.weekOfYear = function (date) {
    var oneJan = new Date(date.getFullYear(), 0, 1);
    return Math.ceil((((date - oneJan) / 86400000) + oneJan.getDay() + 1) / 7);
};

Dates.isoWeekOfYear = function (date) {
    var target = new Date(date.valueOf());
    var dayNr = (date.getDay() + 6) % 7;
    target.setDate(target.getDate() - dayNr + 3);
    var jan4 = new Date(target.getFullYear(), 0, 4);
    var dayDiff = (target - jan4) / 86400000;

    return 1 + Math.ceil(dayDiff / 7);
};

Dates.tweleveHour = function (date) {
    if (date.getHours() > 12) {
        return date.getHours() - 12;
    }

    return date.getHours();
};

Dates.timeZoneOffset = function (date) {
    var hoursDiff = -date.getTimezoneOffset() / 60;
    var result = Dates.padNumber(Math.abs(hoursDiff), 4);

    return (hoursDiff > 0 ? '+' : '-') + result;
};

Dates.format = function (date, format) {
    var match = null;
    return format.replace(Dates.formats, function (m, p) {
        switch (p) {
            case 'a':
                return Dates.abbreviatedWeekdays[date.getDay()];
            case 'A':
                return Dates.fullWeekdays[date.getDay()];
            case 'b':
                return Dates.abbreviatedMonths[date.getMonth()];
            case 'B':
                return Dates.getFullMounth(date.getMonth(), "Ru");
            case 'c':
                return date.toLocaleString();
            case 'C':
                return Math.round(date.getFullYear() / 100);
            case 'd':
                return Dates.padNumber(date.getDate(), 2);
            case 'D':
                return Dates.format(date, '%m/%d/%y');
            case 'e':
                return Dates.padNumber(date.getDate(), 2, ' ');
            case 'F':
                return Dates.format(date, '%Y-%m-%d');
            case 'h':
                return Dates.format(date, '%b');
            case 'H':
                return Dates.padNumber(date.getHours(), 2);
            case 'I':
                return Dates.padNumber(Dates.tweleveHour(date), 2);
            case 'j':
                return Dates.padNumber(Dates.dayOfYear(date), 3);
            case 'k':
                return Dates.padNumber(date.getHours(), 2, ' ');
            case 'l':
                return Dates.padNumber(Dates.tweleveHour(date), 2, ' ');
            case 'L':
                return Dates.padNumber(date.getMilliseconds(), 3);
            case 'm':
                return Dates.padNumber(date.getMonth() + 1, 2);
            case 'M':
                return Dates.padNumber(date.getMinutes(), 2);
            case 'n':
                return '\n';
            case 'p':
                if (date.getHours() > 11) {
                    return 'PM';
                } else {
                    return 'AM';
                }
                break;
            case 'P':
                return Dates.format(date, '%p').toLowerCase();
            case 'r':
                return Dates.format(date, '%I:%M:%S %p');
            case 'R':
                return Dates.format(date, '%H:%M');
            case 's':
                return date.getTime() / 1000;
            case 'S':
                return Dates.padNumber(date.getSeconds(), 2);
            case 't':
                return '\t';
            case 'T':
                return Dates.format(date, '%H:%M:%S');
            case 'u':
                if (date.getDay() === 0) {
                    return 7;
                } else {
                    return date.getDay();
                }
                break;
            case 'U':
                return Dates.padNumber(Dates.weekOfYear(date), 2);
            case 'v':
                return Dates.format(date, '%e-%b-%Y');
            case 'V':
                return Dates.padNumber(Dates.isoWeekOfYear(date), 2);
            case 'W':
                return Dates.padNumber(Dates.weekOfYear(date), 2);
            case 'w':
                return Dates.padNumber(date.getDay(), 2);
            case 'x':
                return date.toLocaleDateString();
            case 'X':
                return date.toLocaleTimeString();
            case 'y':
                return String(date.getFullYear()).substring(2);
            case 'Y':
                return date.getFullYear();
            case 'z':
                return Dates.timeZoneOffset(date);
            case 'Z':
                return Dates.fullMonthsRuP[date.getMonth()];
            default:
                return match;
        }
    });
};

Dates.formats = /%(a|A|b|B|c|C|d|D|e|E|F|h|H|I|j|k|l|L|m|M|n|p|P|r|R|s|S|t|T|u|U|v|V|W|w|x|X|y|Y|z|Z)/g;

Dates.abbreviatedWeekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thur', 'Fri', 'Sat'];
Dates.fullWeekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
Dates.abbreviatedMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
Dates.fullMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

Dates.fullMonthsRuP = ['Января', 'Февраля', 'Марта', 'Апреля', 'Мая', 'Июня', 'Июля', 'Августа', 'Сентября', 'Октября', 'Ноября', 'Декабря'];
Dates.fullMonthsRu = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];

Dates.getFullMounth = function (num, lang) {
    if (lang == "Ru")
        return Dates.fullMonthsRu;
    return Dates.fullMonths;
}


},{}],152:[function(require,module,exports){
/**
 * Handlebars Helpers: Utils
 * http://github.com/assemble/handlebars-helpers
 * Copyright (c) 2013, 2014 Jon Schlinkert, Brian Woodward, contributors
 * Licensed under the MIT License (MIT).
 */
'use strict';

module.exports = {
    isUndefined: function (value) {
        return typeof value === 'undefined' || value.toString() === '[object Function]' || (value.hash != null);
    }
};

},{}],153:[function(require,module,exports){
'use strict';



module.exports = {
    /**
     * Registers all helpers.
     * @param {ServiceLocator} locator Catberry's service locator.
     */
    register: function (locator) {
        var config = locator.resolve('config');
        try {
            var handlebars = locator.resolve('handlebars');
            var helpers = require('./handlebars-helper')(handlebars);

            Object.keys(helpers)
                .forEach(function (name) {
                    handlebars.registerHelper(name, helpers[name]);
                });
        } catch (e) {
            // nothing to do.
        }
    }
};
},{"./handlebars-helper":150}],154:[function(require,module,exports){
/*
 * catberry-handlebars
 *
 * Copyright (c) 2015 Denis Rechkunov and project contributors.
 *
 * catberry-handlebars's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This license applies to all parts of catberry-handlebars that are
 * not externally maintained libraries.
 */

'use strict';

module.exports = TemplateProvider;

/**
 * Creates new instance of Handlebars template provider.
 * @param {Handlebars} $handlebars Handlebars factory.
 * @constructor
 */
function TemplateProvider($handlebars) {
	this._handlebars = $handlebars;
	this._templates = Object.create(null);
}

/**
 * Current Handlebars factory.
 * @type {Handlebars}
 * @private
 */
TemplateProvider.prototype._handlebars = null;

/**
 * Current set of registered templates.
 * @type {Object}
 * @private
 */
TemplateProvider.prototype._templates = null;

/**
 * Registers compiled (precompiled) Handlebars template.
 * http://handlebarsjs.com/reference.html
 * @param {string} name Template name.
 * @param {string} compiled Compiled template source.
 */
TemplateProvider.prototype.registerCompiled = function (name, compiled) {
	// jshint evil:true
	var specs = new Function('return ' + compiled + ';');
	this._templates[name] = this._handlebars.template(specs());
};

/**
 * Renders template with specified data.
 * @param {string} name Name of template.
 * @param {Object} data Data context for template.
 * @returns {Promise<string>} Promise for rendered HTML.
 */
TemplateProvider.prototype.render = function (name, data) {
	if (!(name in this._templates)) {
		return Promise.reject(new Error('No such template'));
	}

	var promise;
	try {
		promise = Promise.resolve(this._templates[name](data));
	} catch (e) {
		promise = Promise.reject(e);
	}
	return promise;
};
},{}],155:[function(require,module,exports){
/*!

 handlebars v2.0.0

Copyright (C) 2011-2014 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
/* exported Handlebars */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.Handlebars = root.Handlebars || factory();
  }
}(this, function () {
// handlebars/safe-string.js
var __module3__ = (function() {
  "use strict";
  var __exports__;
  // Build out our basic SafeString type
  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = function() {
    return "" + this.string;
  };

  __exports__ = SafeString;
  return __exports__;
})();

// handlebars/utils.js
var __module2__ = (function(__dependency1__) {
  "use strict";
  var __exports__ = {};
  /*jshint -W004 */
  var SafeString = __dependency1__;

  var escape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };

  var badChars = /[&<>"'`]/g;
  var possible = /[&<>"'`]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj /* , ...source */) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  __exports__.extend = extend;var toString = Object.prototype.toString;
  __exports__.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  var isFunction = function(value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  /* istanbul ignore next */
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  var isFunction;
  __exports__.isFunction = isFunction;
  /* istanbul ignore next */
  var isArray = Array.isArray || function(value) {
    return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
  };
  __exports__.isArray = isArray;

  function escapeExpression(string) {
    // don't escape SafeStrings, since they're already safe
    if (string instanceof SafeString) {
      return string.toString();
    } else if (string == null) {
      return "";
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = "" + string;

    if(!possible.test(string)) { return string; }
    return string.replace(badChars, escapeChar);
  }

  __exports__.escapeExpression = escapeExpression;function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  __exports__.isEmpty = isEmpty;function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }

  __exports__.appendContextPath = appendContextPath;
  return __exports__;
})(__module3__);

// handlebars/exception.js
var __module4__ = (function() {
  "use strict";
  var __exports__;

  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var line;
    if (node && node.firstLine) {
      line = node.firstLine;

      message += ' - ' + line + ':' + node.firstColumn;
    }

    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    if (line) {
      this.lineNumber = line;
      this.column = node.firstColumn;
    }
  }

  Exception.prototype = new Error();

  __exports__ = Exception;
  return __exports__;
})();

// handlebars/base.js
var __module1__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;

  var VERSION = "2.0.0";
  __exports__.VERSION = VERSION;var COMPILER_REVISION = 6;
  __exports__.COMPILER_REVISION = COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '== 1.0.0-rc.3',
    3: '== 1.0.0-rc.4',
    4: '== 1.x.x',
    5: '== 2.0.0-alpha.x',
    6: '>= 2.0.0-beta.1'
  };
  __exports__.REVISION_CHANGES = REVISION_CHANGES;
  var isArray = Utils.isArray,
      isFunction = Utils.isFunction,
      toString = Utils.toString,
      objectType = '[object Object]';

  function HandlebarsEnvironment(helpers, partials) {
    this.helpers = helpers || {};
    this.partials = partials || {};

    registerDefaultHelpers(this);
  }

  __exports__.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,

    logger: logger,
    log: log,

    registerHelper: function(name, fn) {
      if (toString.call(name) === objectType) {
        if (fn) { throw new Exception('Arg not supported with multiple helpers'); }
        Utils.extend(this.helpers, name);
      } else {
        this.helpers[name] = fn;
      }
    },
    unregisterHelper: function(name) {
      delete this.helpers[name];
    },

    registerPartial: function(name, partial) {
      if (toString.call(name) === objectType) {
        Utils.extend(this.partials,  name);
      } else {
        this.partials[name] = partial;
      }
    },
    unregisterPartial: function(name) {
      delete this.partials[name];
    }
  };

  function registerDefaultHelpers(instance) {
    instance.registerHelper('helperMissing', function(/* [args, ]options */) {
      if(arguments.length === 1) {
        // A missing field in a {{foo}} constuct.
        return undefined;
      } else {
        // Someone is actually trying to call something, blow up.
        throw new Exception("Missing helper: '" + arguments[arguments.length-1].name + "'");
      }
    });

    instance.registerHelper('blockHelperMissing', function(context, options) {
      var inverse = options.inverse,
          fn = options.fn;

      if(context === true) {
        return fn(this);
      } else if(context === false || context == null) {
        return inverse(this);
      } else if (isArray(context)) {
        if(context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }

          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = createFrame(options.data);
          data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
          options = {data: data};
        }

        return fn(context, options);
      }
    });

    instance.registerHelper('each', function(context, options) {
      if (!options) {
        throw new Exception('Must pass iterator to #each');
      }

      var fn = options.fn, inverse = options.inverse;
      var i = 0, ret = "", data;

      var contextPath;
      if (options.data && options.ids) {
        contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
      }

      if (isFunction(context)) { context = context.call(this); }

      if (options.data) {
        data = createFrame(options.data);
      }

      if(context && typeof context === 'object') {
        if (isArray(context)) {
          for(var j = context.length; i<j; i++) {
            if (data) {
              data.index = i;
              data.first = (i === 0);
              data.last  = (i === (context.length-1));

              if (contextPath) {
                data.contextPath = contextPath + i;
              }
            }
            ret = ret + fn(context[i], { data: data });
          }
        } else {
          for(var key in context) {
            if(context.hasOwnProperty(key)) {
              if(data) {
                data.key = key;
                data.index = i;
                data.first = (i === 0);

                if (contextPath) {
                  data.contextPath = contextPath + key;
                }
              }
              ret = ret + fn(context[key], {data: data});
              i++;
            }
          }
        }
      }

      if(i === 0){
        ret = inverse(this);
      }

      return ret;
    });

    instance.registerHelper('if', function(conditional, options) {
      if (isFunction(conditional)) { conditional = conditional.call(this); }

      // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
      if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });

    instance.registerHelper('unless', function(conditional, options) {
      return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
    });

    instance.registerHelper('with', function(context, options) {
      if (isFunction(context)) { context = context.call(this); }

      var fn = options.fn;

      if (!Utils.isEmpty(context)) {
        if (options.data && options.ids) {
          var data = createFrame(options.data);
          data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
          options = {data:data};
        }

        return fn(context, options);
      } else {
        return options.inverse(this);
      }
    });

    instance.registerHelper('log', function(message, options) {
      var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
      instance.log(level, message);
    });

    instance.registerHelper('lookup', function(obj, field) {
      return obj && obj[field];
    });
  }

  var logger = {
    methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

    // State enum
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
    level: 3,

    // can be overridden in the host environment
    log: function(level, message) {
      if (logger.level <= level) {
        var method = logger.methodMap[level];
        if (typeof console !== 'undefined' && console[method]) {
          console[method].call(console, message);
        }
      }
    }
  };
  __exports__.logger = logger;
  var log = logger.log;
  __exports__.log = log;
  var createFrame = function(object) {
    var frame = Utils.extend({}, object);
    frame._parent = object;
    return frame;
  };
  __exports__.createFrame = createFrame;
  return __exports__;
})(__module2__, __module4__);

// handlebars/runtime.js
var __module5__ = (function(__dependency1__, __dependency2__, __dependency3__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;
  var COMPILER_REVISION = __dependency3__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency3__.REVISION_CHANGES;
  var createFrame = __dependency3__.createFrame;

  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = COMPILER_REVISION;

    if (compilerRevision !== currentRevision) {
      if (compilerRevision < currentRevision) {
        var runtimeVersions = REVISION_CHANGES[currentRevision],
            compilerVersions = REVISION_CHANGES[compilerRevision];
        throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
              "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
      } else {
        // Use the embedded version info since the runtime doesn't know about this revision yet
        throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
              "Please update your runtime to a newer version ("+compilerInfo[1]+").");
      }
    }
  }

  __exports__.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

  function template(templateSpec, env) {
    /* istanbul ignore next */
    if (!env) {
      throw new Exception("No environment passed to template");
    }
    if (!templateSpec || !templateSpec.main) {
      throw new Exception('Unknown template object: ' + typeof templateSpec);
    }

    // Note: Using env.VM references rather than local var references throughout this section to allow
    // for external users to override these as psuedo-supported APIs.
    env.VM.checkRevision(templateSpec.compiler);

    var invokePartialWrapper = function(partial, indent, name, context, hash, helpers, partials, data, depths) {
      if (hash) {
        context = Utils.extend({}, context, hash);
      }

      var result = env.VM.invokePartial.call(this, partial, name, context, helpers, partials, data, depths);

      if (result == null && env.compile) {
        var options = { helpers: helpers, partials: partials, data: data, depths: depths };
        partials[name] = env.compile(partial, { data: data !== undefined, compat: templateSpec.compat }, env);
        result = partials[name](context, options);
      }
      if (result != null) {
        if (indent) {
          var lines = result.split('\n');
          for (var i = 0, l = lines.length; i < l; i++) {
            if (!lines[i] && i + 1 === l) {
              break;
            }

            lines[i] = indent + lines[i];
          }
          result = lines.join('\n');
        }
        return result;
      } else {
        throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
      }
    };

    // Just add water
    var container = {
      lookup: function(depths, name) {
        var len = depths.length;
        for (var i = 0; i < len; i++) {
          if (depths[i] && depths[i][name] != null) {
            return depths[i][name];
          }
        }
      },
      lambda: function(current, context) {
        return typeof current === 'function' ? current.call(context) : current;
      },

      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,

      fn: function(i) {
        return templateSpec[i];
      },

      programs: [],
      program: function(i, data, depths) {
        var programWrapper = this.programs[i],
            fn = this.fn(i);
        if (data || depths) {
          programWrapper = program(this, i, fn, data, depths);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = program(this, i, fn);
        }
        return programWrapper;
      },

      data: function(data, depth) {
        while (data && depth--) {
          data = data._parent;
        }
        return data;
      },
      merge: function(param, common) {
        var ret = param || common;

        if (param && common && (param !== common)) {
          ret = Utils.extend({}, common, param);
        }

        return ret;
      },

      noop: env.VM.noop,
      compilerInfo: templateSpec.compiler
    };

    var ret = function(context, options) {
      options = options || {};
      var data = options.data;

      ret._setup(options);
      if (!options.partial && templateSpec.useData) {
        data = initData(context, data);
      }
      var depths;
      if (templateSpec.useDepths) {
        depths = options.depths ? [context].concat(options.depths) : [context];
      }

      return templateSpec.main.call(container, context, container.helpers, container.partials, data, depths);
    };
    ret.isTop = true;

    ret._setup = function(options) {
      if (!options.partial) {
        container.helpers = container.merge(options.helpers, env.helpers);

        if (templateSpec.usePartial) {
          container.partials = container.merge(options.partials, env.partials);
        }
      } else {
        container.helpers = options.helpers;
        container.partials = options.partials;
      }
    };

    ret._child = function(i, data, depths) {
      if (templateSpec.useDepths && !depths) {
        throw new Exception('must pass parent depths');
      }

      return program(container, i, templateSpec[i], data, depths);
    };
    return ret;
  }

  __exports__.template = template;function program(container, i, fn, data, depths) {
    var prog = function(context, options) {
      options = options || {};

      return fn.call(container, context, container.helpers, container.partials, options.data || data, depths && [context].concat(depths));
    };
    prog.program = i;
    prog.depth = depths ? depths.length : 0;
    return prog;
  }

  __exports__.program = program;function invokePartial(partial, name, context, helpers, partials, data, depths) {
    var options = { partial: true, helpers: helpers, partials: partials, data: data, depths: depths };

    if(partial === undefined) {
      throw new Exception("The partial " + name + " could not be found");
    } else if(partial instanceof Function) {
      return partial(context, options);
    }
  }

  __exports__.invokePartial = invokePartial;function noop() { return ""; }

  __exports__.noop = noop;function initData(context, data) {
    if (!data || !('root' in data)) {
      data = data ? createFrame(data) : {};
      data.root = context;
    }
    return data;
  }
  return __exports__;
})(__module2__, __module4__, __module1__);

// handlebars.runtime.js
var __module0__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  "use strict";
  var __exports__;
  /*globals Handlebars: true */
  var base = __dependency1__;

  // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)
  var SafeString = __dependency2__;
  var Exception = __dependency3__;
  var Utils = __dependency4__;
  var runtime = __dependency5__;

  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
  var create = function() {
    var hb = new base.HandlebarsEnvironment();

    Utils.extend(hb, base);
    hb.SafeString = SafeString;
    hb.Exception = Exception;
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;

    hb.VM = runtime;
    hb.template = function(spec) {
      return runtime.template(spec, hb);
    };

    return hb;
  };

  var Handlebars = create();
  Handlebars.create = create;

  Handlebars['default'] = Handlebars;

  __exports__ = Handlebars;
  return __exports__;
})(__module1__, __module3__, __module4__, __module2__, __module5__);

  return __module0__;
}));

},{}],156:[function(require,module,exports){
/*
 * catberry-handlebars
 *
 * Copyright (c) 2014 Denis Rechkunov and project contributors.
 *
 * catberry-handlebars's license follows:
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge,
 * publish, distribute, sublicense, and/or sell copies of the Software,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This license applies to all parts of catberry-handlebars that
 * are not externally maintained libraries.
 */

'use strict';

var Handlebars = require('./lib/vendors/handlebars'),
    TemplateProvider = require('./lib/TemplateProvider');

module.exports = {
    register: function (locator, config) {
        config = config || {};
        locator.registerInstance('handlebars', Handlebars);
        locator.register('templateProvider', TemplateProvider, config, true);
    },
    Handlebars: Handlebars,
    TemplateProvider: TemplateProvider
};

},{"./lib/TemplateProvider":154,"./lib/vendors/handlebars":155}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiX19Ccm93c2VyQnVuZGxlLmpzIiwiYnJvd3Nlci5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvX2NvbW1vbi9jb21tb24taDEvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL19jb21tb24vY29tbW9uLXBhZ2luYXRvci9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvYnJlYWRjcnVtcHMvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL2NhdGFsb2ctbGlzdC9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvZG9jdW1lbnQvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL2hlYWQvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL2xvYWRlci9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvbWFzdGVyL21hc3Rlci1ibG9jay9tYXN0ZXItYmxvY2stYWJvdXQvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItYmxvY2svbWFzdGVyLWJsb2NrLWFydGljbGUvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItYmxvY2svbWFzdGVyLWJsb2NrLWxpbmsvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItYmxvY2svbWFzdGVyLWJsb2NrLXBob3RvL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLWJsb2NrL21hc3Rlci1ibG9jay1yZXZpZXcvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItYmxvY2svbWFzdGVyLWJsb2NrLXNhbGUvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItYmxvY2svbWFzdGVyLWJsb2NrLXNlcnZpY2UvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItYmxvY2svbWFzdGVyLWJsb2NrLXZpZGVvL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLWJsb2NrL21hc3Rlci1ibG9jay13b3JrL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLWZpbHRlci9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvbWFzdGVyL21hc3Rlci1saXN0L2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLW1pbmljYXJkL21hc3Rlci1taW5pY2FyZC9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvbWFzdGVyL21hc3Rlci1taW5pY2FyZC9tYXN0ZXItcGhvbmUtYnRuL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLXBhZ2UvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItcmVjb21tZW5kZWQvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItcnVicmlrYS9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvb3RoZXIvb3RoZXItbmV3cy1pdGVtL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9vdGhlci9vdGhlci1uZXdzL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9vdGhlci9vdGhlci1yZWNvbW1lbmRhdGlvbi9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvb3RoZXIvb3RoZXItdmFjYW5jeS1pdGVtL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9vdGhlci9vdGhlci12YWNhbmN5L2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtY2F0YWxvZy9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLWNvbnRhY3QvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1mZWVkYmFjay9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLWxvZ2luL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtbWFpbi9kb3AtZnVuY3Rpb24vaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1tYWluL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtbWFpbi9tYWluLWZ1bmN0aW9uL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtbWFzdGVyLXBhZ2UvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1tYXN0ZXItcnVicmlrYS9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLW5ld3MtaXRlbS9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLW5ld3MvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1vZmVydGEvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1yZWNvbW1lbmRhdGlvbi9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLXJlZ2lzdHJhdGlvbi9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLXJlcXVlc3QvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1zYWxlL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2Utc292ZXR5L2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtdmFjYW5jeS1pdGVtL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtdmFjYW5jeS9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLXZpZGVvL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9wYWdlcy9wYWdlcy1jb250ZW50L2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9wYWdlcy9wYWdlcy1mb290ZXIvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3BhZ2VzL3BhZ2VzLWhlYWRlci9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZXMvcGFnZXMtbmF2aWdhdGlvbi9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcmVnaXN0cmF0aW9uL3JlZ2lzdHJhdGlvbi1hYm91dC9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcmVnaXN0cmF0aW9uL3JlZ2lzdHJhdGlvbi1mYXEvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3JlZ2lzdHJhdGlvbi9yZWdpc3RyYXRpb24tZm9ybS9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcmVnaXN0cmF0aW9uL3JlZ2lzdHJhdGlvbi1oZWFkZXIvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3JlZ2lzdHJhdGlvbi9yZWdpc3RyYXRpb24tbW9yZS1wYWdlL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9yZWdpc3RyYXRpb24vcmVnaXN0cmF0aW9uLXByaWNlL2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9yZWdpc3RyYXRpb24vcmVnaXN0cmF0aW9uLXdoeS13ZS9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvcnVicmlrYXRvci9ydWJyaWthdG9yLWxpc3QvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3NhbGUvaW5kZXguanMiLCJjYXRiZXJyeV9jb21wb25lbnRzL3NlYXJjaC9pbmRleC5qcyIsImNhdGJlcnJ5X2NvbXBvbmVudHMvc2VydmljZS1yZXF1ZXN0L2luZGV4LmpzIiwiY2F0YmVycnlfY29tcG9uZW50cy9zb2NpYWwvaW5kZXguanMiLCJjYXRiZXJyeV9zdG9yZXMvQnJlYWRjcnVtcHMuanMiLCJjYXRiZXJyeV9zdG9yZXMvSGVhZC5qcyIsImNhdGJlcnJ5X3N0b3Jlcy9QYWdlcy5qcyIsImNhdGJlcnJ5X3N0b3Jlcy9QYWdpbmF0b3IuanMiLCJjYXRiZXJyeV9zdG9yZXMvVGFnLmpzIiwiY2F0YmVycnlfc3RvcmVzL21hc3Rlci9NYXN0ZXJJdGVtLmpzIiwiY2F0YmVycnlfc3RvcmVzL21hc3Rlci9NYXN0ZXJMaXN0LmpzIiwiY2F0YmVycnlfc3RvcmVzL21hc3Rlci9NYXN0ZXJTb3ZldHkuanMiLCJjYXRiZXJyeV9zdG9yZXMvbWFzdGVyL01hc3RlclZpZGVvLmpzIiwiY2F0YmVycnlfc3RvcmVzL21hc3Rlci9SZWNvbW1lbmRlZC5qcyIsImNhdGJlcnJ5X3N0b3Jlcy9vdGhlci9OZXdzLmpzIiwiY2F0YmVycnlfc3RvcmVzL290aGVyL05ld3NJdGVtLmpzIiwiY2F0YmVycnlfc3RvcmVzL290aGVyL1JlY29tbWVuZGF0aW9uLmpzIiwiY2F0YmVycnlfc3RvcmVzL290aGVyL1ZhY2FuY3kuanMiLCJjYXRiZXJyeV9zdG9yZXMvb3RoZXIvVmFjYW5jeUl0ZW0uanMiLCJjYXRiZXJyeV9zdG9yZXMvcnVicmlrYS9SdWJyaWthLmpzIiwiY2F0YmVycnlfc3RvcmVzL3J1YnJpa2EvUnVicmlrYXRvci5qcyIsImNhdGJlcnJ5X3N0b3Jlcy9ydWJyaWthL1J1YnJpa2F0b3JDb21wYW55LmpzIiwiY2F0YmVycnlfc3RvcmVzL3J1YnJpa2EvUnVicmlrYXRvclBhcmVudC5qcyIsImNhdGJlcnJ5X3N0b3Jlcy9ydWJyaWthL1J1YnJpa2F0b3JTYWxlLmpzIiwiY2F0YmVycnlfc3RvcmVzL3NhbGUvU2FsZUJ5UnVicmlrYS5qcyIsImNvbmZpZy9icm93c2VyLmpzb24iLCJjb25maWcvcGFnZXMuanNvbiIsImxpYi9TdG9yZVBhZ2luYXRvci5qcyIsImxpYi91dGlsL0RhdGVGb3JtYXQuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvYnJvd3Nlci9DYXRiZXJyeS5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9icm93c2VyL0Nvb2tpZVdyYXBwZXIuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvYnJvd3Nlci9Eb2N1bWVudFJlbmRlcmVyLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2Jyb3dzZXIvTG9nZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2Jyb3dzZXIvUmVxdWVzdFJvdXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9icm93c2VyL2hlbHBlcnMvaHJUaW1lSGVscGVyLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2Jyb3dzZXIvbG9hZGVycy9Db21wb25lbnRMb2FkZXIuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvYnJvd3Nlci9sb2FkZXJzL1N0b3JlTG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2Jyb3dzZXIvcHJvdmlkZXJzL01vZHVsZUFwaVByb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2xpYi9Db250ZXh0RmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9saWIvU2VyaWFsV3JhcHBlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9saWIvU3RvcmVEaXNwYXRjaGVyLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2xpYi9iYXNlL0Jvb3RzdHJhcHBlckJhc2UuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbGliL2Jhc2UvQ2F0YmVycnlCYXNlLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2xpYi9iYXNlL0Nvb2tpZVdyYXBwZXJCYXNlLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2xpYi9iYXNlL0RvY3VtZW50UmVuZGVyZXJCYXNlLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2xpYi9iYXNlL0xvYWRlckJhc2UuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbGliL2Jhc2UvTW9kdWxlQXBpUHJvdmlkZXJCYXNlLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2xpYi9oZWxwZXJzL2Vycm9ySGVscGVyLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2xpYi9oZWxwZXJzL21vZHVsZUhlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9saWIvaGVscGVycy9wcm9wZXJ0eUhlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9saWIvaGVscGVycy9yb3V0ZUhlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9saWIvcHJvdmlkZXJzL1N0YXRlUHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcHJvY2Vzcy1ocnRpbWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9jYXRiZXJyeS1sb2NhdG9yL2xpYi9Db25zdHJ1Y3RvclRva2VuaXplci5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvY2F0YmVycnktbG9jYXRvci9saWIvU2VydmljZUxvY2F0b3IuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL2NhdGJlcnJ5LXVoci9icm93c2VyL1VIUi5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvY2F0YmVycnktdWhyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9jYXRiZXJyeS11aHIvbGliL1VIUkJhc2UuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL2NhdGJlcnJ5LXVyaS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvY2F0YmVycnktdXJpL2xpYi9BdXRob3JpdHkuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL2NhdGJlcnJ5LXVyaS9saWIvUXVlcnkuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL2NhdGJlcnJ5LXVyaS9saWIvVVJJLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9jYXRiZXJyeS11cmkvbGliL1VzZXJJbmZvLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9jYXRiZXJyeS11cmkvbGliL3BlcmNlbnRFbmNvZGluZ0hlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvbW9ycGhkb20vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9wcmV0dHktaHJ0aW1lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9wcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9kb25lLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9lczYtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZmluYWxseS5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL25vZGUtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9jYXRiZXJyeS9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvc3luY2hyb25vdXMuanMiLCJub2RlX21vZHVsZXMvY2F0YmVycnkvbm9kZV9tb2R1bGVzL3Byb21pc2Uvbm9kZV9tb2R1bGVzL2FzYXAvYnJvd3Nlci1hc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NhdGJlcnJ5L25vZGVfbW9kdWxlcy9wcm9taXNlL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItcmF3LmpzIiwibm9kZV9tb2R1bGVzL2RpZ2l0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kaWdpdHMvbm9kZV9tb2R1bGVzL2xvbmdlc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGlnaXRzL25vZGVfbW9kdWxlcy9wYWQtbGVmdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kaWdpdHMvbm9kZV9tb2R1bGVzL3BhZC1sZWZ0L25vZGVfbW9kdWxlcy9yZXBlYXQtc3RyaW5nL2luZGV4LmpzIiwicm91dGVzLmpzIiwic3BlY2lhbF9tb2R1bGVzL2NhdGJlcnJ5LWhhbmRsZWJhcnMtaGVscGVycy9oYW5kbGViYXJzLWhlbHBlci9pbmRleC5qcyIsInNwZWNpYWxfbW9kdWxlcy9jYXRiZXJyeS1oYW5kbGViYXJzLWhlbHBlcnMvaGFuZGxlYmFycy1oZWxwZXIvdXRpbHMvZGF0ZXMuanMiLCJzcGVjaWFsX21vZHVsZXMvY2F0YmVycnktaGFuZGxlYmFycy1oZWxwZXJzL2hhbmRsZWJhcnMtaGVscGVyL3V0aWxzL3V0aWxzLmpzIiwic3BlY2lhbF9tb2R1bGVzL2NhdGJlcnJ5LWhhbmRsZWJhcnMtaGVscGVycy9pbmRleC5qcyIsInNwZWNpYWxfbW9kdWxlcy9jYXRiZXJyeS1oYW5kbGViYXJzL2Jyb3dzZXIvVGVtcGxhdGVQcm92aWRlci5qcyIsInNwZWNpYWxfbW9kdWxlcy9jYXRiZXJyeS1oYW5kbGViYXJzL2Jyb3dzZXIvdmVuZG9ycy9oYW5kbGViYXJzLmpzIiwic3BlY2lhbF9tb2R1bGVzL2NhdGJlcnJ5LWhhbmRsZWJhcnMvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzd5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBtb2R1bGUgaXMgYSB0ZW1wbGF0ZSBhbmQgaXQgaXMgdXNlZCBvbmx5IHdpdGggc29tZSBzdHJpbmcgcmVwbGFjZXNcbiAqIGJ5IEJyb3dzZXJCdW5kbGVCdWlsZGVyIG1vZHVsZS4gSXQgZG9lcyBub3Qgd29yayBieSBpdHNlbGYuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RvcmVzID0gW1xuXG57bmFtZTogJ0JyZWFkY3J1bXBzJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfc3RvcmVzL0JyZWFkY3J1bXBzLmpzJyl9LFxue25hbWU6ICdIZWFkJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfc3RvcmVzL0hlYWQuanMnKX0sXG57bmFtZTogJ1BhZ2VzJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfc3RvcmVzL1BhZ2VzLmpzJyl9LFxue25hbWU6ICdQYWdpbmF0b3InLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9zdG9yZXMvUGFnaW5hdG9yLmpzJyl9LFxue25hbWU6ICdUYWcnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9zdG9yZXMvVGFnLmpzJyl9LFxue25hbWU6ICdvdGhlci9OZXdzJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfc3RvcmVzL290aGVyL05ld3MuanMnKX0sXG57bmFtZTogJ290aGVyL05ld3NJdGVtJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfc3RvcmVzL290aGVyL05ld3NJdGVtLmpzJyl9LFxue25hbWU6ICdvdGhlci9SZWNvbW1lbmRhdGlvbicsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X3N0b3Jlcy9vdGhlci9SZWNvbW1lbmRhdGlvbi5qcycpfSxcbntuYW1lOiAnb3RoZXIvVmFjYW5jeScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X3N0b3Jlcy9vdGhlci9WYWNhbmN5LmpzJyl9LFxue25hbWU6ICdvdGhlci9WYWNhbmN5SXRlbScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X3N0b3Jlcy9vdGhlci9WYWNhbmN5SXRlbS5qcycpfSxcbntuYW1lOiAncnVicmlrYS9SdWJyaWthJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfc3RvcmVzL3J1YnJpa2EvUnVicmlrYS5qcycpfSxcbntuYW1lOiAncnVicmlrYS9SdWJyaWthdG9yJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfc3RvcmVzL3J1YnJpa2EvUnVicmlrYXRvci5qcycpfSxcbntuYW1lOiAncnVicmlrYS9SdWJyaWthdG9yQ29tcGFueScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X3N0b3Jlcy9ydWJyaWthL1J1YnJpa2F0b3JDb21wYW55LmpzJyl9LFxue25hbWU6ICdydWJyaWthL1J1YnJpa2F0b3JQYXJlbnQnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9zdG9yZXMvcnVicmlrYS9SdWJyaWthdG9yUGFyZW50LmpzJyl9LFxue25hbWU6ICdydWJyaWthL1J1YnJpa2F0b3JTYWxlJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfc3RvcmVzL3J1YnJpa2EvUnVicmlrYXRvclNhbGUuanMnKX0sXG57bmFtZTogJ3NhbGUvU2FsZUJ5UnVicmlrYScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X3N0b3Jlcy9zYWxlL1NhbGVCeVJ1YnJpa2EuanMnKX0sXG57bmFtZTogJ21hc3Rlci9NYXN0ZXJJdGVtJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfc3RvcmVzL21hc3Rlci9NYXN0ZXJJdGVtLmpzJyl9LFxue25hbWU6ICdtYXN0ZXIvTWFzdGVyTGlzdCcsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X3N0b3Jlcy9tYXN0ZXIvTWFzdGVyTGlzdC5qcycpfSxcbntuYW1lOiAnbWFzdGVyL01hc3RlclNvdmV0eScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X3N0b3Jlcy9tYXN0ZXIvTWFzdGVyU292ZXR5LmpzJyl9LFxue25hbWU6ICdtYXN0ZXIvTWFzdGVyVmlkZW8nLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9zdG9yZXMvbWFzdGVyL01hc3RlclZpZGVvLmpzJyl9LFxue25hbWU6ICdtYXN0ZXIvUmVjb21tZW5kZWQnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9zdG9yZXMvbWFzdGVyL1JlY29tbWVuZGVkLmpzJyl9XG5dO1xuXG52YXIgY29tcG9uZW50cyA9IFtcblxue25hbWU6ICdicmVhZGNydW1wcycsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvYnJlYWRjcnVtcHMvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwiYnJlYWRjcnVtcHNcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIiAgICAgICAgPHNwYW4gY2xhc3M9XFxcXFwiYnJlYWRjcnVtYnNfX2ljb25cXFxcXCI+XFxcXG4gICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwiYXJyb3ctYnJlYWRjcnVtYnNcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCJcXFxcbiAgICAgICAgPC9zcGFuPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzW1xcJ2lmXFwnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgyLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLnByb2dyYW0oNywgZGF0YSksXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubGlua3MgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oOSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyO1xcbn0sXCIyXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCJcIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubGlua3MgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5wcm9ncmFtKDUsIGRhdGEpLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyO1xcbn0sXCIzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcImJyZWFkY3J1bWJzX19sZXZlbCBicmVhZGNydW1ic19fbGV2ZWxfbGluayBqcy1wYXJlbnQtcnViXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9hPlxcXFxuXCI7XFxufSxcIjVcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiYnJlYWRjcnVtYnNfX2xldmVsIGJyZWFkY3J1bWJzX19sZXZlbF9saW5rXFxcXFwiIGhyZWY9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudXJsIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC51cmwgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidXJsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGl0bGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRpdGxlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L2E+XFxcXG5cIjtcXG59LFwiN1wiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXFxcImJyZWFkY3J1bWJzX19sZXZlbFxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvc3Bhbj5cXFxcblwiO1xcbn0sXCI5XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCIgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImJyZWFkY3J1bWJzX19saXN0LWNvbnRhaW5lciBqcy1icmVhZGNydW1icy1saXN0XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFxcXCJicmVhZGNydW1ic19fbGlzdFxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubGlua3MgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxMCwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgICAgICAgICAgICAgPC91bD5cXFxcbiAgICAgICAgICAgIDwvZGl2PlxcXFxuXCI7XFxufSxcIjEwXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcImJyZWFkY3J1bWJzX19saXN0LWl0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcXFwiYnJlYWRjcnVtYnNfX2ljb25cXFxcXCI+PC9zcGFuPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcImJyZWFkY3J1bWJzX19sZXZlbCBicmVhZGNydW1ic19fbGV2ZWxfbGlua1xcXFxcIiBocmVmPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnVybCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudXJsIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInVybFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9hPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxcblwiO1xcbn0sXCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGJ1ZmZlciA9IFwiPGRpdiBjbGFzcz1cXFxcXCJicmVhZGNydW1ic1xcXFxcIj5cXFxcbiAgICA8c3BhbiBjbGFzcz1cXFxcXCJicmVhZGNydW1ic19faGVhZGVyXFxcXFwiPtCS0Ysg0L3QsNGF0L7QtNC40YLQtdGB0Yw6IDwvc3Bhbj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCBkZXB0aDAsIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiPC9kaXY+XCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ2NhdGFsb2ctbGlzdCcsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvY2F0YWxvZy1saXN0L2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcImNhdGFsb2ctbGlzdFwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcIjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgYnVmZmVyID0gXCIgICAgICAgIDxsaSBjbGFzcz1cXFxcXCJjYXRhbG9nLWxpc3RfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJjYXRhbG9nLWxpc3RfX2l0ZW0tbGlua1xcXFxcIiBocmVmPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnVybCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudXJsIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInVybFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXFxcImNhdGFsb2ctbGlzdF9faWNvblxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaWNvIDogZGVwdGgwKSwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCJcXFxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxcXG4gICAgICAgICAgICAgICAgXCI7XFxuICBzdGFjazEgPSAoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIlxcXFxuICAgICAgICAgICAgPC9hPlxcXFxuICAgICAgICA8L2xpPlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGJ1ZmZlciA9IFwiPHVsIGNsYXNzPVxcXFxcImNhdGFsb2ctbGlzdF9cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVyc1tcXCdkYXRhLW1vZFxcJ10gfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwW1xcJ2RhdGEtbW9kXFwnXSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJkYXRhLW1vZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiIGNhdGFsb2ctbGlzdFxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY2F0YWxvZ3MgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIjwvdWw+XFxcXG5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdkb2N1bWVudCcsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvZG9jdW1lbnQvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwiZG9jdW1lbnRcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiPCFET0NUWVBFIGh0bWw+XFxcXG48aHRtbCBsYW5nPVxcXFxcImVuXFxcXFwiPlxcXFxuPGhlYWQgY2F0LXN0b3JlPVxcXFxcIkhlYWRcXFxcXCI+PC9oZWFkPlxcXFxuPGJvZHk+XFxcXG5cXHQ8Y2F0LXBhZ2VzLWhlYWRlciBpZD1cXFxcXCJwYWdlcy1oZWFkZXJcXFxcXCIgY2F0LXN0b3JlPVxcXFxcIlBhZ2VzXFxcXFwiPjwvY2F0LXBhZ2VzLWhlYWRlcj5cXFxcblxcdDxjYXQtcGFnZXMtY29udGVudCBpZD1cXFxcXCJwYWdlcy1jb250ZW50XFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJQYWdlc1xcXFxcIj48L2NhdC1wYWdlcy1jb250ZW50PlxcXFxuICAgIDxjYXQtcGFnZXMtZm9vdGVyIGlkPVxcXFxcInBhZ2VzLWZvb3RlclxcXFxcIiBjYXQtc3RvcmU9XFxcXFwiUGFnZXNcXFxcXCI+PC9jYXQtcGFnZXMtZm9vdGVyPlxcXFxuPC9ib2R5PlxcXFxuPC9odG1sPlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogbnVsbH0sXG57bmFtZTogJ2hlYWQnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL2hlYWQvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwiaGVhZFwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgbGFtYmRhPXRoaXMubGFtYmRhO1xcbiAgcmV0dXJuIFwiPG1ldGEgY2hhcnNldD1cXFxcXCJVVEYtOFxcXFxcIj5cXFxcbjx0aXRsZT5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvdGl0bGU+XFxcXG48bWV0YSBjb250ZW50PVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmRlc2NyaXB0aW9uIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5kZXNjcmlwdGlvbiA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJkZXNjcmlwdGlvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiIG5hbWU9XFxcXFwiZGVzY3JpcHRpb25cXFxcXCI+XFxcXG48bWV0YSBjb250ZW50PVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmtleXdvcmRzIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5rZXl3b3JkcyA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJrZXl3b3Jkc1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiIG5hbWU9XFxcXFwia2V5d29yZHNcXFxcXCI+XFxcXG48bWV0YSBjb250ZW50PVxcXFxcInRlbGVwaG9uZT1ub1xcXFxcIiBuYW1lPVxcXFxcImZvcm1hdC1kZXRlY3Rpb25cXFxcXCI+XFxcXG48bWV0YSBuYW1lPVxcXFxcInJvYm90c1xcXFxcIiBjb250ZW50PVxcXFxcIm5vb2RwLCBub3lkaXJcXFxcXCI+XFxcXG5cXFxcbjxtZXRhIG5hbWU9XFxcXFwiSGFuZGhlbGRGcmllbmRseVxcXFxcIiBjb250ZW50PVxcXFxcInRydWVcXFxcXCI+XFxcXG48bWV0YSBodHRwLWVxdWl2PVxcXFxcIlgtVUEtQ29tcGF0aWJsZVxcXFxcIiBjb250ZW50PVxcXFxcIklFPWVkZ2VcXFxcXCI+XFxcXG48bWV0YSBuYW1lPVxcXFxcInZpZXdwb3J0XFxcXFwiIGNvbnRlbnQ9XFxcXFwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTFcXFxcXCI+XFxcXG5cXFxcbjxtZXRhIHByb3BlcnR5PVxcXFxcIm9nOnRpdGxlXFxcXFwiIGNvbnRlbnQ9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zb2NpYWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnRpdGxlIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbjxtZXRhIHByb3BlcnR5PVxcXFxcIm9nOnVybFxcXFxcIiBjb250ZW50PVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc29jaWFsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS51cmwgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuPG1ldGEgcHJvcGVydHk9XFxcXFwib2c6ZGVzY3JpcHRpb25cXFxcXCIgY29udGVudD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNvY2lhbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuZGVzY3JpcHRpb24gOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuPG1ldGEgcHJvcGVydHk9XFxcXFwib2c6aW1hZ2VcXFxcXCIgY29udGVudD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNvY2lhbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuaW1nIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbjxtZXRhIHByb3BlcnR5PVxcXFxcIm9nOmltYWdlOnR5cGVcXFxcXCIgY29udGVudD1cXFxcXCJpbWFnZS9qcGVnXFxcXFwiPlxcXFxuPG1ldGEgcHJvcGVydHk9XFxcXFwib2c6aW1hZ2U6d2lkdGhcXFxcXCIgY29udGVudD1cXFxcXCI1MDBcXFxcXCI+XFxcXG48bWV0YSBwcm9wZXJ0eT1cXFxcXCJvZzppbWFnZTpoZWlnaHRcXFxcXCIgY29udGVudD1cXFxcXCIzMDBcXFxcXCI+XFxcXG48bWV0YSBwcm9wZXJ0eT1cXFxcXCJ0d2l0dGVyOmRlc2NyaXB0aW9uXFxcXFwiIGNvbnRlbnQ9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zb2NpYWwgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmRlc2NyaXB0aW9uIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbjxsaW5rIHJlbD1cXFxcXCJpbWFnZV9zcmNcXFxcXCIgaHJlZj1cXFxcXCJcXFxcXCI+XFxcXG48bGluayByZWw9XFxcXFwiaWNvblxcXFxcIiB0eXBlPVxcXFxcImltYWdlL3BuZ1xcXFxcIiBocmVmPVxcXFxcIi9pbWcvaWNvbi5pY29cXFxcXCI+XFxcXG5cXFxcbjxsaW5rIGhyZWY9XFxcXFwiL2Nzcy9tYWluLmNzc1xcXFxcIiByZWw9XFxcXFwic3R5bGVzaGVldFxcXFxcIj5cXFxcbjxsaW5rIGhyZWY9XFxcXFwiL2Nzcy92ZW5kb3IubWluLmNzc1xcXFxcIiByZWw9XFxcXFwic3R5bGVzaGVldFxcXFxcIj5cXFxcbjxzY3JpcHQgc3JjPVxcXFxcIi92ZW5kb3IubWluLmpzXFxcXFwiPjwvc2NyaXB0PlxcXFxuPHNjcmlwdCBzcmM9XFxcXFwiL2J1bmRsZS5qc1xcXFxcIj48L3NjcmlwdD5cXFxcbjxzY3JpcHQ+c3ZnNGV2ZXJ5Ym9keSgpOzwvc2NyaXB0PlxcXFxuXFxcXG48IS0tW2lmIGx0IElFIDkgXT48IS0tPHNjcmlwdCBzcmM9XFxcXFwiL3NlcGFyYXRlLWpzL2h0bWw1c2hpdi0zLjcuMi5taW4uanNcXFxcXCIgdHlwZT1cXFxcXCJ0ZXh0L2phdmFzY3JpcHRcXFxcXCI+PC9zY3JpcHQ+PG1ldGEgY29udGVudD1cXFxcXCJub1xcXFxcIiBodHRwLWVxdWl2PVxcXFxcImltYWdldG9vbGJhclxcXFxcIj4tLT48IVtlbmRpZl0tLT5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiBudWxsfSxcbntuYW1lOiAnbG9hZGVyJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9sb2FkZXIvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwibG9hZGVyXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcXFwibG9hZGluZ1xcXFxcIj48L2Rpdj5cXFxcblxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogbnVsbH0sXG57bmFtZTogJ3NhbGUnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3NhbGUvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwic2FsZVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcIjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIiAgICA8aDI+0KDRg9Cx0YDQuNC60LDRgtC+0YA8L2gyPlxcXFxuXFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnJ1YnJpa2F0b3IgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgyLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiAgICA8aDI+0KHQutC40LTQutC4PC9oMj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc2FsZSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEzLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIiAgICA8Y2F0LWNvbW1vbi1wYWdpbmF0b3IgaWQ9XFxcXFwiY29tbW9uLXBhZ2luYXRvclxcXFxcIiBjYXQtc3RvcmU9XFxcXFwiUGFnaW5hdG9yXFxcXFwiIG1vZGVsPVxcXFxcInNhbGUvU2FsZUJ5UnVicmlrYVxcXFxcIj48L2NhdC1jb21tb24tcGFnaW5hdG9yPlxcXFxuXCI7XFxufSxcIjJcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIlwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hY3RpdmUgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyO1xcbn0sXCIzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGJ1ZmZlciA9IFwiICAgICAgICAgICAgPHA+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCIgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuc2FsZUNvdW50IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zYWxlQ291bnQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwic2FsZUNvdW50XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3A+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNoaWxkcmVuIDogZGVwdGgwKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oNCwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCJcXFxcblwiO1xcbn0sXCI0XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCJcIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucm9vdCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg1LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLnByb2dyYW0oMTAsIGRhdGEpLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyO1xcbn0sXCI1XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBsYW1iZGE9dGhpcy5sYW1iZGEsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgYnVmZmVyID0gXCIgICAgICAgICAgICAgICAgICAgIDxwPi0tLTxhIGhyZWY9XFxcXFwiL3NhbGUvY2F0YWxvZy9cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnJvb3QgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmlkIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnJvb3QgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLm5hbWUgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiPC9hPiBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5zYWxlQ291bnQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNhbGVDb3VudCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJzYWxlQ291bnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvcD5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnJvb3QgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmFjdGl2ZSA6IHN0YWNrMSksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg2LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXI7XFxufSxcIjZcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIlwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY2hpbGQgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg3LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXI7XFxufSxcIjdcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgYnVmZmVyID0gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tLS0tLTxhIGhyZWY9XFxcXFwiL3NhbGUvY2F0YWxvZy9cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5pZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaWQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvYT4gXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuc2FsZUNvdW50IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zYWxlQ291bnQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwic2FsZUNvdW50XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hY3RpdmUgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oOCwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxcXFxuXCI7XFxufSxcIjhcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDQsNC60YLQuNCy0L3QsNGPXFxcXG5cIjtcXG4gIH0sXCIxMFwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGJ1ZmZlciA9IFwiXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jaGlsZCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDExLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXI7XFxufSxcIjExXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgPHA+LS0tPGEgaHJlZj1cXFxcXCIvc2FsZS9jYXRhbG9nL1wiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmlkIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJpZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9hPiBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5zYWxlQ291bnQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNhbGVDb3VudCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJzYWxlQ291bnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvcD5cXFxcblwiO1xcbn0sXCIxM1wiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgPGRpdj5cXFxcbiAgICAgICAgICAgIFwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXG4gICAgICAgIDwvZGl2PlxcXFxuXCI7XFxufSxcIjE1XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCJcXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCBkZXB0aDAsIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDE2LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIlxcXFxuXCI7XFxufSxcIjE2XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGJ1ZmZlciA9IFwiICAgICAgICA8cD5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIiBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5zYWxlQ291bnQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNhbGVDb3VudCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJzYWxlQ291bnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvcD5cXFxcbiAgICAgICAgPGRpdj5cXFxcbiAgICAgICAgICAgIDxwPtC/0L7QtNGA0YPQsdGA0LjQutC4OjwvcD5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY2hpbGRyZW4gOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxNywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCIgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICA8ZGl2PlxcXFxuICAgICAgICAgICAgPHA+0LDQutGG0LjQuDwvcD5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc2FsZSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDIwLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIiAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDxocj5cXFxcblwiO1xcbn0sXCIxN1wiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGJ1ZmZlciA9IFwiXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzW1xcJ2lmXFwnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnJvb3QgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMTgsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMucHJvZ3JhbSgxMCwgZGF0YSksXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXI7XFxufSxcIjE4XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBsYW1iZGE9dGhpcy5sYW1iZGEsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZztcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgPHA+LS0tPGEgaHJlZj1cXFxcXCIvc2FsZS9jYXRhbG9nL1wiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucm9vdCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuaWQgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucm9vdCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEubmFtZSA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCI8L2E+IFwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnNhbGVDb3VudCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc2FsZUNvdW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInNhbGVDb3VudFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuXCI7XFxufSxcIjIwXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgIDxwPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCLQtNCw0L3QvdGL0LkgaGJzINGB0LTQtdC70LDQvSDRgtCw0Log0LTQu9GPINC/0YDQuNC80LXRgNCwINC10LPQviDQvNC+0LbQvdC+INGA0LDQt9Cx0LjRgtGMINC00LvRjyDRg9C00L7QsdGB0YLQstCwINC/0L4g0LHQu9C+0LrQsNC8XFxcXG5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jdXJyZW50UnVicmlrYSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLnByb2dyYW0oMTUsIGRhdGEpLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCJcXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdzZWFyY2gnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3NlYXJjaC9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJzZWFyY2hcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiIHNlYXJjaF9cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5tb2RpZmljYXRvciB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kaWZpY2F0b3IgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibW9kaWZpY2F0b3JcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIiBcIjtcXG59LFwiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgYnVmZmVyID0gXCI8ZGl2IGNsYXNzPVxcXFxcInNlYXJjaCBcIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubW9kaWZpY2F0b3IgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCJcXFxcXCI+XFxcXG4gICAgPGZvcm0gY2xhc3M9XFxcXFwic2VhcmNoX19mb3JtXFxcXFwiIGFjdGlvbj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51cmwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIiBtZXRob2Q9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubWV0aG9kIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tZXRob2QgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibWV0aG9kXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwic2VhcmNoX190aXRsZVxcXFxcIj5cXFxcbiAgICAgICAgICAgIFwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJzZWFyY2hcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCJcXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwic2VhcmNoX19maWVsZFxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJzZWFyY2hfX2ZpZWxkLWlucHV0IGlucHV0LXRleHRcXFxcXCIgdHlwZT1cXFxcXCJ0ZXh0XFxcXFwiIG5hbWU9XFxcXFwic2VhcmNoXFxcXFwiPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJzZWFyY2hfX2J1dHRvblxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcXFwic2VhcmNoX19idXR0b24tc3VibWl0XFxcXFwiIHR5cGU9XFxcXFwic3VibWl0XFxcXFwiPtC90LDQudC00Lgg0YPRgdC70YPQs9GDPC9idXR0b24+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuICAgIDwvZm9ybT5cXFxcbjwvZGl2PlxcXFxuXCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ3NlcnZpY2UtcmVxdWVzdCcsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvc2VydmljZS1yZXF1ZXN0L2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInNlcnZpY2UtcmVxdWVzdFwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdzb2NpYWwnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3NvY2lhbC9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJzb2NpYWxcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgIDxsaSBjbGFzcz1cXFxcXCJzb2NpYWxfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgIDxhIGNsYXNzPVxcXFxcInNvY2lhbF9faXRlbS1saW5rIGxpbmtcXFxcXCIgaHJlZj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51cmwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIiB0YXJnZXQ9XFxcXFwiX2JsYW5rXFxcXFwiPlxcXFxuICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaWNvIDogZGVwdGgwKSwgXCJpY29uX3doaXRlXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXG4gICAgICAgIDwvYT5cXFxcbiAgICA8L2xpPlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCI8dWwgY2xhc3M9XFxcXFwic29jaWFsXFxcXFwiPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsIGRlcHRoMCwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCI8L3VsPlxcXFxuXCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ2NvbW1vbi1oMScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvX2NvbW1vbi9jb21tb24taDEvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwiY29tbW9uLWgxXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCI8aDEgY2xhc3M9XFxcXFwiaDEgaDFfc3R5bGVcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L2gxPlxcXFxuXCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ2NvbW1vbi1wYWdpbmF0b3InLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL19jb21tb24vY29tbW9uLXBhZ2luYXRvci9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJjb21tb24tcGFnaW5hdG9yXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGxhbWJkYT10aGlzLmxhbWJkYSwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGJ1ZmZlciA9IFwiICAgIDxkaXYgY2xhc3M9XFxcXFwicGFnaW5hdG9yXFxcXFwiPlxcXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFxcXCJwYWdpbmF0b3JfX3RpdGxlXFxcXFwiPtCf0LXRgNC10LnRgtC4INC6INGB0YLRgNCw0L3QuNGG0LU6IDwvc3Bhbj5cXFxcbiAgICAgICAgPHVsIGNsYXNzPVxcXFxcInBhZ2luYXRvcl9fbGlzdFxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxsaSBjbGFzcz1cXFxcXCJwYWdpbmF0b3JfX3BhZ2UgcGFnaW5hdG9yX19wYWdlX3ByZXZpb3VzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcInBhZ2luYXRvcl9fbnVtYmVyXFxcXFwiIGhyZWY9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zdGFydCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEudXJsIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxcIj4mbHQ7PC9hPlxcXFxuICAgICAgICAgICAgPC9saT5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubGlzdCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDIsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcInBhZ2luYXRvcl9fcGFnZSBwYWdpbmF0b3JfX3BhZ2VfbmV4dFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJwYWdpbmF0b3JfX251bWJlclxcXFxcIiBocmVmPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZW5kIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS51cmwgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPiZndDs8L2E+XFxcXG4gICAgICAgICAgICA8L2xpPlxcXFxuICAgICAgICA8L3VsPlxcXFxuICAgIDwvZGl2PlxcXFxuXCI7XFxufSxcIjJcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIlwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMFtcXCdpcy1zZWxlY3RlZFxcJ10gOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5wcm9ncmFtKDUsIGRhdGEpLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyO1xcbn0sXCIzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XFxcXFwicGFnaW5hdG9yX19wYWdlIHBhZ2luYXRvcl9fcGFnZV9zZWxlY3RlZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwYWdpbmF0b3JfX251bWJlclxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5udW1iZXIgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm51bWJlciA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJudW1iZXJcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvc3Bhbj48L2xpPlxcXFxuXCI7XFxufSxcIjVcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFxcXCJwYWdpbmF0b3JfX3BhZ2VcXFxcXCI+PGEgY2xhc3M9XFxcXFwicGFnaW5hdG9yX19udW1iZXJcXFxcXCIgaHJlZj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51cmwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5udW1iZXIgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm51bWJlciA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJudW1iZXJcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvYT48L2xpPlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMTtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDBbXFwnaXMtcGFnaW5hdG9yXFwnXSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IHJldHVybiBzdGFjazE7IH1cXG4gIGVsc2UgeyByZXR1cm4gXFwnXFwnOyB9XFxuICB9LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAnbWFzdGVyLWZpbHRlcicsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvbWFzdGVyL21hc3Rlci1maWx0ZXIvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwibWFzdGVyLWZpbHRlclwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcIjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgYnVmZmVyID0gXCIgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZmlsdGVyLXNlY3Rpb25cXFxcXCI+XFxcXG4gICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJmaWx0ZXItc2VjdGlvbl9fdGl0bGUgZmlsdGVyLXNlY3Rpb25fX3RpdGxlX1wiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnNlY3Rpb25OYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zZWN0aW9uTmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJzZWN0aW9uTmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiIFwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5vcGVuU2VjdGlvbiA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgyLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiBqcy1maWx0ZXItdG9nZ2xlLWJ0blxcXFxcIiBocmVmPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnVybCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudXJsIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInVybFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZmlsdGVyLXNlY3Rpb25fX2ljb25cXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAub3BlblNlY3Rpb24gOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oNCwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5wcm9ncmFtKDYsIGRhdGEpLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCIgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmaWx0ZXItc2VjdGlvbl9fYXJyb3dcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAub3BlblNlY3Rpb24gOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oOCwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5wcm9ncmFtKDEwLCBkYXRhKSxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgYnVmZmVyICs9IFwiICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPC9hPlxcXFxuXFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnd2l0aFxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5vcGVuU2VjdGlvbiA6IGRlcHRoMCksIHtcIm5hbWVcIjpcIndpdGhcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEyLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIiAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiMlwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcImFjdGl2ZVwiO1xcbiAgfSxcIjRcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaWNvIDogZGVwdGgwKSwgXCJpY29uX3doaXRlXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXG5cIjtcXG59LFwiNlwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pY28gOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIlxcXFxuXCI7XFxufSxcIjhcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcInN0cmVsa2FcIiwgXCJkb3duXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXG5cIjtcXG59LFwiMTBcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcInN0cmVsa2FcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCJcXFxcblwiO1xcbn0sXCIxMlwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGJ1ZmZlciA9IFwiICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZmlsdGVyLXNlY3Rpb25fX3NlY3Rpb24ganMtZmlsdGVyLXRvZ2dsZS1zZWN0aW9uXFxcXFwiPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzW1xcJ2lmXFwnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNvcnRCeSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxMywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCJcXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50YWdzR3JvdXAgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMTUsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuXCI7XFxufSxcIjEzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgbGFtYmRhPXRoaXMubGFtYmRhLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwic29ydC1ieVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJzb3J0LWJ5X190aXRsZVxcXFxcIj7QntGC0YHQvtGA0YLQuNGA0L7QstCw0YLRjDogPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGZvcm0gY2xhc3M9XFxcXFwic29ydC1ieV9fZm9ybVxcXFxcIiBhY3Rpb249XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zb3J0QnkgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnVybCA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCJcXFxcXCIgbWV0aG9kPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc29ydEJ5IDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5tZXRob2QgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImZpbHRlci1yYWRpb1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJmaWx0ZXItcmFkaW9fX2lucHV0XFxcXFwiIHR5cGU9XFxcXFwicmFkaW9cXFxcXCIgbmFtZT1cXFxcXCJzb3J0LWJ5XFxcXFwiIHZhbHVlPVxcXFxcIm5hbWVcXFxcXCIgaWQ9XFxcXFwic29ydC1ieS1uYW1lXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXFxcImZpbHRlci1yYWRpb19fbGFiZWxcXFxcXCIgZm9yPVxcXFxcInNvcnQtYnktbmFtZVxcXFxcIj7Qv9C+INGE0LDQvNC40LvQuNC4INC/0L4g0LDQu9GE0LDQstC40YLRgzwvbGFiZWw+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImZpbHRlci1yYWRpb1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJmaWx0ZXItcmFkaW9fX2lucHV0XFxcXFwiIHR5cGU9XFxcXFwicmFkaW9cXFxcXCIgbmFtZT1cXFxcXCJzb3J0LWJ5XFxcXFwiIHZhbHVlPVxcXFxcInJlY29tbWVuZGF0aW9uXFxcXFwiIGlkPVxcXFxcInNvcnQtYnktcmVjb21tZW5kYXRpb25cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcXFwiZmlsdGVyLXJhZGlvX19sYWJlbFxcXFxcIiBmb3I9XFxcXFwic29ydC1ieS1yZWNvbW1lbmRhdGlvblxcXFxcIj7Qv9C+INC60L7Qu9C40YfQtdGB0YLQstGDXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg0YDQtdC60L7QvNC10L3QtNCw0YbQuNC5PC9sYWJlbD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiMTVcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZmlsdGVyLWJ5XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImZpbHRlci1ieV9fdGl0bGVcXFxcXCI+0J7RgtGE0LjQu9GM0YLRgNC+0LLQsNGC0Yw6PC9wPlxcXFxuXFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRhZ3NHcm91cCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDE2LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiMTZcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIlwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxNywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50YWdzIDogZGVwdGgwKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMTksIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlcjtcXG59LFwiMTdcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJmaWx0ZXItYnlfX3RpdGxlXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuXCI7XFxufSxcIjE5XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCJcIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaXNBY3RpdmUgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMjAsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMucHJvZ3JhbSgyMiwgZGF0YSksXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXI7XFxufSxcIjIwXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXFxcImZpbHRlci1ieV9fdGFnLWFjdGl2ZVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmaWx0ZXItYnlfX2Nsb3NlXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiZmlsdGVyLWJ5X19jbG9zZS1saW5rXFxcXFwiIGhyZWY9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudXJsQmFjayB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudXJsQmFjayA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxCYWNrXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmaWx0ZXItYnlfX2Nsb3NlLWljb25cXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcImNsb3NlXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cXFxcblwiO1xcbn0sXCIyMlwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJmaWx0ZXItYnlfX3RhZ1xcXFxcIiBocmVmPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnBhdGggfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnBhdGggOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwicGF0aFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cXFxcblwiO1xcbn0sXCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGJ1ZmZlciA9IFwiPGRpdiBjbGFzcz1cXFxcXCJmaWx0ZXJcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmZpbHRlclNlY3Rpb24gOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIjwvZGl2PlwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdtYXN0ZXItbGlzdCcsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvbWFzdGVyL21hc3Rlci1saXN0L2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcIm1hc3Rlci1saXN0XCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtYXN0ZXItbGlzdF9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxjYXQtbWFzdGVyLW1pbmljYXJkIGlkPVxcXFxcIm1hc3Rlci1taW5pY2FyZC1cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5pZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaWQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIiBtYXN0ZXItaWQ9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImlkXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCIgY2F0LXN0b3JlPVxcXFxcIm1hc3Rlci9NYXN0ZXJMaXN0XFxcXFwiPjwvY2F0LW1hc3Rlci1taW5pY2FyZD5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGJ1ZmZlciA9IFwiPGRpdiBjbGFzcz1cXFxcXCJtYXN0ZXItbGlzdFxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCBkZXB0aDAsIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiICAgIDxkaXYgY2xhc3M9XFxcXFwid2FpdC1zcGlubmVyXFxcXFwiIGlkPVxcXFxcIndhaXQtc3Bpbm5lclxcXFxcIj48ZGl2IGNsYXNzPVxcXFxcIndhaXQtc3Bpbm5lcl9fYW5pbWF0ZVxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwic3Bpbm5lclwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvZGl2PjwvZGl2PlxcXFxuPC9kaXY+PCEtLW1hc3Rlci1saXN0LS0+XCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ21hc3Rlci1wYWdlJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLXBhZ2UvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwibWFzdGVyLXBhZ2VcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBsYW1iZGE9dGhpcy5sYW1iZGE7XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1jYXJkLW1wX19jb21wYW55XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+PGltZyBjbGFzcz1cXFxcXCJtYXN0ZXItY2FyZC1tcF9fbG9nb1xcXFxcIiBzcmM9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pbWdTcmMgfHwgKGRlcHRoMCAmJiBkZXB0aDAuaW1nU3JjKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY29tcGFueSA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuaW1nSUQgOiBzdGFjazEpLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubnVsbCA6IGRlcHRoMCksIDcwLCB7XCJuYW1lXCI6XCJpbWdTcmNcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXFwiIGFsdD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbXBhbnkgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLm5hbWUgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPjwvc3Bhbj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY29tcGFueSA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEubmFtZSA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCI8L3NwYW4+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvcD5cXFxcblwiO1xcbn0sXCIzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgbGFtYmRhPXRoaXMubGFtYmRhLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbnRhY3RzIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5waG9uZSA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCI8YnI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9XFxcXFwiY29sb3I6IHJlZDsgZm9udC13ZWlnaHQ6IGJvbGRcXFxcXCI+d29ya1Bob25lIC0gRVJST1IhPC9zcGFuPlxcXFxuXCI7XFxufSxcIjVcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAg0L3QtSDRg9C60LDQt9Cw0L3QvlxcXFxuXCI7XFxuICB9LFwiN1wiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGxhbWJkYT10aGlzLmxhbWJkYSwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiY29udGFjdHMtbXBfX2FuY2hcXFxcXCIgaHJlZj1cXFxcXCJtYWlsdG86XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb250YWN0cyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuZW1haWwgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY29udGFjdHMgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmVtYWlsIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIjwvYT5cXFxcblwiO1xcbn0sXCI5XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgbGFtYmRhPXRoaXMubGFtYmRhLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbnRhY3RzIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5za3lwZSA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCJcXFxcblwiO1xcbn0sXCIxMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGxhbWJkYT10aGlzLmxhbWJkYSwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb250YWN0cyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuaWNxIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxuXCI7XFxufSxcIjEzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgbGFtYmRhPXRoaXMubGFtYmRhLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbnRhY3RzIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5hZGRyIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIjxicj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFxcXCJjb250YWN0cy1tcF9fb25tYXBcXFxcXCI+PGEgY2xhc3M9XFxcXFwiY29udGFjdHMtbXBfX2FuY2hcXFxcXCIgaHJlZj1cXFxcXCIjXFxcXFwiPtC90LAg0LrQsNGA0YLQtTwvYT4g4oaSPC9zcGFuPlxcXFxuXCI7XFxufSxcIjE1XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCJcIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYWNjZXNzIDogZGVwdGgwKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDE2LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXI7XFxufSxcIjE2XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCIgICAgICAgICAgICAgICAgPGxpPlwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hY3RpdmUgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMTcsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMucHJvZ3JhbSgxOSwgZGF0YSksXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIjwvbGk+XFxcXG5cIjtcXG59LFwiMTdcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBsYW1iZGE9dGhpcy5sYW1iZGEsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZztcXG4gIHJldHVybiBcIjxhIGhyZWY9XFxcXFwiI21hc3Rlci1ibG9jay1cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKChkYXRhICYmIGRhdGEua2V5KSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvYT5cIjtcXG59LFwiMTlcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCI8c3Bhbj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvc3Bhbj5cIjtcXG59LFwiMjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIlwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hY2Nlc3MgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMjIsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlcjtcXG59LFwiMjJcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIlwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hY3RpdmUgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMjMsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlcjtcXG59LFwiMjNcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGxhbWJkYT10aGlzLmxhbWJkYTtcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwibWFzdGVyLXBhZ2VfX3NlY3Rpb24tdGl0bGVcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtYXN0ZXItcGFnZV9fc2VjdGlvbi1jb250XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGNhdC1tYXN0ZXItYmxvY2stXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoZGF0YSAmJiBkYXRhLmtleSksIGRlcHRoMCkpXFxuICAgICsgXCIgaWQ9XFxcXFwibWFzdGVyLWJsb2NrLVwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKGRhdGEgJiYgZGF0YS5rZXkpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJtYXN0ZXIvTWFzdGVySXRlbVxcXFxcIiBtYXN0ZXItcGFnZT1cXFxcXCJ0cnVlXFxcXFwiPjwvY2F0LW1hc3Rlci1ibG9jay1cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKChkYXRhICYmIGRhdGEua2V5KSwgZGVwdGgwKSlcXG4gICAgKyBcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgbGFtYmRhPXRoaXMubGFtYmRhLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwibWFzdGVyLXBhZ2VcXFxcXCI+PCEtLSBtcCAtIG1hc3Rlci1wYWdlIC0tPlxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwibWFzdGVyLXBhZ2VfX3Jvd1xcXFxcIj5cXFxcblxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1hc3Rlci1wYWdlX19tYXN0ZXItY2FyZFxcXFxcIj5cXFxcblxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtYXN0ZXItcGFnZV9fYXZhdGFyLWNvbnRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGltZyBzcmM9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pbWdTcmMgfHwgKGRlcHRoMCAmJiBkZXB0aDAuaW1nU3JjKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmltZ0lEIDogZGVwdGgwKSwge1wibmFtZVwiOlwiaW1nU3JjXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIlxcXFxcIiBhbHQ9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwibWFzdGVyLXBhZ2VfX2xpa2VcXFxcXCIgc3R5bGU9XFxcXFwiY29sb3I6IHJlZDsgZm9udC13ZWlnaHQ6IGJvbGRcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcImxpa2VcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCIgMTI5PC9pPlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibWFzdGVyLWNhcmQtbXBcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGgxIGNsYXNzPVxcXFxcIm1hc3Rlci1jYXJkLW1wX19uYW1lXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9oMT5cXFxcblxcXFxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1jYXJkLW1wX19zcGVjXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnNwZWMgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNwZWMgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwic3BlY1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuXFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY29tcGFueSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtYXN0ZXItY2FyZC1tcF9fbWFzdGVyLW51bWJlclxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwibWFzdGVyLW51bWJlclxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXFxcIm1hc3Rlci1udW1iZXJfX3RpdGxlXFxcXFwiPtC70LjRh9C90YvQuSDQvdC+0LzQtdGAINCc0LDRgdGC0LXRgNCwPC9zcGFuPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcXFwibWFzdGVyLW51bWJlcl9fbnVtYmVyXFxcXFwiPuKEllwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucGFnZSA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEubnVtYmVyIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIjwvc3Bhbj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXFxcIm1hc3Rlci1udW1iZXJfX3ByaW50XFxcXFwiPjxhIGNsYXNzPVxcXFxcIm1hc3Rlci1udW1iZXJfX3ByaW50XFxcXFwiIGhyZWY9XFxcXFwiI1xcXFxcIj7RgNCw0YHQv9C10YfQsNGC0LDRgtGMINCy0LjQt9C40YLQutGDPC9hPjwvc3Bhbj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9wPlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibWFzdGVyLXBhZ2VfX2NvbnRhY3QtY29udFxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiY29udGFjdHMtbXBcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJjb250YWN0cy1tcF9fY2FwXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8cD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJwaG9uZVwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT48YnI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj4rNyAqKiogKioqLSoqLSoqPC9zcGFuPlxcXFxuICAgICAgICAgICAgICAgICAgICA8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiY29udGFjdHMtbXBfX3Nob3ctY29udGFjdFxcXFxcIiBocmVmPVxcXFxcIlxcXFxcIj7Qn9C+0LrQsNC30LDRgtGMINC60L7QvdGC0LDQutGC0Ys8L2E+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cXFxcblxcXFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFxcXCJjb250YWN0cy1tcF9fbGlzdFxcXFxcIj5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8bGk+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8aT5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwicGhvbmVcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb250YWN0cyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEucGhvbmUgOiBzdGFjazEpLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5wcm9ncmFtKDUsIGRhdGEpLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCIgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGxpPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGk+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcImVtYWlsXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzW1xcJ2lmXFwnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY29udGFjdHMgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmVtYWlsIDogc3RhY2sxKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDcsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMucHJvZ3JhbSg1LCBkYXRhKSxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgYnVmZmVyICs9IFwiICAgICAgICAgICAgICAgICAgICA8L2xpPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIDxsaT48aT5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwic2t5cGVcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb250YWN0cyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuc2t5cGUgOiBzdGFjazEpLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oOSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5wcm9ncmFtKDUsIGRhdGEpLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCIgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGxpPjxpPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJpY3FcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb250YWN0cyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuaWNxIDogc3RhY2sxKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDExLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLnByb2dyYW0oNSwgZGF0YSksXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8bGk+PGk+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcInBsYWNlbWFya1wiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbnRhY3RzIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5hZGRyIDogc3RhY2sxKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEzLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLnByb2dyYW0oNSwgZGF0YSksXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxcbiAgICAgICAgICAgICAgICA8L3VsPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiY29udGFjdHMtbXBfX2EtY2FsbGJhY2sganMtc2hvdy1jYWxsYmFjay1wb3B1cFxcXFxcIiBocmVmPVxcXFxcIiNjYWxsYmFjay1yZXF1ZXN0LXBvcHVwXFxcXFwiPtC30LDQutCw0LfQsNGC0YxcXFxcbiAgICAgICAgICAgICAgICAgICAg0LfQstC+0L3QvtC6PC9hPlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuICAgIDwvZGl2PlxcXFxuXFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJjYWxsYmFjay1wb3B1cFxcXFxcIj5cXFxcbiAgICAgICAgPGZvcm0gY2xhc3M9XFxcXFwiY2FsbGJhY2stcG9wdXBfX2Zvcm1cXFxcXCIgaWQ9XFxcXFwiY2FsbGJhY2stcmVxdWVzdC1wb3B1cC1mb3JtXFxcXFwiIG1ldGhvZD1cXFxcXCJcXFxcXCIgYWN0aW9uPVxcXFxcIlxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJjYWxsYmFjay1wb3B1cF9faW5wdXQtdGV4dFxcXFxcIiB0eXBlPVxcXFxcInRleHRcXFxcXCIgcGxhY2Vob2xkZXI9XFxcXFwi0JLQsNGI0LUg0LjQvNGPXFxcXFwiIG5hbWU9XFxcXFwiY2FsbGJhY2tSZXF1ZXN0Rm9ybVtuYW1lXVxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJjYWxsYmFjay1wb3B1cF9faW5wdXQtdGV4dFxcXFxcIiB0eXBlPVxcXFxcInRleHRcXFxcXCIgcGxhY2Vob2xkZXI9XFxcXFwi0JLQsNGIINGC0LXQu9C10YTQvtC9XFxcXFwiIG5hbWU9XFxcXFwiY2FsbGJhY2tSZXF1ZXN0Rm9ybVtwaG9uZV1cXFxcXCI+XFxcXG4gICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XFxcXFwiY2FsbGJhY2stcG9wdXBfX3RleHRhcmVhXFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCS0LDRiCDQutC+0LzQvNC10L3RgtCw0YDQuNC5XFxcXFwiIG5hbWU9XFxcXFwiY2FsbGJhY2tSZXF1ZXN0Rm9ybVt0ZXh0XVxcXFxcIj48L3RleHRhcmVhPlxcXFxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXFxcImNhbGxiYWNrLXBvcHVwX19idG5cXFxcXCIgdHlwZT1cXFxcXCJzdWJtaXRcXFxcXCIgdmFsdWU9XFxcXFwi0L7RgtC/0YDQsNCy0LjRgtGMINC30LDRj9Cy0LrRg1xcXFxcIj5cXFxcbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPVxcXFxcImNvbG9yOiByZWQ7IGZvbnQtd2VpZ2h0OiBib2xkXFxcXFwiPtCe0YLQv9GA0LDQstC60LAg0YTQvtGA0LzRiyDQvdC1INGA0LDQsdC+0YLQsNC10YIgLSBFUlJPUiE8L3NwYW4+XFxcXG4gICAgICAgIDwvZm9ybT5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJzdWNjZXNzX3Jlc3BvbnNlXFxcXFwiPlxcXFxuICAgICAgICAgICAg0JLQsNGI0LAg0LfQsNGP0LLQutCwINC+0YLQv9GA0LDQstC70LXQvdCwINCc0LDRgdGC0LXRgNGDXFxcXG4gICAgICAgIDwvZGl2PlxcXFxuICAgIDwvZGl2PlxcXFxuXFxcXG4gICAgPHVsIGNsYXNzPVxcXFxcIm1lbnUtbXBcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlzQmxvY2sgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxNSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCIgICAgPC91bD5cXFxcbiAgICA8IS0tIG1lbnUtbXAgLS0+XFxcXG5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcIm1hc3Rlci1wYWdlX19jb250ZW50XFxcXFwiPlxcXFxuXFxcXG4gICAgICAgIDwhLS0g0KPQtNCw0LvQuNGC0Ywg0LrQvtCz0LTQsCDQt9Cw0YDQsNCx0L7RgtCw0Y7RgiDRg9GB0LvRg9Cz0LggLS0+XFxcXG4gICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1wYWdlX19zZWN0aW9uLXRpdGxlXFxcXFwiPtCj0YHQu9GD0LPQuDwvcD5cXFxcblxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1hc3Rlci1wYWdlX19zZWN0aW9uLWNvbnRcXFxcXCI+XFxcXG4gICAgICAgICAgICA8Y2F0LW1hc3Rlci1ibG9jay1zZXJ2aWNlIGlkPVxcXFxcIm1hc3Rlci1ibG9jay1zZXJ2aWNlXFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJtYXN0ZXIvTWFzdGVySXRlbVxcXFxcIiBtYXN0ZXItcGFnZT1cXFxcXCJ0cnVlXFxcXFwiPjwvY2F0LW1hc3Rlci1ibG9jay1zZXJ2aWNlPlxcXFxuICAgICAgICAgICAgPCEtLSBFUlJPUiAtLT5cXFxcbiAgICAgICAgICAgIDxicj5cXFxcbiAgICAgICAgICAgIDxwIHN0eWxlPVxcXFxcImNvbG9yOiByZWQ7IGZvbnQtd2VpZ2h0OiBib2xkXFxcXFwiPi0tLS0tLSBFUlJPUiEgKNCj0YHQu9GD0LPQuCkgLS0tLS0tPC9wPlxcXFxuICAgICAgICAgICAgISHQv9C10YDQtdC00LXQu9Cw0LXRgiDQuNC70YzRj1xcXFxuICAgICAgICAgICAgPCEtLSBFUlJPUiAtLT5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwhLS0g0KPQtNCw0LvQuNGC0Ywg0LrQvtCz0LTQsCDQt9Cw0YDQsNCx0L7RgtCw0Y7RgiDRg9GB0LvRg9Cz0LggLSDQutC+0L3QtdGGIC0tPlxcXFxuXFxcXG4gICAgICAgIDwhLS0g0KPQtNCw0LvQuNGC0Ywg0LrQvtCz0LTQsCDQt9Cw0YDQsNCx0L7RgtCw0Y7RgiDRgdGB0YvQu9C60LggLS0+XFxcXG4gICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1wYWdlX19zZWN0aW9uLXRpdGxlXFxcXFwiPtCh0YHRi9C70LrQuDwvcD5cXFxcblxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1hc3Rlci1wYWdlX19zZWN0aW9uLWNvbnRcXFxcXCI+XFxcXG4gICAgICAgICAgICA8Y2F0LW1hc3Rlci1ibG9jay1saW5rIGlkPVxcXFxcIm1hc3Rlci1ibG9jay1saW5rXFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJtYXN0ZXIvTWFzdGVySXRlbVxcXFxcIiBtYXN0ZXItcGFnZT1cXFxcXCJ0cnVlXFxcXFwiPjwvY2F0LW1hc3Rlci1ibG9jay1saW5rPlxcXFxuICAgICAgICAgICAgPCEtLSBFUlJPUiAtLT5cXFxcbiAgICAgICAgICAgIDxicj5cXFxcbiAgICAgICAgICAgIDxwIHN0eWxlPVxcXFxcImNvbG9yOiByZWQ7IGZvbnQtd2VpZ2h0OiBib2xkXFxcXFwiPi0tLS0tLSBFUlJPUiEgKNCb0LjQvdC60LgpIC0tLS0tLTwvcD5cXFxcbiAgICAgICAgICAgICEh0L/QtdGA0LXQtNC10LvQsNC10YIg0LjQu9GM0Y9cXFxcbiAgICAgICAgICAgIDwhLS0gRVJST1IgLS0+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuICAgICAgICA8IS0tINCj0LTQsNC70LjRgtGMINC60L7Qs9C00LAg0LfQsNGA0LDQsdC+0YLQsNGO0YIg0YHRgdGL0LvQutC4IC0g0LrQvtC90LXRhiAtLT5cXFxcblxcXFxuXFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlzQmxvY2sgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgyMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgPC9kaXY+XFxcXG48L2Rpdj5cXFxcbjwhLS0gbWFzdGVyLXBhZ2UgLS0+XCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ21hc3Rlci1yZWNvbW1lbmRlZCcsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvbWFzdGVyL21hc3Rlci1yZWNvbW1lbmRlZC9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJtYXN0ZXItcmVjb21tZW5kZWRcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCIgICAgPGRpdiBjbGFzcz1cXFxcXCJtYXN0ZXJfcmVjb21tZW5kZWRcXFxcXCI+XFxcXG4gICAgICAgIDxoMiBjbGFzcz1cXFxcXCJtYXN0ZXJfcmVjb21tZW5kZWRfX3RpdGxlXFxcXFwiPlxcXFxuICAgICAgICAgICAg0K3RgtC40YU8YnI+XFxcXG4gICAgICAgICAgICDQnNCw0YHRgtC10YDQvtCyPGJyPlxcXFxuICAgICAgICAgICAg0YDQtdC60L7QvNC10L3QtNGD0Y7RglxcXFxuICAgICAgICA8L2gyPlxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibWFzdGVyX3JlY29tbWVuZGVkX19zbGlkZXJcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwW1xcJ3JlY29tbWVuZGVkLW1hc3RlclxcJ10gOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgyLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIiAgICAgICAgPC9kaXY+XFxcXG4gICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiMlwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJtYXN0ZXJfcmVjb21tZW5kZWRfX21hc3RlclxcXFxcIiBocmVmPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzW1xcJ21hc3Rlci11cmxcXCddIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMFtcXCdtYXN0ZXItdXJsXFwnXSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJtYXN0ZXItdXJsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcXFwibWFzdGVyX3JlY29tbWVuZGVkX19tYXN0ZXItcGhvdG9cXFxcXCIgc3JjPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnNyYyB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc3JjIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInNyY1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiIGFsdD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5hbHQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmFsdCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJhbHRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJtYXN0ZXJfcmVjb21tZW5kZWRfX21hc3Rlci1uYW1lXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnNbXFwnbWFzdGVyLW5hbWVcXCddIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMFtcXCdtYXN0ZXItbmFtZVxcJ10gOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibWFzdGVyLW5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICA8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwibWFzdGVyX3JlY29tbWVuZGVkX19tYXN0ZXItcmVjb21tZW5kYXRpb25zXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnNbXFwncmVjb21tZW5kYXRpb24tbnVtYmVyXFwnXSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDBbXFwncmVjb21tZW5kYXRpb24tbnVtYmVyXFwnXSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJyZWNvbW1lbmRhdGlvbi1udW1iZXJcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICA8L3A+XFxcXG4gICAgICAgICAgICAgICAgPC9hPlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMTtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDBbXFwnaXMtcmVjb21tZW5kZWQtbWFzdGVyc1xcJ10gOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyByZXR1cm4gc3RhY2sxOyB9XFxuICBlbHNlIHsgcmV0dXJuIFxcJ1xcJzsgfVxcbiAgfSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ21hc3Rlci1ydWJyaWthJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLXJ1YnJpa2EvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwibWFzdGVyLXJ1YnJpa2FcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgbGFtYmRhPXRoaXMubGFtYmRhLCBidWZmZXIgPSBcIiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJzZW8tdGV4dFxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwic2VvLXRleHRfX3RleHQgZm9ybWF0XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIFwiO1xcbiAgc3RhY2sxID0gbGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmN1cnJlbnRTZW8gOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnRleHQgOiBzdGFjazEpLCBkZXB0aDApO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgbGFtYmRhPXRoaXMubGFtYmRhLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGJ1ZmZlciA9IFwiPGRpdiBjbGFzcz1cXFxcXCJpbm5lci10b3BcXFxcXCI+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJpbm5lci10b3BfX3RpdGxlXFxcXFwiPlxcXFxuICAgICAgICA8Y2F0LWNvbW1vbi1oMSBpZD1cXFxcXCJjb21tb24taDFcXFxcXCIgbmFtZT1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmN1cnJlbnRTZW8gOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnBhZ2VUaXRsZSA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCJcXFxcXCI+PC9jYXQtY29tbW9uLWgxPlxcXFxuICAgIDwvZGl2PlxcXFxuXFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJpbm5lci10b3BfX3NlYXJjaFxcXFxcIj5cXFxcbiAgICAgICAgPGNhdC1zZWFyY2ggaWQ9XFxcXFwic2VhcmNoXFxcXFwiIG1vZGlmaWNhdG9yPVxcXFxcImlubmVyXFxcXFwiPjwvY2F0LXNlYXJjaD5cXFxcbiAgICA8L2Rpdj5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcImlubmVyLXRvcF9fY2FsbGJhY2tcXFxcXCI+XFxcXG4gICAgICAgIDxhIGNsYXNzPVxcXFxcInJlcXVlc3RcXFxcXCIgaHJlZj1cXFxcXCIvcmVxdWVzdFxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwicmVxdWVzdF9faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwic3Rhci1pbi1zdW5cIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2Rpdj5cXFxcbiAgICAgICAgICAgINCe0YLQv9GA0LDQstC40YLRjCDQt9Cw0LTQsNC90LjQtSDQvNCw0YHRgtC10YDQsNC8XFxcXG4gICAgICAgIDwvYT5cXFxcbiAgICA8L2Rpdj5cXFxcbjwvZGl2PlxcXFxuPGRpdiBjbGFzcz1cXFxcXCJpbm5lci1jb250ZW50XFxcXFwiPlxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwiaW5uZXItY29udGVudF9fbGVmdC1zaWRlXFxcXFwiPlxcXFxuICAgICAgICA8Y2F0LW1hc3Rlci1maWx0ZXIgaWQ9XFxcXFwibWFzdGVyLWZpbHRlclxcXFxcIiBjYXQtc3RvcmU9XFxcXFwiVGFnXFxcXFwiPjwvY2F0LW1hc3Rlci1maWx0ZXI+XFxcXG4gICAgICAgIHsgez4gYmFubmVyL2Jhbm5lcl9zaWRlL2Jhbm5lcl9zaWRlIGJhbm5lcl9zaWRlfSB9XFxcXG4gICAgPC9kaXY+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJpbm5lci1jb250ZW50X19yaWdodC1zaWRlXFxcXFwiPlxcXFxuICAgICAgICA8Y2F0LW1hc3Rlci1yZWNvbW1lbmRlZCBpZD1cXFxcXCJtYXN0ZXItcmVjb21tZW5kZWRcXFxcXCIgY2F0LXN0b3JlPVxcXFxcIm1hc3Rlci9SZWNvbW1lbmRlZFxcXFxcIj48L2NhdC1tYXN0ZXItcmVjb21tZW5kZWQ+XFxcXG4gICAgICAgIDxjYXQtbWFzdGVyLWxpc3QgaWQ9XFxcXFwibWFzdGVyLWxpc3RcXFxcXCIgY2F0LXN0b3JlPVxcXFxcIm1hc3Rlci9NYXN0ZXJMaXN0XFxcXFwiPjwvY2F0LW1hc3Rlci1saXN0PlxcXFxuICAgIDwvZGl2PlxcXFxuPC9kaXY+XFxcXG48ZGl2IGNsYXNzPVxcXFxcInJvd1xcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmN1cnJlbnRTZW8gOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnRleHQgOiBzdGFjazEpLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCI8L2Rpdj5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAnb3RoZXItbmV3cycsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvb3RoZXIvb3RoZXItbmV3cy9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJvdGhlci1uZXdzXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJuZXdzXFxcXFwiPlxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJuZXdzX19pbm5lclxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm5ld3NfX2ltZy13clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cXFxcXCJuZXdzX19pbWdcXFxcXCIgc3JjPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnNyYyB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc3JjIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInNyY1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiIGFsdD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm5ld3NfX2NvbnRlbnRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm5ld3NfX3RpdGxlXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm5ld3NfX2ludHJvXFxcXFwiPlwiO1xcbiAgc3RhY2sxID0gKChoZWxwZXJzLnN0cmlwVGFncyB8fCAoZGVwdGgwICYmIGRlcHRoMC5zdHJpcFRhZ3MpIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucHJldmlldyA6IGRlcHRoMCksIHtcIm5hbWVcIjpcInN0cmlwVGFnc1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm5ld3NfX2RhdGVcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5mb3JtYXREYXRlIHx8IChkZXB0aDAgJiYgZGVwdGgwLmZvcm1hdERhdGUpIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZGF0ZSA6IGRlcHRoMCksIFwiJWQgJVogJVlcIiwge1wibmFtZVwiOlwiZm9ybWF0RGF0ZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwibmV3c19fbW9yZVxcXFxcIiBocmVmPVxcXFxcIi9uZXdzL2l0ZW0vXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImlkXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICDQv9C+0LTRgNC+0LHQvdC10LVcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXFxcIm5ld3NfX2ljb25cXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcInN0cmVsa2FcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvYT5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm5ld3NfX2F1dG9yXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8cD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgINCd0L7QstC+0YHRgtGMINC00L7QsdCw0LLQuNC7OiA8YnI+IEVSUk9SXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5hdXRvciB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYXV0b3IgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiYXV0b3JcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICA8L3A+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwibmV3cy1saXN0XFxcXFwiPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5kYXRhIDogZGVwdGgwKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCI8L2Rpdj5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdvdGhlci1uZXdzLWl0ZW0nLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL290aGVyL290aGVyLW5ld3MtaXRlbS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJvdGhlci1uZXdzLWl0ZW1cIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIlxcXFxuPGNhdC1jb21tb24taDEgaWQ9XFxcXFwiY29tbW9uLWgxXFxcXFwiIG5hbWU9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGl0bGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRpdGxlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+PC9jYXQtY29tbW9uLWgxPlxcXFxuXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImlkXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcblwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmltZyB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaW1nIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImltZ1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXG5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5kYXRlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5kYXRlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImRhdGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxuXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMucHJldmlldyB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucHJldmlldyA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJwcmV2aWV3XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcblwiO1xcbiAgc3RhY2sxID0gKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50ZXh0IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50ZXh0IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRleHRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCJcXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdvdGhlci1yZWNvbW1lbmRhdGlvbicsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvb3RoZXIvb3RoZXItcmVjb21tZW5kYXRpb24vaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwib3RoZXItcmVjb21tZW5kYXRpb25cIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGJ1ZmZlciA9IFwiICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJlY29tbWVuZGF0aW9uXFxcXFwiPlxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJyZWNvbW1lbmRhdGlvbl9faW5uZXJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJyZWNvbW1lbmRhdGlvbl9faW1nLXdyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVxcXFxcInJlY29tbWVuZGF0aW9uX19pbWdcXFxcXCIgc3JjPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnBob3RvIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5waG90byA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJwaG90b1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiIGFsdD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJlY29tbWVuZGF0aW9uX19jb250ZW50XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJyZWNvbW1lbmRhdGlvbl9fdGl0bGVcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGl0bGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRpdGxlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJyZWNvbW1lbmRhdGlvbl9faW50cm9cXFxcXCI+XCI7XFxuICBzdGFjazEgPSAoKGhlbHBlcnMuc3RyaXBTdHlsZSB8fCAoZGVwdGgwICYmIGRlcHRoMC5zdHJpcFN0eWxlKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRleHQgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJzdHJpcFN0eWxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCI8L2Rpdj5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJyZWNvbW1lbmRhdGlvbl9fZGF0ZVxcXFxcIj5FUlJPUlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmRhdGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmRhdGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiZGF0ZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCI8ZGl2IGNsYXNzPVxcXFxcInJlY29tbWVuZGF0aW9uLWxpc3RcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmRhdGEgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIjwvZGl2PlwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJFUlJPUlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ290aGVyLXZhY2FuY3knLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL290aGVyL290aGVyLXZhY2FuY3kvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwib3RoZXItdmFjYW5jeVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcIjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCIgICAgPHA+PHN0cm9uZz7QodC10LnRh9Cw0YEg0L7RgtC60YDRi9GC0Ysg0LLQsNC60LDQvdGB0LjQuDo8L3N0cm9uZz48L3A+XFxcXG5cIjtcXG4gIH0sXCIzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgIDxwPjxhIGhyZWY9XFxcXFwiL3ZhY2FuY3kvaXRlbS9cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5pZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaWQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5wb3N0IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wb3N0IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInBvc3RcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvYT48L3A+XFxcXG5cIjtcXG59LFwiNVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIiAgICA8cD48c3Ryb25nPtCh0LXQudGH0LDRgSDQvtGC0LrRgNGL0YLRi9GFINCy0LDQutCw0L3RgdC40Lkg0L3QtdGCLjwvc3Ryb25nPjwvcD5cXFxcblwiO1xcbiAgfSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCJcIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudmFjYW5jeSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnZhY2FuY3kgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgzLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLnByb2dyYW0oNSwgZGF0YSksXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ290aGVyLXZhY2FuY3ktaXRlbScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvb3RoZXIvb3RoZXItdmFjYW5jeS1pdGVtL2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcIm90aGVyLXZhY2FuY3ktaXRlbVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGJ1ZmZlciA9IFwiPGRpdiBjbGFzcz1cXFxcXCJ2YWNhbmN5LW9uZS1wYWdlXFxcXFwiPlxcXFxuICAgIDxoMSBjbGFzcz1cXFxcXCJoMSBoMV9zdHlsZVxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5wb3N0IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wb3N0IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInBvc3RcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvaDE+XFxcXG4gICAgPGltZyBjbGFzcz1cXFxcXCJ2YWNhbmN5LW9uZS1wYWdlX19pbWdcXFxcXCIgc3JjPVxcXFxcIi9pbWcvb3RoZXIvdmFjYW5jeS5wbmdcXFxcXCIgYWx0PVxcXFxcItCd0LDRiNC4INCy0LDQutCw0L3RgdC40LhcXFxcXCI+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJ2YWNhbmN5LW9uZS1wYWdlX190ZXh0IGZvcm1hdFxcXFxcIj5cXFxcbiAgICAgICAgXCI7XFxuICBzdGFjazEgPSAoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRleHQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRleHQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidGV4dFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIlxcXFxuICAgIDwvZGl2PlxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwidmFjYW5jeS1vbmUtcGFnZV9fY29udGFjdCBmb3JtYXRcXFxcXCI+XFxcXG5cXFxcbiAgICAgICAgPCEtLSBFUlJPUiAtLT5cXFxcbiAgICAgICAgXCI7XFxuICBzdGFjazEgPSAoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmNvbnRhY3QgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbnRhY3QgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiY29udGFjdFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIlxcXFxuICAgICAgICA8cCBzdHlsZT1cXFxcXCJjb2xvcjogcmVkOyBmb250LXdlaWdodDogYm9sZFxcXFxcIj4tLS0tLS0gRVJST1IhICjQvdC10YIg0L/QvtC70Y8gY29udGFjdCkgLS0tLS0tPC9wPlxcXFxuICAgICAgICA8IS0tIEVSUk9SIC0tPlxcXFxuXFxcXG4gICAgPC9kaXY+XFxcXG48L2Rpdj5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLWNhdGFsb2cnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1jYXRhbG9nL2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInBhZ2UtY2F0YWxvZ1wiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJtYXN0ZXItcnVicmlrYXRvci1wYWdlIG1hc3Rlci1ydWJyaWthdG9yLXBhZ2VfY29sbGFwc2VkXFxcXFwiPlxcXFxuXFxcXG4gICAgPGNhdC1jb21tb24taDEgaWQ9XFxcXFwiY29tbW9uLWgxXFxcXFwiIG5hbWU9XFxcXFwi0JrQsNGC0LDQu9C+0LMg0YPRgdC70YPQs1xcXFxcIj48L2NhdC1jb21tb24taDE+XFxcXG5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcInJvd1xcXFxcIj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtYXN0ZXItcnVicmlrYXRvci1wYWdlX19ydWJyaWtzLWNvbHVtbnNcXFxcXCI+XFxcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJvd1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8Y2F0LXJ1YnJpa2F0b3ItbGlzdCBpZD1cXFxcXCJydWJyaWthdG9yLWxpc3RcXFxcXCIgY2F0LXN0b3JlPVxcXFxcInJ1YnJpa2EvUnVicmlrYXRvclxcXFxcIj48L2NhdC1ydWJyaWthdG9yLWxpc3Q+XFxcXG4gICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibWFzdGVyLXJ1YnJpa2F0b3ItcGFnZV9fZG9wXFxcXFwiPlxcXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwibWFzdGVyLXJ1YnJpa2F0b3ItcGFnZV9fZG9wLXRpdGxlXFxcXFwiPtCU0YDRg9Cz0LjQtSDQstC+0LfQvNC+0LbQvdC+0YHRgtC4XFxcXG4gICAgICAgICAgICAgICAg0LIg0L/QvtC00LHQvtGA0LUg0LzQsNGB0YLQtdGA0LA8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibWFzdGVyLXJ1YnJpa2F0b3ItcGFnZV9fZG9wLWNhdGFsb2dzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxjYXQtY2F0YWxvZy1saXN0IGlkPVxcXFxcImNhdGFsb2ctbGlzdFxcXFxcIiBkYXRhLW1vZD1cXFxcXCJwYWdlX3J1YnJpa2F0b3JcXFxcXCI+PC9jYXQtY2F0YWxvZy1saXN0PlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuICAgIDwvZGl2PlxcXFxuPC9kaXY+XFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLWNvbnRhY3QnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1jb250YWN0L2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInBhZ2UtY29udGFjdFwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJjb250YWN0LXBhZ2VcXFxcXCI+XFxcXG4gICAgPGgxIGNsYXNzPVxcXFxcImgxIGgxX3N0eWxlXFxcXFwiPtCa0L7QvdGC0LDQutGC0Ys8L2gxPlxcXFxuXFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJjb250YWN0LWJsb2NrXFxcXFwiPlxcXFxuICAgICAgICA8cCBjbGFzcz1cXFxcXCJjb250YWN0LWJsb2NrX19waG9uZVxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJjb250YWN0LWJsb2NrX19uYW1lXFxcXFwiPtCi0LXQu9C10YTQvtC9Ojwvc3Bhbj4gXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMucGhvbmUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnBob25lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInBob25lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3A+XFxcXG4gICAgICAgIDxwIGNsYXNzPVxcXFxcImNvbnRhY3QtYmxvY2tfX2VtYWlsXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcImNvbnRhY3QtYmxvY2tfX25hbWVcXFxcXCI+RS1tYWlsOjwvc3Bhbj4gPGEgaHJlZj1cXFxcXCJtYWlsdG86XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZW1haWwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmVtYWlsIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImVtYWlsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZW1haWwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmVtYWlsIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImVtYWlsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L2E+PC9wPlxcXFxuICAgICAgICA8cCBjbGFzcz1cXFxcXCJjb250YWN0LWJsb2NrX19hZHJlc3NcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwiY29udGFjdC1ibG9ja19fbmFtZVxcXFxcIj7QkNC00YDQtdGBOjwvc3Bhbj4gXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuYWRyZXNzIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hZHJlc3MgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiYWRyZXNzXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3A+XFxcXG4gICAgPC9kaXY+XFxcXG5cXFxcbjwvZGl2PlwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLWZlZWRiYWNrJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtZmVlZGJhY2svaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwicGFnZS1mZWVkYmFja1wiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJmZWVkYmFjay1wYWdlXFxcXFwiPlxcXFxuICAgIDxoMSBjbGFzcz1cXFxcXCJoMSBoMV9zdHlsZVxcXFxcIj7QntCx0YDQsNGC0L3QsNGPINGB0LLRj9C30Yw8L2gxPlxcXFxuXFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJmZWVkYmFjay1ibG9ja1xcXFxcIj5cXFxcbiAgICAgICAgPGZvcm0gY2xhc3M9XFxcXFwiZmVlZGJhY2stYmxvY2tfX2Zvcm1cXFxcXCIgaWQ9XFxcXFwiZmVlZGJhY2stZm9ybVxcXFxcIiBhY3Rpb249XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudXJsIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC51cmwgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidXJsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCIgbWV0aG9kPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm1ldGhvZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubWV0aG9kIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm1ldGhvZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgPGxhYmVsPlxcXFxuICAgICAgICAgICAgICAgIDxzcGFuPtCS0LDRiNC1INC40LzRjzwvc3Bhbj5cXFxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFxcXCJ0ZXh0XFxcXFwiIG5hbWU9XFxcXFwiZmVlZGJhY2tbbmFtZV1cXFxcXCIgYXV0b2ZvY3VzPlxcXFxuICAgICAgICAgICAgPC9sYWJlbD5cXFxcblxcXFxuICAgICAgICAgICAgPGxhYmVsPlxcXFxuICAgICAgICAgICAgICAgIDxzcGFuPtCS0LDRiCBlLW1haWw8L3NwYW4+XFxcXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcXFwidGV4dFxcXFxcIiBuYW1lPVxcXFxcImZlZWRiYWNrW2VtYWlsXVxcXFxcIj5cXFxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxcXG5cXFxcbiAgICAgICAgICAgIDxsYWJlbD5cXFxcbiAgICAgICAgICAgICAgICA8c3Bhbj7QktCw0YjQtSDRgdC+0L7QsdGJ0LXQvdC40LU8L3NwYW4+XFxcXG4gICAgICAgICAgICAgICAgPHRleHRhcmVhIG5hbWU9XFxcXFwiZmVlZGJhY2tbdGV4dF1cXFxcXCI+PC90ZXh0YXJlYT5cXFxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxcXG5cXFxcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJidG4tYWNjZW50XFxcXFwiIHR5cGU9XFxcXFwic3VibWl0XFxcXFwiIHZhbHVlPVxcXFxcItCe0YLQv9GA0LDQstC40YLRjFxcXFxcIj5cXFxcbiAgICAgICAgPC9mb3JtPlxcXFxuICAgIDwvZGl2PlxcXFxuPC9kaXY+XFxcXG5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAncGFnZS1sb2dpbicsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLWxvZ2luL2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInBhZ2UtbG9naW5cIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBsYW1iZGE9dGhpcy5sYW1iZGE7XFxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXFxcInBhZ2UtbG9naW5cXFxcXCI+XFxcXG4gICAgPGgxIGNsYXNzPVxcXFxcImgxIGgxX3N0eWxlXFxcXFwiPtCS0YXQvtC0IC8g0YDQtdCz0LjRgdGC0YDQsNGG0LjRjzwvaDE+XFxcXG5cXFxcbiAgICA8Zm9ybSBjbGFzcz1cXFxcXCJsb2dpbi1mb3JtXFxcXFwiIG1ldGhvZD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5tZXRob2QgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1ldGhvZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJtZXRob2RcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIiBhY3Rpb249XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudXJsIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC51cmwgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidXJsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJsb2dpbi1mb3JtX19pbnB1dC10ZXh0XFxcXFwiIHR5cGU9XFxcXFwidGV4dFxcXFxcIiBwbGFjZWhvbGRlcj1cXFxcXCLQrdC7LiDQv9C+0YfRgtCwINC40LvQuCDRgtC10LvQtdGE0L7QvVxcXFxcIiBuYW1lPVxcXFxcImxvZ2luRm9ybVtsb2dpbl1cXFxcXCI+XFxcXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJsb2dpbi1mb3JtX19pbnB1dC10ZXh0XFxcXFwiIHR5cGU9XFxcXFwicGFzc3dvcmRcXFxcXCIgcGxhY2Vob2xkZXI9XFxcXFwi0J/QsNGA0L7Qu9GMXFxcXFwiIG5hbWU9XFxcXFwibG9naW5Gb3JtW3Bhc3N3b3JkXVxcXFxcIj5cXFxcbiAgICAgICAgPGxhYmVsIGNsYXNzPVxcXFxcImxvZ2luLWZvcm1fX2xhYmVsLWNoZWNrYm94XFxcXFwiPjxpbnB1dCB0eXBlPVxcXFxcImNoZWNrYm94XFxcXFwiIGlkPVxcXFxcInJlbWVtYmVyLW1lXFxcXFwiPjxzcGFuPtCX0LDQv9C+0LzQvdC40YLRjCDQvNC10L3Rjzwvc3Bhbj48L2xhYmVsPlxcXFxuICAgICAgICA8aW5wdXQgY2xhc3M9XFxcXFwibG9naW4tZm9ybV9fYnRuXFxcXFwiIHR5cGU9XFxcXFwic3VibWl0XFxcXFwiIHZhbHVlPVxcXFxcItCS0L7QudGC0LhcXFxcXCI+XFxcXG5cXFxcbiAgICAgICAgPHAgY2xhc3M9XFxcXFwibG9naW4tZm9ybV9faHJlZi1jb250XFxcXFwiPlxcXFxuICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwibG9naW4tZm9ybV9fcmVjb3ZlcnlcXFxcXCIgaHJlZj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVyc1tcXCdyZWNvdmVyeS11cmxcXCddIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMFtcXCdyZWNvdmVyeS11cmxcXCddIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInJlY292ZXJ5LXVybFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPtCX0LDQsdGL0LvQuCDQv9Cw0YDQvtC70Yw/PC9hPlxcXFxuICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwibG9naW4tZm9ybV9fcmVnaXN0cmF0aW9uXFxcXFwiIGhyZWY9XFxcXFwiI1xcXFxcIiBpZD1cXFxcXCJyZWctbGlua1xcXFxcIj7QoNC10LPQuNGB0YLRgNCw0YbQuNGPPC9hPlxcXFxuICAgICAgICAgICAgPGJyPlxcXFxuICAgICAgICA8L3A+XFxcXG4gICAgPC9mb3JtPlxcXFxuXFxcXG4gICAgPGZvcm0gY2xhc3M9XFxcXFwicmVnaXN0cmF0aW9uLWZvcm1cXFxcXCIgbWV0aG9kPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm1ldGhvZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubWV0aG9kIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm1ldGhvZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiIGFjdGlvbj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51cmwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbiAgICAgICAgPGlucHV0IGNsYXNzPVxcXFxcInJlZ2lzdHJhdGlvbi1mb3JtX19pbnB1dC10ZXh0XFxcXFwiIHR5cGU9XFxcXFwiZW1haWxcXFxcXCIgcGxhY2Vob2xkZXI9XFxcXFwi0K3Quy4g0L/QvtGH0YLQsFxcXFxcIiBuYW1lPVxcXFxcInJlZ0Zvcm1bbG9naW5dXFxcXFwiPlxcXFxuICAgICAgICA8aW5wdXQgY2xhc3M9XFxcXFwicmVnaXN0cmF0aW9uLWZvcm1fX2lucHV0LXRleHRcXFxcXCIgdHlwZT1cXFxcXCJ0ZXh0XFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCY0LzRjyDQpNCw0LzQuNC70LjRj1xcXFxcIiBuYW1lPVxcXFxcInJlZ0Zvcm1bbmFtZV1cXFxcXCI+XFxcXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJyZWdpc3RyYXRpb24tZm9ybV9faW5wdXQtdGV4dFxcXFxcIiB0eXBlPVxcXFxcInBhc3N3b3JkXFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCf0LDRgNC+0LvRjFxcXFxcIiBuYW1lPVxcXFxcInJlZ0Zvcm1bcGFzc3dvcmRdXFxcXFwiPlxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwicmVnaXN0cmF0aW9uLWZvcm1fX2NhcGNoYSByZWdpc3RyYXRpb24tZm9ybV9fY2FwY2hhX3JlZ2lzdHJhdGlvblxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwicmVnaXN0cmF0aW9uLWZvcm1fX2NvZGUtaW1nXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPVxcXFxcImltZy9hc3NldHMvcmVjb3ZlcnktcGFzc3dvcmQvY2FwdGNoYS5wbmdcXFxcXCIgYWx0PVxcXFxcImNhcGNoYVxcXFxcIj5cXFxcbiAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwicmVnaXN0cmF0aW9uLWZvcm1fX3JlbG9hZC1saW5rXFxcXFwiIGhyZWY9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jYXBjaGEgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxW1xcJ3JlbG9hZC11cmxcXCddIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxcIj7Qn9C+0LvRg9GH0LjRgtGMINC90L7QstGL0Lkg0LrQvtC0PC9hPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcblxcXFxuICAgICAgICA8aW5wdXQgY2xhc3M9XFxcXFwicmVnaXN0cmF0aW9uLWZvcm1fX2lucHV0LXRleHRcXFxcXCIgdHlwZT1cXFxcXCJ0ZXh0XFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCa0L7QtCDRgSDQutCw0YDRgtC40L3QutC4XFxcXFwiIG5hbWU9XFxcXFwicmVnRm9ybVtjb2RlXVxcXFxcIj5cXFxcbiAgICAgICAgPGlucHV0IGNsYXNzPVxcXFxcInJlZ2lzdHJhdGlvbi1mb3JtX19idG4gcmVnaXN0cmF0aW9uLWZvcm1fX2J0bl9sb25nLXRleHRcXFxcXCIgdHlwZT1cXFxcXCJzdWJtaXRcXFxcXCIgdmFsdWU9XFxcXFwi0JfQsNGA0LXQs9C40YHRgtGA0LjRgNC+0LLQsNGC0YzRgdGPXFxcXFwiPlxcXFxuICAgICAgICA8cCBjbGFzcz1cXFxcXCJyZWdpc3RyYXRpb24tZm9ybV9fZW50cnlcXFxcXCI+PGEgaHJlZj1cXFxcXCIjXFxcXFwiIGlkPVxcXFxcImVudHJ5LWxpbmtcXFxcXCI+0JLQvtC50YLQuDwvYT48L3A+XFxcXG4gICAgPC9mb3JtPlxcXFxuXFxcXG4gICAgPGZvcm0gY2xhc3M9XFxcXFwicmVjb3ZlcnktcGFzcy1mb3JtXFxcXFwiIG1ldGhvZD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5tZXRob2QgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1ldGhvZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJtZXRob2RcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIiBhY3Rpb249XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudXJsIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC51cmwgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidXJsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJyZWNvdmVyeS1wYXNzLWZvcm1fX2lucHV0LXRleHRcXFxcXCIgdHlwZT1cXFxcXCJ0ZXh0XFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCt0LsuINC/0L7Rh9GC0LAg0LjQu9C4INGC0LXQu9C10YTQvtC9XFxcXFwiIG5hbWU9XFxcXFwicmVjb3ZlcnktcGFzc3dvcmRbbG9naW5dXFxcXFwiIGF1dG9mb2N1cz5cXFxcblxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJlY292ZXJ5LXBhc3MtZm9ybV9fY2FwY2hhIHJlY292ZXJ5LXBhc3MtZm9ybV9fY2FwY2hhX3JlZ2lzdHJhdGlvblxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwicmVjb3ZlcnktcGFzcy1mb3JtX19jb2RlLWltZ1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8aW1nIHNyYz1cXFxcXCJpbWcvYXNzZXRzL3JlY292ZXJ5LXBhc3N3b3JkL2NhcHRjaGEucG5nXFxcXFwiIGFsdD1cXFxcXCJjYXBjaGFcXFxcXCI+XFxcXG4gICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcInJlY292ZXJ5LXBhc3MtZm9ybV9fcmVsb2FkLWxpbmtcXFxcXCIgaHJlZj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNhcGNoYSA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazFbXFwncmVsb2FkLXVybFxcJ10gOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPtCf0L7Qu9GD0YfQuNGC0Ywg0L3QvtCy0YvQuSDQutC+0LQ8L2E+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuXFxcXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJyZWNvdmVyeS1wYXNzLWZvcm1fX2lucHV0LXRleHRcXFxcXCIgdHlwZT1cXFxcXCJ0ZXh0XFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCa0L7QtCDRgSDQutCw0YDRgtC40L3QutC4XFxcXFwiIG5hbWU9XFxcXFwicmVjb3ZlcnktcGFzc3dvcmRbY29kZV1cXFxcXCI+XFxcXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJyZWNvdmVyeS1wYXNzLWZvcm1fX2J0blxcXFxcIiB0eXBlPVxcXFxcInN1Ym1pdFxcXFxcIiB2YWx1ZT1cXFxcXCLQktC+0YHRgdGC0LDQvdC+0LLQuNGC0YxcXFxcXCI+XFxcXG4gICAgPC9mb3JtPlxcXFxuXFxcXG48L2Rpdj5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLW1haW4nLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1tYWluL2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInBhZ2UtbWFpblwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJtYWluLXBhZ2VcXFxcXCI+XFxcXG4gICAgPGNhdC1tYWluLWZ1bmN0aW9uIGlkPVxcXFxcIm1haW4tZnVuY3Rpb25cXFxcXCI+PC9jYXQtbWFpbi1mdW5jdGlvbj5cXFxcbiAgICA8Y2F0LWRvcC1mdW5jdGlvbiBpZD1cXFxcXCJkb3AtZnVuY3Rpb25cXFxcXCI+PC9jYXQtZG9wLWZ1bmN0aW9uPlxcXFxuPC9kaXY+XFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLW1hc3Rlci1wYWdlJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtbWFzdGVyLXBhZ2UvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwicGFnZS1tYXN0ZXItcGFnZVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiPGgxIGNsYXNzPVxcXFxcImgxIGgxX3N0eWxlXFxcXFwiPtCh0YLRgNCw0L3QuNGG0LAg0JzQsNGB0YLQtdGA0LA8L2gxPlxcXFxuPGNhdC1tYXN0ZXItcGFnZSBpZD1cXFxcXCJtYXN0ZXItcGFnZVxcXFxcIiBjYXQtc3RvcmU9XFxcXFwibWFzdGVyL01hc3Rlckl0ZW1cXFxcXCI+PC9jYXQtbWFzdGVyLXBhZ2U+XFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLW1hc3Rlci1ydWJyaWthJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtbWFzdGVyLXJ1YnJpa2EvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwicGFnZS1tYXN0ZXItcnVicmlrYVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJjb250YWluZXJcXFxcXCI+XFxcXG4gICAgPGNhdC1tYXN0ZXItcnVicmlrYSBpZD1cXFxcXCJtYXN0ZXItcnVicmlrYVxcXFxcIiBjYXQtc3RvcmU9XFxcXFwiVGFnXFxcXFwiPjwvY2F0LW1hc3Rlci1ydWJyaWthPlxcXFxuPC9kaXY+XCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAncGFnZS1uZXdzJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtbmV3cy9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJwYWdlLW5ld3NcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcXFwicGFnZV9vdGhfbmV3c1xcXFxcIj5cXFxcbiAgICA8Y2F0LWNvbW1vbi1oMSBpZD1cXFxcXCJjb21tb24taDFcXFxcXCIgbmFtZT1cXFxcXCLQndC+0LLQvtGB0YLQuFxcXFxcIj48L2NhdC1jb21tb24taDE+XFxcXG5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcInBhZ2Vfb3RoX25ld3NfX2xpc3RcXFxcXCI+XFxcXG4gICAgICAgIDxjYXQtb3RoZXItbmV3cyBpZD1cXFxcXCJvdGhlci1uZXdzXFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJvdGhlci9OZXdzXFxcXFwiPjwvY2F0LW90aGVyLW5ld3M+XFxcXG4gICAgICAgIDxjYXQtY29tbW9uLXBhZ2luYXRvciBpZD1cXFxcXCJjb21tb24tcGFnaW5hdG9yXFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJQYWdpbmF0b3JcXFxcXCIgbW9kZWw9XFxcXFwib3RoZXIvTmV3c1xcXFxcIj48L2NhdC1jb21tb24tcGFnaW5hdG9yPlxcXFxuICAgIDwvZGl2PlxcXFxuPC9kaXY+XCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAncGFnZS1uZXdzLWl0ZW0nLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1uZXdzLWl0ZW0vaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwicGFnZS1uZXdzLWl0ZW1cIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcXFwicGFnZV9vdGhfbmV3c1xcXFxcIj5cXFxcbiAgICA8Y2F0LW90aGVyLW5ld3MtaXRlbSBpZD1cXFxcXCJvdGhlci1uZXdzXFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJvdGhlci9OZXdzSXRlbVxcXFxcIj48L2NhdC1vdGhlci1uZXdzLWl0ZW0+XFxcXG48L2Rpdj5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLW9mZXJ0YScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLW9mZXJ0YS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJwYWdlLW9mZXJ0YVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJvZmVydGEtcGFnZVxcXFxcIj5cXFxcblxcXFxuICAgIDxoMSBjbGFzcz1cXFxcXCJoMSBoMV9zdHlsZVxcXFxcIj7QntCk0JXQoNCi0JAg0L7RgiAwMS4wMy4yMDE1IDwvaDE+XFxcXG5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJ0YVxcXFxcIj5cXFxcbiAgICAgICAgPHA+PHN0cm9uZz7QvdCwINC/0L7Qu9GM0LfQvtCy0LDQvdC40LUg0KPRgdC70YPQs9Cw0LzQuCDQodCw0LnRgtCwIHd3dy5mYWNlbWFzdGVyLnJ1PC9zdHJvbmc+PC9wPlxcXFxuXFxcXG4gICAgICAgIDxwPtCX0JDQniDCq9Ck0LXQudGB0JzQsNGB0YLQtdGALtGA0YPCuywg0LjQvNC10L3Rg9C10LzQvtC1INCyINC00LDQu9GM0L3QtdC50YjQtdC8IMKr0JrQvtC80L/QsNC90LjRj8K7LCDQv9GA0LXQtNC+0YHRgtCw0LLQu9GP0LXRgiDQu9GO0LHQvtC80YMg0LvQuNGG0YMg0YPRgdC70YPQs9C4INC/0L4g0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40Y5cXFxcbiAgICAgICAgICAgINGB0LDQudGC0LAg0JrQvtC80L/QsNC90LjQuCDQsiDQu9C40YfQvdGL0YUg0YbQtdC70Y/RhSDQv9C+0YHRgNC10LTRgdGC0LLQvtC8INC/0YDQtdC00L7RgdGC0LDQstC70LXQvdC40Y8g0YHQtdGA0LLQuNGB0L7QsiDRgdCw0LnRgtCwINC90LAg0L/RgNC40LLQtdC00LXQvdC90YvRhSDQvdC40LbQtSDRg9GB0LvQvtCy0LjRj9GFLjwvcD5cXFxcblxcXFxuICAgICAgICA8cD7QkdC10LfRg9GB0LvQvtCy0L3Ri9C8INC/0YDQuNC90Y/RgtC40LXQvCAo0LDQutGG0LXQv9GC0L7QvCkg0YPRgdC70L7QstC40Lkg0L3QsNGB0YLQvtGP0YnQtdC5INC+0YTQtdGA0YLRiyDRgdGH0LjRgtCw0LXRgtGB0Y8g0L/QvtC70YzQt9C+0LLQsNC90LjQtSDQodCw0LnRgtC+0LwgPHN0cm9uZz5odHRwOi8vd3d3LmZhY2VtYXN0ZXIucnU8L3N0cm9uZz4sXFxcXG4gICAgICAgICAgICDQstC60LvRjtGH0LDRjyDQv9GA0L7RgdC80L7RgtGAINGB0YLRgNCw0L3QuNGGINCh0LDQudGC0LAsINC90LUg0LfQsNCy0LjRgdC40LzQviDQvtGCINC/0YDQvtGF0L7QttC00LXQvdC40Y8g0L/RgNC+0YbQtdC00YPRgNGLINCg0LXQs9C40YHRgtGA0LDRhtC40LguPC9wPlxcXFxuXFxcXG4gICAgICAgIDxwPtCd0LDRgdGC0L7Rj9GJ0LDRjyDQntGE0LXRgNGC0LAg0LzQvtC20LXRgiDQsdGL0YLRjCDQuNC30LzQtdC90LXQvdCwINC/0L4g0YPRgdC80L7RgtGA0LXQvdC40Y4g0JrQvtC80L/QsNC90LjQuCDQsiDQu9GO0LHQvtC1INCy0YDQtdC80Y8g0LHQtdC3INC60LDQutC+0LPQvi3Qu9C40LHQviDRgdC/0LXRhtC40LDQu9GM0L3QvtCz0L5cXFxcbiAgICAgICAgICAgINGD0LLQtdC00L7QvNC70LXQvdC40Y8g0L7QsSDRjdGC0L7QvCDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8uINCd0L7QstCw0Y8g0YDQtdC00LDQutGG0LjRjyDQntGE0LXRgNGC0YssINC40LfQvNC10L3QtdC90LjRjyDQuCDQtNC+0L/QvtC70L3QtdC90LjRjyDQuiDQvdC10Lkg0LLRgdGC0YPQv9Cw0Y7RgiDQsiDRgdC40LvRgyDRgVxcXFxuICAgICAgICAgICAg0LzQvtC80LXQvdGC0LAg0LjRhSDRgNCw0LfQvNC10YnQtdC90LjRjyDQvdCwINCh0LDQudGC0LUuINCg0LXQs9GD0LvRj9GA0L3QvtC1INC+0LfQvdCw0LrQvtC80LvQtdC90LjQtSDRgSDQtNC10LnRgdGC0LLRg9GO0YnQtdC5INGA0LXQtNCw0LrRhtC40LXQuSDQntGE0LXRgNGC0Ysg0Y/QstC70Y/QtdGC0YHRjyDQvtCx0Y/Qt9Cw0L3QvdC+0YHRgtGM0Y5cXFxcbiAgICAgICAgICAgINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjy4g0J/QvtC70YzQt9C+0LLQsNC90LjQtSDQodCw0LnRgtC+0Lwg0L/QvtGB0LvQtSDQstGB0YLRg9C/0LvQtdC90LjRjyDQsiDRgdC40LvRgyDQvdC+0LLQvtC5INGA0LXQtNCw0LrRhtC40Lgg0J7RhNC10YDRgtGLLCDQtNC+0L/QvtC70L3QtdC90LjQuSDQuCDQuNC30LzQtdC90LXQvdC40Lkg0Log0L3QtdC5XFxcXG4gICAgICAgICAgICDQvtC30L3QsNGH0LDQtdGCINGB0L7Qs9C70LDRgdC40LUg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GPINGB0L4g0LLRgdC10LzQuCDRgtCw0LrQuNC80Lgg0LjQt9C80LXQvdC10L3QuNGP0LzQuCDQuNC70Lgg0LTQvtC/0L7Qu9C90LXQvdC40Y/QvNC4LCDQvdC+0LLQvtC5INGA0LXQtNCw0LrRhtC40LXQuSDQntGE0LXRgNGC0YsuPC9wPlxcXFxuXFxcXG4gICAgICAgIDxicj5cXFxcblxcXFxuICAgICAgICA8cD48c3Ryb25nPjEuINCi0JXQoNCc0JjQndCrINC4INCe0JHQntCX0J3QkNCn0JXQndCY0K88L3N0cm9uZz48L3A+XFxcXG5cXFxcbiAgICAgICAgPHA+PHN0cm9uZz7QmtC+0LzQv9Cw0L3QuNGPPC9zdHJvbmc+IOKAkyDQl9CQ0J4gwqvQpNC10LnRgdCc0LDRgdGC0LXRgC7RgNGDwrs6INCe0JPQoNCdIDExMzYzMjAwMjA4MjUg0JjQndCdIDYzMjEzMjM0MDYsINCu0YDQuNC00LjRh9C10YHQutC40Lkg0LDQtNGA0LXRgTpcXFxcbiAgICAgICAgICAgIDQ0NTA1Niwg0LMu0KLQvtC70YzRj9GC0YLQuCwg0YPQuy7QkNCy0YLQvtGB0YLRgNC+0LjRgtC10LvQtdC5LCA0MdCQLCDQutC+0YDQvy4xPGJyPlxcXFxuICAgICAgICAgICAgPGJyPlxcXFxuICAgICAgICAgICAgPHN0cm9uZz7Qn9C+0LvRjNC30L7QstCw0YLQtdC70Ywv0JrQu9C40LXQvdGCPC9zdHJvbmc+IOKAkyDQtNC10LXRgdC/0L7RgdC+0LHQvdC+0LUsINCyINCy0L7Qt9GA0LDRgdGC0LUg0L7RgiAxOCDQu9C10YIsINGE0LjQt9C40YfQtdGB0LrQvtC1INC70LjRhtC+L9C/0YDQsNCy0L7RgdC/0L7RgdC+0LHQvdC+0LVcXFxcbiAgICAgICAgICAgINGO0YDQuNC00LjRh9C10YHQutC+0LUg0LvQuNGG0L4sINC/0YDQvtGI0LXQtNGI0LjQtSDQoNC10LPQuNGB0YLRgNCw0YbQuNGOINC90LAg0YHQsNC50YLQtSDQmtC+0LzQv9Cw0L3QuNC4LCDQuNC80LXRjtGJ0LjQtSDQstGB0LUg0L/RgNCw0LLQvtCy0YvQtSDQv9C+0LvQvdC+0LzQvtGH0LjRjyDQsiDRgdC+0L7RgtCy0LXRgtGB0YLQstC40Lgg0YFcXFxcbiAgICAgICAgICAgINC00LXQudGB0YLQstGD0Y7RidC40Lwg0LfQsNC60L7QvdC+0LTQsNGC0LXQu9GM0YHRgtCy0L7QvCDQoNCkINC90LAg0LfQsNC60LvRjtGH0LXQvdC40LUg0J7RhNC10YDRgtGLINC4INC40L3Ri9GFINGB0L7Qv9GD0YLRgdGC0LLRg9GO0YnQuNGFINC00L7QutGD0LzQtdC90YLQvtCyINC00LvRjyDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjRj1xcXFxuICAgICAgICAgICAg0LLQvtC30LzQvtC20L3QvtGB0YLQtdC5INCh0LDQudGC0LAg0JrQvtC80L/QsNC90LjQuC48YnI+XFxcXG4gICAgICAgICAgICA8YnI+XFxcXG4gICAgICAgICAgICA8c3Ryb25nPtCh0LDQudGCPC9zdHJvbmc+IOKAkyDQmNC90YLQtdGA0L3QtdGCLdGB0LDQudGCLCDRgNCw0LfQvNC10YnQtdC90L3Ri9C5INCyINGB0LXRgtC4INCY0L3RgtC10YDQvdC10YIg0L/QviDQsNC00YDQtdGB0YM6IHd3dy5mYWNlbWFzdGVyLnJ1LCDQstC60LvRjtGH0LDRjtGJ0LjQuVxcXFxuICAgICAgICAgICAg0LIg0YHQtdCx0Y8g0LrQvtC80L/Qu9C10LrRgSDRjdC70LXQvNC10L3RgtC+0LI6INC/0YDQvtCz0YDQsNC80LzRiyDQtNC70Y8g0K3QktCcLCDQsdCw0LfRiyDQtNCw0L3QvdGL0YUsINC40L3RgtC10YDRhNC10LnRgSAo0LTQuNC30LDQudC9KSwg0LrQsNC6INCyINGB0L7QstC+0LrRg9C/0L3QvtGB0YLQuCwg0YLQsNC6INC4XFxcXG4gICAgICAgICAgICDQvtGC0LTQtdC70YzQvdGL0LUg0Y3Qu9C10LzQtdC90YLRiyDQtNC40LfQsNC50L3QsCwg0Lgg0LTRgC48YnI+XFxcXG4gICAgICAgICAgICA8YnI+XFxcXG4gICAgICAgICAgICA8c3Ryb25nPtCT0L7RgdGC0Yw8L3N0cm9uZz4g4oCTINC70Y7QsdC+0LUg0LvQuNGG0L4sINC90LUg0L/RgNC+0YjQtdC00YjQtdC1INCg0LXQs9C40YHRgtGA0LDRhtC40Y4sINC40LzQtdGO0YnQtdC1INCy0L7Qt9C80L7QttC90L7RgdGC0Ywg0L/RgNC+0YHQvNCw0YLRgNC40LLQsNGC0Ywg0YHRgtGA0LDQvdC40YbRi1xcXFxuICAgICAgICAgICAg0KHQsNC50YLQsCDQuCDQmNC90YTQvtGA0LzQsNGG0LjRjiwg0YDQsNC30LzQtdGJ0LXQvdC90YPRjiDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y/QvNC4INC00LvRjyDQvtCx0YnQtdCz0L4g0LTQvtGB0YLRg9C/0LAuPGJyPlxcXFxuICAgICAgICAgICAgPGJyPlxcXFxuICAgICAgICAgICAgPHN0cm9uZz7QoNC10LPQuNGB0YLRgNCw0YbQuNGPPC9zdHJvbmc+IOKAkyDQutC+0LzQv9C70LXQutGBINC00LXQudGB0YLQstC40Lkg0L/QviDQv9GA0LjQvdGP0YLQuNGOINC+0YTQtdGA0YLRiywg0YDQsNC30LzQtdGJ0LXQvdC90L7QuSDQvdCwINCh0LDQudGC0LUsINGB0L7Qt9C00LDQvdC40Y4g0JvQuNGH0L3QvtCz0L5cXFxcbiAgICAgICAgICAgINC60LDQsdC40L3QtdGC0LAsINC/0YPRgtC10Lwg0LLQstC+0LTQsCDRg9GH0LXRgtC90YvRhSDQtNCw0L3QvdGL0YUg0Lgg0LjQvdGL0YUg0L3QtdC+0LHRhdC+0LTQuNC80YvRhSDRgdCy0LXQtNC10L3QuNC5LCDQuCDQv9C+0LvRg9GH0LXQvdC40Y4g0L/RgNCw0LLQsCDQvdCwINC/0L7Qu9GM0LfQvtCy0LDQvdC40LUg0KPRgdC70YPQs9Cw0LzQuFxcXFxuICAgICAgICAgICAg0JjQvdGC0LXRgNC90LXRgi3RgdCw0LnRgtCwLjxicj5cXFxcbiAgICAgICAgICAgIDxicj5cXFxcbiAgICAgICAgICAgIDxzdHJvbmc+0KPRh9C10YLQvdGL0LUg0LTQsNC90L3Ri9C1IDwvc3Ryb25nPuKAlCDRg9C90LjQutCw0LvRjNC90YvQuSDQu9C+0LPQuNC9ICjQvdC+0LzQtdGAINGC0LXQu9C10YTQvtC90LApINC4INC/0LDRgNC+0LvRjCwg0YHQvtC30LTQsNCy0LDQtdC80YvQtSDQsiDQv9GA0L7RhtC10YHRgdC1XFxcXG4gICAgICAgICAgICDQoNC10LPQuNGB0YLRgNCw0YbQuNC4INC90LAg0KHQsNC50YLQtSwg0LjRgdC/0L7Qu9GM0LfRg9C10LzRi9C1INC00LvRjyDQtNC+0YHRgtGD0L/QsCDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAg0LIg0JvQuNGH0L3Ri9C5INC60LDQsdC40L3QtdGCINC/0YPRgtC10Lwg0JDQstGC0L7RgNC40LfQsNGG0LjQuC48YnI+XFxcXG4gICAgICAgICAgICA8YnI+XFxcXG4gICAgICAgICAgICA8c3Ryb25nPtCQ0LLRgtC+0YDQuNC30LDRhtC40Y88L3N0cm9uZz4g4oCUINC40LTQtdC90YLQuNGE0LjQutCw0YbQuNGPINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjy/QmtC70LjQtdC90YLQsCDQv9C+0YHRgNC10LTRgdGC0LLQvtC8INCy0LLQtdC00LXQvdC40Y8g0LIg0YHQvtC+0YLQstC10YLRgdGC0LLRg9GO0YnQuNC1XFxcXG4gICAgICAgICAgICDQv9C+0LvRjyDQvdCwINCh0LDQudGC0LUg0KPRh9C10YLQvdGL0YUg0LTQsNC90L3Ri9GFLjxicj5cXFxcbiAgICAgICAgICAgIDxicj5cXFxcbiAgICAgICAgICAgIDxzdHJvbmc+0JvQuNGH0L3Ri9C5INC60LDQsdC40L3QtdGCIDwvc3Ryb25nPuKAlCDQv9C10YDRgdC+0L3QsNC70YzQvdCw0Y8g0YHRgtGA0LDQvdC40YbQsCDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAsINGE0L7RgNC80LjRgNGD0LXQvNCw0Y8g0L/QvtGB0LvQtSDQoNC10LPQuNGB0YLRgNCw0YbQuNC4LFxcXFxuICAgICAgICAgICAg0LTQvtGB0YLRg9C/INC6INC60L7RgtC+0YDQvtC5INC/0YDQtdC00L7RgdGC0LDQstC70Y/QtdGC0YHRjyDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y4v0JrQu9C40LXQvdGC0YMg0LIg0YDQtdC30YPQu9GM0YLQsNGC0LUg0JDQstGC0L7RgNC40LfQsNGG0LjQuC48YnI+XFxcXG4gICAgICAgICAgICA8YnI+XFxcXG4gICAgICAgICAgICA8c3Ryb25nPtCe0YTQtdGA0YLQsDwvc3Ryb25nPiDigJMg0L3QsNGB0YLQvtGP0YnQtdC1INC/0YDQtdC00LvQvtC20LXQvdC40LUg0JrQvtC80L/QsNC90LjQuCwg0LDQtNGA0LXRgdC+0LLQsNC90L3QvtC1INC90LXQvtC/0YDQtdC00LXQu9C10L3QvdC+0LzRgyDQutGA0YPQs9GDINC70LjRhiwg0YHQvtC00LXRgNC20LDRidC10LVcXFxcbiAgICAgICAgICAgINC/0YDQsNCy0LjQu9CwINC4INGD0YHQu9C+0LLQuNGPINC/0L7Qu9GM0LfQvtCy0LDQvdC40Y8g0KPRgdC70YPQs9Cw0LzQuCDQodCw0LnRgtCwLCDQsCDRgtCw0LrQttC1INC/0YDQsNCy0LAg0Lgg0L7QsdGP0LfQsNC90L3QvtGB0YLQuCDQn9C+0LvRjNC30L7QstCw0YLQtdC70LXQuS/QmtC70LjQtdC90YLQvtCyXFxcXG4gICAgICAgICAgICDQvtCx0Y/Qt9Cw0YLQtdC70YzQvdGL0LUg0LTQu9GPINC40YHQv9C+0LvQvdC10L3QuNGPINC/0YDQuCDRgNCw0LfQvNC10YnQtdC90LjQuCDQmNC90YTQvtGA0LzQsNGG0LjQuCDQvdCwINCh0LDQudGC0LUg0LTQu9GPINC+0LHRidC10LPQviDQtNC+0YHRgtGD0L/QsC48YnI+XFxcXG4gICAgICAgICAgICA8YnI+XFxcXG4gICAgICAgICAgICA8c3Ryb25nPtCj0YHQu9GD0LPQuDwvc3Ryb25nPiAtINCy0L7Qt9C80L7QttC90L7RgdGC0LggKNC/0YDQsNCy0LApLCDQv9GA0LXQtNC+0YHRgtCw0LLQu9GP0LXQvNGL0LUg0JrQvtC80L/QsNC90LjQtdC5INC4INC/0L7Qt9Cy0L7Qu9GP0Y7RidC40LVcXFxcbiAgICAgICAgICAgINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRji/QmtC70LjQtdC90YLRgy/Qk9C+0YHRgtGOINGA0LDQt9C80LXRidCw0YLRjCwg0L7RgdGD0YnQtdGB0YLQstC70Y/RgtGMINC/0L7QuNGB0Log0Lgg0L/RgNC+0YHQvNC+0YLRgCDQmNC90YTQvtGA0LzQsNGG0LjQuCwg0LAg0YLQsNC60LbQtSDQu9GO0LHRi9C1INC40L3Ri9C1XFxcXG4gICAgICAgICAgICDQstC+0LfQvNC+0LbQvdC+0YHRgtC4INC4INGE0YPQvdC60YbQuNC4LCDQtNC+0YHRgtGD0L/QvdGL0LUg0L3QsCDQodCw0LnRgtC1LiA8c3Ryb25nPtCR0LXRgdC/0LvQsNGC0L3Ri9C1INGD0YHQu9GD0LPQuDwvc3Ryb25nPiDigJMg0LHQsNC30L7QstGL0Lkg0L3QsNCx0L7RgCDRg9GB0LvRg9CzLFxcXFxuICAgICAgICAgICAg0L/RgNC10LTQvtGB0YLQsNCy0LvRj9C10LzRi9C5INCx0LXQtyDQstC30LjQvNCw0L3QuNGPINC/0LvQsNGC0YsuIDxzdHJvbmc+0J/Qu9Cw0YLQvdGL0LUg0YPRgdC70YPQs9C4PC9zdHJvbmc+IOKAkyDQvdCw0LHQvtGAINC00L7Qv9C+0LvQvdC40YLQtdC70YzQvdGL0YUg0YPRgdC70YPQsywg0LfQsFxcXFxuICAgICAgICAgICAg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LUg0LrQvtGC0L7RgNGL0YUg0LLQt9C40LzQsNC10YLRgdGPINC/0LvQsNGC0LAg0YHQvtCz0LvQsNGB0L3QviDRgtCw0YDQuNGE0LDQvCDQmtC+0LzQv9Cw0L3QuNC4LjwvcD5cXFxcblxcXFxuICAgICAgICA8cD48c3Ryb25nPtCY0L3RhNC+0YDQvNCw0YbQuNGPIOKAkyA8L3N0cm9uZz7Rg9GB0LvRg9Cz0Lgg0Lgg0L/RgNC10LTQu9C+0LbQtdC90LjRjyDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAsINGB0LLQtdC00LXQvdC40Y8g0L4g0LrQvtGC0L7RgNGL0YUg0L7QvSDRgNCw0LfQvNC10YnQsNC10YIg0L3QsFxcXFxuICAgICAgICAgICAg0KHQsNC50YLQtSwg0LDQtNGA0LXRgdC+0LLQsNC90L3Ri9C1INC4INC00L7RgdGC0YPQv9C90YvQtSDQvdC10L7Qv9GA0LXQtNC10LvQtdC90L3QvtC80YMg0LrRgNGD0LPRgyDQu9C40YYgKNCT0L7RgdGC0Y/QvCDQuC/QuNC70Lgg0LTRgNGD0LPQuNC8INCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRj9C8KS48YnI+XFxcXG4gICAgICAgICAgICA8YnI+XFxcXG4gICAgICAgICAgICA8c3Ryb25nPtCU0L7Qs9C+0LLQvtGAPC9zdHJvbmc+IOKAkyDRgdC+0LPQu9Cw0YjQtdC90LjQtSwg0YTQvtGA0LzQuNGA0YPQtdC80L7QtSDQv9GA0Lgg0KDQtdCz0LjRgdGC0YDQsNGG0LjQuCDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAg0Lgg0LLRgdGC0YPQv9Cw0Y7RidC10LUg0LIg0YHQuNC70YNcXFxcbiAgICAgICAgICAgINCyINC80L7QvNC10L3RgiDQvtC/0LvQsNGC0Ysg0L/QtdGA0LLQvtCz0L4g0YHRh9C10YLQsCDQt9CwINCj0YHQu9GD0LPQuC48L3A+XFxcXG5cXFxcbiAgICAgICAgPGJyPlxcXFxuXFxcXG4gICAgICAgIDxwPjxzdHJvbmc+Mi4g0J7QkdCp0JjQlSDQn9Ce0JvQntCW0JXQndCY0K88L3N0cm9uZz48L3A+XFxcXG5cXFxcbiAgICAgICAgPHA+Mi4xINCa0L7QvNC/0LDQvdC40Y8g0L/RgNC10LTQvtGB0YLQsNCy0LvRj9C10YIg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GOL9Ca0LvQuNC10L3RgtGDL9CT0L7RgdGC0Y4g0L3QsCDRg9GB0LvQvtCy0LjRj9GFINC90LDRgdGC0L7Rj9GJ0LXQuSDQntGE0LXRgNGC0YssINCU0L7Qs9C+0LLQvtGA0LAg0Lgg0JTQvtC/0L7Qu9C90LjRgtC10LvRjNC90YvRhVxcXFxuICAgICAgICAgICAg0YHQvtCz0LvQsNGI0LXQvdC40LksINC/0YDQuNC70L7QttC10L3QuNC5INC/0YDQsNCy0L4g0L3QsCDQv9C+0LvRjNC30L7QstCw0L3QuNC1INCj0YHQu9GD0LPQsNC80Lgg0KHQsNC50YLQsCDRgSDQstC+0LfQvNC+0LbQvdC+0YHRgtGM0Y4g0YDQsNC30LzQtdGJ0LDRgtGMLCDQvtGB0YPRidC10YHRgtCy0LvRj9GC0Ywg0L/QvtC40YHQuiDQuFxcXFxuICAgICAgICAgICAg0L/RgNC+0YHQvNC+0YLRgCDQmNC90YTQvtGA0LzQsNGG0LjQuCDQtNGA0YPQs9C40YUg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9C10LlcXFxcXFzQmtC70LjQtdC90YLQvtCyLjxicj5cXFxcbiAgICAgICAgICAgIDIuMiDQktGB0LUg0YHQtNC10LvQutC4OiDCq9Cf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjC/QmtC70LjQtdC90YIg4oCTINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjC/QmtC70LjQtdC90YLCuyDQu9C40LHQviDCq9Cf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjC/QmtC70LjQtdC90YIg4oCTINCT0L7RgdGC0YzCuyDQt9Cw0LrQu9GO0YfQsNGO0YLRgdGPXFxcXG4gICAgICAgICAgICDQvdCw0L/RgNGP0LzRg9GOLiDQn9GA0Lgg0Y3RgtC+0LwsINCa0L7QvNC/0LDQvdC40Y8g0L3QtSDRj9Cy0LvRj9C10YLRgdGPINGD0YfQsNGB0YLQvdC40LrQvtC8INGC0LDQutC40YUg0YHQtNC10LvQvtC6LCDQsCDQv9GA0LXQtNC+0YHRgtCw0LLQu9GP0LXRgiDQu9C40YjRjCDQutC+0LzQvNGD0L3QuNC60LDRhtC40L7QvdC90YPRjlxcXFxuICAgICAgICAgICAg0L/Qu9Cw0YLRhNC+0YDQvNGDINC00LvRjyDQmNC90YTQvtGA0LzQsNGG0LjQuCDQn9C+0LvRjNC30L7QstCw0YLQtdC70LXQuS/QmtC70LjQtdC90YLQvtCyLjxicj5cXFxcbiAgICAgICAgICAgIDIuMyDQo9GB0LvRg9Cz0Lgg0L3QtSDQv9GA0LXQtNC+0YHRgtCw0LLQu9GP0Y7RgtGB0Y8g0Lgg0L3QtSDQtNC+0LvQttC90Ysg0LjRgdC/0L7Qu9GM0LfQvtCy0LDRgtGM0YHRjyDQu9C40YbQsNC80Lgg0LzQu9Cw0LTRiNC1IDE4INC70LXRgiwg0LvQuNGG0LDQvNC4INC/0YDQuNC30L3QsNC90L3Ri9C80LhcXFxcbiAgICAgICAgICAgINC90LXQtNC10LXRgdC/0L7RgdC+0LHQvdGL0LzQuCwg0LAg0YLQsNC60LbQtSDQvtCz0YDQsNC90LjRh9C10L3QvdC+INC00LXQtdGB0L/QvtGB0L7QsdC90YvQvNC4INC70LjRhtCw0LzQuC4g0JvQuNGG0LAsINC90LUg0LTQvtGB0YLQuNCz0YjQuNC1IDE4INC70LXRgiwg0LjQu9C4INC70LjRhtCwLCDQv9GA0LjQt9C90LDQvdC90YvQtVxcXFxuICAgICAgICAgICAg0L3QtdC00LXQtdGB0L/QvtGB0L7QsdC90YvQvNC4INC40LvQuCDQvtCz0YDQsNC90LjRh9C10L3QviDQtNC10LXRgdC/0L7RgdC+0LHQvdGL0LzQuCwg0LzQvtCz0YPRgiDQv9C+0LvRjNC30L7QstCw0YLRjNGB0Y8g0KPRgdC70YPQs9Cw0LzQuCDRgtC+0LvRjNC60L4g0YEg0YHQvtCz0LvQsNGB0LjRjyDRgdCy0L7QuNGFINC30LDQutC+0L3QvdGL0YVcXFxcbiAgICAgICAgICAgINC/0YDQtdC00YHRgtCw0LLQuNGC0LXQu9C10LkuPC9wPlxcXFxuXFxcXG4gICAgICAgIDxicj5cXFxcblxcXFxuICAgICAgICA8cD48c3Ryb25nPjMuINCf0KDQkNCS0JjQm9CQINCf0J7Qm9Cs0JfQntCS0JDQndCY0K8g0KHQkNCZ0KLQntCcPC9zdHJvbmc+PC9wPlxcXFxuXFxcXG4gICAgICAgIDxwPjMuMS4g0JPQvtGB0YLRjCDQstC/0YDQsNCy0LUg0L/RgNC+0YHQvNCw0YLRgNC40LLQsNGC0Ywg0JjQvdGE0L7RgNC80LDRhtC40Y4g0J/QvtC70YzQt9C+0LLQsNGC0LXQu9C10Lkv0JrQu9C40LXQvdGC0L7Qsiwg0L3QsNGF0L7QtNGP0YnRg9GO0YHRjyDQsiDQvtGC0LrRgNGL0YLQvtC8INC00L7RgdGC0YPQv9C1LCDQuFxcXFxuICAgICAgICAgICAg0LLQvtGB0L/QvtC70YzQt9C+0LLQsNGC0YzRgdGPINGD0YHQu9GD0LPQsNC80LgsINGB0L7QtNC10YDQttCw0YnQuNC80LjRgdGPINCyINCY0L3RhNC+0YDQvNCw0YbQuNC4LCDQsdC10Lcg0KDQtdCz0LjRgdGC0YDQsNGG0LjQuCDQvdCwINCh0LDQudGC0LUuPGJyPlxcXFxuICAgICAgICAgICAgMy4yLiDQn9C+0LvRjNC30L7QstCw0YLQtdC70Ywv0JrQu9C40LXQvdGCINC/0L7Qu9GD0YfQsNC10YIg0L/RgNCw0LLQviDQstC+0YHQv9C+0LvRjNC30L7QstCw0YLRjNGB0Y8g0KPRgdC70YPQs9Cw0LzQuCDQodCw0LnRgtCwINC/0L4g0YDQsNC30LzQtdGJ0LXQvdC40Y4g0JjQvdGE0L7RgNC80LDRhtC40Lgg0LTQu9GPINC00L7RgdGC0YPQv9CwXFxcXG4gICAgICAgICAgICDQuiDQvdC10Lkg0L3QtdC+0L/RgNC10LTQtdC70LXQvdC90L7Qs9C+INC60YDRg9Cz0LAg0LvQuNGGLCDQv9C+0YHQu9C1INC/0YDQvtGF0L7QttC00LXQvdC40Y8g0L/RgNC+0YbQtdC00YPRgNGLINCg0LXQs9C40YHRgtGA0LDRhtC40Lgg4oCTINC00LvRjyDQkdC10YHQv9C70LDRgtC90YvRhSDQo9GB0LvRg9CzLCDQsCDRgtCw0LrQttC1LFxcXFxuICAgICAgICAgICAg0LTQvtC/0L7Qu9C90LjRgtC10LvRjNC90L4sINC/0L7RgdC70LUg0L7RhNC+0YDQvNC70LXQvdC40Y8g0JTQvtCz0L7QstC+0YDQsCwg0LvQuNGB0YLQsCDQt9Cw0LrQsNC30LAg0Lgg0L7Qv9C70LDRgtGLINGB0YfQtdGC0LAgLSDQtNC70Y8g0J/Qu9Cw0YLQvdGL0YUg0KPRgdC70YPQsy48YnI+XFxcXG4gICAgICAgICAgICAzLjMuINCf0YDQuCDQoNC10LPQuNGB0YLRgNCw0YbQuNC4LCDQsCDRgtCw0LrQttC1INC+0YTQvtGA0LzQu9C10L3QuNC4INC00L7Qs9C+0LLQvtGA0LAg0Lgg0LvQuNGB0YLQsCDQt9Cw0LrQsNC30LAg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GML9Ca0LvQuNC10L3RgiDQt9Cw0L/QvtC70L3Rj9C10YIg0LLRgdC1XFxcXG4gICAgICAgICAgICDQvdC10L7QsdGF0L7QtNC40LzRi9C1INC/0L7Qu9GPINGB0L/QtdGG0LjQsNC70YzQvdGL0YUg0YTQvtGA0LwuINCd0LUg0LfQsNC/0L7Qu9C90LXQvdC40LUg0YXQvtGC0Y8g0LHRiyDQvtC00L3QvtCz0L4g0L7QsdGP0LfQsNGC0LXQu9GM0L3QvtCz0L4g0L/QvtC70Y8gKNCyINGCLtGHLiDQstCy0L7QtCDQvdC10LrQvtGA0YDQtdC60YLQvdGL0YVcXFxcbiAgICAgICAgICAgINC00LDQvdC90YvRhSkg0LLQu9C10YfQtdGCINC90LXQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3QvtGB0YLRjCDRgNC10LPQuNGB0YLRgNCw0YbQuNC4INC70LjQsdC+INC70LjRgdGC0LAg0LfQsNC60LDQt9CwLjxicj5cXFxcbiAgICAgICAgICAgIDMuNC4g0J/QvtGB0LvQtSDQv9GA0L7RhdC+0LbQtNC10L3QuNGPINCg0LXQs9C40YHRgtGA0LDRhtC40Lgg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GML9Ca0LvQuNC10L3RgiDQv9C+0LvRg9GH0LDQtdGCINC90LAg0YPQutCw0LfQsNC90L3Ri9C5INC40Lwg0L3QvtC80LXRgCDQvNC+0LHQuNC70YzQvdC+0LPQviDRgtC10LvQtdGE0L7QvdCwXFxcXG4gICAgICAgICAgICDQn9CQ0KDQntCb0KwsINC60L7RgtC+0YDRi9C5INCyINC00LDQu9GM0L3QtdC50YjQtdC8INC40YHQv9C+0LvRjNC30YPQtdGC0YHRjyDQn9C+0LvRjNC30L7QstCw0YLQtdC70LXQvC/QmtC70LjQtdC90YLQvtC8INC00LvRjyDQkNCy0YLQvtGA0LjQt9Cw0YbQuNC4INC4INCy0YXQvtC00LAg0LIg0JvQuNGH0L3Ri9C5XFxcXG4gICAgICAgICAgICDQutCw0LHQuNC90LXRgi48YnI+XFxcXG4gICAgICAgICAgICAzLjUuINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjC/QmtC70LjQtdC90YIg0L3QtdGB0LXRgiDQv9C+0LvQvdGD0Y4g0L7RgtCy0LXRgtGB0YLQstC10L3QvdC+0YHRgtGMINC30LAg0LLRgdC1INC00LXQudGB0YLQstC40Y8g0YEg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LXQvCDQtdCz0L4g0JvQvtCz0LjQvdCwICjQvdC+0LzQtdGAXFxcXG4gICAgICAgICAgICDQvNC+0LHQuNC70YzQvdC+0LPQviDRgtC10LvQtdGE0L7QvdCwKSDQuCDQn9Cw0YDQvtC70Y8uINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjC/QmtC70LjQtdC90YIg0LjQvNC10LXRgiDQv9GA0LDQstC+INC/0L7Qu9GM0LfQvtCy0LDRgtGM0YHRjyDQo9GB0LvRg9Cz0LDQvNC4INCh0LDQudGC0LAg0YLQvtC70YzQutC+INC/0YDQuCDQv9C+0LzQvtGJ0LhcXFxcbiAgICAgICAgICAgINGB0L7QsdGB0YLQstC10L3QvdC+0LPQviDQvdC+0LzQtdGA0LAg0LzQvtCx0LjQu9GM0L3QvtCz0L4g0YLQtdC70LXRhNC+0L3QsCDQuCDQv9Cw0YDQvtC70Y8uPGJyPlxcXFxuICAgICAgICAgICAgMy42LiDQn9GA0Lgg0L/QvtC70YzQt9C+0LLQsNC90LjQuCDQodCw0LnRgtC+0LwgPHN0cm9uZz7Ql9CQ0J/QoNCV0KnQldCd0J46PC9zdHJvbmc+PGJyPlxcXFxuICAgICAgICAgICAgLSDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0LDQstGC0L7QvNCw0YLQuNGH0LXRgdC60LjQtSDQv9GA0L7Qs9GA0LDQvNC80Ysg0LTQu9GPINC/0L7Qu9GD0YfQtdC90LjRjyDQtNC+0YHRgtGD0L/QsCDQvdCwINCh0LDQudGCOzxicj5cXFxcbiAgICAgICAgICAgIC0g0LjRgdC/0L7Qu9GM0LfQvtCy0LDRgtGMINC60L7QvNC/0YzRjtGC0LXRgNC90YvQtSDQv9GA0L7Qs9GA0LDQvNC80YssINC/0L7Qt9Cy0L7Qu9GP0Y7RidC40LUg0YDQsNC30LzQtdGJ0LDRgtGMINC90LAg0KHQsNC50YLQtSDQmNC90YTQvtGA0LzQsNGG0LjRjiwg0LzQuNC90YPRjyDQvtCx0YvRh9C90YvQuSDQv9C+0YDRj9C00L7QulxcXFxuICAgICAgICAgICAg0YDQsNC30LzQtdGJ0LXQvdC40Y8gKNC6INC/0YDQuNC80LXRgNGDINC40YHQv9C+0LvRjNC30L7QstCw0L3QuNC1INC/0YDQvtCz0YDQsNC80Lwg0L/QviDQsNCy0YLQvtC30LDQs9GA0YPQt9C60LUg0JjQvdGE0L7RgNC80LDRhtC40LgpOzxicj5cXFxcbiAgICAgICAgICAgIC0g0L/RgNC10LTQv9GA0LjQvdC40LzQsNGC0Ywg0LrQsNC60LjQtS3Qu9C40LHQviDQtNC10LnRgdGC0LLQuNGPLCDQutC+0YLQvtGA0YvQtSDQvNC+0LPRg9GCINC/0YDQuNCy0LXRgdGC0Lgg0Log0L3QtdC/0YDQvtC/0L7RgNGG0LjQvtC90LDQu9GM0L3QviDQsdC+0LvRjNGI0L7QuSDQvdCw0LPRgNGD0LfQutC1INC90LBcXFxcbiAgICAgICAgICAgINC40L3RhNGA0LDRgdGC0YDRg9C60YLRg9GA0YMg0KHQsNC50YLQsDs8YnI+XFxcXG4gICAgICAgICAgICAtINC60L7Qv9C40YDQvtCy0LDRgtGMLCDQstC+0YHQv9GA0L7QuNC30LLQvtC00LjRgtGMLCDQuNC30LzQtdC90Y/RgtGMLCDRgNCw0YHQv9GA0L7RgdGC0YDQsNC90Y/RgtGMINC4INC/0YDQtdC00YHRgtCw0LLQu9GP0YLRjCDQvtCx0YnQtdGB0YLQstC10L3QvdC+0YHRgtC4INC70Y7QsdGD0Y4g0LjQvdGE0L7RgNC80LDRhtC40Y4sXFxcXG4gICAgICAgICAgICDRgdC+0LTQtdGA0LbQsNGJ0YPRjtGB0Y8g0L3QsCDQodCw0LnRgtC1ICjQutGA0L7QvNC1INCh0LLQtdC00LXQvdC40LksINC/0YDQtdC00L7RgdGC0LDQstC70LXQvdC90YvRhSDRgdCw0LzQuNC8INCf0L7Qu9GM0LfQvtCy0LDRgtC10LvQtdC8L9Ca0LvQuNC10L3RgtC+0LwpINCx0LXQtyDQv9GA0LXQtNCy0LDRgNC40YLQtdC70YzQvdC+0LPQvlxcXFxuICAgICAgICAgICAg0L/QuNGB0YzQvNC10L3QvdC+0LPQviDRgNCw0LfRgNC10YjQtdC90LjRjyDQmtC+0LzQv9Cw0L3QuNC4Ozxicj5cXFxcbiAgICAgICAgICAgIC0g0L/RgNC10L/Rj9GC0YHRgtCy0L7QstCw0YLRjCDRgNCw0LHQvtGC0LUg0KHQsNC50YLQsCwg0LAg0YLQsNC60LbQtSDQv9GA0LXQv9GP0YLRgdGC0LLQvtCy0LDRgtGMINC00LXQudGB0YLQstC40Y4g0LDQstGC0L7QvNCw0YLQuNGH0LXRgdC60LjRhSDRgdC40YHRgtC10Lwg0LjQu9C4INC/0YDQvtGG0LXRgdGB0L7Qsiwg0YEg0YbQtdC70YzRjlxcXFxuICAgICAgICAgICAg0LLQvtGB0L/RgNC10L/Rj9GC0YHRgtCy0L7QstCw0YLRjCDQuNC70Lgg0L7Qs9GA0LDQvdC40YfQuNGC0Ywg0LTQvtGB0YLRg9C/INC90LAg0KHQsNC50YI7PGJyPlxcXFxuICAgICAgICAgICAgLSDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0YHQstC10LTQtdC90LjRjywg0L/RgNC10LTQvtGB0YLQsNCy0LvQtdC90L3Ri9C1INC00YDRg9Cz0LjQvCDQn9C+0LvRjNC30L7QstCw0YLQtdC70LXQvC/QmtC70LjQtdC90YLQvtC8LCDQsdC10Lcg0L/QuNGB0YzQvNC10L3QvdC+0LPQviDRgNCw0LfRgNC10YjQtdC90LjRj1xcXFxuICAgICAgICAgICAg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GPL9Ca0LvQuNC10L3RgtCwLCDRgNCw0LfQvNC10YHRgtC40LLRiNC10LPQviDRgtCw0LrQuNC1INGB0LLQtdC00LXQvdC40Y8sINC40LvQuCDQsdC10Lcg0L/QvtC00YLQstC10YDQttC00LXQvdC40Y8g0LrQsNC60LjQvC3Qu9C40LHQviDQtNGA0YPQs9C40Lwg0YHQv9C+0YHQvtCx0L7QvCDQv9GA0LDQstCwXFxcXG4gICAgICAgICAgICDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0YLQsNC60LjQtSDRgdCy0LXQtNC10L3QuNGPLiDQktGB0LUg0YHQstC10LTQtdC90LjRjywg0L/QvtC70YPRh9C10L3QvdGL0LUg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9C10Lwv0JrQu9C40LXQvdGC0L7QvCDQviDQtNGA0YPQs9C40YUg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GP0YUg0LIg0YHQstGP0LfQuFxcXFxuICAgICAgICAgICAg0YEg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LXQvCDQodCw0LnRgtCwLCDQvNC+0LPRg9GCINCx0YvRgtGMINC40YHQv9C+0LvRjNC30L7QstCw0L3RiyDRgtC+0LvRjNC60L4g0LTQu9GPINGB0L7QstC10YDRiNC10L3QuNGPINC4INC40YHQv9C+0LvQvdC10L3QuNGPINGB0LTQtdC70L7QuiDQsiDQvtGC0L3QvtGI0LXQvdC40Lgg0YPRgdC70YPQsyxcXFxcbiAgICAgICAgICAgINGB0L7QtNC10YDQttCw0YnQuNGF0YHRjyDQsiDQmNC90YTQvtGA0LzQsNGG0LjQuCDQn9C+0LvRjNC30L7QstCw0YLQtdC70LXQuS/QmtC70LjQtdC90YLQvtCyLiDQotCw0LrQuNC8INC+0LHRgNCw0LfQvtC8LCDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y4v0JrQu9C40LXQvdGC0YMg0L3QtSDRgNCw0LfRgNC10YjQsNC10YLRgdGPXFxcXG4gICAgICAgICAgICDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0Y3Qu9C10LrRgtGA0L7QvdC90YvQuSDQsNC00YDQtdGBLCDRgNC+0LLQvdC+LCDQutCw0Log0Lgg0L3QvtC80LXRgCDRgtC10LvQtdGE0L7QvdCwINC00YDRg9Cz0L7Qs9C+INCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjy/QmtC70LjQtdC90YLQsCDQtNC70Y8g0YbQtdC70LXQuSDQv9GA0Y/QvNC+0LlcXFxcbiAgICAgICAgICAgINGA0LXQutC70LDQvNC90L7QuSDRgNCw0YHRgdGL0LvQutC4INC40LvQuCDQtNGA0YPQs9C+0Lkg0YDQsNGB0YHRi9C70LrQuCDQvdC10LbQtdC70LDRgtC10LvRjNC90YvRhSDRjdC70LXQutGC0YDQvtC90L3Ri9GFINGB0L7QvtCx0YnQtdC90LjQuSwg0LAg0YLQsNC60LbQtSDQtNC70Y8g0LjQvdGL0YUg0L/RgNC+0YLQuNCy0L7Qv9GA0LDQstC90YvRhVxcXFxuICAgICAgICAgICAg0LTQtdC50YHRgtCy0LjQuSDQuNC70Lgg0LTQtdC50YHRgtCy0LjQuSwg0YHQvtCy0LXRgNGI0LDQtdC80YvRhSDQsdC10Lcg0LLQtdC00L7QvNCwINC4L9C40LvQuCDRgdC+0LPQu9Cw0YHQuNGPINC00YDRg9Cz0L7QuSDRgdGC0L7RgNC+0L3Rizs8YnI+XFxcXG4gICAgICAgICAgICAtINC90LDRgNGD0YjQsNGC0Ywg0LjQvdGE0L7RgNC80LDRhtC40L7QvdC90YPRjiDQsdC10LfQvtC/0LDRgdC90L7RgdGC0Ywg0KHQsNC50YLQsDs8YnI+XFxcXG4gICAgICAgICAgICAtINCy0L3QtdC00YDRj9GC0Ywg0LjRgdC/0L7Qu9C90Y/QtdC80YvQuSDQutC+0LQg0L3QsCDRgdGC0L7RgNC+0L3QtSDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAsINC70Y7QsdGL0LUg0LLQvdC10LTRgNGP0LXQvNGL0LUg0L7QsdGK0LXQutGC0YssINC40YHQv9C+0LvRjNC30L7QstCw0YLRjCBmcmFtZSDQuFxcXFxuICAgICAgICAgICAgaWZyYW1lLCDQutCw0YHQutCw0LTQvdGL0LUg0YLQsNCx0LvQuNGG0Ysg0YHRgtC40LvQtdC5LCBodG1sLdC60L7QtDs8YnI+XFxcXG4gICAgICAgICAgICAtINC/0YDQtdC00YHRgtCw0LLQu9GP0YLRjNGB0Y8g0YfRg9C20LjQvCDQuNC80LXQvdC10Lwg0LjQu9C4INC+0YIg0YfRg9C20L7Qs9C+INC40LzQtdC90Lgg4oCUINC30LDRgNC10LPQuNGB0YLRgNC40YDQvtCy0LDQvdC90L7Qs9C+INC90LAg0KHQsNC50YLQtSDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAsXFxcXG4gICAgICAgICAgICDRgdC+0YLRgNGD0LTQvdC40LrQsCDQmtC+0LzQv9Cw0L3QuNC4LiDQktCy0L7QtNC40YLRjCDQsiDQt9Cw0LHQu9GD0LbQtNC10L3QuNC1INC00YDRg9Cz0LjRhSDQn9C+0LvRjNC30L7QstCw0YLQtdC70LXQuVxcXFxcXNCa0LvQuNC10L3RgtC+0LIg0Lgg0LDQtNC80LjQvdC40YHRgtGA0LDRhtC40Y4g0KHQsNC50YLQsCDQvtGC0L3QvtGB0LjRgtC10LvRjNC90L5cXFxcbiAgICAgICAgICAgINGB0LLQvtC10Lkg0LjQtNC10L3RgtC40YTQuNC60LDRhtC40Lgg0LvRjtCx0YvQvCDQuNC90YvQvCDRgdC/0L7RgdC+0LHQvtC8PGJyPlxcXFxuICAgICAgICAgICAgLSDRgNCw0LfQvNC10YnQsNGC0Ywg0LTRg9Cx0LvQuNGA0YPRjtGJ0YPRjiDQmNC90YTQvtGA0LzQsNGG0LjRjiDQvtC00L3QvtCz0L4g0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GPL9Ca0LvQuNC10L3RgtCwINGBINC40YHQv9C+0LvRjNC30L7QstCw0L3QuNC10Lwg0YDQsNC30L3Ri9GFIEUtbWFpbCDQuCDQvdC+0LzQtdGA0L7QslxcXFxuICAgICAgICAgICAg0LzQvtCx0LjQu9GM0L3Ri9GFINGC0LXQu9C10YTQvtC90L7Qsjs8YnI+XFxcXG4gICAgICAgICAgICAtINC40YHQv9C+0LvRjNC30L7QstCw0YLRjCDQo9GB0LvRg9Cz0Lgg0KHQsNC50YLQsCDQtNC70Y8g0L3QtdC30LDQutC+0L3QvdC+0Lkg0LTQtdGP0YLQtdC70YzQvdC+0YHRgtC4INC70LjQsdC+INC00LXRj9GC0LXQu9GM0L3QvtGB0YLQuCwg0LrQvtGC0L7RgNCw0Y8g0LzQvtC20LXRgiDQv9GA0LjQstC10YHRgtC4INC6XFxcXG4gICAgICAgICAgICDQvdCw0YDRg9GI0LXQvdC40Y4g0JrQvtC80L/QsNC90LjQtdC5INC4L9C40LvQuCDQn9C+0LvRjNC30L7QstCw0YLQtdC70LXQvC/QmtC70LjQtdC90YLQvtC8INC00LXQudGB0YLQstGD0Y7RidC10LPQviDQt9Cw0LrQvtC90L7QtNCw0YLQtdC70YzRgdGC0LLQsCDQoNCkLjwvcD5cXFxcblxcXFxuICAgICAgICA8YnI+XFxcXG5cXFxcbiAgICAgICAgPHA+PHN0cm9uZz40LiDQn9Cg0JDQktCQINCYINCe0JHQr9CX0JDQndCd0J7QodCi0Jgg0J/QntCb0KzQl9Ce0JLQkNCi0JXQm9CvL9Ca0JvQmNCV0J3QotCQPC9zdHJvbmc+PC9wPlxcXFxuXFxcXG4gICAgICAgIDxwPjQuMS4mbmJzcDsmbmJzcDsmbmJzcDsg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GML9Ca0LvQuNC10L3RgiDQvtCx0Y/Qt9GD0LXRgtGB0Y86PGJyPlxcXFxuICAgICAgICAgICAgNC4xLjEuINCh0L7QsdC70Y7QtNCw0YLRjCDRgtGA0LXQsdC+0LLQsNC90LjRjywg0L7Qv9GA0LXQtNC10LvQtdC90L3Ri9C1INCyINC90LDRgdGC0L7Rj9GJ0LXQuSDQntGE0LXRgNGC0LUsINCU0L7Qs9C+0LLQvtGA0LUsINC70LjRgdGC0LUg0LfQsNC60LDQt9CwINC4INC40L3Ri9GFINC00L7QutGD0LzQtdC90YLQsNGFLFxcXFxuICAgICAgICAgICAg0L7Qv9GA0LXQtNC10LvRj9GO0YnQuNGFINC/0L7Qu9GM0LfQvtCy0LDQvdC40LUg0KHQsNC50YLQvtC8Ljxicj5cXFxcbiAgICAgICAgICAgIDQuMS4yLiDQn9GA0Lgg0KDQtdCz0LjRgdGC0YDQsNGG0LjQuCDQvdCwINCh0LDQudGC0LUg0LjRgdC/0L7Qu9GM0LfQvtCy0LDRgtGMINGC0L7Qu9GM0LrQviDRgNC10LDQu9GM0L3Ri9C1INC00LDQvdC90YvQtSDQviDRgdC10LHQtSDQuCDRgNCw0LfQvNC10YnQsNC10LzQvtC5INCY0L3RhNC+0YDQvNCw0YbQuNC4Ljxicj5cXFxcbiAgICAgICAgICAgIDQuMS4zLiDQodC70LXQtNC40YLRjCDQt9CwINGB0L7RhdGA0LDQvdC90L7RgdGC0YzRjiDRgdCy0L7QtdCz0L4g0J/QsNGA0L7Qu9GPINC4INC90LUg0YDQsNGB0LrRgNGL0LLQsNGC0Ywg0LXQs9C+INC/0L7RgdGC0L7RgNC+0L3QvdC40Lwg0LvQuNGG0LDQvC48YnI+XFxcXG4gICAgICAgICAgICA0LjEuNC4g0J3QtSDQv9C10YDQtdC00LDQstCw0YLRjCDQuNC70Lgg0L/RgNC+0LTQsNCy0LDRgtGMINGB0LLQvtC4INCj0YfQtdGC0L3Ri9C1INC00LDQvdC90YvQtSDQtNC70Y8g0JDQstGC0L7RgNC40LfQsNGG0LjQuCDQvdCwINCh0LDQudGC0LUg0YLRgNC10YLRjNC40Lwg0LvQuNGG0LDQvC48YnI+XFxcXG4gICAgICAgICAgICA0LjEuNS4g0J/RgNC4INGA0LDQt9C80LXRidC10L3QuNC4INCY0L3RhNC+0YDQvNCw0YbQuNC4INGB0L7QsdC70Y7QtNCw0YLRjCDRgtGA0LXQsdC+0LLQsNC90LjRjyDQtNC10LnRgdGC0LLRg9GO0YnQtdCz0L4g0LfQsNC60L7QvdC+0LTQsNGC0LXQu9GM0YHRgtCy0LAg0KDQpCwg0LIg0YIu0YcuINCk0JcgwqvQnlxcXFxuICAgICAgICAgICAg0YDQtdC60LvQsNC80LXCuyDQvtGCIDEzLjAzLjIwMDbQsy4g4oSWIDM4LdCk0JcuPGJyPlxcXFxuICAgICAgICAgICAgNC4xLjYuINCf0YDQtdC00L7RgdGC0LDQstC40YLRjCwg0L/QviDRgtGA0LXQsdC+0LLQsNC90LjRjiDQmtC+0LzQv9Cw0L3QuNC4LCDQtNC+0LrRg9C80LXQvdGC0LDQu9GM0L3QviDQv9C+0LTRgtCy0LXRgNC20LTRkdC90L3Ri9C1INGB0LLQtdC00LXQvdC40Y8g0L4g0YHQvtC+0YLQstC10YLRgdGC0LLQuNC4INCY0L3RhNC+0YDQvNCw0YbQuNC4XFxcXG4gICAgICAgICAgICDRgtGA0LXQsdC+0LLQsNC90LjRj9C8INC00LXQudGB0YLQstGD0Y7RidC10LPQviDQt9Cw0LrQvtC90L7QtNCw0YLQtdC70YzRgdGC0LLQsCDQoNCkLCDQsiDRgtC+0Lwg0YfQuNGB0LvQtSDQvdCw0LTQu9C10LbQsNGJ0LjQvCDQvtCx0YDQsNC30L7QvCDQt9Cw0LLQtdGA0LXQvdC90YvQtSDQutC+0L/QuNC4INC00LjQv9C70L7QvNC+0LIsXFxcXG4gICAgICAgICAgICDQu9C40YbQtdC90LfQuNC5LCDRgdC10YDRgtC40YTQuNC60LDRgtC+0LIsINGB0LLQuNC00LXRgtC10LvRjNGB0YLQsiDQviDRgNC10LPQuNGB0YLRgNCw0YbQuNC4LCDQsiDRgdC70YPRh9Cw0LUg0LXRgdC70Lgg0YPRgdC70YPQs9C4INC/0L7QtNC70LXQttCw0YIg0LvQuNGG0LXQvdC30LjRgNC+0LLQsNC90LjRjixcXFxcbiAgICAgICAgICAgINC+0LHRj9C30LDRgtC10LvRjNC90L7QuSDRgdC10YDRgtC40YTQuNC60LDRhtC40LgsINCz0L7RgdGD0LTQsNGA0YHRgtCy0LXQvdC90L7QuSDRgNC10LPQuNGB0YLRgNCw0YbQuNC4Ljxicj5cXFxcbiAgICAgICAgICAgIDQuMS43LiDQndC1INGA0LDQt9C80LXRidCw0YLRjCDQmNC90YTQvtGA0LzQsNGG0LjRjiwg0LLRhdC+0LTRj9GJ0YPRjiDQsiDCq9Ch0L/QuNGB0L7QuiDQt9Cw0L/RgNC10YnQtdC90L3QvtC5INC6INGA0LDQt9C80LXRidC10L3QuNGOINCY0L3RhNC+0YDQvNCw0YbQuNC4wrsuPGJyPlxcXFxuICAgICAgICAgICAgNC4xLjguINCd0LUg0YPQvdC40YfRgtC+0LbQsNGC0Ywg0Lgv0LjQu9C4INC90LUg0LjQt9C80LXQvdGP0YLRjCDQu9GO0LHRi9C1INC80LDRgtC10YDQuNCw0LvRiyDQvdCwINCh0LDQudGC0LUsINCw0LLRgtC+0YDQvtC8INC60L7RgtC+0YDRi9GFINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjC/QmtC70LjQtdC90YIg0L3QtVxcXFxuICAgICAgICAgICAg0Y/QstC70Y/QtdGC0YHRjy48YnI+XFxcXG4gICAgICAgICAgICA0LjEuOS4g0JfQsNC/0L7Qu9C90LjRgtGMINCy0YHQtSDQvdC10L7QsdGF0L7QtNC40LzRi9C1INGE0L7RgNC80Ysg0Lgg0L/RgNC10LTQvtGB0YLQsNCy0LjRgtGMINGC0L7Qu9GM0LrQviDRgdCy0L7QtSDQpNC+0YLQviAo0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GPKS/Qm9C+0LPQvtGC0LjQvyAo0JrQu9C40LXQvdGC0LApLlxcXFxuICAgICAgICAgICAg0JjQvdGE0L7RgNC80LDRhtC40Y8sINGB0L7QtNC10YDQttCw0YnQsNGPINC70LjRhtC10L3Qt9C40YDRg9C10LzRi9C1INCy0LjQtNGLINC00LXRj9GC0LXQu9GM0L3QvtGB0YLQuCwg0LTQvtC70LbQvdCwINGB0L7QtNC10YDQttCw0YLRjCDQvdC+0LzQtdGAINC70LjRhtC10L3Qt9C40LguIDQuMS4xMC4g0KDQsNC30LzQtdGJ0LDRgtGMXFxcXG4gICAgICAgICAgICDQmNC90YTQvtGA0LzQsNGG0LjRjiwg0YHQvtC+0YLQstC10YLRgdGC0LLRg9GO0YnRg9GOINC/0L4g0YHQvtC00LXRgNC20LDQvdC40Y4g0LLRi9Cx0YDQsNC90L3QvtC5INCg0YPQsdGA0LjQutC1L9C/0L7QtNGA0YPQsdGA0LjQutC1Ljxicj5cXFxcbiAgICAgICAgICAgIDQuMS4xMS4g0J7Qv9C70LDRh9C40LLQsNGC0Ywg0J/Qu9Cw0YLQvdGL0LUg0KPRgdC70YPQs9C4INCa0L7QvNC/0LDQvdC40Lgg0LIg0L/QvtGA0Y/QtNC60LUg0Lgg0YHRgNC+0LrQuCwg0L7Qv9GA0LXQtNC10LvQtdC90L3Ri9C1INCe0YTQtdGA0YLQvtC5LCDQlNC+0LPQvtCy0L7RgNC+0Lwg0Lgg0LvQuNGB0YLQvtC8XFxcXG4gICAgICAgICAgICDQt9Cw0LrQsNC30LAuPGJyPlxcXFxuICAgICAgICAgICAgNC4yLiAg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GML9Ca0LvQuNC10L3RgiDQuNC80LXQtdGCINC/0YDQsNCy0L46PGJyPlxcXFxuICAgICAgICAgICAgNC4yLjEg0J/QvtC70YPRh9Cw0YLRjCDQv9GA0LDQstC+INCy0L7RgdC/0L7Qu9GM0LfQvtCy0LDRgtGM0YHRjyDQn9C70LDRgtC90YvQvNC4INCj0YHQu9GD0LPQsNC80Lgg0KHQsNC50YLQsCDQv9C+0YHQu9C1INC/0L7Qu9C90L7QuSDQvtC/0LvQsNGC0Ysg0YHRh9C10YLQsCwg0LLRi9GB0YLQsNCy0LvQtdC90L3QvtCz0L4g0L/RgNC4XFxcXG4gICAgICAgICAgICDQvtGE0L7RgNC80LvQtdC90LjQuCDQu9C40YHRgtCwINC30LDQutCw0LfQsCDQvdCwINC00LDQvdC90YvQtSDQo9GB0LvRg9Cz0LguPGJyPlxcXFxuICAgICAgICAgICAgNC4yLjIuINCS0L7RgdC/0L7Qu9GM0LfQvtCy0LDRgtGM0YHRjyDRg9GB0LvRg9Cz0LDQvNC4INC80LXQvdC10LTQttC10YDQvtCyINCa0L7QvNC/0LDQvdC40Lgg0LTQu9GPINC+0LrQsNC30LDQvdC40Y8g0L/QvtC80L7RidC4INC/0YDQuCDQoNC10LPQuNGB0YLRgNCw0YbQuNC4LCDQutCw0Log0L/QviDRgtC10LvQtdGE0L7QvdGDOiArN1xcXFxuICAgICAgICAgICAgKDg0ODIpIDc0LTQ0LTE5LCDRgtCw0Log0Lgg0L3QtdC/0L7RgdGA0LXQtNGB0YLQstC10L3QvdC+INC/0YDQuCDQstGB0YLRgNC10YfQtS48YnI+XFxcXG4gICAgICAgICAgICA0LjIuMy4g0KDQsNC30LzQtdGJ0LDRgtGMINCY0L3RhNC+0YDQvNCw0YbQuNGOINC+0LEg0YPRgdC70YPQs9Cw0YUsINC60L7RgtC+0YDRi9C1INCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjC/QmtC70LjQtdC90YIg0LzQvtC20LXRgiDQvtC60LDQt9GL0LLQsNGC0YwsINC40LzQtdGPINGB0L7QvtGC0LLQtdGC0YHRgtCy0YPRjtGJ0LjQtVxcXFxuICAgICAgICAgICAg0L3QsNCy0YvQutC4LCDQvtCx0YDQsNC30L7QstCw0L3QuNC1INC4INGA0LDQt9GA0LXRiNC10L3QuNGPLiA0LjIuNC4g0KDQsNC30YDQtdGI0LjRgtGMINC+0L/Qu9Cw0YLRgyDRgdGH0LXRgtCwINC30LAg0J/Qu9Cw0YLQvdGL0LUg0KPRgdC70YPQs9C4INGC0YDQtdGC0YzQtdC80YMg0LvQuNGG0YNcXFxcbiAgICAgICAgICAgICjQn9C70LDRgtC10LvRjNGJ0LjQutGDKSDRgSDRg9GH0LXRgtC+0Lwg0YLRgNC10LHQvtCy0LDQvdC40Lkg0LTQtdC50YHRgtCy0YPRjtGJ0LXQs9C+INC30LDQutC+0L3QvtC00LDRgtC10LvRjNGB0YLQstCwINC4INC+0YTQvtGA0LzQu9C10L3QvdC+0LPQviDQtNC+0LPQvtCy0L7RgNCwLiA0LjMuINCa0L7QvNC/0LDQvdC40Y9cXFxcbiAgICAgICAgICAgINC+0LHRj9C30YPQtdGC0YHRjzo8YnI+XFxcXG4gICAgICAgICAgICA0LjMuMS4g0J/RgNC10LTQvtGB0YLQsNCy0LjRgtGMINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRji/QmtC70LjQtdC90YLRgyDQv9GA0LDQstC+INC/0L7Qu9GM0LfQvtCy0LDRgtGM0YHRjyDQo9GB0LvRg9Cz0LDQvNC4INCh0LDQudGC0LAg0LIg0L/QvtGA0Y/QtNC60LUg0Lgg0YHRgNC+0LrQuCwg0L7Qv9GA0LXQtNC10LvQtdC90L3Ri9C80LhcXFxcbiAgICAgICAgICAgINCyINCe0YTQtdGA0YLQtSwg0JTQvtCz0L7QstC+0YDQtSDQuCDQu9C40YHRgtC1INC30LDQutCw0LfQsC48YnI+XFxcXG4gICAgICAgICAgICA0LjMuMi4g0J/RgNC10LTQvtGB0YLQsNCy0LjRgtGMINCy0L7Qt9C80L7QttC90L7RgdGC0Ywg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GP0Lwv0JrQu9C40LXQvdGC0LDQvCDRg9C/0YDQsNCy0LvRj9GC0Ywg0LTQvtGB0YLRg9C/0L7QvCDQuiDRgdCy0L7QuNC8INC/0LXRgNGB0L7QvdCw0LvRjNC90YvQvCDQtNCw0L3QvdGL0Lwg0LhcXFxcbiAgICAgICAgICAgINGA0LDQt9C80LXRidC10L3QvdC+0Lkg0JjQvdGE0L7RgNC80LDRhtC40LguPGJyPlxcXFxuICAgICAgICAgICAgNC40LiZuYnNwOyZuYnNwOyZuYnNwOyAg0JrQvtC80L/QsNC90LjRjyDQuNC80LXQtdGCINC/0YDQsNCy0L46PGJyPlxcXFxuICAgICAgICAgICAgNC40LjEuINCj0LTQsNC70LjRgtGMINCY0L3RhNC+0YDQvNCw0YbQuNGOLCDQt9Cw0LHQu9C+0LrQuNGA0L7QstCw0YLRjCDQtNC+0YHRgtGD0L8v0YPQtNCw0LvQuNGC0Ywg0KPRh9C10YLQvdGL0LUg0LTQsNC90L3Ri9C1INCf0L7Qu9GM0LfQvtCy0LDRgtC10LvQtdC5L9Ca0LvQuNC10L3RgtC+0LIsINC90LDRgNGD0YjQuNCy0YjQuNGFXFxcXG4gICAgICAgICAgICDQv9C+0LvQvtC20LXQvdC40Y8g0L3QsNGB0YLQvtGP0YnQtdC5INCe0YTQtdGA0YLRiywg0JTQvtCz0L7QstC+0YDQsCDQuCDQu9C40YHRgtCwINC30LDQutCw0LfQsCwg0LHQtdC3INC40LfQstC10YnQtdC90LjRjyDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAuPC9wPlxcXFxuXFxcXG4gICAgICAgIDxicj5cXFxcblxcXFxuICAgICAgICA8cD48c3Ryb25nPjUuINCY0J3QpNCe0KDQnNCQ0KbQmNCvLCDQl9CQ0J/QoNCV0KnQldCd0J3QkNCvINCaINCg0JDQl9Cc0JXQqdCV0J3QmNCuPC9zdHJvbmc+PC9wPlxcXFxuXFxcXG4gICAgICAgIDxwPjUuMS4g0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GOL9Ca0LvQuNC10L3RgtGDINC30LDQv9GA0LXRidC10L3QviDRgNCw0LfQvNC10YnQsNGC0YwsINCwINCyINGB0LvRg9GH0LDQtSDRgNCw0LfQvNC10YnQtdC90LjRjywg0L/QvtC00LvQtdC20LjRgiDRg9C00LDQu9C10L3QuNGOINCY0L3RhNC+0YDQvNCw0YbQuNGPLFxcXFxuICAgICAgICAgICAg0YHQvtC00LXRgNC20LDRidCw0Y86PC9wPlxcXFxuXFxcXG4gICAgICAgIDx1bD5cXFxcbiAgICAgICAgICAgIDxsaT5cXFxcbiAgICAgICAgICAgICAgICA8cD7Qu9C+0LbQvdGL0LUsINC90LXRgtC+0YfQvdGL0LUg0LjQu9C4INCy0LLQvtC00Y/RidC40LUg0LIg0LfQsNCx0LvRg9C20LTQtdC90LjQtSDRgdCy0LXQtNC10L3QuNGPOzwvcD5cXFxcbiAgICAgICAgICAgIDwvbGk+XFxcXG4gICAgICAgICAgICA8bGk+XFxcXG4gICAgICAgICAgICAgICAgPHA+0YHQstC10LTQtdC90LjRjywg0YHQv9C+0YHQvtCx0YHRgtCy0YPRjtGJ0LjQtSDQvNC+0YjQtdC90L3QuNGH0LXRgdGC0LLRgywg0L7QsdC80LDQvdGDINC40LvQuCDQt9C70L7Rg9C/0L7RgtGA0LXQsdC70LXQvdC40Y4g0LTQvtCy0LXRgNC40LXQvDs8L3A+XFxcXG4gICAgICAgICAgICA8L2xpPlxcXFxuICAgICAgICAgICAgPGxpPlxcXFxuICAgICAgICAgICAgICAgIDxwPtC+0YHQutC+0YDQsdC70LXQvdC40Y8g0YfRjNC10Lkt0LvQuNCx0L4g0YfQtdGB0YLQuCwg0LTQvtGB0YLQvtC40L3RgdGC0LLQsCDQuNC70Lgg0LTQtdC70L7QstC+0Lkg0YDQtdC/0YPRgtCw0YbQuNC4LCDQvdCw0YDRg9GI0LXQvdC40Y8g0YfQsNGB0YLQvdC+0Lkg0LbQuNC30L3QuDs8L3A+XFxcXG4gICAgICAgICAgICA8L2xpPlxcXFxuICAgICAgICAgICAgPGxpPlxcXFxuICAgICAgICAgICAgICAgIDxwPtC60LvQtdCy0LXRgtGDINC40LvQuCDRg9Cz0YDQvtC30Ysg0LrQvtC80YMg0LHRiyDRgtC+INC90Lgg0LHRi9C70L47PC9wPlxcXFxuICAgICAgICAgICAgPC9saT5cXFxcbiAgICAgICAgICAgIDxsaT5cXFxcbiAgICAgICAgICAgICAgICA8cD7QvdCw0YDRg9GI0LXQvdC40Y8g0LjQvdGC0LXQu9C70LXQutGC0YPQsNC70YzQvdGL0YUg0L/RgNCw0LIg0YLRgNC10YLRjNC40YUg0LvQuNGGLCDQv9GA0LDQsiDQvdCwINC40LfQvtCx0YDQsNC20LXQvdC40LUg0LPRgNCw0LbQtNCw0L3QuNC90LAsINC4INC40L3Ri9C1INC/0YDQsNCy0LAg0YLRgNC10YLRjNC40YVcXFxcbiAgICAgICAgICAgICAgICAgICAg0LvQuNGGOzwvcD5cXFxcbiAgICAgICAgICAgIDwvbGk+XFxcXG4gICAgICAgICAgICA8bGk+XFxcXG4gICAgICAgICAgICAgICAgPHA+0L/RgNC40LfRi9Cy0Ysg0Log0YHQvtCy0LXRgNGI0LXQvdC40Y4g0L/RgNC10YHRgtGD0L/Qu9C10L3QuNGPINC4INGA0LDQt9C20LjQs9Cw0L3QuNGOINC80LXQttC90LDRhtC40L7QvdCw0LvRjNC90L7QuSDRgNC+0LfQvdC4OzwvcD5cXFxcbiAgICAgICAgICAgIDwvbGk+XFxcXG4gICAgICAgICAgICA8bGk+XFxcXG4gICAgICAgICAgICAgICAgPHA+0YHQstC10LTQtdC90LjRjywg0YHQv9C+0YHQvtCx0YHRgtCy0YPRjtGJ0LjQtSwg0L/QvtC00LTQtdGA0LbQuNCy0LDRjtGJ0LjQtSDQuNC70Lgg0L/RgNC40LfRi9Cy0LDRjtGJ0LjQtSDQuiDRgtC10YDRgNC+0YDQuNGB0YLQuNGH0LXRgdC60L7QuSDQuCDRjdC60YHRgtGA0LXQvNC40YHRgtGB0LrQvtC5XFxcXG4gICAgICAgICAgICAgICAgICAgINC00LXRj9GC0LXQu9GM0L3QvtGB0YLQuDs8L3A+XFxcXG4gICAgICAgICAgICA8L2xpPlxcXFxuICAgICAgICAgICAgPGxpPlxcXFxuICAgICAgICAgICAgICAgIDxwPtGB0LLQtdC00LXQvdC40Y8g0L3QtdC/0YDQuNGB0YLQvtC50L3Ri9C1LCDQu9C40LHQviDQvdC+0YHRj9GJ0LjQtSDRhdCw0YDQsNC60YLQtdGAINC/0L7RgNC90L7Qs9GA0LDRhNC40Lg7PC9wPlxcXFxuICAgICAgICAgICAgPC9saT5cXFxcbiAgICAgICAgICAgIDxsaT5cXFxcbiAgICAgICAgICAgICAgICA8cD7QutC+0LzQv9GM0Y7RgtC10YDQvdGL0LUg0LLQuNGA0YPRgdGLLCDQsCDRgtCw0LrQttC1INC40L3Ri9C1INC60L7QvNC/0YzRjtGC0LXRgNC90YvQtSDQv9GA0L7Qs9GA0LDQvNC80YssINC90LDQv9GA0LDQstC70LXQvdC90YvQtSwg0LIg0YfQsNGB0YLQvdC+0YHRgtC4LCDQvdCwINC90LDQvdC10YHQtdC90LjQtVxcXFxuICAgICAgICAgICAgICAgICAgICDQstGA0LXQtNCwLCDQvdC10YPQv9C+0LvQvdC+0LzQvtGH0LXQvdC90L7QtSDQstGC0L7RgNC20LXQvdC40LUsINGC0LDQudC90YvQuSDQv9C10YDQtdGF0LLQsNGCINC70LjQsdC+INC/0YDQuNGB0LLQvtC10L3QuNC1INC00LDQvdC90YvRhSDQu9GO0LHQvtC5INGB0LjRgdGC0LXQvNGLINC70LjQsdC+INGB0LDQvNC+0LlcXFxcbiAgICAgICAgICAgICAgICAgICAg0YHQuNGB0YLQtdC80YssINC70LjQsdC+INC10LUg0YfQsNGB0YLQuCwg0LvQuNCx0L4g0LvQuNGH0L3QvtC5INC40L3RhNC+0YDQvNCw0YbQuNC4INC40LvQuCDQuNC90YvRhSDQtNCw0L3QvdGL0YUgKNCy0LrQu9GO0YfQsNGPINC00LDQvdC90YvQtSDQmtC+0LzQv9Cw0L3QuNC4KTs8L3A+XFxcXG4gICAgICAgICAgICA8L2xpPlxcXFxuICAgICAgICAgICAgPGxpPlxcXFxuICAgICAgICAgICAgICAgIDxwPtCh0LLQtdC00LXQvdC40Y8sINC/0YDQuNGH0LjQvdGP0Y7RidC40LUg0LLRgNC10LQg0JrQvtC80L/QsNC90LjQuCwg0YHRgtCw0LIg0L/RgNC40YfQuNC90L7QuSDQv9C+0LvQvdC+0Lkg0LvQuNCx0L4g0YfQsNGB0YLQuNGH0L3QvtC5INC/0L7RgtC10YDQuCDQmtC+0LzQv9Cw0L3QuNC10Lkg0YPRgdC70YPQs1xcXFxuICAgICAgICAgICAgICAgICAgICDQv9GA0L7QstCw0LnQtNC10YDQvtCyINGB0LXRgtC4INC40L3RgtC10YDQvdC10YIsINC70LjQsdC+INGD0YHQu9GD0LMg0LvRjtCx0YvRhSDQuNC90YvRhSDQu9C40YY7PC9wPlxcXFxuICAgICAgICAgICAgPC9saT5cXFxcbiAgICAgICAgICAgIDxsaT5cXFxcbiAgICAgICAgICAgICAgICA8cD7RgdCy0LXQtNC10L3QuNGPLCDQuNC90YvQvCDQvtCx0YDQsNC30L7QvCDQvdCw0YDRg9GI0LDRjtGJ0LjQtSDQtNC10LnRgdGC0LLRg9GO0YnQtdC1INC30LDQutC+0L3QvtC00LDRgtC10LvRjNGB0YLQstC+INCg0KQuPC9wPlxcXFxuICAgICAgICAgICAgPC9saT5cXFxcbiAgICAgICAgPC91bD5cXFxcblxcXFxuICAgICAgICA8cD41LjIuINCj0LTQsNC70LXQvdC40LUg0JjQvdGE0L7RgNC80LDRhtC40Lgg0L/RgNC+0LjQt9Cy0L7QtNC40YLRgdGPINCa0L7QvNC/0LDQvdC40LXQuSDQsiDQu9GO0LHQvtC1INCy0YDQtdC80Y8g0LHQtdC3INC40LfQstC10YnQtdC90LjRjyDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAuPC9wPlxcXFxuXFxcXG4gICAgICAgIDxicj5cXFxcblxcXFxuICAgICAgICA8cD48c3Ryb25nPjYuINCe0J/Qm9CQ0KLQkCDQn9Cb0JDQotCd0KvQpSDQo9Ch0JvQo9CTPC9zdHJvbmc+PC9wPlxcXFxuXFxcXG4gICAgICAgIDxwPjYuMS4g0J/QvtGB0LvQtSDQvtGE0L7RgNC80LvQtdC90LjRjyDQu9C40YHRgtCwINC30LDQutCw0LfQsCDQvdCwINC/0L7Qu9GM0LfQvtCy0LDQvdC40LUg0J/Qu9Cw0YLQvdGL0LzQuCDQo9GB0LvRg9Cz0LDQvNC4INCh0LDQudGC0LAg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GML9Ca0LvQuNC10L3RgiDQu9C40LHQviDQn9C70LDRgtC10LvRjNGJ0LjQulxcXFxuICAgICAgICAgICAgKNC/0YDQuCDQvdCw0LvQuNGH0LjQuCksINC/0L7Qu9GD0YfQsNC10YIg0YHRh9C10YIg0Lgg0LLRi9Cx0LjRgNCw0LXRgiDRgdC/0L7RgdC+0LEg0LXQs9C+INC+0L/Qu9Cw0YLRiyDQuNC3INC/0YDQtdC00LvQvtC20LXQvdC90L7Qs9C+INC90LAg0KHQsNC50YLQtSDRgdC/0LjRgdC60LAuINCh0YfQtdGCINC90LXQvtCx0YXQvtC00LjQvNC+XFxcXG4gICAgICAgICAgICDQvtC/0LvQsNGC0LjRgtGMINCyINGD0LrQsNC30LDQvdC90YvQuSDQsiDQvdC10Lwg0YHRgNC+0LouIDYuMi4g0KHRgNC+0Log0L/QvtC70YzQt9C+0LLQsNC90LjRjyDQn9C70LDRgtC90YvQvNC4INCj0YHQu9GD0LPQsNC80Lgg0L3QsNGH0LjQvdCw0LXRgtGB0Y8g0YEg0LTQsNGC0Ysg0L7Qv9C70LDRgtGLINGB0YfQtdGC0LAuXFxcXG4gICAgICAgICAgICDQldGB0LvQuCDQv9GA0Lgg0KDQtdCz0LjRgdGC0YDQsNGG0LjQuCDQvdC1INCx0YvQu9C4INC30LDQv9C+0LvQvdC10L3RiyDQvtCx0Y/Qt9Cw0YLQtdC70YzQvdGL0LUg0L/QvtC70Y8g0LjQu9C4INC/0L7Qu9GPINCx0YvQu9C4INC30LDQv9C+0LvQvdC10L3RiyDQvdC10LrQvtGA0YDQtdC60YLQvdC+LCDQvdC1INCx0YvQu9CwXFxcXG4gICAgICAgICAgICDQt9Cw0LPRgNGD0LbQtdC90LAg0YTQvtGC0L7Qs9GA0LDRhNC40Y8g0LjQu9C4INC40L3Ri9C8INC+0LHRgNCw0LfQvtC8INC90LDRgNGD0YjQtdC90Ysg0L/RgNCw0LLQuNC70LAg0KDQtdCz0LjRgdGC0YDQsNGG0LjQuCwg0JjQvdGE0L7RgNC80LDRhtC40Y8g0L3QtSDQvtGC0YDQsNC20LDQtdGC0YHRjyDQvdCwINCh0LDQudGC0LUg0LTQvlxcXFxuICAgICAgICAgICAg0LzQvtC80LXQvdGC0LAg0LLQvdC10YHQtdC90LjRjyDRgdC+0L7RgtCy0LXRgtGB0YLQstGD0Y7RidC40YUg0LjRgdC/0YDQsNCy0LvQtdC90LjQuSwg0L/RgNC4INGN0YLQvtC8INGB0YDQvtC6INC90LDRh9Cw0LvQsCDQv9C+0LvRjNC30L7QstCw0L3QuNGPINCf0LvQsNGC0L3Ri9C80Lgg0KPRgdC70YPQs9Cw0LzQuCDQvdC1XFxcXG4gICAgICAgICAgICDQv9GA0L7QtNC70Y/QtdGC0YHRjyDQvdCwINGB0YDQvtC6LCDQsiDRgtC10YfQtdC90LjQtSDQutC+0YLQvtGA0L7Qs9C+INCY0L3RhNC+0YDQvNCw0YbQuNGPINC90LUg0L7RgtC+0LHRgNCw0LbQsNC70LDRgdGMINC90LAg0KHQsNC50YLQtSDQv9C+INCy0LjQvdC1INCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjy/QmtC70LjQtdC90YLQsC5cXFxcbiAgICAgICAgICAgIDYuMy4g0JrQsNC20LTRi9C5INGB0L/QvtGB0L7QsSDQvtC/0LvQsNGC0Ysg0YHQvtC/0YDQvtCy0L7QttC00LDQtdGC0YHRjyDQv9C+0LTRgNC+0LHQvdC+0Lkg0LjQvdGB0YLRgNGD0LrRhtC40LXQuSwg0YDQsNC30LzQtdGJ0LXQvdC90L7QuSDQvdCwINCh0LDQudGC0LUuINCf0YDQuCDRjdGC0L7QvCDQmtC+0LzQv9Cw0L3QuNGPINC90LVcXFxcbiAgICAgICAgICAgINC90LXRgdC10YIg0L7RgtCy0LXRgtGB0YLQstC10L3QvdC+0YHRgtGMINC30LAg0LTQtdC50YHRgtCy0LjRjyDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAv0J/Qu9Cw0YLQtdC70YzRiNC40LrQsCDQv9GA0Lgg0L7Qv9C70LDRgtC1INGB0YfQtdGC0LAsINCyINGB0LvQtdC00YHRgtCy0LjQtSDQutC+0YLQvtGA0YvRhVxcXFxuICAgICAgICAgICAg0LTQtdC90LXQttC90YvQtSDRgdGA0LXQtNGB0YLQstCwINC90LUg0L/QvtGB0YLRg9C/0LjQu9C4INC90LAg0YHRh9C10YIg0JrQvtC80L/QsNC90LjQuCwg0Lgg0Y3RgtC4INGB0YPQvNC80Ysg0JrQvtC80L/QsNC90LjRjyDQvdC1INC60L7QvNC/0LXQvdGB0LjRgNGD0LXRgiDQuCDQvdC1INCy0L7Qt9Cy0YDQsNGJ0LDQtdGCLjxicj5cXFxcbiAgICAgICAgICAgIDYuNC4g0J7Qv9C70LDRgtCwINCj0YHQu9GD0LMg0YHQsNC50YLQsCDQv9GA0L7QuNC30LLQvtC00LjRgtGB0Y8g0LIg0L/QvtGA0Y/QtNC60LUgMTAwJSDQv9GA0LXQtNC+0L/Qu9Cw0YLRiy4g0KPRgdC70YPQs9C4INGB0YfQuNGC0LDRjtGC0YHRjyDQvtC/0LvQsNGH0LXQvdC90YvQvNC4INCyINC80L7QvNC10L3RglxcXFxuICAgICAgICAgICAg0LjQt9Cy0LXRidC10L3QuNGPINCa0L7QvNC/0LDQvdC40Lgg0L7QsSDQvtC/0LvQsNGC0LUg0YHRh9C10YLQsC4g0JLQsNC70Y7RgtC+0Lkg0YDQsNGB0YfQtdGC0L7QsiDRj9Cy0LvRj9C10YLRgdGPINCg0L7RgdGB0LjQudGB0LrQuNC5INGA0YPQsdC70YwuPGJyPlxcXFxuICAgICAgICAgICAgNi41LiDQkiDRgdC70YPRh9Cw0LUg0L7RgtC60LDQt9CwINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjy/QmtC70LjQtdC90YLQsCDQvtGCINC+0L/Qu9Cw0YfQtdC90L3Ri9GFINCj0YHQu9GD0LMg0KHQsNC50YLQsCDQtNC+INC+0LrQvtC90YfQsNC90LjRjyDRgdGA0L7QutCwINC/0L7Qu9GM0LfQvtCy0LDQvdC40Y8g0LTQtdC90LXQttC90YvQtVxcXFxuICAgICAgICAgICAg0YHRgNC10LTRgdGC0LLQsCDQvdC1INCy0L7Qt9Cy0YDQsNGJ0LDRjtGC0YHRjy48L3A+XFxcXG5cXFxcbiAgICAgICAgPGJyPlxcXFxuXFxcXG4gICAgICAgIDxwPjxzdHJvbmc+Ny4g0J7Qk9Cg0JDQndCY0KfQldCd0JjQryDQntCi0JLQldCi0KHQotCS0JXQndCd0J7QodCi0Jg8L3N0cm9uZz48L3A+XFxcXG5cXFxcbiAgICAgICAgPHA+Ny4xLiDQkiDRgdC+0L7RgtCy0LXRgtGB0YLQstC40Lgg0YEg0YLRgNC10LHQvtCy0LDQvdC40Y/QvNC4INCk0LXQtNC10YDQsNC70YzQvdC+0LPQviDQt9Cw0LrQvtC90LAg0L7RgiAyNy4wNy4yMDA2INCzLiDihJYgMTUyLdCk0JcgwqvQniDQv9C10YDRgdC+0L3QsNC70YzQvdGL0YUg0LTQsNC90L3Ri9GFwrs6INCyXFxcXG4gICAgICAgICAgICDQv9GA0L7RhtC10YHRgdC1INC/0L7Qu9GM0LfQvtCy0LDQvdC40Y8g0KPRgdC70YPQs9Cw0LzQuCDQodCw0LnRgtCwICjQsiDRgtC+0Lwg0YfQuNGB0LvQtSDQv9GA0Lgg0KDQtdCz0LjRgdGC0YDQsNGG0LjQuCwg0LLQt9Cw0LjQvNC+0LTQtdC50YHRgtCy0LjQuCDRgSDQtNGA0YPQs9C40LzQuFxcXFxuICAgICAgICAgICAg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GP0LzQuC/QmtC70LjQtdC90YLQsNC80Lgg0YfQtdGA0LXQtyDQuNC90YLQtdGA0YTQtdC50YEg0KHQsNC50YLQsCwg0YDQsNC30LzQtdGJ0LXQvdC40Lgg0JjQvdGE0L7RgNC80LDRhtC40LgsINC/0YDQvtGB0LzQvtGC0YDQtSDRgdGC0YDQsNC90LjRhiDQodCw0LnRgtCwINC4INGCLtC/LiksXFxcXG4gICAgICAgICAgICDQn9C+0LvRjNC30L7QstCw0YLQtdC70Ywg0YHQsNC80L7RgdGC0L7Rj9GC0LXQu9GM0L3QviDQtNC+0LHRgNC+0LLQvtC70YzQvdC+INC/0YDQuNC90LjQvNCw0LXRgiDRgNC10YjQtdC90LjQtSDQviDQv9GA0LXQtNC+0YHRgtCw0LLQu9C10L3QuNC4INCa0L7QvNC/0LDQvdC40Lgg0L/QtdGA0YHQvtC90LDQu9GM0L3Ri9GFINC4INC40L3Ri9GFXFxcXG4gICAgICAgICAgICDQtNCw0L3QvdGL0YUg0L4g0J/QvtC70YzQt9C+0LLQsNGC0LXQu9C1ICjRhNCw0LzQuNC70LjRjywg0LjQvNGPLCDQvtGC0YfQtdGB0YLQstC+LCDQsNC00YDQtdGBINGN0LvQtdC60YLRgNC+0L3QvdC+0Lkg0L/QvtGH0YLRiywg0L3QvtC80LXRgCDQvNC+0LHQuNC70YzQvdC+0LPQviDRgtC10LvQtdGE0L7QvdCwLCDQsCDRgtCw0LrQttC1XFxcXG4gICAgICAgICAgICDQu9GO0LHQsNGPINC40L3QsNGPINC40L3RhNC+0YDQvNCw0YbQuNGPLCDQv9GA0LXQtNC+0YHRgtCw0LLQu9C10L3QvdCw0Y8g0J/QvtC70YzQt9C+0LLQsNGC0LXQu9C10LwsINC40L3RhNC+0YDQvNCw0YbQuNGPINC+INC00LXQudGB0YLQstC40Y/RhSDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8g0L3QsCDQodCw0LnRgtC1INC4INC/0YAuKVxcXFxuICAgICAgICAgICAg0LTQu9GPINGG0LXQu9C10Lkg0LjRgdC/0L7Qu9C90LXQvdC40Y8g0J7RhNC10YDRgtGLLCDQsCDRgtCw0LrQttC1INC90LDRgdGC0L7Rj9GJ0LjQvCDQt9Cw0Y/QstC70Y/QtdGCINC+INGB0LLQvtC10Lwg0YHQvtCz0LvQsNGB0LjQuCDQvdCwINC+0LHRgNCw0LHQvtGC0LrRgyDQuCDRhdGA0LDQvdC10L3QuNC1INCa0L7QvNC/0LDQvdC40LXQuVxcXFxuICAgICAgICAgICAg0L/QtdGA0YHQvtC90LDQu9GM0L3Ri9GFINC4INC40L3Ri9GFINC00LDQvdC90YvRhSDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8sINC40YUg0L/QtdGA0LXQtNCw0YfRgyDQtNC70Y8g0L7QsdGA0LDQsdC+0YLQutC4INC00YDRg9Cz0LjQvCDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y/QvCDQuC/QuNC70Lgg0YLRgNC10YLRjNC40Lwg0LvQuNGG0LDQvCxcXFxcbiAgICAgICAgICAgINC00LXQudGB0YLQstGD0Y7RidC40Lwg0L/QviDQv9C+0YDRg9GH0LXQvdC40Y4g0JrQvtC80L/QsNC90LjQuCwg0LIg0YLQvtC8INGH0LjRgdC70LUg0LTQu9GPINGG0LXQu9C10Lk6INC/0L7Qu9GD0YfQtdC90LjRjyDRgdGC0LDRgtC40YHRgtC40YfQtdGB0LrQuNGFINC4INCw0L3QsNC70LjRgtC40YfQtdGB0LrQuNGFINC00LDQvdC90YvRhVxcXFxuICAgICAgICAgICAg0LTQu9GPINGD0LvRg9GH0YjQtdC90LjRjyDRhNGD0L3QutGG0LjQvtC90LjRgNC+0LLQsNC90LjRjyDQodCw0LnRgtCwINC4L9C40LvQuCDQo9GB0LvRg9CzLCDRgNCw0YHRiNC40YDQtdC90LjRjyDRgdC/0LXQutGC0YDQsCDQvtC60LDQt9GL0LLQsNC10LzRi9GFINCj0YHQu9GD0LMsINC/0L7Qu9GD0YfQtdC90LjRj1xcXFxuICAgICAgICAgICAg0LjQvdGE0L7RgNC80LDRhtC40L7QvdC90YvRhSDQuC/QuNC70Lgg0YDQtdC60LvQsNC80L3Ri9GFINGB0L7QvtCx0YnQtdC90LjQuSDQmtC+0LzQv9Cw0L3QuNC4INC40LvQuCDRgtGA0LXRgtGM0LjRhSDQu9C40YYsINC/0YDQtdC00YPQv9GA0LXQttC00LXQvdC40Y8g0LjQu9C4INC/0YDQtdGB0LXRh9C10L3QuNGPINC90LXQt9Cw0LrQvtC90L3Ri9GFXFxcXG4gICAgICAgICAgICDQuC/QuNC70Lgg0L3QtdGB0LDQvdC60YbQuNC+0L3QuNGA0L7QstCw0L3QvdGL0YUg0LTQtdC50YHRgtCy0LjQuSDQn9C+0LvRjNC30L7QstCw0YLQtdC70LXQuSDQuNC70Lgg0YLRgNC10YLRjNC40YUg0LvQuNGGLCDQvtCx0LXRgdC/0LXRh9C10L3QuNGPINGB0L7QsdC70Y7QtNC10L3QuNGPINGC0YDQtdCx0L7QstCw0L3QuNC5XFxcXG4gICAgICAgICAgICDQtNC10LnRgdGC0LLRg9GO0YnQtdCz0L4g0LfQsNC60L7QvdC+0LTQsNGC0LXQu9GM0YHRgtCy0LAg0KDQvtGB0YHQuNC50YHQutC+0Lkg0KTQtdC00LXRgNCw0YbQuNC4LiDQmtC+0LzQv9Cw0L3QuNGPINC/0YDQuNC90LjQvNCw0LXRgiDQstGB0LUg0L3QtdC+0LHRhdC+0LTQuNC80YvQtSDQvNC10YDRiyDQtNC70Y8g0LfQsNGJ0LjRgtGLXFxcXG4gICAgICAgICAgICDQv9C10YDRgdC+0L3QsNC70YzQvdGL0YUg0LTQsNC90L3Ri9GFINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjyDQvtGCINC90LXRgdCw0L3QutGG0LjQvtC90LjRgNC+0LLQsNC90L3QvtCz0L4g0LTQvtGB0YLRg9C/0LAg0YLRgNC10YLRjNC40YUg0LvQuNGGPGJyPlxcXFxuICAgICAgICAgICAgNy4yLiDQmtC+0LzQv9Cw0L3QuNGPINC90LUg0L7RgtCy0LXRh9Cw0LXRgiDQt9CwINCy0L7Qt9C80L7QttC90L7QtSDQvdC10YbQtdC70LXQstC+0LUg0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40LUg0LjQvdGE0L7RgNC80LDRhtC40Lgg0YEg0KHQsNC50YLQsCDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y/QvNC4L9Ca0LvQuNC10L3RgtCw0LzQuFxcXFxuICAgICAgICAgICAg0LjQu9C4INC40L3Ri9C80Lgg0LvQuNGG0LDQvNC4INC4L9C40LvQuCDQvtGA0LPQsNC90LjQt9Cw0YbQuNGP0LzQuCwg0LrQvtGC0L7RgNC+0LUg0L/RgNC+0LjQt9C+0YjQu9C+INCx0LXQtyDRg9Cy0LXQtNC+0LzQu9C10L3QuNGPINCa0L7QvNC/0LDQvdC40Lgg0YEg0L3QsNGA0YPRiNC10L3QuNC10Lwg0LjQu9C4INCx0LXQt1xcXFxuICAgICAgICAgICAg0LjQvdGE0L7RgNC80LDRhtC40L7QvdC90L7QuSDQsdC10LfQvtC/0LDRgdC90L7RgdGC0Lgg0KHQsNC50YLQsC48YnI+XFxcXG4gICAgICAgICAgICA3LjMuINCa0L7QvNC/0LDQvdC40Y8g0L/RgNC40LvQsNCz0LDQtdGCINCy0YHQtSDQstC+0LfQvNC+0LbQvdGL0LUg0YPRgdC40LvQuNGPINC00LvRjyDRgtC+0LPQviwg0YfRgtC+0LHRiyDQuNC30LHQtdC20LDRgtGMINC90LXRgdCw0L3QutGG0LjQvtC90LjRgNC+0LLQsNC90L3QvtCz0L4g0LjRgdC/0L7Qu9GM0LfQvtCy0LDQvdC40Y9cXFxcbiAgICAgICAgICAgINGC0YDQtdGC0YzQuNC80Lgg0LvQuNGG0LDQvNC4INC/0LXRgNGB0L7QvdCw0LvRjNC90YvRhSDQtNCw0L3QvdGL0YUg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9C10Lkv0JrQu9C40LXQvdGC0L7Qsi4g0J3QviDQmtC+0LzQv9Cw0L3QuNGPINGC0LDQutC20LUg0L3QtSDQvdC10YHQtdGCINC+0YLQstC10YLRgdGC0LLQtdC90L3QvtGB0YLQuCDQt9CwXFxcXG4gICAgICAgICAgICDQstC+0LfQvNC+0LbQvdC+0LUg0L3QtdGG0LXQu9C10LLQvtC1INC40YHQv9C+0LvRjNC30L7QstCw0L3QuNC1INC/0LXRgNGB0L7QvdCw0LvRjNC90YvRhSDQtNCw0L3QvdGL0YUg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9C10Lkv0JrQu9C40LXQvdGC0L7Qsiwg0L/RgNC+0LjQt9C+0YjQtdC00YjQtdC1INCyINGB0LvRg9GH0LDQtTo8YnI+XFxcXG4gICAgICAgICAgICAtINGC0LXRhdC90LjRh9C10YHQutC40YUg0L3QtdC/0L7Qu9Cw0LTQvtC6INCyINC/0YDQvtCz0YDQsNC80LzQvdC+0Lwg0L7QsdC10YHQv9C10YfQtdC90LjQuCwg0YHQtdGA0LLQtdGA0LDRhSDQuNC70Lgg0LrQvtC80L/RjNGO0YLQtdGA0L3Ri9GFINGB0LXRgtGP0YUsINC90LDRhdC+0LTRj9GJ0LjRhdGB0Y8g0LLQvdC1INC60L7QvdGC0YDQvtC70Y9cXFxcbiAgICAgICAgICAgINCa0L7QvNC/0LDQvdC40Lg7PGJyPlxcXFxuICAgICAgICAgICAgLSDQv9C10YDQtdCx0L7QtdCyINCyINGA0LDQsdC+0YLQtSDQodCw0LnRgtCwLCDRgdCy0Y/Qt9Cw0L3QvdGL0YUg0YEg0L3QsNC80LXRgNC10L3QvdGL0Lwg0LjQu9C4INC90LXQvdCw0LzQtdGA0LXQvdC90YvQvCDQuNGB0L/QvtC70YzQt9C+0LLQsNC90LjQtdC8INCh0LDQudGC0LAg0L3QtSDQv9C+INC90LDQt9C90LDRh9C10L3QuNGOXFxcXG4gICAgICAgICAgICDRgtGA0LXRgtGM0LjQvNC4INC70LjRhtCw0LzQuDs8YnI+XFxcXG4gICAgICAgICAgICAtINC/0LXRgNC10LTQsNGH0Lgg0L/QsNGA0L7Qu9C10Lkg0LjQu9C4INC40L3RhNC+0YDQvNCw0YbQuNC4INGBINCh0LDQudGC0LAg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GP0LzQuC/QmtC70LjQtdC90YLQsNC80Lgg0LTRgNGD0LPQuNC8INC70LjRhtCw0LwsINC90LUg0Y/QstC70Y/RjtGJ0LjQvNC40YHRj1xcXFxuICAgICAgICAgICAg0LfQsNGA0LXQs9C40YHRgtGA0LjRgNC+0LLQsNC90L3Ri9C80Lgg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GP0LzQuCDQodCw0LnRgtCwINC40LvQuCDQtNGA0YPQs9C40Lwg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GP0LwsINC90LUg0LjQvNC10Y7RidC40Lwg0LTQvtGB0YLRg9C/0LAg0Log0LTQsNC90L3QvtC5INC40L3RhNC+0YDQvNCw0YbQuNC4INCyXFxcXG4gICAgICAgICAgICDRgdC40LvRgyDRg9GB0LvQvtCy0LjQuSDRgNC10LPQuNGB0YLRgNCw0YbQuNC4INC4INC30LDQutC70Y7Rh9C10L3QvdGL0YUg0LTQvtCz0L7QstC+0YDQvtCyINGBINCa0L7QvNC/0LDQvdC40LXQuS48YnI+XFxcXG4gICAgICAgICAgICA3LjQuINCa0LDQttC00YvQuSDQn9C+0LvRjNC30L7QstCw0YLQtdC70Ywv0JrQu9C40LXQvdGCINC+0YLQstC10YfQsNC10YIg0LfQsCDQmNC90YTQvtGA0LzQsNGG0LjRjiwg0YDQsNC30LzQtdGJ0LDQtdC80YPRjiDQvtGCINC10LPQviDQuNC80LXQvdC4LCDQuCDQt9CwINC/0L7RgdC70LXQtNGB0YLQstC40Y8g0Y3RgtC+0LPQvlxcXFxuICAgICAgICAgICAg0YDQsNC30LzQtdGJ0LXQvdC40Y8uPGJyPlxcXFxuICAgICAgICAgICAgNy41LiDQn9C+0LvRjNC30L7QstCw0YLQtdC70Ywv0JrQu9C40LXQvdGCINGB0LDQvNC+0YHRgtC+0Y/RgtC10LvRjNC90L4sINC/0L4g0YHQstC+0LXQvNGDINGD0YHQvNC+0YLRgNC10L3QuNGOINC4INCy0L3QtSDQutC+0L3RgtGA0L7Qu9GPINGB0L4g0YHRgtC+0YDQvtC90Ysg0JrQvtC80L/QsNC90LjQuCDRgNCw0LfQvNC10YnQsNC10YJcXFxcbiAgICAgICAgICAgINCY0L3RhNC+0YDQvNCw0YbQuNGOINC90LAg0KHQsNC50YLQtSwg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GML9Ca0LvQuNC10L3RgiDQvdC10YHQtdGCINC+0YLQstC10YLRgdGC0LLQtdC90L3QvtGB0YLRjCDQutCw0Log0YDQtdC60LvQsNC80L7QtNCw0YLQtdC70Ywg0Lgg0YDQtdC60LvQsNC80L7RgNCw0YHQv9GA0L7RgdGC0YDQsNC90LjRgtC10LvRjCDQslxcXFxuICAgICAgICAgICAg0L7RgtC90L7RiNC10L3QuNC4INCy0YHQtdC5INGA0LDQt9C80LXRidC10L3QvdC+0Lkg0LjQvCDQmNC90YTQvtGA0LzQsNGG0LjQuCDQsiDRgdC+0L7RgtCy0LXRgtGB0YLQstC40Lgg0YEg0KTQlyBcXFxcXCLQniDRgNC10LrQu9Cw0LzQtVxcXFxcIiDQuCDQmtC+0JDQnyDQoNCkLjxicj5cXFxcbiAgICAgICAgICAgIDcuNi4g0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GML9Ca0LvQuNC10L3RgiDRgdCw0LzQvtGB0YLQvtGP0YLQtdC70YzQvdC+INC90LXRgdC10YIg0L7RgtCy0LXRgtGB0YLQstC10L3QvdC+0YHRgtGMINC30LAg0LTQvtGB0YLQvtCy0LXRgNC90L7RgdGC0Ywg0YDQsNC30LzQtdGJ0LDQtdC80L7QuSDQmNC90YTQvtGA0LzQsNGG0LjQuCDQuFxcXFxuICAgICAgICAgICAg0LrQsNGH0LXRgdGC0LLQviDQv9GA0LXQtNC+0YHRgtCw0LLQu9GP0LXQvNGL0YUg0LjQvCDRg9GB0LvRg9CzLCDQutC+0YLQvtGA0YvQtSDRgdC+0LTQtdGA0LbQsNGC0YHRjyDQsiDQmNC90YTQvtGA0LzQsNGG0LjQuCwg0LAg0YLQsNC60LbQtSDQvtGB0LLQvtCx0L7QttC00LDQtdGCINCa0L7QvNC/0LDQvdC40Y4g0L7RgiDQstGB0LXRhVxcXFxuICAgICAgICAgICAg0YLRgNC10LHQvtCy0LDQvdC40LksINC+0LHRj9C30LDRgtC10LvRjNGB0YLQsiwg0LrQvtC80L/QtdC90YHQsNGG0LjQuSDQv9C+INCy0L7Qt9C80LXRidC10L3QuNGOINGD0YnQtdGA0LHQsCwg0YPQsdGL0YLQutC+0LIsINC30LDRgtGA0LDRgiDQuCDQuNC30LTQtdGA0LbQtdC6LCDQstC60LvRjtGH0LDRjyDRgdGD0LTQtdCx0L3Ri9C1INC4XFxcXG4gICAgICAgICAgICDQuNC90YvQtSDRgNCw0YHRhdC+0LTRiywg0LLQvtC30L3QuNC60YjQuNC1INCyINGA0LXQt9GD0LvRjNGC0LDRgtC1INC40LvQuCDQsiDRgdCy0Y/Qt9C4INGBINGC0YDQtdCx0L7QstCw0L3QuNGP0LzQuCDRgtGA0LXRgtGM0LjRhSDQu9C40YYuPC9wPlxcXFxuXFxcXG4gICAgICAgIDxicj5cXFxcblxcXFxuICAgICAgICA8cD48c3Ryb25nPjguINCX0JDQmtCb0K7Qp9CY0KLQldCb0KzQndCr0JUg0J/QntCb0J7QltCV0J3QmNCvPC9zdHJvbmc+PC9wPlxcXFxuXFxcXG4gICAgICAgIDxwPjguMSDQn9C+0LvRjNC30L7QstCw0YLQtdC70Ywv0JrQu9C40LXQvdGCINC/0YDQtdC00L7RgdGC0LDQstC70Y/QtdGCINCa0L7QvNC/0LDQvdC40Lgg0L/RgNCw0LLQviDQuNGB0L/QvtC70YzQt9C+0LLQsNGC0Ywg0YHQstC10LTQtdC90LjRjywg0YHQvtC00LXRgNC20LDRidC40LXRgdGPINCyINCY0L3RhNC+0YDQvNCw0YbQuNC4XFxcXG4gICAgICAgICAgICDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAsINC00LvRjyDRhtC10LvQtdC5INC+0LrQsNC30LDQvdC40Y8g0KPRgdC70YPQsywg0L/Rg9GC0LXQvCDQv9C10YDQtdC00LDRh9C4INCa0L7QvNC/0LDQvdC40Lgg0L3QtSDRjdC60YHQutC70Y7Qt9C40LLQvdC+0LPQviwg0LTQtdC50YHRgtCy0YPRjtGJ0LXQs9C+XFxcXG4gICAgICAgICAgICDQv9C+0LLRgdC10LzQtdGB0YLQvdC+LCDQsdC10YHRgdGA0L7Rh9C90L7Qs9C+INC/0YDQsNCy0LAg0L7RgtC90L7RgdC40YLQtdC70YzQvdC+INCw0LLRgtC+0YDRgdC60LjRhSDQv9GA0LDQsiwg0YLQvtGA0LPQvtCy0YvRhSDQvNCw0YDQvtC6LCDQu9C+0LPQvtGC0LjQv9C+0LIsINC/0YPQsdC70LjQutCw0YbQuNC5INC4INCx0LDQt1xcXFxuICAgICAgICAgICAg0LTQsNC90L3Ri9GFLCDQutC+0YLQvtGA0L7QtSDQuNC80LXQtdGCINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjC/QmtC70LjQtdC90YIg0Lgg0L/RgNC10LTQvtGB0YLQsNCy0LvQtdC90L3Ri9GFINC40Lwg0L3QsCDQstGB0LXRhSDQuNC30LLQtdGB0YLQvdGL0YUg0LjQu9C4INC90LUg0LjQt9Cy0LXRgdGC0L3Ri9GFXFxcXG4gICAgICAgICAgICDQuNC90YTQvtGA0LzQsNGG0LjQvtC90L3Ri9GFINC90L7RgdC40YLQtdC70Y/RhS48YnI+XFxcXG4gICAgICAgICAgICA4LjIuINCd0LDRgdGC0L7Rj9GJ0LDRjyDQntGE0LXRgNGC0LAg0L3QsNGH0LjQvdCw0LXRgiDQtNC10LnRgdGC0LLQvtCy0LDRgtGMINC4LCDRgdGH0LjRgtCw0LXRgtGB0Y8sINCx0LXQt9GD0YHQu9C+0LLQvdC+INC/0YDQuNC90Y/RgtC+0LlcXFxcbiAgICAgICAgICAgINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvQtdC8XFxcXFxc0JrQu9C40LXQvdGC0L7QvFxcXFxcXNCT0L7RgdGC0LXQvFxcXFxcXNC/0LvQsNGC0LXQu9GM0YnQuNC60L7QvCDRgSDQvNC+0LzQtdC90YLQsCDQvdCw0YfQsNC70LAg0L/QvtC70YzQt9C+0LLQsNC90LjRjyDQo9GB0LvRg9Cz0LDQvCDQodCw0LnRgtCwLCDQvdC10LfQsNCy0LjRgdC40LzQviDQvtGCINGE0LDQutGC0LBcXFxcbiAgICAgICAgICAgINCg0LXQs9C40YHRgtGA0LDRhtC40LgsINC4INC00LXQudGB0YLQstGD0LXRgiDQsdC10YHRgdGA0L7Rh9C90L4uPGJyPlxcXFxuICAgICAgICAgICAgOC4zLiDQn9C+0LvRjNC30L7QstCw0YLQtdC70Ywv0JrQu9C40LXQvdGCINCy0L/RgNCw0LLQtSDQvtGC0LrQsNC30LDRgtGM0YHRjyDQvtGCINC/0L7Qu9GM0LfQvtCy0LDQvdC40Y8g0KPRgdC70YPQs9Cw0LzQuCDQodCw0LnRgtCwLCDQv9C+0YHQu9C1INGH0LXQs9C+INGA0LDQt9C80LXRidC10L3QuNC1INCY0L3RhNC+0YDQvNCw0YbQuNC4XFxcXG4gICAgICAgICAgICDQvdCwINCh0LDQudGC0LUg0L7RgiDQtNCw0L3QvdC+0LPQviDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAg0L3QtdCy0L7Qt9C80L7QttC90L4uPGJyPlxcXFxuICAgICAgICAgICAgOC40LiDQmtC+0LzQv9Cw0L3QuNGPINC+0YHRgtCw0LLQu9GP0LXRgiDQt9CwINGB0L7QsdC+0Lkg0L/RgNCw0LLQviDQv9C+INGB0L7QsdGB0YLQstC10L3QvdC+0LzRgyDRg9GB0LzQvtGC0YDQtdC90LjRjiDQv9GA0LXQutGA0LDRgtC40YLRjCDQtNC+0YHRgtGD0L8g0Log0KPRgdC70YPQs9Cw0LxcXFxcbiAgICAgICAgICAgINCf0L7Qu9GM0LfQvtCy0LDRgtC10LvRjy/QmtC70LjQtdC90YLQsCwg0L3QsNGA0YPRiNCw0Y7RidC10LPQviDQntGE0LXRgNGC0YMsINCU0L7Qs9C+0LLQvtGAINC70LjQsdC+INC70LjRgdGCINC30LDQutCw0LfQsC4g0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GML9Ca0LvQuNC10L3Rgiwg0LTQvtGB0YLRg9C/INC60L7RgtC+0YDQvtCz0L4g0LpcXFxcbiAgICAgICAgICAgINCj0YHQu9GD0LPQsNC8INCx0YvQuyDQv9GA0LXQutGA0LDRidC10L0sINC40LvQuCDQmNC90YTQvtGA0LzQsNGG0LjRjyDQutC+0YLQvtGA0L7Qs9C+INC/0LXRgNC10YHRgtCw0LvQsCDQsdGL0YLRjCDQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3QvtC5LCDQvdC1INC40LzQtdC10YIg0L/RgNCw0LLQsFxcXFxuICAgICAgICAgICAg0YDQtdCz0LjRgdGC0YDQuNGA0L7QstCw0YLRjNGB0Y8g0L/QvtCy0YLQvtGA0L3QviDQsdC10Lcg0YHQvtC+0YLQstC10YLRgdGC0LLRg9GO0YnQtdCz0L4g0YHQvtCz0LvQsNGB0LjRjyDQmtC+0LzQv9Cw0L3QuNC4LCDQsCDRgtCw0LrQttC1INGC0LDQutC+0Lkg0J/QvtC70YzQt9C+0LLQsNGC0LXQu9GML9Ca0LvQuNC10L3RgiDQvdC1INC40LzQtdC10YJcXFxcbiAgICAgICAgICAgINC/0YDQsNCy0LAg0LjRgdC/0L7Qu9GM0LfQvtCy0LDRgtGMINC00LvRjyDQtNC+0YHRgtGD0L/QsCDQvdCwINCh0LDQudGCINCj0YfQtdGC0L3Ri9C1INC00LDQvdC90YvQtSDQtNGA0YPQs9C+0LPQviDQn9C+0LvRjNC30L7QstCw0YLQtdC70Y8v0JrQu9C40LXQvdGC0LAuPGJyPlxcXFxuICAgICAgICAgICAgOC41LiDQodC/0L7RgNGLLCDQstC+0LfQvdC40LrQsNGO0YnQuNC1INCyINGF0L7QtNC1INC/0L7Qu9GM0LfQvtCy0LDQvdC40Y8g0KHQsNC50YLQvtC8LCDRgNCw0LfRgNC10YjQsNGO0YLRgdGPINGBINGB0L7QsdC70Y7QtNC10L3QuNC10Lwg0L7QsdGP0LfQsNGC0LXQu9GM0L3QvtCz0L4g0L/RgNC10YLQtdC90LfQuNC+0L3QvdC+0LPQvlxcXFxuICAgICAgICAgICAg0L/QvtGA0Y/QtNC60LAuINCh0YDQvtC6INC+0YLQstC10YLQsCDQvdCwINC/0YDQtdGC0LXQvdC30LjRjiAxNSDQtNC90LXQuSDRgdC+INC00L3RjyDQv9C+0LvRg9GH0LXQvdC40Y8g0L/RgNC10YLQtdC90LfQuNC4LiDQkiDRgdC70YPRh9Cw0LUg0L3QtdGD0LTQvtCy0LvQtdGC0LLQvtGA0LXQvdC40Y8g0L/RgNC10YLQtdC90LfQuNC4XFxcXG4gICAgICAgICAgICDQv9C+0LvQvdC+0YHRgtGM0Y4g0LjQu9C4INCyINC60LDQutC+0Lkt0LvQuNCx0L4g0YfQsNGB0YLQuCwg0LAg0YLQsNC60LbQtSDQsiDRgdC70YPRh9Cw0LUg0L3QtdC/0L7Qu9GD0YfQtdC90LjRjyDQvtGC0LLQtdGC0LAg0L3QsCDQv9GA0LXRgtC10L3Qt9C40Y4g0LIg0YPRgdGC0LDQvdC+0LLQu9C10L3QvdGL0Lkg0YHRgNC+0LosXFxcXG4gICAgICAgICAgICDQt9Cw0LjQvdGC0LXRgNC10YHQvtCy0LDQvdC90LDRjyDRgdGC0L7RgNC+0L3QsCDQstC/0YDQsNCy0LUg0L7QsdGA0LDRgtC40YLRjNGB0Y8g0LfQsCDRgNCw0LfRgNC10YjQtdC90LjQtdC8INGB0L/QvtGA0LAg0LIg0YHRg9C0INGBINGC0LXRgNGA0LjRgtC+0YDQuNCw0LvRjNC90L7QuSDQv9C+0LTRgdGD0LTQvdC+0YHRgtGM0Y5cXFxcbiAgICAgICAgICAgINCa0L7QvNC/0LDQvdC40LguPGJyPlxcXFxuICAgICAgICAgICAgOC42LiDQkiDRgdC70YPRh9Cw0LUg0L/RgNC40LfQvdCw0L3QuNGPINGB0YPQtNC+0Lwg0L7RgtC00LXQu9GM0L3Ri9GFINC/0L7Qu9C+0LbQtdC90LjQuSDQvdCw0YHRgtC+0Y/RidC10Lkg0J7RhNC10YDRgtGLINC90LXQtNC10LnRgdGC0LLQuNGC0LXQu9GM0L3Ri9C80LgsINC+0YHRgtCw0LvRjNC90YvQtSDRg9GB0LvQvtCy0LjRj1xcXFxuICAgICAgICAgICAg0J7RhNC10YDRgtGLINC/0YDQvtC00L7Qu9C20LDRjtGCINC00LXQudGB0YLQstC+0LLQsNGC0YwuXFxcXG4gICAgICAgIDwvcD5cXFxcbiAgICAgICAgPGJyPlxcXFxuICAgIDwvZGl2PlxcXFxuPC9kaXY+XFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLXJlY29tbWVuZGF0aW9uJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtcmVjb21tZW5kYXRpb24vaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwicGFnZS1yZWNvbW1lbmRhdGlvblwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJwYWdlX29odF9yZWNvbW1lbmRhdGlvblxcXFxcIj5cXFxcbiAgICA8Y2F0LWNvbW1vbi1oMSBpZD1cXFxcXCJjb21tb24taDFcXFxcXCIgbmFtZT1cXFxcXCLQnNCw0YHRgtC10YDQsCDQviDRgdCw0LnRgtC1XFxcXFwiPjwvY2F0LWNvbW1vbi1oMT5cXFxcblxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwicGFnZV9vaHRfcmVjb21tZW5kYXRpb25fX2xpc3RcXFxcXCI+XFxcXG5cXFxcbiAgICAgICAgPGNhdC1vdGhlci1yZWNvbW1lbmRhdGlvbiBpZD1cXFxcXCJvdGhlci1yZWNvbW1lbmRhdGlvblxcXFxcIiBjYXQtc3RvcmU9XFxcXFwib3RoZXIvUmVjb21tZW5kYXRpb25cXFxcXCI+PC9jYXQtb3RoZXItcmVjb21tZW5kYXRpb24+XFxcXG4gICAgICAgIDxjYXQtY29tbW9uLXBhZ2luYXRvciBpZD1cXFxcXCJjb21tb24tcGFnaW5hdG9yXFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJQYWdpbmF0b3JcXFxcXCIgbW9kZWw9XFxcXFwib3RoZXIvUmVjb21tZW5kYXRpb25cXFxcXCI+PC9jYXQtY29tbW9uLXBhZ2luYXRvcj5cXFxcblxcXFxuICAgIDwvZGl2PlxcXFxuPC9kaXY+XCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAncGFnZS1yZWdpc3RyYXRpb24nLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1yZWdpc3RyYXRpb24vaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwicGFnZS1yZWdpc3RyYXRpb25cIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIjxjYXQtcmVnaXN0cmF0aW9uLWhlYWRlciBpZD1cXFxcXCJyZWdpc3RyYXRpb24taGVhZGVyXFxcXFwiPjwvY2F0LXJlZ2lzdHJhdGlvbi1oZWFkZXI+XFxcXG48ZGl2IGlkPVxcXFxcImZvcm0xXFxcXFwiPlxcXFxuICAgIDxjYXQtcmVnaXN0cmF0aW9uLWZvcm0gaWQ9XFxcXFwicmVnaXN0cmF0aW9uLWZvcm0tMVxcXFxcIj48L2NhdC1yZWdpc3RyYXRpb24tZm9ybT5cXFxcbjwvZGl2PlxcXFxuPGNhdC1yZWdpc3RyYXRpb24tYWJvdXQgaWQ9XFxcXFwicmVnaXN0cmF0aW9uLWFib3V0XFxcXFwiPjwvY2F0LXJlZ2lzdHJhdGlvbi1hYm91dD5cXFxcbjxjYXQtcmVnaXN0cmF0aW9uLXdoeS13ZSBpZD1cXFxcXCJyZWdpc3RyYXRpb24td2h5LXdlXFxcXFwiPjwvY2F0LXJlZ2lzdHJhdGlvbi13aHktd2U+XFxcXG48Y2F0LXJlZ2lzdHJhdGlvbi1wcmljZSBpZD1cXFxcXCJyZWdpc3RyYXRpb24tcHJpY2VcXFxcXCI+PC9jYXQtcmVnaXN0cmF0aW9uLXByaWNlPlxcXFxuPGRpdiBpZD1cXFxcXCJmb3JtMlxcXFxcIj5cXFxcbiAgICA8Y2F0LXJlZ2lzdHJhdGlvbi1mb3JtIGlkPVxcXFxcInJlZ2lzdHJhdGlvbi1mb3JtLTJcXFxcXCI+PC9jYXQtcmVnaXN0cmF0aW9uLWZvcm0+XFxcXG48L2Rpdj5cXFxcbjxjYXQtcmVnaXN0cmF0aW9uLW1vcmUtcGFnZSBpZD1cXFxcXCJyZWdpc3RyYXRpb24tbW9yZS1wYWdlXFxcXFwiPjwvY2F0LXJlZ2lzdHJhdGlvbi1tb3JlLXBhZ2U+XFxcXG48Y2F0LXJlZ2lzdHJhdGlvbi1mYXEgaWQ9XFxcXFwicmVnaXN0cmF0aW9uLWZhcVxcXFxcIj48L2NhdC1yZWdpc3RyYXRpb24tZmFxPlxcXFxuPGRpdiBpZD1cXFxcXCJmb3JtM1xcXFxcIj5cXFxcbiAgICA8Y2F0LXJlZ2lzdHJhdGlvbi1mb3JtIGlkPVxcXFxcInJlZ2lzdHJhdGlvbi1mb3JtLTNcXFxcXCI+PC9jYXQtcmVnaXN0cmF0aW9uLWZvcm0+XFxcXG48L2Rpdj5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLXJlcXVlc3QnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1yZXF1ZXN0L2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInBhZ2UtcmVxdWVzdFwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJjYWxsYmFja19yZXF1ZXN0XFxcXFwiPlxcXFxuPGgxIGNsYXNzPVxcXFxcImgxIGgxX3N0eWxlXFxcXFwiPtCX0LDRj9Cy0LrQsCDQvNCw0YHRgtC10YDRgzwvaDE+XFxcXG5cXFxcbiAgICA8Zm9ybSBjbGFzcz1cXFxcXCJjYWxsYmFja19yZXF1ZXN0X19mb3JtXFxcXFwiIG1ldGhvZD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5tZXRob2QgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1ldGhvZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJtZXRob2RcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIiBhY3Rpb249XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudXJsIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC51cmwgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidXJsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCIgaWQ9XFxcXFwiY2FsbGJhY2stcmVxdWVzdC1mb3JtXFxcXFwiPlxcXFxuICAgICAgICA8cCBjbGFzcz1cXFxcXCJjYWxsYmFja19yZXF1ZXN0X19pbnRyb1xcXFxcIj7QntC/0LjRiNC40YLQtSDQstCw0YjRgyDQt9Cw0LTQsNGH0YM8L3A+XFxcXG5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJjYWxsYmFja19yZXF1ZXN0X19pbnB1dFxcXFxcIj5cXFxcbiAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cXFxcXCJ0ZXh0YXJlYVxcXFxcIiBwbGFjZWhvbGRlcj1cXFxcXCLQryDRhdC+0YfRgyAo0L7RgtGA0LXQvNC+0L3RgtC40YDQvtCy0LDRgtGMLCDQvtGA0LPQsNC90LjQt9C+0LLQsNGC0YwsINGD0YHRgtCw0L3QvtCy0LjRgtGMLCDQtNC+0YHRgtCw0LLQuNGC0YwpXFxcXFwiIG5hbWU9XFxcXFwiY2FsbGJhY2tSZXF1ZXN0Rm9ybVt0ZXh0XVxcXFxcIj48L3RleHRhcmVhPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPHAgY2xhc3M9XFxcXFwiY2FsbGJhY2tfcmVxdWVzdF9faW50cm9cXFxcXCI+XFxcXG4gICAgICAgICAgICDQntGB0YLQsNCy0YzRgtC1INCy0LDRiNC4INC60L7QvdGC0LDQutGC0YtcXFxcbiAgICAgICAgPC9wPlxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiY2FsbGJhY2tfcmVxdWVzdF9faW5wdXRcXFxcXCI+XFxcXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcXFwiaW5wdXQtdGV4dFxcXFxcIiB0eXBlPVxcXFxcInRleHRcXFxcXCIgcGxhY2Vob2xkZXI9XFxcXFwi0JLQsNGI0LUg0LjQvNGPXFxcXFwiIG5hbWU9XFxcXFwiY2FsbGJhY2tSZXF1ZXN0Rm9ybVtuYW1lXVxcXFxcIj5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiY2FsbGJhY2tfcmVxdWVzdF9faW5wdXRcXFxcXCI+XFxcXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcXFwiaW5wdXQtdGV4dFxcXFxcIiB0eXBlPVxcXFxcInRleHRcXFxcXCIgcGxhY2Vob2xkZXI9XFxcXFwi0JLQsNGIINGC0LXQu9C10YTQvtC9XFxcXFwiIG5hbWU9XFxcXFwiY2FsbGJhY2tSZXF1ZXN0Rm9ybVtwaG9uZV1cXFxcXCI+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImNhbGxiYWNrX3JlcXVlc3RfX2lucHV0XFxcXFwiPlxcXFxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXFxcImlucHV0LXRleHRcXFxcXCIgdHlwZT1cXFxcXCJ0ZXh0XFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCS0LDRiCBlbWFpbFxcXFxcIiBuYW1lPVxcXFxcImNhbGxiYWNrUmVxdWVzdEZvcm1bZW1haWxdXFxcXFwiPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJjYWxsYmFja19yZXF1ZXN0X19zdWJtaXRcXFxcXCI+XFxcXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcXFwiYnRuLWFjY2VudFxcXFxcIiB0eXBlPVxcXFxcInN1Ym1pdFxcXFxcIiB2YWx1ZT1cXFxcXCLQvtGC0L/RgNCw0LLQuNGC0Ywg0LfQsNGP0LLQutGDXFxcXFwiPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICA8L2Zvcm0+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJzdWNjZXNzX3Jlc3BvbnNlXFxcXFwiPtCS0LDRiNCwINC30LDRj9Cy0LrQsCDQvtGC0L/RgNCw0LLQu9C10L3QsDwvZGl2PlxcXFxuPC9kaXY+XFxcXG5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAncGFnZS1zYWxlJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2Utc2FsZS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJwYWdlLXNhbGVcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIjxjYXQtc2FsZSBpZD1cXFxcXCJzYWxlXFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJzYWxlL1NhbGVCeVJ1YnJpa2FcXFxcXCI+PC9jYXQtc2FsZT5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLXNvdmV0eScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLXNvdmV0eS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJwYWdlLXNvdmV0eVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG7QodC+0LLQtdGC0Ysg0LrQsNGC0LDQu9C+0LNcIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLXZhY2FuY3knLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS12YWNhbmN5L2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInBhZ2UtdmFjYW5jeVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJ2YWNhbmN5LXBhZ2VcXFxcXCI+XFxcXG4gICAgPGgxIGNsYXNzPVxcXFxcImgxIGgxX3N0eWxlXFxcXFwiPtCd0LDRiNC4INCy0LDQutCw0L3RgdC40Lg8L2gxPlxcXFxuICAgIDxpbWcgY2xhc3M9XFxcXFwidmFjYW5jeS1wYWdlX19pbWdcXFxcXCIgc3JjPVxcXFxcIi9pbWcvb3RoZXIvdmFjYW5jeS5wbmdcXFxcXCIgYWx0PVxcXFxcItCd0LDRiNC4INCy0LDQutCw0L3RgdC40LhcXFxcXCI+XFxcXG5cXFxcbiAgICA8cCBjbGFzcz1cXFxcXCJ2YWNhbmN5LXBhZ2VfX3RleHRcXFxcXCI+XFxcXG4gICAgICAgINCc0YsgLSDQvNC+0LvQvtC00L7QuSDQutC+0LvQu9C10LrRgtC40LIg0LXQtNC40L3QvtC80YvRiNC70LXQvdC90LjQutC+0LIsINC10YHQu9C4INGDINCS0LDRgSDQtdGB0YLRjCDQttC10LvQsNC90LjQtSDRgNCw0LHQvtGC0LDRgtGMINCyINC90LDRiNC10Lkg0LrQvtC80L/QsNC90LjQuCwg0YLQviDQv9GA0LjRgdC+0LXQtNC40L3Rj9C50YLQtdGB0Ywg0LpcXFxcbiAgICAgICAg0L3QsNC8LCDRg9GH0LDRgdGC0LLRg9C50YLQtSDQsiDRgdC+0LfQtNCw0L3QuNC4INC90L7QstC+0LPQviDQuNC90YLQtdGA0LXRgdC90L7Qs9C+INC/0YDQvtC00YPQutGC0LAuINCS0LzQtdGB0YLQtSDRgSDQvdCw0LzQuCDQstGLINGB0LzQvtC20LXRgtC1INCy0L7Qv9C70L7RgtC40YLRjCDRgdCy0L7QuCDRgdCw0LzRi9C1INGB0LzQtdC70YvQtVxcXFxuICAgICAgICDQuNC00LXQuCwg0YDQsNGB0LrRgNGL0YLRjCDRgdCy0L7QuSDRgtCy0L7RgNGH0LXRgdC60LjQuSDQv9C+0YLQtdC90YbQuNCw0Lsg0Lgg0YDQtdCw0LvQuNC30L7QstCw0YLRjNGB0Y8g0LIg0LrQsNGA0YzQtdGA0L3QvtC8INC/0LvQsNC90LUuINCc0Ysg0LjRidC10Lwg0YbQtdC70LXRg9GB0YLRgNC10LzQu9C10L3QvdGL0YUg0Lgg0YPQstC10YDQtdC90L3Ri9GFXFxcXG4gICAgICAgINGB0L/QtdGG0LjQsNC70LjRgdGC0L7Qsiwg0LrQvtGC0L7RgNGL0LUg0LLQtdGA0Y/RgiDQsiDRgdCy0L7QuCDRgdC40LvRiyDQuCDRg9GB0L/QtdGFLlxcXFxuICAgIDwvcD5cXFxcblxcXFxuICAgIDxjYXQtb3RoZXItdmFjYW5jeSBpZD1cXFxcXCJvdGhlci12YWNhbmN5XFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJvdGhlci9WYWNhbmN5XFxcXFwiPjwvY2F0LW90aGVyLXZhY2FuY3k+XFxcXG48L2Rpdj5cXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ3BhZ2UtdmFjYW5jeS1pdGVtJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtdmFjYW5jeS1pdGVtL2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInBhZ2UtdmFjYW5jeS1pdGVtXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCI8Y2F0LW90aGVyLXZhY2FuY3ktaXRlbSBpZD1cXFxcXCJvdGhlci12YWNhbmN5LWl0ZW1cXFxcXCIgY2F0LXN0b3JlPVxcXFxcIm90aGVyL1ZhY2FuY3lJdGVtXFxcXFwiPjwvY2F0LW90aGVyLXZhY2FuY3ktaXRlbT5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdwYWdlLXZpZGVvJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9wYWdlL3BhZ2UtdmlkZW8vaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwicGFnZS12aWRlb1wiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG7QktC40LTQtdC+INC60LDRgtCw0LvQvtCzXFxcXG5cXFxcbjxjYXQtY29tbW9uLXBhZ2luYXRvciBpZD1cXFxcXCJjb21tb24tcGFnaW5hdG9yXFxcXFwiIGNhdC1zdG9yZT1cXFxcXCJQYWdpbmF0b3JcXFxcXCIgbW9kZWw9XFxcXFwibWFzdGVyL01hc3RlclZpZGVvXFxcXFwiPjwvY2F0LWNvbW1vbi1wYWdpbmF0b3I+XCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAncGFnZXMtY29udGVudCcsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZXMvcGFnZXMtY29udGVudC9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJwYWdlcy1jb250ZW50XCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgPGNhdC1icmVhZGNydW1wcyBpZD1cXFxcXCJicmVhZGNydW1wc1xcXFxcIiBjYXQtc3RvcmU9XFxcXFwiQnJlYWRjcnVtcHNcXFxcXCI+PC9jYXQtYnJlYWRjcnVtcHM+XFxcXG5cIjtcXG4gIH0sXCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwicGFnZSBjb250YWluZXJcXFxcXCI+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJwYWdlX19yb3dcXFxcXCI+XFxcXG4gICAgICAgIDxjYXQtbG9hZGVyIGlkPVxcXFxcInBhZ2VzLWNvbnRlbnQtbG9hZGVyXFxcXFwiPjwvY2F0LWxvYWRlcj5cXFxcblxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzLnVubGVzcy5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaXNBY3RpdmUgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLm1haW4gOiBzdGFjazEpLCB7XCJuYW1lXCI6XCJ1bmxlc3NcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiY29udGVudFxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxjYXQtcGFnZS1cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5jdXJyZW50IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jdXJyZW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImN1cnJlbnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIiBpZD1cXFxcXCJwYWdlLWN1cnJlbnQtXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuY3VycmVudCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY3VycmVudCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJjdXJyZW50XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+PC9jYXQtcGFnZS1cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5jdXJyZW50IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jdXJyZW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImN1cnJlbnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIj5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgPC9kaXY+XFxcXG48L2Rpdj5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiBudWxsfSxcbntuYW1lOiAncGFnZXMtZm9vdGVyJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9wYWdlcy9wYWdlcy1mb290ZXIvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwicGFnZXMtZm9vdGVyXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiZm9vdGVyX19saW5rcy1hXFxcXFwiIGhyZWY9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudXJsIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC51cmwgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidXJsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XCI7XFxuICBzdGFjazEgPSAoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnRpdGxlIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50aXRsZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0aXRsZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIjwvYT4mbmJzcDtcXFxcblwiO1xcbn0sXCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIjxmb290ZXIgY2xhc3M9XFxcXFwiZm9vdGVyXFxcXFwiPlxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwiY29udGFpbmVyXFxcXFwiPlxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwidG8tdG9wXFxcXFwiPlxcXFxuICAgICAgICAgICAgPGEgaHJlZj1cXFxcXCJcXFxcXCI+PHNwYW4+4oaRPC9zcGFuPiDQstCy0LXRgNGFPC9hPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcblxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwicm93XFxcXFwiPlxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmb290ZXJfX2Nvb3JkaW5hdG9yXFxcXFwiPtCa0L7QvtGA0LTQuNC90LDRgtC+0YAg0YHQsNC50YLQsDogXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMucGhvbmUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnBob25lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInBob25lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L2Rpdj5cXFxcblxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmb290ZXJfX2NvcHlyaWdodFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJmb290ZXJfX2NvcHlyaWdodC13aG9cXFxcXCI+wqkgRmFjZU1hc3RlciDigJQg0KTQtdC50YHQvNCw0YHRgtC10YA8L3A+XFxcXG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwiZm9vdGVyX19jb3B5cmlnaHQtdGV4dFxcXFxcIj7Qn9GA0Lgg0L/QvtC70L3QvtC8INC40LvQuCDRh9Cw0YHRgtC40YfQvdC+0Lwg0LLQvtGB0L/RgNC+0LjQt9Cy0LXQtNC10L3QuNC4INC40L3RhNC+0YDQvNCw0YbQuNC4XFxcXG4gICAgICAgICAgICAgICAgICAgINCw0LrRgtC40LLQvdCw0Y8g0YHRgdGL0LvQutCwINC90LAg0KTQtdC50YHQvNCw0YHRgtC10YAg0L7QsdGP0LfQsNGC0LXQu9GM0L3QsC48L3A+XFxcXG4gICAgICAgICAgICA8L2Rpdj5cXFxcblxcXFxuXFxcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImZvb3Rlcl9fbGlua3NcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmxpbmtzIDogZGVwdGgwKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgICAgICAgICA8L2Rpdj5cXFxcblxcXFxuXFxcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImZvb3Rlcl9fY291bnRlcnNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPCEtLXsgeyA+IGZvb3Rlci9jb3VudGVycy9jb3VudGVycyBjb3VudGVyc30gfS0tPlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuICAgIDwvZGl2PlxcXFxuPC9mb290ZXI+XCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ3BhZ2VzLWhlYWRlcicsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZXMvcGFnZXMtaGVhZGVyL2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInBhZ2VzLWhlYWRlclwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcIjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibG9naW5cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJsb2dpbl9fYnRuIGJ0blxcXFxcIiBocmVmPVxcXFxcIi9sb2dpblxcXFxcIj7QktGF0L7QtCDQtNC70Y8g0JzQsNGB0YLQtdGA0L7QsjwvYT5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG4gIH0sXCIzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCIgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibG9naW5cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJsb2dpbl9fYnRuIGJ0blxcXFxcIiBocmVmPVxcXFxcIjwhLS1FUlJPUi0tPlxcXFxcIj48IS0tRVJST1IgLSB1c2VybmFtZS0tPjwvYT5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtZW51LXVzZXJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXFxcIm1lbnUtdXNlcl9fdWxcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwhLS1FUlJPUiBNRU5VVVNFUi0tPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmF1dGhEYXRhIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5tZW51VXNlciA6IHN0YWNrMSksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDQsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiNFwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFxcXCJtZW51LXVzZXJfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwibWVudS11c2VyX19pdGVtLWxpbmtcXFxcXCIgaHJlZj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51cmwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cIjtcXG4gIHN0YWNrMSA9ICgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGl0bGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRpdGxlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiPC9hPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxcblwiO1xcbn0sXCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIjxoZWFkZXIgY2xhc3M9XFxcXFwiaGVhZGVyXFxcXFwiPlxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwiY29udGFpbmVyXFxcXFwiPlxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJvd1xcXFxcIj5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiaGVhZGVyX19sZWZ0LWNvbFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImxvZ29cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibG9nb19faW1nXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwibG9nb19fbGlua1xcXFxcIiBocmVmPVxcXFxcIi9tYWluXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgYWx0PVxcXFxcIkZhY2VtYXN0ZXIucnUgTG9nb1xcXFxcIiBzcmM9XFxcXFwiL2ltZy9sb2dvLnN2Z1xcXFxcIiB3aWR0aD1cXFxcXCIxMDAlXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJ2aXNpdG9yXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwidmlzaXRvcl9fY291bnRcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudmlzaXRDb3VudCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudmlzaXRDb3VudCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ2aXNpdENvdW50XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInZpc2l0b3JfX21lcmFcXFxcXCI+0LIg0L3QtdC00LXQu9GOPC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJoZWFkZXJfX3RpdGxlXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcInRpdGxlXFxcXFwiIGhyZWY9XFxcXFwiL21haW5cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInRpdGxlX190ZXh0IGgxXFxcXFwiPtCf0J7QmNCh0Jog0JzQkNCh0KLQldCg0J7QkiDQkiDQodCk0JXQoNCVINCj0KHQm9Cj0JM8L3A+XFxcXG4gICAgICAgICAgICAgICAgPC9hPlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImhlYWRlcl9fbG9naW5cXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaXNHdWVzdCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLnByb2dyYW0oMywgZGF0YSksXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIiAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJoZWFkZXJfX21lbnVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGNhdC1wYWdlcy1uYXZpZ2F0aW9uIGlkPVxcXFxcInBhZ2VzLW5hdmlnYXRpb25cXFxcXCI+PC9jYXQtcGFnZXMtbmF2aWdhdGlvbj5cXFxcbiAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJoZWFkZXJfX3NvY2lhbFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8Y2F0LXNvY2lhbCBpZD1cXFxcXCJzb2NpYWxcXFxcXCI+PC9jYXQtc29jaWFsPlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuICAgIDwvZGl2PlxcXFxuPC9oZWFkZXI+XFxcXG5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAncGFnZXMtbmF2aWdhdGlvbicsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZXMvcGFnZXMtbmF2aWdhdGlvbi9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJwYWdlcy1uYXZpZ2F0aW9uXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcIm1haW4tbWVudV9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJtYWluLW1lbnVfX2l0ZW0tbGluayBsaW5rXFxcXFwiIGhyZWY9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubGluayB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubGluayA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJsaW5rXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L2E+XFxcXG4gICAgICAgICAgICA8L2xpPlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCI8bmF2IGNsYXNzPVxcXFxcIm1lbnVcXFxcXCI+XFxcXG4gICAgPHVsIGNsYXNzPVxcXFxcIm1haW4tbWVudVxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubWVudSA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiICAgIDwvdWw+XFxcXG48L25hdj5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiBudWxsfSxcbntuYW1lOiAncmVnaXN0cmF0aW9uLWFib3V0JywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9yZWdpc3RyYXRpb24vcmVnaXN0cmF0aW9uLWFib3V0L2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInJlZ2lzdHJhdGlvbi1hYm91dFwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcXFwiYWJvdXQtd3JcXFxcXCI+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJjb250YWluZXJcXFxcXCI+XFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwicm93XFxcXFwiPlxcXFxuICAgICAgICAgICAgPHNlY3Rpb24gY2xhc3M9XFxcXFwiYWJvdXRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXFxcImFib3V0X19saXN0IHJvd1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbV9fdGV4dFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFxcXCJhYm91dC1saXN0LWl0ZW1fX3RleHQtdmVyLWFsXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDQl9CQ0KDQldCT0JjQodCi0KDQmNCg0KPQmdCh0K88YnI+0J3QkCDQodCQ0JnQotCVXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbV9faWNvbi13clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwiYWRkLXBhZ2VcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbV9fYXJyb3dcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcImFycm93XCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbV9fdGV4dFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFxcXCJhYm91dC1saXN0LWl0ZW1fX3RleHQtdmVyLWFsXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDQntCf0KPQkdCb0JjQmtCj0JnQodCvXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbV9faWNvbi13clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwicGljdHVyZVwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbV9fYXJyb3dcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcImFycm93XCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbV9fdGV4dFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFxcXCJhYm91dC1saXN0LWl0ZW1fX3RleHQtdmVyLWFsXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDQn9Ce0JvQo9Cn0JDQmTxicj7QmtCb0JjQldCd0KLQntCSXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImFib3V0LWxpc3QtaXRlbV9faWNvbi13clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwicGVvcGxlXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9saT5cXFxcbiAgICAgICAgICAgICAgICA8L3VsPlxcXFxuICAgICAgICAgICAgPC9zZWN0aW9uPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICA8L2Rpdj5cXFxcbjwvZGl2PlwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdyZWdpc3RyYXRpb24tZmFxJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9yZWdpc3RyYXRpb24vcmVnaXN0cmF0aW9uLWZhcS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJyZWdpc3RyYXRpb24tZmFxXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcbjxkaXYgY2xhc3M9XFxcXFwiY29udGFpbmVyIGNvcm5lciBjb3JuZXJfYmdcXFxcXCI+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJyb3dcXFxcXCI+XFxcXG4gICAgICAgIDxzZWN0aW9uIGNsYXNzPVxcXFxcImZhcVxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInBhZ2UtdGl0bGUgcGFnZS10aXRsZV9sYW5kaW5nXFxcXFwiPtCn0LDRgdGC0YvQtSDQstC+0L/RgNC+0YHRizo8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZmFxX19ibG9ja1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImZhcV9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwiZmFxX19pdGVtLXRpdGxlXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcImZhcV9faXRlbS10aXRsZS1pbm5lclxcXFxcIj7QmtCw0Log0L7Qv9C70LDRgtC40YLRjCDRgdC10YDQstC40YE/PC9zcGFuPjwvcD5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJmYXFfX2l0ZW0tdGV4dFxcXFxcIj7QndCwINC00LDQvdC90YvQuSDQvNC+0LzQtdC90YIsINGH0YLQvtCx0Ysg0YHQvtCy0LXRgNGI0LjRgtGMINC+0L/Qu9Cw0YLRgyxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgINCy0LDQvCDQvdGD0LbQvdC+INC/0YDQuNC10YXQsNGC0Ywg0LIg0L3QsNGIINC+0YTQuNGBINC/0L4g0LDQtNGA0LXRgdGDINCQ0LLRgtC+0YHRgtGA0L7QuNGC0LXQu9C10LkgNDHQkCDQui4xINGBIDk6MDAg0LTQviAxNzowMCAo0L/QvS3Qv9GCKS5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgINCc0LXQvdC10LTQttC10YAg0L/RgNC10LTQvtGB0YLQsNCy0LjRgiDQstCw0Lwg0LLRgdGOINC90LXQvtCx0YXQvtC00LjQvNGD0Y4g0LjQvdGE0L7RgNC80LDRhtC40Y4g0L/QviDQstGL0LHQvtGA0YNcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgINGC0LDRgNC40YTQvdC+0LPQviDQv9C70LDQvdCwINC4INC/0YDQvtCy0LXQtNC10L3QuNGOINC+0L/Qu9Cw0YLRiy4g0KLQsNC60LbQtSDQvNGLINGA0LDQsdC+0YLQsNC10Lwg0L3QsNC0INGB0LjRgdGC0LXQvNC+0LlcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgINGN0LvQtdC60YLRgNC+0L3QvdGL0YUg0L/Qu9Cw0YLQtdC20LXQuS5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9wPlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZmFxX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJmYXFfX2l0ZW0tdGl0bGVcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwiZmFxX19pdGVtLXRpdGxlLWlubmVyXFxcXFwiPtCn0YLQviDQsdGD0LTQtdGCLCDQutC+0LPQtNCwINC30LDQutC+0L3Rh9C40YLRgdGPINC80LXRgdGP0YY/PC9zcGFuPjwvcD5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJmYXFfX2l0ZW0tdGV4dFxcXFxcIj7QktGLINC/0L7Qu9GD0YfQuNGC0LUg0YPQstC10LTQvtC80LvQtdC90LjQtSDQvdCwINCy0LDRiCBlLW1haWwsINC30LDRgNC10LPQuNGB0YLRgNC40YDQvtCy0LDQvdC90YvQuSDQsiDRgdC40YHRgtC10LzQtSwg0YEg0L/RgNC10LTQu9C+0LbQtdC90LjQtdC8INC/0YDQvtC00LvQuNGC0Ywg0LTQtdC50YHRgtCy0YPRjtGJ0LjQuSDRgtCw0YDQuNGE0L3Ri9C5INC/0LvQsNC9INC40LvQuCDQv9C10YDQtdC50YLQuCDQvdCwINC90L7QstGL0LkuINCV0YHQu9C4INCyINGC0LXRh9C10L3QuNC1IDMwINC00L3QtdC5INCy0Ysg0L3QuCDRgNCw0LfRgyDQvdC1INGB0L7QstC10YDRiNC40LvQuCDQstGF0L7QtCDQsiDQutCw0LHQuNC90LXRgiDRgdCw0LnRgtCwIEZhY2VNYXN0ZXIsINGC0L4g0LLQsNGIINC60LDQsdC40L3QtdGCINCx0YPQtNC10YIg0YPQtNCw0LvRkdC9LjwvcD5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmYXFfX2Jsb2NrXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZmFxX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJmYXFfX2l0ZW0tdGl0bGVcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwiZmFxX19pdGVtLXRpdGxlLWlubmVyXFxcXFwiPtCc0L7Qs9GDINC70Lgg0Y8g0LjQt9C80LXQvdC40YLRjCDRgtCw0YDQuNGE0L3Ri9C5INC/0LvQsNC9Pzwvc3Bhbj48L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwiZmFxX19pdGVtLXRleHRcXFxcXCI+0JXRgdC70Lgg0LLRiyDQv9C+0LvRjNC30YPQtdGC0LXRgdGMINCx0LXRgdC/0LvQsNGC0L3QvtC5INC80LjQvdC4LdGB0YLRgNCw0L3QuNGG0LXQuSwg0YLQviDQv9C+0LvRg9GH0LjRgtGMINCy0YHQtSDQstC+0LfQvNC+0LbQvdC+0YHRgtC4INGN0YTRhNC10LrRgtC40LLQvdC+0LPQviDQv9GA0L7QtNCy0LjQttC10L3QuNGPINC90LAg0YHQsNC50YLQtSBGYWNlTWFzdGVyINCy0Ysg0LzQvtC20LXRgtC1INCyINC70Y7QsdC+0LUg0LLRgNC10LzRjywg0LLRi9Cx0YDQsNCyINGC0LDRgNC40YTQvdGL0Lkg0L/Qu9Cw0L0g0Lgg0L7Qv9C70LDRgtC40LIg0LXQs9C+LiDQldGB0LvQuCDQstGLINGD0LbQtSDRgdC+0LLQtdGA0YjQuNC70Lgg0L7Qv9C70LDRgtGDINC4INGF0L7RgtC40YLQtSDQv9C+0LzQtdC90Y/RgtGMINC+0LTQuNC9INGC0LDRgNC40YTQvdGL0Lkg0L/Qu9Cw0L0g0L3QsCDQtNGA0YPQs9C+0LksINGC0L4g0LLQsNC8INC90YPQttC90L4g0L/QvtC00L7QttC00LDRgtGMLCDQv9C+0LrQsCDQt9Cw0LrQvtC90YfQuNGC0YHRjyDQv9C10YDQstGL0LkuPC9wPlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZmFxX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJmYXFfX2l0ZW0tdGl0bGVcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwiZmFxX19pdGVtLXRpdGxlLWlubmVyXFxcXFwiPtCjINC80LXQvdGPINC10YHRgtGMINCy0L7Qv9GA0L7RgSE8L3NwYW4+PC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImZhcV9faXRlbS10ZXh0XFxcXFwiPtCR0YPQtNC10Lwg0YDQsNC00Ysg0L/RgNC10LTRgdGC0LDQstC40YLRjCDQstCw0LxcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgINC00L7Qv9C+0LvQvdC40YLQtdC70YzQvdGD0Y4g0LjQvdGE0L7RgNC80LDRhtC40Y4g0L4g0YDQsNCx0L7RgtC1INC/0LvQsNGC0YTQvtGA0LzRiyDQuCDQviDRhtC10L3QsNGFINC/0L4g0YLQtdC70LXRhNC+0L3RgyAoODQ4MikgNzQtNDQtMTkuPC9wPlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwvc2VjdGlvbj5cXFxcbiAgICA8L2Rpdj5cXFxcbjwvZGl2PlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAncmVnaXN0cmF0aW9uLWZvcm0nLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3JlZ2lzdHJhdGlvbi9yZWdpc3RyYXRpb24tZm9ybS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJyZWdpc3RyYXRpb24tZm9ybVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJzZWN0aW9uLXJlZ1xcXFxcIj5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcImNvbnRhaW5lclxcXFxcIj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJyb3dcXFxcXCI+XFxcXG4gICAgICAgICAgICA8c2VjdGlvbiBjbGFzcz1cXFxcXCJmb3JtIGZvcm1fcmVnLW1hc3RlclxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImZvcm1fX2NvbnRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzcz1cXFxcXCJmb3JtX190aXRsZVxcXFxcIj7QndCw0YfQsNGC0Ywg0YDQtdCz0LjRgdGC0YDQsNGG0LjRjjwvaDI+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gY2xhc3M9XFxcXFwiZm9ybV9fZm9ybVxcXFxcIiBhY3Rpb249XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudXJsIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC51cmwgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidXJsXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCIgbWV0aG9kPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm1ldGhvZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubWV0aG9kIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm1ldGhvZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiIGRhdGEtdXJsLWxrPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnVybExLIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC51cmxMSyA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxMS1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmb3JtX19yb3dcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcXFwidGV4dFxcXFxcIiBwbGFjZWhvbGRlcj1cXFxcXCLQmtCw0Log0JLQsNGBINC30L7QstGD0YI/XFxcXFwiIG5hbWU9XFxcXFwicmVnbWFzdGVyW25hbWVdXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImZvcm1fX3JvdyByb3dcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmb3JtX19yb3dfaGFsZlxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcXFwidGV4dFxcXFxcIiBwbGFjZWhvbGRlcj1cXFxcXCLQo9C60LDQttC40YLQtSDQktCw0Ygg0YLQtdC70LXRhNC+0L1cXFxcXCIgbmFtZT1cXFxcXCJyZWdtYXN0ZXJbcGhvbmVdXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZm9ybV9fcm93X2hhbGZcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXFxcInBhc3N3b3JkXFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCf0YDQuNC00YPQvNCw0LnRgtC1INC/0LDRgNC+0LvRjFxcXFxcIiBuYW1lPVxcXFxcInJlZ21hc3RlcltwYXNzd29yZF1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZm9ybV9fcm93XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJmb3JtX19idG4gYnRuXFxcXFwiIHR5cGU9XFxcXFwic3VibWl0XFxcXFwiIHZhbHVlPVxcXFxcItCX0JDQoNCQ0JPQmNCh0KLQoNCY0KDQntCS0JDQotCs0KHQr1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmb3JtX19yb3dcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVxcXFxcImNoZWNrYm94XFxcXFwiIGNoZWNrZWQgdmFsdWU9XFxcXFwidHJ1ZVxcXFxcIj7RjyDRgdC+0LPQu9Cw0YHQtdC9INGBIDxhIGhyZWY9XFxcXFwiL29mZXJ0YVxcXFxcIj7Rg9GB0LvQvtCy0LjRj9C80Lg8L2E+IDwvbGFiZWw+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPC9zZWN0aW9uPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICA8L2Rpdj5cXFxcbjwvZGl2PlxcXFxuXCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ3JlZ2lzdHJhdGlvbi1oZWFkZXInLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3JlZ2lzdHJhdGlvbi9yZWdpc3RyYXRpb24taGVhZGVyL2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInJlZ2lzdHJhdGlvbi1oZWFkZXJcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcXFwiY29udGFpbmVyXFxcXFwiPlxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwicm93XFxcXFwiPlxcXFxuICAgICAgICA8c2VjdGlvbiBjbGFzcz1cXFxcXCJsYW5kaW5nLWhlYWRlclxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxoMSBjbGFzcz1cXFxcXCJwYWdlLXRpdGxlIHBhZ2UtdGl0bGVfbGFuZGluZ1xcXFxcIj5GYWNlTWFzdGVyIOKAlCDRgdCw0LnRgiDQv9C+0LjRgdC60LAg0YHQv9C10YbQuNCw0LvQuNGB0YLQvtCyXFxcXG4gICAgICAgICAgICAgICAg0LIg0YHRhNC10YDQtSDRg9GB0LvRg9CzINCyINCi0L7Qu9GM0Y/RgtGC0Lg8L2gxPlxcXFxuICAgICAgICA8L3NlY3Rpb24+XFxcXG4gICAgPC9kaXY+XFxcXG48L2Rpdj5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdyZWdpc3RyYXRpb24tbW9yZS1wYWdlJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9yZWdpc3RyYXRpb24vcmVnaXN0cmF0aW9uLW1vcmUtcGFnZS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJyZWdpc3RyYXRpb24tbW9yZS1wYWdlXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZS13clxcXFxcIj5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcImNvbnRhaW5lclxcXFxcIj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJyb3dcXFxcXCI+XFxcXG4gICAgICAgICAgICA8c2VjdGlvbiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwicGFnZS10aXRsZSBwYWdlLXRpdGxlX2xhbmRpbmdcXFxcXCI+0J/QvtC00YDQvtCx0L3QtdC1INC+INGB0YLRgNCw0L3QuNGG0LDRhTo8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3BpY1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19waWMtaW1nXFxcXFwiIGFsdD1cXFxcXCLRgdGC0YDQsNC90LjRhtCwINC4INC80LjQvdC4LdGB0YLRgNCw0L3QuNGG0LBcXFxcXCIgc3JjPVxcXFxcIi9pbWcvcmVnaXN0cmF0aW9uLzEucG5nXFxcXFwiIHdpZHRoPVxcXFxcIjEwMCVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fdGV4dFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX190ZXh0LXRpdGxlXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX190ZXh0LXRpdGxlLWNvdW50XFxcXFwiPjwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX190ZXh0LXRpdGxlLWhlYWRlciBtb3JlLXBhZ2VfX3RleHQtdGl0bGUtaGVhZGVyX25vLXZhbGlnblxcXFxcIj7QmtCw0YLQsNC70L7QsyDQvNCw0YHRgtC10YDQvtCyPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3RleHQtdGl0bGUtc3ViLWhlYWRlclxcXFxcIj7QnNC40L3QuC3RgdGC0YDQsNC90LjRhtCwICsg0LvQuNGH0L3QsNGPINGB0YLRgNCw0L3QuNGG0LA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3BhcmFncmFwaFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3BhcmFncmFwaC10aXRsZVxcXFxcIj7Qm9C40YfQvdCw0Y8g0YHRgtGA0LDQvdC40YbQsDwvcD5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fcGFyYWdyYXBoLXRleHRcXFxcXCI+0JvQuNGH0L3QsNGPINGB0YLRgNCw0L3QuNGG0LAg4oCTINGN0YLQviDQstCw0YjQtSDRgdC+0LHRgdGC0LLQtdC90L3QvtC1INC40L3RhNC+0YDQvNCw0YbQuNC+0L3QvdC+0LUg0L/RgNC+0YHRgtGA0LDQvdGB0YLQstC+INC00LvRjyDQv9GA0L7QtNCy0LjQttC10L3QuNGPINCyINCh0LXRgtC4LiDQntC90LAg0LzQvtC20LXRgiDRgdGC0LDRgtGMINCw0L3QsNC70L7Qs9C+0Lwg0L/QtdGA0YHQvtC90LDQu9GM0L3QvtCz0L4g0YHQsNC50YLQsCwg0LvQuNCx0L4sINC10YHQu9C4INGDINCy0LDRgSDRg9C20LUg0LXRgdGC0Ywg0YHQstC+0Lkg0YHQsNC50YIsINC80Ysg0L/QvtC80L7QttC10Lwg0YDQsNGB0YjQuNGA0LjRgtGMINCw0YDRgdC10L3QsNC7INC00LvRjyDQv9GA0LjQstC70LXRh9C10L3QuNGPINC90LAg0L3QtdCz0L4g0LrQu9C40LXQvdGC0L7Qsi4g0JvQuNGH0L3QsNGPINGB0YLRgNCw0L3QuNGG0LAg0LTQsNGR0YIg0LTQvtGB0YLRg9C/INC6INC80L3QvtC20LXRgdGC0LLRgyDRgdC10YDQstC40YHQvtCyLCDRh9GC0L7QsdGLINC/0L7QvNC+0YfRjCDRgdC/0LXRhtC40LDQu9C40YHRgtGDINC4INC60LvQuNC10L3RgtGDINC90LDQudGC0Lgg0LTRgNGD0LMg0LTRgNGD0LPQsDog0L3QsNC/0LjRgdCw0L3QuNC1INGB0YLQsNGC0LXQuSwg0YTQvtGC0L7QsNC70YzQsdC+0LzRiywg0L7RgtC30YvQstGLLCDQv9GA0L7QtNCy0LjQttC10L3QuNC1INCyINGB0L7RhtC40LDQu9GM0L3Ri9GFINGB0LXRgtGP0YUsINCy0LjQtNC10L7QutCw0YLQsNC70L7Qsywg0YDRg9Cx0YDQuNC60LAgwqvQodC+0LLQtdGC0Ysg0JzQsNGB0YLQtdGA0L7QssK7LCDQutCw0YLQsNC70L7QsyDRhNC40YDQvCDQuCDQvNC90L7Qs9C+0LUg0LTRgNGD0LPQvtC1LjwvcD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3BhcmFncmFwaFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3BhcmFncmFwaC10aXRsZVxcXFxcIj7QnNC40L3QuC3RgdGC0YDQsNC90LjRhtCwPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19wYXJhZ3JhcGgtdGV4dFxcXFxcIj7QnNC40L3QuC3RgdGC0YDQsNC90LjRhtCwIOKAlCDRjdGC0L4g0LLQsNGI0LAg0LLQuNC30LjRgtC60LAg0YEg0LrQvtC90YLQsNC60YLQvdC+0Lkg0LjQvdGE0L7RgNC80LDRhtC40LXQuS4g0JfQsNGA0LXQs9C40YHRgtGA0LjRgNC+0LLQsNCy0YjQuNGB0Ywg0L3QsCDQvdCw0YjQtdC8INGB0LDQudGC0LUg0LHQtdGB0L/Qu9Cw0YLQvdC+LCDQstGLINC/0L7Qu9GD0YfQsNC10YLQtSDRgtC+0LvRjNC60L4g0LzQtdGB0YLQviDQsiDQvtCx0YnQtdC8INC60LDRgtCw0LvQvtCz0LUg0JzQsNGB0YLQtdGA0L7Qsiwg0LPQtNC1INCy0LDRiNGDINCy0LjQt9C40YLQutGDINGB0LzQvtCz0YPRgiDRg9Cy0LjQtNC10YLRjCDQv9C+0YHQtdGC0LjRgtC10LvQuC4g0J3QviDQstGLINCy0YHQtdCz0LTQsCDQvNC+0LbQtdGC0LUg0YHQtNC10LvQsNGC0Ywg0LjQtyDQvdC10ZEg0LvQuNGH0L3Rg9GOINGB0YLRgNCw0L3QuNGG0YMg0Lgg0YLQtdC8INGB0LDQvNGL0Lwg0YPQstC10LvQuNGH0LjRgtGMINC/0YDQuNGC0L7QuiDQutC70LjQtdC90YLQvtCyLiDQlNC70Y8g0Y3RgtC+0LPQviDQstCw0Lwg0L3Rg9C20L3QviDQstGL0LHRgNCw0YLRjCDQuCDQvtC/0LvQsNGC0LjRgtGMINC+0LTQuNC9INC40Lcg0YLQsNGA0LjRhNC90YvRhSDQv9C70LDQvdC+0LIuPC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fcGljXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3BpYy1pbWcgbW9yZS1wYWdlX19waWMtaW1nX29mZnNldC0xXFxcXFwiIGFsdD1cXFxcXCLRgdGC0YDQsNC90LjRhtCwINC4INC80LjQvdC4LdGB0YLRgNCw0L3QuNGG0LBcXFxcXCIgc3JjPVxcXFxcIi9pbWcvcmVnaXN0cmF0aW9uLzIucG5nXFxcXFwiIHdpZHRoPVxcXFxcIjEwMCVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fdGV4dFxcXFxcIj5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3RleHQtdGl0bGVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3RleHQtdGl0bGUtY291bnRcXFxcXCI+PC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3RleHQtdGl0bGUtaGVhZGVyXFxcXFwiPtCa0LDRgtCw0LvQvtCzINGB0LrQuNC00L7QuiDQuCDQv9C+0LTQsNGA0LrQvtCyPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19wYXJhZ3JhcGhcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19wYXJhZ3JhcGgtdGV4dFxcXFxcIj7Qo9GB0YLRgNCw0LjQstCw0LnRgtC1INCw0LrRhtC40Lgg0Lgg0YHQutC40LTQutC4LCDQv9C+0LvRg9GH0LDRjyDQtdGJ0ZEg0LHQvtC70YzRiNC1INC60LvQuNC10L3RgtC+0LIhINCc0L3QvtCz0LjQtSDQv9C+0YHQtdGC0LjRgtC10LvQuCDRgNC10LPRg9C70Y/RgNC90L4g0L7RgtGB0LvQtdC20LjQstCw0Y7RgiDQstGL0LPQvtC00L3Ri9C1INC/0YDQtdC00LvQvtC20LXQvdC40Y8g0LIg0L3QsNGI0LXQvCDQutCw0YLQsNC70L7Qs9C1IMKr0KHQutC40LTQutC4INC4INC/0L7QtNCw0YDQutC4wrsuINCf0L7RjdGC0L7QvNGDINC10YHQu9C4INCy0Ysg0YDQsNC30LzQtdGJ0LDQtdGC0LUg0LIg0L3RkdC8INC40L3RhNC+0YDQvNCw0YbQuNGOINC+INGB0LrQuNC00LrQtSwg0YLQviDRiNCw0L3RgdGLLCDRh9GC0L4g0LrQu9C40LXQvdGCINC30LDQuNC90YLQtdGA0LXRgdGD0LXRgtGB0Y8g0LLQsNGI0LjQvCDQv9GA0LXQtNC70L7QttC10L3QuNC10LwsINCy0L7Qt9GA0LDRgdGC0LDRjtGCINCy0LTQstC+0LUhINCa0YDQvtC80LUg0YLQvtCz0L4sINGB0LDQvNGL0LUg0LDQutGC0YPQsNC70YzQvdGL0LUg0Lgg0LjQvdGC0LXRgNC10YHQvdGL0LUg0LDQutGG0LjQuCDQvNGLINGA0LXQs9GD0LvRj9GA0L3QviDQvtGB0LLQtdGJ0LDQtdC8INCyINGB0L7RhtC40LDQu9GM0L3Ri9GFINGB0LXRgtGP0YUuPC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19saW5lXFxcXFwiPjwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fcGljXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3BpYy1pbWcgbW9yZS1wYWdlX19waWMtaW1nX29mZnNldC0xXFxcXFwiIGFsdD1cXFxcXCLRgdGC0YDQsNC90LjRhtCwINC4INC80LjQvdC4LdGB0YLRgNCw0L3QuNGG0LBcXFxcXCIgc3JjPVxcXFxcIi9pbWcvcmVnaXN0cmF0aW9uLzMucG5nXFxcXFwiIHdpZHRoPVxcXFxcIjEwMCVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fdGV4dFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX190ZXh0LXRpdGxlXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX190ZXh0LXRpdGxlLWNvdW50XFxcXFwiPjwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX190ZXh0LXRpdGxlLWhlYWRlclxcXFxcIj7QmtCw0YLQsNC70L7QsyDQstC40LTQtdC+PC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19wYXJhZ3JhcGhcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19wYXJhZ3JhcGgtdGV4dFxcXFxcIj7QkiDQstC40LTQtdC+0LrQsNGC0LDQu9C+0LPQtSDRg9C20LUg0YHQvtCx0YDQsNC90LAg0YbQtdC70LDRjyDQutC+0LvQu9C10LrRhtC40Y8g0YHQsNC80YvRhSDQv9C+0LvQtdC30L3Ri9GFINGA0L7Qu9C40LrQvtCyLCDQvdCw0LnQtNC10L3QvdGL0YUg0JzQsNGB0YLQtdGA0LDQvNC4INC90LAg0L/RgNC+0YHRgtC+0YDQsNGFINCY0L3RgtC10YDQvdC10YLQsC4g0JzQvdC+0LPQuNC1INGB0L/QtdGG0LjQsNC70LjRgdGC0Ysg0L3QtSDRgtC+0LvRjNC60L4g0L7RgtCx0LjRgNCw0Y7RgiDQu9GD0YfRiNC10LUsINC40YHRhdC+0LTRjyDQuNC3INGB0LLQvtC40YUg0LfQvdCw0L3QuNC5INC4INC+0L/Ri9GC0LAsINC90L4g0Lgg0YHQvtC30LTQsNGO0YIg0LXQs9C+ISDQktGLINC80L7QttC10YLQtSDQt9Cw0YHQvdGP0YLRjCDQvdCwINCy0LjQtNC10L4g0YHQtdCx0Y8sINGB0LLQvtGOINGA0LDQsdC+0YLRgywg0LTQvtCy0L7Qu9GM0L3Ri9GFINC60LvQuNC10L3RgtC+0LIsINC/0L7QutCw0LfQsNGC0YwsINC60LDQuiDRh9GC0L4t0YLQviDRgNCw0LHQvtGC0LDQtdGCLCDQuNC70Lgg0LTQsNGC0Ywg0LTQtdC70YzQvdGL0Lkg0YHQvtCy0LXRgiDQuNC3INGB0L7QsdGB0YLQstC10L3QvdC+0Lkg0L/RgNCw0LrRgtC40LrQuC4g0JLQuNC00LXQvtGA0L7Qu9C40LrQuCDRgdC/0L7RgdC+0LHQvdGLINC/0L7QutCw0LfQsNGC0Ywg0L/QvtGB0LXRgtC40YLQtdC70Y4g0YLQviwg0YfRgtC+INC/0L7RgNC+0Lkg0YHQu9C+0LbQvdC+INC/0LXRgNC10LTQsNGC0Ywg0L7QtNC90LjQvNC4INGE0L7RgtC+0LPRgNCw0YTQuNGP0LzQuCwg0L/QvtC80L7Qs9Cw0Y7RgiDRgdGE0L7RgNC80LjRgNC+0LLQsNGC0Ywg0LjQvdGC0LXRgNC10YEg0Log0LrQsNC60L7QuS3Qu9C40LHQviDRg9GB0LvRg9Cz0LUg0LjQu9C4INGC0L7QstCw0YDRgy48L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX2xpbmVcXFxcXCI+PC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19waWNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fcGljLWltZyBtb3JlLXBhZ2VfX3BpYy1pbWdfb2Zmc2V0LTFcXFxcXCIgYWx0PVxcXFxcItGB0YLRgNCw0L3QuNGG0LAg0Lgg0LzQuNC90Lgt0YHRgtGA0LDQvdC40YbQsFxcXFxcIiBzcmM9XFxcXFwiL2ltZy9yZWdpc3RyYXRpb24vNC5wbmdcXFxcXCIgd2lkdGg9XFxcXFwiMTAwJVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX190ZXh0XFxcXFwiPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fdGV4dC10aXRsZVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fdGV4dC10aXRsZS1jb3VudFxcXFxcIj48L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fdGV4dC10aXRsZS1oZWFkZXJcXFxcXCI+0JrQsNGC0LDQu9C+0LMg0YHQvtCy0LXRgtC+0LIg0LzQsNGB0YLQtdGA0L7QsjwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fcGFyYWdyYXBoXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fcGFyYWdyYXBoLXRleHRcXFxcXCI+0KDRg9Cx0YDQuNC60LAgwqvQodC10LrRgNC10YLRiyDQnNCw0YHRgtC10YDQvtCywrsg4oCTINGN0YLQviDRgdCx0L7RgNC90LjQuiDRgdGC0LDRgtC10Lkg0L7RgiDQvdCw0YjQuNGFINGB0L/QtdGG0LjQsNC70LjRgdGC0L7QsiDQtNC70Y8g0L/QvtC80L7RidC4INC/0L7RgdC10YLQuNGC0LXQu9GP0Lwg0LIg0YHQsNC80YvRhSDRgNCw0LfQu9C40YfQvdGL0YUg0LbQuNC30L3QtdC90L3Ri9GFINGB0LjRgtGD0LDRhtC40Y/RhS4g0KfRgtC+0LHRiyDQv9C+0L/QsNGB0YLRjCDQsiDQutCw0YLQsNC70L7QsyDCq9Ch0LXQutGA0LXRgtC+0LLCuywg0LLQsNC8INC90YPQttC90L4g0L3QsNC/0LjRgdCw0YLRjCDQvdCwINC70LjRh9C90L7QuSDRgdGC0YDQsNC90LjRhtC1INGB0YLQsNGC0YzRji4g0JjQvdGC0LXRgNC10YHQvdGL0Lkg0Lgg0L/QvtC70LXQt9C90YvQuSDQvNCw0YLQtdGA0LjQsNC7INC00LXQvNC+0L3RgdGC0YDQuNGA0YPQtdGCINC60LvQuNC10L3RgtGDINCy0LDRiCDQsdC+0LPQsNGC0YvQuSDQvtC/0YvRgiDQuCDQstGL0YHQvtC60LjQuSDRg9GA0L7QstC10L3RjCDQv9GA0L7RhNC10YHRgdC40L7QvdCw0LvQuNC30LzQsC4g0JrQvtCz0LTQsCDRgdGC0LDRgtGM0Y8g0LHRg9C00LXRgiDQvtC/0YPQsdC70LjQutC+0LLQsNC90LAg0L3QsCDQstCw0YjQtdC5INGB0YLRgNCw0L3QuNGG0LUsINC80L7QtNC10YDQsNGC0L7RgNGLINC/0YDQvtCy0LXRgNGP0YIsINC/0L7QtNGF0L7QtNC40YIg0LvQuCDQvtC90LAg0LTQu9GPINC60LDRgtCw0LvQvtCz0LAg0YHQvtCy0LXRgtC+0LIuINCT0LvQsNCy0L3Ri9C80Lgg0LrRgNC40YLQtdGA0LjRj9C80Lgg0Y/QstC70Y/RjtGC0YHRjyDQv9GA0LDQutGC0LjRh9C90L7RgdGC0Ywg0Lgg0L/QvtC90Y/RgtC90L7RgdGC0Ywg0LTQu9GPINC/0L7RgdC10YLQuNGC0LXQu9GPLCDQvtGC0YHRg9GC0YHRgtCy0LjQtSDQv9GA0Y/QvNC+0Lkg0YDQtdC60LvQsNC80YsuPC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19saW5lXFxcXFwiPjwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fcGljXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3BpYy1pbWcgbW9yZS1wYWdlX19waWMtaW1nX29mZnNldC0xXFxcXFwiIGFsdD1cXFxcXCLRgdGC0YDQsNC90LjRhtCwINC4INC80LjQvdC4LdGB0YLRgNCw0L3QuNGG0LBcXFxcXCIgc3JjPVxcXFxcIi9pbWcvcmVnaXN0cmF0aW9uLzUucG5nXFxcXFwiIHdpZHRoPVxcXFxcIjEwMCVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm1vcmUtcGFnZV9fdGV4dFxcXFxcIj5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3RleHQtdGl0bGVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3RleHQtdGl0bGUtY291bnRcXFxcXCI+PC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJtb3JlLXBhZ2VfX3RleHQtdGl0bGUtaGVhZGVyXFxcXFwiPtCa0LDRgtCw0LvQvtCzINGE0LjRgNC8PC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19wYXJhZ3JhcGhcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwibW9yZS1wYWdlX19wYXJhZ3JhcGgtdGV4dFxcXFxcIj7Qn9C+0LzQuNC80L4g0L/QtdGA0LXRh9C90Y8g0L7RgtC00LXQu9GM0L3Ri9GFINGB0L/QtdGG0LjQsNC70LjRgdGC0L7QsiDRgyDQvdCw0YEg0YLQsNC60LbQtSDQtdGB0YLRjCDQutCw0YLQsNC70L7QsyDQutC+0LzQv9Cw0L3QuNC5LiDQndCwINGB0LXQs9C+0LTQvdGP0YjQvdC40Lkg0LTQtdC90Ywg0LIg0L3RkdC8INC90LDRhdC+0LTQuNGC0YHRjyDQsdC+0LvQtdC1IDEwMCDQvtGA0LPQsNC90LjQt9Cw0YbQuNC5LCDQs9C00LUg0YDQsNCx0L7RgtCw0Y7RgiDQvdCw0YjQuCDQnNCw0YHRgtC10YDQsC4g0JLRgdC1INC60L7QvNC/0LDQvdC40Lgg0YDQsNGB0L/QvtC70LDQs9Cw0Y7RgtGB0Y8g0LIg0YHQvtC+0YLQstC10YLRgdGC0LLQuNC4INGBINC/0YDQuNCy0YvRh9C90YvQvCDRgNGD0LHRgNC40LrQsNGC0L7RgNC+0Lwg0LIg0LfQsNCy0LjRgdC40LzQvtGB0YLQuCDQvtGCINGC0L7Qs9C+LCDQsiDQutCw0LrQvtC5INGB0YTQtdGA0LUg0L/QvtGB0LXRgtC40YLQtdC70Ywg0LjRidC10YIg0YHQv9C10YbQuNCw0LvQuNGB0YLQsC4g0JTQsNC90L3Ri9C5INC60LDRgtCw0LvQvtCzINC/0L7QvNC+0LPQsNC10YIg0L7RgNCz0LDQvdC40LfQvtCy0LDRgtGMINGN0YTRhNC10LrRgtC40LLQvdC+0LUg0L/RgNC+0LTQstC40LbQtdC90LjQtSDQvdC1INGC0L7Qu9GM0LrQviDQtNC70Y8g0L7RgtC00LXQu9GM0L3QvtCz0L4g0YHQvtGC0YDRg9C00L3QuNC60LAsINC90L4g0Lgg0LTQu9GPINGG0LXQu9C+0Lkg0LrQvtC80L/QsNC90LjQuC4g0JrQsNC20LTQsNGPINC+0YDQs9Cw0L3QuNC30LDRhtC40Y8g0LzQvtC20LXRgiDQuNC80LXRgtGMINC+0LTQvdC+0LPQviDRgdCy0L7QtdCz0L4g0L/RgNC10LTRgdGC0LDQstC40YLQtdC70Y8g0L3QsCBGYWNlTWFzdGVyINC40LvQuCDQsdC+0LvRjNGI0LUuINCi0LDQutC20LUg0LIg0LrQsNGC0LDQu9C+0LPQtSDRhNC40YDQvCDQtdGB0YLRjCDRgdCy0L7QuSDRgNC10LnRgtC40L3QsyDRgNC10LrQvtC80LXQvdC00LDRhtC40LkuINCe0L0g0YHQutC70LDQtNGL0LLQsNC10YLRgdGPINC40Lcg0YHRg9C80LzRiyDCq9C70LDQudC60L7QssK7LCDQutC+0YLQvtGA0YvQtSDQv9C+0LvRg9GH0LjQu9C4INCy0YHQtSDQnNCw0YHRgtC10YDQsCDQuNC3INC+0LTQvdC+0Lkg0LrQvtC80L/QsNC90LjQuC4g0KLQsNC60LjQvCDQvtCx0YDQsNC30L7QvCwg0YfQtdC8INC/0L7Qv9GD0LvRj9GA0L3QtdC1INGB0L7RgtGA0YPQtNC90LjQutC4INGB0YDQtdC00Lgg0LrQu9C40LXQvdGC0L7Qsiwg0YLQtdC8INCy0YvRiNC1INGA0LXQudGC0LjQvdCzINC+0YDQs9Cw0L3QuNC30LDRhtC40LguPC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPC9zZWN0aW9uPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICA8L2Rpdj5cXFxcbjwvZGl2PlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAncmVnaXN0cmF0aW9uLXByaWNlJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9yZWdpc3RyYXRpb24vcmVnaXN0cmF0aW9uLXByaWNlL2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcInJlZ2lzdHJhdGlvbi1wcmljZVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIjxkaXYgY2xhc3M9XFxcXFwicHJpY2Utd3IgY29ybmVyIGNvcm5lcl9iZ1xcXFxcIj5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcImNvbnRhaW5lclxcXFxcIj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJyb3dcXFxcXCI+XFxcXG4gICAgICAgICAgICA8c2VjdGlvbiBjbGFzcz1cXFxcXCJwcmljZVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJwYWdlLXRpdGxlIHBhZ2UtdGl0bGVfbGFuZGluZ1xcXFxcIj7QodC60L7Qu9GM0LrQviDRgdGC0L7QuNGCINC/0YDQtdC00LvQvtC20LXQvdC40LU/PC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwic3ViLXRpdGxlIHN1Yi10aXRsZV9sYW5kaW5nXFxcXFwiPtCS0YvQsdC10YDQuNGC0LUg0L3Rg9C20L3Rg9GOINC30LDQutC70LDQtNC60YM6PC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgPCEtLTxkaXYgaWQ9XFxcXFwiaG9yaXpvbnRhbFRhYlxcXFxcIj4tLT5cXFxcbiAgICAgICAgICAgICAgICAgICAgPCEtLTx1bCBibG9jaz1cXFxcXCJwcmljZS10YWJzLWxpc3RcXFxcXCIgbWl4PVxcXFxcImJsb2NrOnJlc3AtdGFicy1saXN0IGhvcl8xXFxcXFwiPi0tPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPCEtLTxsaSBlbGVtPVxcXFxcIml0ZW1cXFxcXCI+0KPRgdC70L7QstC40Y8g0LTQu9GPINGE0LjQt9C40YfQtdGB0LrQuNGFINC70LjRhjwvbGk+LS0+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tPGxpIGVsZW09XFxcXFwiaXRlbVxcXFxcIj7Qo9GB0LvQvtCy0LjRjyDQtNC70Y8g0Y7RgNC40LTQuNGH0LXRgdC60LjRhSDQu9C40YY8L2xpPi0tPlxcXFxuICAgICAgICAgICAgICAgICAgICA8IS0tPC91bD4tLT5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJwcmljZS10YWJzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJ0YWItY29udGVudCB0YWItY29udGVudF9hY3RpdmVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJ0YWItY29udGVudF9fbmFtZVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcInN0cmVsa2FcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCJcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg0KPRgdC70L7QstC40Y8g0LTQu9GPINGE0LjQt9C40YfQtdGB0LrQuNGFINC70LjRhlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2tcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2tfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3BhcnQtMVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fbWVkYWxzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1tZWRhbHNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stbWVkYWxzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtZWRhbF9jb2xvclwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3RpdGxlXFxcXFwiPtCh0YLQsNGA0YI8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3N1Yi10aXRsZVxcXFxcIj7QkdC10YHQv9C70LDRgtC90L48L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fcGFydC0yXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXMgb2ZlcnMtYmxvY2stcGx1c19zaW5nbGVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXNfX2l0ZW0gb2ZlcnMtYmxvY2stcGx1c19faXRlbV9zaW5nbGVcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwibWluaS1wYWdlX2NvbG9yXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19fdGV4dFxcXFxcIj7QnNC40L3QuDxicj7RgdGC0YDQsNC90LjRhtCwPC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3BhcnQtM1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fYnRuXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiYnRuIGJ0bl9yZWctcGx1cyBqcy1zY3JvbGx0b1xcXFxcIiBocmVmPVxcXFxcIiNmb3JtMlxcXFxcIj7QktGL0LHRgNCw0YLRjDwvYT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2tfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3BhcnQtMVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fbWVkYWxzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1tZWRhbHNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stbWVkYWxzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtZWRhbF9jb2xvclwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1tZWRhbHNfX2ljb25cXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcIm1lZGFsX2NvbG9yXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fdGl0bGVcXFxcXCI+0KHQv9C10YbQuNCw0LvQuNGB0YI8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3N1Yi10aXRsZVxcXFxcIj44INGA0YPQsS4g0LIg0LTQtdC90Yw8L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19wYXJ0LTJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtaW5pLXBhZ2VfY29sb3JcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzX190ZXh0XFxcXFwiPtCc0LjQvdC4PGJyPtGB0YLRgNCw0L3QuNGG0LA8L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJwYWdlX2NvbG9yXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19fdGV4dFxcXFxcIj7Qm9C40YfQvdCw0Y8g0YHRgtGA0LDQvdC40YbQsDwvcD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19wYXJ0LTNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX2J0blxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcImJ0biBidG5fcmVnLXBsdXMganMtc2Nyb2xsdG9cXFxcXCIgaHJlZj1cXFxcXCIjZm9ybTJcXFxcXCI+0JLRi9Cx0YDQsNGC0Yw8L2E+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZlxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19wYXJ0LTFcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX21lZGFsc1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stbWVkYWxzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLW1lZGFsc19faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwibWVkYWxfY29sb3JcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stbWVkYWxzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtZWRhbF9jb2xvclwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1tZWRhbHNfX2ljb25cXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcIm1lZGFsX2NvbG9yXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fdGl0bGVcXFxcXCI+0J/RgNC+0YTQtdGB0YHQuNC+0L3QsNC7PC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19zdWItdGl0bGVcXFxcXCI+MTYg0YDRg9CxLiDQsiDQtNC10L3RjDwvcD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19wYXJ0LTJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1cyBvZmVycy1ibG9jay1wbHVzX3Byb2ZcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXNfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwibWluaS1wYWdlX2NvbG9yXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19fdGV4dFxcXFxcIj7QnNC40L3QuDxicj7RgdGC0YDQsNC90LjRhtCwPC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXNfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwicGFnZV9jb2xvclwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXNfX3RleHRcXFxcXCI+0JvQuNGH0L3QsNGPINGB0YLRgNCw0L3QuNGG0LA8L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1cy1kb3BcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXMtZG9wX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXMtZG9wX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJ2aWRlb1wiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwiZ2lmdFwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwicGljdHVyZVwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwiZGlhbG9nXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19kZXNjci10ZXh0XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg0KHQutC40LTQutC4ICsg0YTQvtGC0L4gKyDQstC40LTQtdC+ICsg0L7RgtC30YvQstGLXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3BhcnQtM1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fYnRuXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiYnRuIGJ0bl9yZWctcGx1cyBqcy1zY3JvbGx0b1xcXFxcIiBocmVmPVxcXFxcIiNmb3JtMlxcXFxcIj7QktGL0LHRgNCw0YLRjDwvYT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX2hlYWRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fZW1wdHkgcHJpY2UtdGFibGUtZmlyc3QtY29sdW1uXFxcXFwiPiZuYnNwOzwvdGg+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9faGVhZC10ZXh0IHByaWNlLXRhYmxlLXNlY29uZC1jb2x1bW5cXFxcXCI+0J3QvtCy0LjRh9C+0Lo8L3RoPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX2hlYWQtdGV4dCBwcmljZS10YWJsZS10aGlyZC1jb2x1bW5cXFxcXCI+0KHQv9C10YbQuNCw0LvQuNGB0YI8L3RoPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX2hlYWQtdGV4dCBwcmljZS10YWJsZS1mb3J0aC1jb2x1bW5cXFxcXCI+0J/RgNC+0YTQtdGB0YHQuNC+0L3QsNC7PC90aD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90aGVhZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRib2R5IGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19ib2R5XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj45MCDQtNC90LXQuTwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPtCR0LXRgdC/0LvQsNGC0L3QvjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JleVxcXFxcIj4tPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjEgNTAwINGA0YPQsS48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj4xODAg0LTQvdC10Lk8L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZXlcXFxcXCI+LTwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj4xIDQ1MCDRgNGD0LEuPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+MiA3MDAg0YDRg9CxLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdHJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjM2MNC00L3QtdC5PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+MiA2MDAg0YDRg9CxLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjQgODAwINGA0YPQsS48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj7QnNC40L3QuC3RgdGC0YDQsNC90LjRhtCwPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmVlblxcXFxcIj4rPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JlZW5cXFxcXCI+Kzwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZWVuXFxcXFwiPis8L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+0JvQuNGH0L3QsNGPINGB0YLRgNCw0L3QuNGG0LA8L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZXlcXFxcXCI+LTwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZWVuXFxcXFwiPis8L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmVlblxcXFxcIj4rPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdHJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPtCQ0YHRgdC+0YDRgtC40LzQtdC90YIg0YPRgdC70YPQszwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjXRiNGCLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjjRiNGCLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjjRiNGCLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdHJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPtCh0LrQuNC00LrQuCDQuCDQv9C+0LTQsNGA0LrQuCArINGA0LDQt9C80LXRidC10L3QuNC1INCyINC60LDRgtCw0LvQvtCz0LUgXFxcXFwi0KHQutC40LTQutC4INC4INC/0L7QtNCw0YDQutC4XFxcXFwiPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+MtGI0YIuPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+0KTQvtGC0L7QsNC70YzQsdC+0Lw8L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZXlcXFxcXCI+LTwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZXlcXFxcXCI+LTwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj4z0YjRgi48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj7QktC40LTQtdC+0YDQvtC70LjQuiArINGA0LDQt9C80LXRidC10L3QuNC1INCyINC60LDRgtCw0LvQvtCz0LUg0JLQuNC00LXQvjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JleVxcXFxcIj4tPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JleVxcXFxcIj4tPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjLRiNGCLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdHJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPtCh0YLQsNGC0YzRjyArINGA0LDQt9C80LXRidC10L3QuNC1INCyINC60LDRgtCw0LvQvtCz0LUg0KHQvtCy0LXRgtC+0LIg0JzQsNGB0YLQtdGA0L7QsjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JleVxcXFxcIj4tPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JleVxcXFxcIj4tPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjLRiNGCLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdHJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPtCb0LDQudC60LgsINC+0YLQt9GL0LLRiywg0YDQtdC60L7QvNC10L3QtNCw0YbQuNC4PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+0LLQutC7LjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdHJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPiZuYnNwOzwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxhIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19idG4ganMtc2Nyb2xsdG9cXFxcXCIgaHJlZj1cXFxcXCIjZm9ybTJcXFxcXCI+0JzQvdC1INC/0L7QtNGF0L7QtNC40YIhPC9hPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxhIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19idG4ganMtc2Nyb2xsdG9cXFxcXCIgaHJlZj1cXFxcXCIjZm9ybTJcXFxcXCI+0JzQvdC1INC/0L7QtNGF0L7QtNC40YIhPC9hPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxhIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19idG4ganMtc2Nyb2xsdG9cXFxcXCIgaHJlZj1cXFxcXCIjZm9ybTJcXFxcXCI+0JzQvdC1INC/0L7QtNGF0L7QtNC40YIhPC9hPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJ0YWItY29udGVudFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInRhYi1jb250ZW50X19uYW1lXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwic3RyZWxrYVwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDQo9GB0LvQvtCy0LjRjyDQtNC70Y8g0Y7RgNC40LTQuNGH0LXRgdC60LjRhSDQu9C40YZcXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZiBkZXNjcmlwdGlvbi10YXJpZl9sb25nXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3BhcnQtMVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fbWVkYWxzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1tZWRhbHNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stbWVkYWxzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtZWRhbF9jb2xvclwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3RpdGxlXFxcXFwiPtCh0YLQsNGA0YI8YnI+0JHQuNC30L3QtdGBPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19zdWItdGl0bGVcXFxcXCI+MTYg0YDRg9CxLiDQsiDQtNC10L3RjDwvcD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19wYXJ0LTJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1cyBvZmVycy1ibG9jay1wbHVzX3NpbmdsZVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faXRlbSBvZmVycy1ibG9jay1wbHVzX19pdGVtX3NpbmdsZVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtaW5pLXBhZ2VfY29sb3JcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzX190ZXh0XFxcXFwiPtCc0LjQvdC4PGJyPtGB0YLRgNCw0L3QuNGG0LA8L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fcGFydC0zXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19idG5cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJidG4gYnRuX3JlZy1wbHVzIGpzLXNjcm9sbHRvXFxcXFwiIGhyZWY9XFxcXFwiI2Zvcm0yXFxcXFwiPtCS0YvQsdGA0LDRgtGMPC9hPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9ja19faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWYgZGVzY3JpcHRpb24tdGFyaWZfbG9uZ1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19wYXJ0LTFcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX21lZGFsc1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stbWVkYWxzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLW1lZGFsc19faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwibWVkYWxfY29sb3JcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stbWVkYWxzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtZWRhbF9jb2xvclwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3RpdGxlXFxcXFwiPtCh0L/QtdGG0LjQsNC70LjRgdGCINCR0LjQt9C90LXRgTwvcD5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fc3ViLXRpdGxlXFxcXFwiPjI1INGA0YPQsS4g0LIg0LTQtdC90Yw8L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19wYXJ0LTJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtaW5pLXBhZ2VfY29sb3JcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzX190ZXh0XFxcXFwiPtCc0LjQvdC4PGJyPtGB0YLRgNCw0L3QuNGG0LA8L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJwYWdlX2NvbG9yXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19fdGV4dFxcXFxcIj7Qm9C40YfQvdCw0Y8g0YHRgtGA0LDQvdC40YbQsDwvcD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19wYXJ0LTNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX2J0blxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcImJ0biBidG5fcmVnLXBsdXMganMtc2Nyb2xsdG9cXFxcXCIgaHJlZj1cXFxcXCIjZm9ybTJcXFxcXCI+0JLRi9Cx0YDQsNGC0Yw8L2E+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZiBkZXNjcmlwdGlvbi10YXJpZl9sb25nXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3BhcnQtMVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fbWVkYWxzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1tZWRhbHNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stbWVkYWxzX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtZWRhbF9jb2xvclwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1tZWRhbHNfX2ljb25cXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcIm1lZGFsX2NvbG9yXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLW1lZGFsc19faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwibWVkYWxfY29sb3JcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX190aXRsZVxcXFxcIj7Qn9GA0L7RhNC10YHRgdC40L7QvdCw0Lsg0JHQuNC30L3QtdGBPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19zdWItdGl0bGVcXFxcXCI+MzMg0YDRg9CxLiDQsiDQtNC10L3RjDwvcD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19wYXJ0LTJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1cyBvZmVycy1ibG9jay1wbHVzX3Byb2ZcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXNfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwibWluaS1wYWdlX2NvbG9yXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19fdGV4dFxcXFxcIj7QnNC40L3QuDxicj7RgdGC0YDQsNC90LjRhtCwPC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXNfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1c19faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwicGFnZV9jb2xvclwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXNfX3RleHRcXFxcXCI+0JvQuNGH0L3QsNGPINGB0YLRgNCw0L3QuNGG0LA8L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib2ZlcnMtYmxvY2stcGx1cy1kb3BcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXMtZG9wX19pdGVtXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXFxcIm9mZXJzLWJsb2NrLXBsdXMtZG9wX19pY29uXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJ2aWRlb1wiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwiZ2lmdFwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwicGljdHVyZVwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faXRlbVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJvZmVycy1ibG9jay1wbHVzLWRvcF9faWNvblxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwiZGlhbG9nXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImRlc2NyaXB0aW9uLXRhcmlmX19kZXNjci10ZXh0XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg0KHQutC40LTQutC4ICsg0YTQvtGC0L4gKyDQstC40LTQtdC+ICsg0L7RgtC30YvQstGLXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZGVzY3JpcHRpb24tdGFyaWZfX3BhcnQtM1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJkZXNjcmlwdGlvbi10YXJpZl9fYnRuXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiYnRuIGJ0bl9yZWctcGx1cyBqcy1zY3JvbGx0b1xcXFxcIiBocmVmPVxcXFxcIiNmb3JtMlxcXFxcIj7QktGL0LHRgNCw0YLRjDwvYT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGhlYWQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX2hlYWRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fZW1wdHkgcHJpY2UtdGFibGUtZmlyc3QtY29sdW1uXFxcXFwiPiZuYnNwOzwvdGg+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9faGVhZC10ZXh0IHByaWNlLXRhYmxlLXNlY29uZC1jb2x1bW5cXFxcXCI+0KHRgtCw0YDRgjxicj7QkdC40LfQvdC10YE8L3RoPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX2hlYWQtdGV4dCBwcmljZS10YWJsZS10aGlyZC1jb2x1bW5cXFxcXCI+0KHQv9C10YbQuNCw0LvQuNGB0YIg0JHQuNC30L3QtdGBPC90aD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19oZWFkLXRleHQgcHJpY2UtdGFibGUtZm9ydGgtY29sdW1uXFxcXFwiPtCf0YDQvtGE0LXRgdGB0LjQvtC90LDQuyDQkdC40LfQvdC10YE8L3RoPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RoZWFkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGJvZHkgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX2JvZHlcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdHJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjkwINC00L3QtdC5PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+MSA1MDAg0YDRg9CxLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjIgMjUwINGA0YPQsS48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj4zIDAwMCDRgNGD0LEuPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+MTgwINC00L3QtdC5PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+NCAwNTAg0YDRg9CxLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjUgNDAwINGA0YPQsS48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj4zNjDQtNC90LXQuTwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JleVxcXFxcIj4tPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjcgMjAwINGA0YPQsS48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj45IDYwMCDRgNGD0LEuPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+0JzQuNC90Lgt0YHRgtGA0LDQvdC40YbQsDwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JlZW5cXFxcXCI+Kzwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZWVuXFxcXFwiPis8L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmVlblxcXFxcIj4rPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdHJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPtCb0LjRh9C90LDRjyDRgdGC0YDQsNC90LjRhtCwPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmVlblxcXFxcIj4rPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JlZW5cXFxcXCI+Kzwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj7QkNGB0YHQvtGA0YLQuNC80LXQvdGCINGD0YHQu9GD0LM8L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj410YjRgi48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj440YjRgi48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj440YjRgi48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj7Qm9C+0LPQvtGC0LjQvyDQutC+0LzQv9Cw0L3QuNC4ICsg0YDQsNC30LzQtdGJ0LXQvdC40LUg0LIg0LrQsNGC0LDQu9C+0LPQtSDQutC+0LzQv9Cw0L3QuNC5PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmVlblxcXFxcIj4rPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JlZW5cXFxcXCI+Kzwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZWVuXFxcXFwiPis8L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+0KHQutC40LTQutC4INC4INC/0L7QtNCw0YDQutC4ICsg0YDQsNC30LzQtdGJ0LXQvdC40LUg0LIg0LrQsNGC0LDQu9C+0LPQtSBcXFxcXCLQodC60LjQtNC60Lgg0Lgg0L/QvtC00LDRgNC60LhcXFxcXCI8L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZXlcXFxcXCI+LTwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZXlcXFxcXCI+LTwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj4y0YjRgi48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj7QpNC+0YLQvtCw0LvRjNCx0L7QvDwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JleVxcXFxcIj4tPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjxzcGFuIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX19yb3VuZCBwcmljZS10YWJsZV9fcm91bmRfZ3JleVxcXFxcIj4tPC9zcGFuPjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPjPRiNGCLjwvdGQ+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdHJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3RkXFxcXFwiPtCS0LjQtNC10L7RgNC+0LvQuNC6ICsg0YDQsNC30LzQtdGJ0LXQvdC40LUg0LIg0LrQsNGC0LDQu9C+0LPQtSDQktC40LTQtdC+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+MtGI0YIuPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+0KHRgtCw0YLRjNGPICsg0YDQsNC30LzQtdGJ0LXQvdC40LUg0LIg0LrQsNGC0LDQu9C+0LPQtSDQodC+0LLQtdGC0L7QsiDQnNCw0YHRgtC10YDQvtCyPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PHNwYW4gY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX3JvdW5kIHByaWNlLXRhYmxlX19yb3VuZF9ncmV5XFxcXFwiPi08L3NwYW4+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+MtGI0YIuPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+0JvQsNC50LrQuCwg0L7RgtC30YvQstGLLCDRgNC10LrQvtC80LXQvdC00LDRhtC40Lg8L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZXlcXFxcXCI+LTwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj48c3BhbiBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fcm91bmQgcHJpY2UtdGFibGVfX3JvdW5kX2dyZXlcXFxcXCI+LTwvc3Bhbj48L3RkPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190ZFxcXFxcIj7QstC60LsuPC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVxcXFxcInByaWNlLXRhYmxlX190clxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+Jm5ic3A7PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PGEgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX2J0biBqcy1zY3JvbGx0b1xcXFxcIiBocmVmPVxcXFxcIiNmb3JtMlxcXFxcIj7QnNC90LUg0L/QvtC00YXQvtC00LjRgiE8L2E+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PGEgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX2J0biBqcy1zY3JvbGx0b1xcXFxcIiBocmVmPVxcXFxcIiNmb3JtMlxcXFxcIj7QnNC90LUg0L/QvtC00YXQvtC00LjRgiE8L2E+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJwcmljZS10YWJsZV9fdGRcXFxcXCI+PGEgY2xhc3M9XFxcXFwicHJpY2UtdGFibGVfX2J0biBqcy1zY3JvbGx0b1xcXFxcIiBocmVmPVxcXFxcIiNmb3JtMlxcXFxcIj7QnNC90LUg0L/QvtC00YXQvtC00LjRgiE8L2E+PC90ZD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90cj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC90Ym9keT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3RhYmxlPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDwhLS08L2Rpdj4tLT5cXFxcbiAgICAgICAgICAgIDwvc2VjdGlvbj5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgPC9kaXY+XFxcXG48L2Rpdj5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdyZWdpc3RyYXRpb24td2h5LXdlJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9yZWdpc3RyYXRpb24vcmVnaXN0cmF0aW9uLXdoeS13ZS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJyZWdpc3RyYXRpb24td2h5LXdlXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBsYW1iZGE9dGhpcy5sYW1iZGEsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwid2h5LXdlLXdyXFxcXFwiPlxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwiY29udGFpbmVyXFxcXFwiPlxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJvd1xcXFxcIj5cXFxcbiAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzPVxcXFxcIndoeS13ZVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJwYWdlLXRpdGxlIHBhZ2UtdGl0bGVfbGFuZGluZ1xcXFxcIj7Qn9C+0YfQtdC80YMg0LLRi9Cx0LjRgNCw0Y7RgiDQvdCw0YE/PC9wPlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwid2h5LXdlX19saXN0XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJvd1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib3VyLXBsdXNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvdXItcGx1c19fcm91bmRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm91ci1wbHVzX190aXRsZVxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvdW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5tYXN0ZXIgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm91ci1wbHVzX190ZXh0XFxcXFwiPlwiO1xcbiAgc3RhY2sxID0gbGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvdW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5tYXN0ZXJOYW1lIDogc3RhY2sxKSwgZGVwdGgwKTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCI8L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib3VyLXBsdXNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvdXItcGx1c19fcm91bmRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm91ci1wbHVzX190aXRsZVxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvdW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS52aXNpdHMgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm91ci1wbHVzX190ZXh0XFxcXFwiPtC/0L7RgdC10YnQtdC90LjQuTxicj7QsiDQvdC10LTQtdC70Y48L3A+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwib3VyLXBsdXNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvdXItcGx1c19fcm91bmRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm91ci1wbHVzX190aXRsZVxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvdW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5vcmRlcnMgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm91ci1wbHVzX190ZXh0XFxcXFwiPtC/0L7RgdGC0YPQv9C40LLRiNC40YU8YnI+0LfQsNGP0LLQvtC6PC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPC9zZWN0aW9uPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICA8L2Rpdj5cXFxcbjwvZGl2PlxcXFxuXCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ3J1YnJpa2F0b3ItbGlzdCcsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvcnVicmlrYXRvci9ydWJyaWthdG9yLWxpc3QvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwicnVicmlrYXRvci1saXN0XCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEsZGVwdGhzKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBsYW1iZGE9dGhpcy5sYW1iZGEsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBidWZmZXIgPSBcIlwiO1xcbiAgc3RhY2sxID0gKChoZWxwZXJzLmlzIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlzKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKGRhdGEgJiYgZGF0YS5pbmRleCksIFwiPT1cIiwgNywge1wibmFtZVwiOlwiaXNcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDIsIGRhdGEsIGRlcHRocyksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgYnVmZmVyICs9IFwiXFxcXG5cIjtcXG4gIHN0YWNrMSA9ICgoaGVscGVycy5pcyB8fCAoZGVwdGgwICYmIGRlcHRoMC5pcykgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIChkYXRhICYmIGRhdGEuaW5kZXgpLCBcIj09XCIsIDE1LCB7XCJuYW1lXCI6XCJpc1wiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMiwgZGF0YSwgZGVwdGhzKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCJcXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJydWJyaWthLWxpc3RcXFxcXCI+XFxcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJ1YnJpa2EtbGlzdF9fdGl0bGUganMtcnVicmlrYS1saXN0XFxcXFwiIHN0eWxlPVxcXFxcImJvcmRlci1yaWdodC1jb2xvcjogXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5lbCA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuY29sb3IgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInJ1YnJpa2EtbGlzdF9fbmFtZVxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmVsIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5uYW1lIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIjwvcD5cXFxcblxcXFxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInJ1YnJpa2EtbGlzdF9fY291bnRcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuY291bnQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvdW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImNvdW50XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3A+XFxcXG4gICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwicnVicmlrYS1saXN0X19saXN0XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDx1bD5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucG9kcnVicmlrcyA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDQsIGRhdGEsIGRlcHRocyksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgICAgICAgICAgICAgPC91bD5cXFxcbiAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICA8L2Rpdj5cXFxcblwiO1xcbn0sXCIyXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJydWJyaWtzLWNvbHVtblxcXFxcIj5cXFxcblwiO1xcbiAgfSxcIjRcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhLGRlcHRocykge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBsYW1iZGE9dGhpcy5sYW1iZGEsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZztcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFxcXCJydWJyaWthLWxpc3RfX2xpc3QtbGlcXFxcXCI+PGEgY2xhc3M9XFxcXFwicnVicmlrYS1saXN0X19saXN0LWFcXFxcXCIgaHJlZj1cXFxcXCIvXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aHNbMV0gIT0gbnVsbCA/IGRlcHRoc1sxXS5lbCA6IGRlcHRoc1sxXSkpICE9IG51bGwgPyBzdGFjazEudW5pcXVlIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIi9cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51bmlxdWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVuaXF1ZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1bmlxdWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXFxcInJ1YnJpa2EtbGlzdF9fbGlzdC1jb3VudFxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5tYXN0ZXJDb3VudCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubWFzdGVyQ291bnQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibWFzdGVyQ291bnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvc3Bhbj48L2E+PC9saT5cXFxcblwiO1xcbn0sXCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEsZGVwdGhzKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwicnVicmlrcy1jb2x1bW5cXFxcXCI+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJydWJyaWthLWxpc3QgcnVicmlrYS1saXN0X3Rvb2wtY29sbGFwc2VkIGpzLXJ1YnJpa2EtY29sbGFwc2VkXFxcXFwiPlxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJ1YnJpa2EtbGlzdF9fdGl0bGVcXFxcXCI+XFxcXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJydWJyaWthLWxpc3RfX25hbWVcXFxcXCI+0KDQsNC30LLQtdGA0L3Rg9GC0Ywg0LLRgdC1INGA0YPQsdGA0LjQutC4PC9wPlxcXFxuICAgICAgICAgICAgPGkgY2xhc3M9XFxcXFwicnVicmlrYS1saXN0X19pY29uXFxcXFwiPjwvaT5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgPC9kaXY+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnJ1YnJpa2F0b3IgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhLCBkZXB0aHMpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiPC9kaXY+XFxcXG5cIjtcXG59LFwidXNlRGF0YVwiOnRydWUsXCJ1c2VEZXB0aHNcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ21hc3Rlci1ibG9jay1hYm91dCcsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvbWFzdGVyL21hc3Rlci1ibG9jay9tYXN0ZXItYmxvY2stYWJvdXQvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwibWFzdGVyLWJsb2NrLWFib3V0XCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGJ1ZmZlciA9IFwiICAgICAgICA8cCBjbGFzcz1cXFxcXCJhYm91dC1tZF9fdGV4dC1jYXB0aW9uXFxcXFwiPtCe0LHRgNCw0LfQvtCy0LDQvdC40LU6PC9wPlxcXFxuICAgICAgICA8cCBjbGFzcz1cXFxcXCJhYm91dC1tZF9fdGV4dFxcXFxcIj5cIjtcXG4gIHN0YWNrMSA9ICgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuYWJvdXRFZHVjIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hYm91dEVkdWMgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiYWJvdXRFZHVjXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiPC9wPlxcXFxuXCI7XFxufSxcIjNcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBidWZmZXIgPSBcIiAgICAgICAgPHAgY2xhc3M9XFxcXFwiYWJvdXQtbWRfX3RleHQtY2FwdGlvblxcXFxcIj7QntC/0YvRgiDRgNCw0LHQvtGC0Ys6PC9wPlxcXFxuICAgICAgICA8cCBjbGFzcz1cXFxcXCJhYm91dC1tZF9fdGV4dFxcXFxcIj5cIjtcXG4gIHN0YWNrMSA9ICgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuYWJvdXRFeHAgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmFib3V0RXhwIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImFib3V0RXhwXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiPC9wPlxcXFxuXCI7XFxufSxcIjVcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBidWZmZXIgPSBcIiAgICAgICAgPHAgY2xhc3M9XFxcXFwiYWJvdXQtbWRfX3RleHQtY2FwdGlvblxcXFxcIj7QlNC+0L/QvtC70L3QuNGC0LXQu9GM0L3QsNGPINC40L3RhNC+0YDQvNCw0YbQuNGPOjwvcD5cXFxcbiAgICAgICAgPHAgY2xhc3M9XFxcXFwiYWJvdXQtbWRfX3RleHRcXFxcXCI+XCI7XFxuICBzdGFjazEgPSAoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmFib3V0QWRkSW5mbyB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYWJvdXRBZGRJbmZvIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImFib3V0QWRkSW5mb1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIjwvcD5cXFxcblwiO1xcbn0sXCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGJ1ZmZlciA9IFwiPGRpdiBjbGFzcz1cXFxcXCJhYm91dC1tZFxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hYm91dEVkdWMgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCJcXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hYm91dEV4cCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgzLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzW1xcJ2lmXFwnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmFib3V0QWRkSW5mbyA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg1LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIjwvZGl2PjwhLS0gYWJvdXQtbWQgLS0+XFxcXG5cXFxcblxcXFxuXFxcXG5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdtYXN0ZXItYmxvY2stYXJ0aWNsZScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvbWFzdGVyL21hc3Rlci1ibG9jay9tYXN0ZXItYmxvY2stYXJ0aWNsZS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJtYXN0ZXItYmxvY2stYXJ0aWNsZVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcIjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiYXJ0aWNsZS1jb250LW1kX19pdGVtLWNvbnRcXFxcXCI+XFxcXG5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiYXJ0aWNsZVxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJhcnRpY2xlX19saW5rIGpzLW9wZW4tYXJ0aWNsZVxcXFxcIiBocmVmPVxcXFxcIiNcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5pZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaWQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJhcnRpY2xlX19waWNcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVxcXFxcImFydGljbGVfX2ltZ1xcXFxcIiBzcmM9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pbWdTcmMgfHwgKGRlcHRoMCAmJiBkZXB0aDAuaW1nU3JjKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmltZ0lEIDogZGVwdGgwKSwge1wibmFtZVwiOlwiaW1nU3JjXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIlxcXFxcIiBhbHQ9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGl0bGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRpdGxlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImFydGljbGVfX3RleHRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvcD5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImFydGljbGVfX2F1dGhvclxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5hdXRob3IgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmF1dGhvciA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJhdXRob3JcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvcD5cXFxcbiAgICAgICAgICAgICAgICA8L2E+XFxcXG4gICAgICAgICAgICA8L2Rpdj5cXFxcblxcXFxuICAgICAgICA8L2Rpdj5cXFxcblwiO1xcbn0sXCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGJ1ZmZlciA9IFwiPGRpdiBjbGFzcz1cXFxcXCJhcnRpY2xlLWNvbnQtbWRcXFxcXCI+XFxcXG5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYXJ0aWNsZXMgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIlxcXFxuPC9kaXY+XFxcXG5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAnbWFzdGVyLWJsb2NrLWxpbmsnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItYmxvY2svbWFzdGVyLWJsb2NrLWxpbmsvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwibWFzdGVyLWJsb2NrLWxpbmtcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgbGFtYmRhPXRoaXMubGFtYmRhO1xcbiAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFxcXCJsaW5rLW1wXFxcXFwiPlxcXFxuICAgIDxhIGhyZWY9XFxcXFwiaHR0cHM6Ly92ay5jb20vaWQxMzQyMzQ3XFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJ2a1wiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjxzcGFuPmh0dHBzOi8vdmsuY29tL2lkMTM0MjM0Nzwvc3Bhbj48L2E+XFxcXG4gICAgPGEgaHJlZj1cXFxcXCJodHRwczovL29rLmNvbS9pZDEzNDIzNDdcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcIm9rXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPHNwYW4+aHR0cHM6Ly9vay5jb20vaWQxMzQyMzQ3PC9zcGFuPjwvYT5cXFxcbiAgICA8YSBocmVmPVxcXFxcImh0dHA6Ly9teS1zaXRlLnJ1XFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJlYXJ0aFwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjxzcGFuPmh0dHA6Ly9teS1zaXRlLnJ1PC9zcGFuPjwvYT5cXFxcbiAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbnRhY3RzIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5saW5rcyA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCJcXFxcbjwvZGl2PjwhLS0gbGluay1tcCAtLT5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAnbWFzdGVyLWJsb2NrLXBob3RvJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLWJsb2NrL21hc3Rlci1ibG9jay1waG90by9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJtYXN0ZXItYmxvY2stcGhvdG9cIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwicGhvdG8tbWRfX2FsYnVtLWNvdmVyIGpzLXNlbGVjdC1hbGJ1bVxcXFxcIiBpZD1cXFxcXCJhbGJ1bS1cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5pZCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaWQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiaWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcXFwiL21hc3Rlci1kYXRhLWVkaXQvanNvbjMuanNvblxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8aW1nIHNyYz1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmltZ1NyYyB8fCAoZGVwdGgwICYmIGRlcHRoMC5pbWdTcmMpIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnBob3RvcyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazFbXFwnMFxcJ10gOiBzdGFjazEpKSAhPSBudWxsID8gc3RhY2sxLmltZ0lEIDogc3RhY2sxKSwgMjAwLCB7XCJuYW1lXCI6XCJpbWdTcmNcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXFwiIGFsdD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj48YnI+XFxcXG4gICAgICAgICAgICAgICAgPHNwYW4+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3NwYW4+XFxcXG4gICAgICAgICAgICA8L2E+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuXCI7XFxufSxcIjNcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgYnVmZmVyID0gXCIgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInBob3RvLW1kX19hbGJ1bS1jb250XFxcXFwiIGlkPVxcXFxcImNvbnQtYWxidW0tXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImlkXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwicGhvdG8tbWRfX2FsYnVtLXRpdGxlXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJwaG90by1tZF9fd3JhcHBlclxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucGhvdG9zIDogZGVwdGgwKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oNCwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgICAgICAgICAgICAgPC9kaXY+XFxcXG5cXFxcbiAgICAgICAgICAgIDwvZGl2PlxcXFxuXCI7XFxufSxcIjRcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCI7XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJwaG90by1tZF9faW1nLXByZXZcXFxcXCIgaHJlZj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmltZ1NyYyB8fCAoZGVwdGgwICYmIGRlcHRoMC5pbWdTcmMpIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaW1nSUQgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpbWdTcmNcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaW1nU3JjIHx8IChkZXB0aDAgJiYgZGVwdGgwLmltZ1NyYykgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pbWdJRCA6IGRlcHRoMCksIDIwMCwge1wibmFtZVwiOlwiaW1nU3JjXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIlxcXFxcIiBhbHQ9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZGVzY3JpcHRpb24gfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmRlc2NyaXB0aW9uIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImRlc2NyaXB0aW9uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+PGJyPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCI8ZGl2IGNsYXNzPVxcXFxcInBob3RvLW1kXFxcXFwiPlxcXFxuXFxcXG4gICAgPCEtLSBFUlJPUiAtLT5cXFxcbiAgICA8cCBzdHlsZT1cXFxcXCJjb2xvcjogcmVkOyBmb250LXdlaWdodDogYm9sZFxcXFxcIj4tLS0tLS0gRVJST1IhIC0tLS0tLTwvcD5cXFxcbiAgICAhISHRhNC+0YLQvi4gQVBJIC0g0L3QtdC00L7RgdGC0LDRgtC+0YfQvdC+INC00LDQvdC90YvRhVxcXFxuICAgIDxicj48YnI+PGJyPlxcXFxuICAgIDwhLS0gRVJST1IgLS0+XFxcXG5cXFxcbiAgICA8ZGl2PlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hbGJ1bXMgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiAgICA8L2Rpdj5cXFxcblxcXFxuICAgIDxkaXY+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmFsYnVtcyA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDMsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiICAgIDwvZGl2PlxcXFxuPC9kaXY+PCEtLSBwaG90by1tZCAtLT5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdtYXN0ZXItYmxvY2stcmV2aWV3JywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLWJsb2NrL21hc3Rlci1ibG9jay1yZXZpZXcvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwibWFzdGVyLWJsb2NrLXJldmlld1wiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcIjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBsYW1iZGE9dGhpcy5sYW1iZGEsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIiAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInJlY29tbWVuZGF0aW9uc19fdG90YWxcXFxcXCI+0JzQsNGB0YLQtdGA0LAg0YDQtdC60L7QvNC10L3QtNGD0Y7RgiA8c3BhbiBjbGFzcz1cXFxcXCJyZWNvbW1lbmRhdGlvbnNfX3RvdGFsLWNvdW50XFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudmtMaWtlcyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuY291bnRMaWtlcyA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCIg0YfQtdC70L7QstC10Lo8L3NwYW4+PC9wPlxcXFxuXFxcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJlY29tbWVuZGF0aW9uc19fbGlzdFxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC52a0xpa2VzIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5kYXRhIDogc3RhY2sxKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMiwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgICAgICAgICA8L2Rpdj5cXFxcblwiO1xcbn0sXCIyXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJyZWNvbW1lbmRhdGlvbnNfX2l0ZW1cXFxcXCIgdGFyZ2V0PVxcXFxcIl9ibGFua1xcXFxcIiBocmVmPVxcXFxcImh0dHA6Ly92ay5jb20vaWRcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51aWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVpZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1aWRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnBob3RvXzEwMCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucGhvdG9fMTAwIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInBob3RvXzEwMFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiIGFsdD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5maXJzdF9uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5maXJzdF9uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImZpcnN0X25hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIiBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5sYXN0X25hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmxhc3RfbmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJsYXN0X25hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPC9hPlxcXFxuXCI7XFxufSxcIjRcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIiAgICAgICAgPHAgY2xhc3M9XFxcXFwicmV2aWV3cy1jb250LW1kX190aXRsZVxcXFxcIj7QnNC+0Lgg0L7RgtC30YvQstGLPC9wPlxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwicmV2aWV3cy1jb250LW1kX19jb21tZW50c1xcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY29tbWVudHMgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg1LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIiAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiNVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJldmlld3MtY29udC1tZF9faXRlbS1jb250XFxcXFwiPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInJldmlld3MtY29udC1tZF9fbmFtZVxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5hdXRob3JOYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5hdXRob3JOYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImF1dGhvck5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjxzcGFuIGNsYXNzPVxcXFxcInJldmlld3MtY29udC1tZF9fZGF0ZVxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmZvcm1hdERhdGUgfHwgKGRlcHRoMCAmJiBkZXB0aDAuZm9ybWF0RGF0ZSkgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5kYXRlIDogZGVwdGgwKSwgXCIlUiB8ICVkICVaICVZXCIsIHtcIm5hbWVcIjpcImZvcm1hdERhdGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9zcGFuPjwvcD5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJyZXZpZXdzLWNvbnQtbWRfX3RleHRcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGV4dCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGV4dCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0ZXh0XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcblwiO1xcbn0sXCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwicmV2aWV3cy1jb250LW1kXFxcXFwiPlxcXFxuXFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJyZWNvbW1lbmRhdGlvbnNcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9ICgoaGVscGVycy5pcyB8fCAoZGVwdGgwICYmIGRlcHRoMC5pcykgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnZrTGlrZXMgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmNvdW50TGlrZXMgOiBzdGFjazEpLCBcIj5cIiwgMCwge1wibmFtZVwiOlwiaXNcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSkpO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIlxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInJlY29tbWVuZGF0aW9uc19fYnV0dG9ucy1ibG9ja1xcXFxcIj5cXFxcbiAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInJlY29tbWVuZGF0aW9uc19fYnV0dG9ucy1ibG9jay10aXRsZVxcXFxcIj7Qn9C+0YDQtdC60L7QvNC10L3QtNGD0LnRgtC1INC80LDRgdGC0LXRgNCwOjwvcD5cXFxcblxcXFxuICAgICAgICAgICAgPGRpdj48L2Rpdj5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgPC9kaXY+XFxcXG5cXFxcbiAgICA8cCBjbGFzcz1cXFxcXCJyZXZpZXdzLWNvbnQtbWRfX3RpdGxlXFxcXFwiPtCe0YHRgtCw0LLQuNGC0Ywg0L7RgtC30YvQsjwvcD5cXFxcblxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwicmV2aWV3cy1jb250LW1kX19yb3dcXFxcXCI+XFxcXG4gICAgICAgIDxmb3JtIGNsYXNzPVxcXFxcImFkZC1jb21tZW50XFxcXFwiIG1ldGhvZD1cXFxcXCJQT1NUXFxcXFwiIGFjdGlvbj1cXFxcXCJcXFxcXCI+XFxcXG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XFxcXFwiYWRkLWNvbW1lbnRfX3RleHQtaW5wdXRcXFxcXCIgdHlwZT1cXFxcXCJ0ZXh0XFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCS0LDRiNC1INC40LzRj1xcXFxcIiBuYW1lPVxcXFxcImNvbW1lbnRfZm9ybVtuYW1lXVxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJhZGQtY29tbWVudF9fdGV4dC1pbnB1dFxcXFxcIiB0eXBlPVxcXFxcInRleHRcXFxcXCIgcGxhY2Vob2xkZXI9XFxcXFwi0JLQsNGIINC90L7QvNC10YAg0YLQtdC70LXRhNC+0L3QsFxcXFxcIiBuYW1lPVxcXFxcImNvbW1lbnRfZm9ybVtwaG9uZV1cXFxcXCI+XFxcXG4gICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XFxcXFwiYWRkLWNvbW1lbnRfX3RleHRhcmVhXFxcXFwiIHBsYWNlaG9sZGVyPVxcXFxcItCi0LXQutGB0YIg0L7RgtC30YvQstCwXFxcXFwiIG5hbWU9XFxcXFwiY29tbWVudF9mb3JtW2NvbW1lbnRfdGV4dF1cXFxcXCI+PC90ZXh0YXJlYT5cXFxcbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFxcXCJhZGQtY29tbWVudF9fYnRuXFxcXFwiIHR5cGU9XFxcXFwic3VibWl0XFxcXFwiIHZhbHVlPVxcXFxcItC+0YLQv9GA0LDQstC40YLRjFxcXFxcIj5cXFxcblxcXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwiYWRkLWNvbW1lbnRfX3N1Y2Nlc3NcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAg0JLQsNGIINC+0YLQt9GL0LIg0YPRgdC/0LXRiNC90L4g0L7RgtC/0YDQsNCy0LvQtdC9LCDRgdC/0LDRgdC40LHQviFcXFxcbiAgICAgICAgICAgIDwvcD5cXFxcbiAgICAgICAgPC9mb3JtPlxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwic29jaWFsLWxpbmtzXFxcXFwiPlxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJzb2NpYWwtbGlua3NfX3dyYXBwZXJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwic29jaWFsLWxpbmtzX190aXRsZVxcXFxcIj7QoNCw0LfQvNC10YHRgtC40YLRjCDRgdGB0YvQu9C60YMg0L3QsCZuYnNwO9GB0YLRgNCwJnNoeTvQvdC40YbRgyDQnNCw0YHRgtC10YDQsCDQsiZuYnNwO9GB0L7Rhi4mbmJzcDvRgdC10YLQuDo8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInNvY2lhbC1saW5rc19fbWFzdGVyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInNvY2lhbC1saW5rc19fcGhvdG8tY29udFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaW1nU3JjIHx8IChkZXB0aDAgJiYgZGVwdGgwLmltZ1NyYykgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pbWdJRCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImltZ1NyY1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCJcXFxcXCIgYWx0PVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJzb2NpYWwtbGlua3NfX25hbWVcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMubmFtZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAubmFtZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJuYW1lXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCI8L3A+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwic29jaWFsLWxpbmtzX19ub3RlXFxcXFwiPtCf0L7RgNC10LrQvtC80LXQvdC00YPQudGC0LUg0Y3RgtC+0LPQviDRgdC/0LXRhtC40LDQu9C40YHRgtCwINGB0LLQvtC40Lwg0LTRgNGD0LfRj9C8INCyJm5ic3A70YHQvtGG0LjQsNC70YzQvdC+0Lkg0YHQtdGC0Lg8L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInNvY2lhbC1saW5rc19fYnV0dG9uc1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPHAgc3R5bGU9XFxcXFwiY29sb3I6cmVkXFxcXFwiPtCh0YHRi9C70LrQuCEgVkssIE9LLCBGQiwgVFc8L3A+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG5cXFxcbiAgICA8L2Rpdj5cXFxcblxcXFxuXFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY29tbWVudHMgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oNCwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCJcXFxcbjwvZGl2PjwhLS1tZGUtcmV2aWV3cy0tPlxcXFxuXCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ21hc3Rlci1ibG9jay1zYWxlJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLWJsb2NrL21hc3Rlci1ibG9jay1zYWxlL2luZGV4LmpzJyksIHByb3BlcnRpZXM6IHtcIm5hbWVcIjpcIm1hc3Rlci1ibG9jay1zYWxlXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIiAgICA8ZGl2IGNsYXNzPVxcXFxcInNhbGUtY29udC1tZF9faXRlbS1jb250XFxcXFwiPlxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwic2FsZVxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcInNhbGVfX2xpbmsganMtb3Blbi1zYWxlXFxcXFwiIGhyZWY9XFxcXFwiI1wiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmlkIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJpZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInNhbGVfX3RpdGxlXFxcXFwiPlxcXFxuXCI7XFxuICBzdGFjazEgPSAoKGhlbHBlcnMuaXMgfHwgKGRlcHRoMCAmJiBkZXB0aDAuaXMpIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudHlwZSA6IGRlcHRoMCksIFwiPT1cIiwgMSwge1wibmFtZVwiOlwiaXNcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDIsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSkpO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHN0YWNrMSA9ICgoaGVscGVycy5pcyB8fCAoZGVwdGgwICYmIGRlcHRoMC5pcykgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50eXBlIDogZGVwdGgwKSwgXCI9PVwiLCAyLCB7XCJuYW1lXCI6XCJpc1wiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oNCwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgc3RhY2sxID0gKChoZWxwZXJzLmlzIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlzKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnR5cGUgOiBkZXB0aDApLCBcIj09XCIsIDMsIHtcIm5hbWVcIjpcImlzXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg2LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgICAgICAgICAgICAgPC9wPlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwic2FsZV9fcGljXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVxcXFxcInNhbGVfX2ltZ1xcXFxcIiBzcmM9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pbWdTcmMgfHwgKGRlcHRoMCAmJiBkZXB0aDAuaW1nU3JjKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmltZ0lEIDogZGVwdGgwKSwge1wibmFtZVwiOlwiaW1nU3JjXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIlxcXFxcIiBhbHQ9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGV4dCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGV4dCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ0ZXh0XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJzYWxlX190ZXh0XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8cD5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50ZXh0IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC50ZXh0IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRleHRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvcD5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgIDwvYT5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG5cXFxcbiAgICA8L2Rpdj5cXFxcblwiO1xcbn0sXCIyXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAg0J/QvtC00LDRgNC+0LpcXFxcblwiO1xcbiAgfSxcIjRcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICDQodC60LjQtNC60LAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuZGlzY291bnQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmRpc2NvdW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImRpc2NvdW50XCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCIlXFxcXG5cIjtcXG59LFwiNlwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgICAgICAgICAgICAgIC1cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5kaXNjb3VudCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZGlzY291bnQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiZGlzY291bnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIiDRgNGD0LEuXFxcXG5cIjtcXG59LFwiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwic2FsZS1jb250LW1kXFxcXFwiPlxcXFxuXFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNhbGVzIDogZGVwdGgwKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCJcXFxcbjwvZGl2PlwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdtYXN0ZXItYmxvY2stc2VydmljZScsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvbWFzdGVyL21hc3Rlci1ibG9jay9tYXN0ZXItYmxvY2stc2VydmljZS9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJtYXN0ZXItYmxvY2stc2VydmljZVwiLFwidGVtcGxhdGVcIjpcIi4vdGVtcGxhdGUuaGJzXCIsXCJlcnJvclRlbXBsYXRlXCI6XCIuL2Vycm9yLmhic1wiLFwibG9naWNcIjpcImluZGV4LmpzXCJ9LCB0ZW1wbGF0ZVNvdXJjZTogJ3tcIjFcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgbGFtYmRhPXRoaXMubGFtYmRhLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgIDxsaT5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKGRlcHRoMCwgZGVwdGgwKSlcXG4gICAgKyBcIjwvbGk+XFxcXG5cIjtcXG59LFwiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwic2VydmljZS1tZFxcXFxcIj5cXFxcbiAgICA8dWwgY2xhc3M9XFxcXFwic2VydmljZS1tZF9fbGlzdFxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zZXJ2aWNlcyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEucGFydDEgOiBzdGFjazEpLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiAgICA8L3VsPlxcXFxuXFxcXG4gICAgPHVsIGNsYXNzPVxcXFxcInNlcnZpY2UtbWRfX2xpc3RcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc2VydmljZXMgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLnBhcnQyIDogc3RhY2sxKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgPC91bD5cXFxcblxcXFxuICAgIDxiciBjbGFzcz1cXFxcXCJzZXJ2aWNlLW1kX19jbGVhclxcXFxcIj5cXFxcbjwvZGl2PjwhLS1tZGUtc2VydmljZS0tPlxcXFxuXFxcXG5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAnbWFzdGVyLWJsb2NrLXZpZGVvJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLWJsb2NrL21hc3Rlci1ibG9jay12aWRlby9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJtYXN0ZXItYmxvY2stdmlkZW9cIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBmdW5jdGlvblR5cGU9XCJmdW5jdGlvblwiLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGxhbWJkYT10aGlzLmxhbWJkYTtcXG4gIHJldHVybiBcIiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJ2aWRlby1tZF9fdmlkZW8tY29udFxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcInZpZGVvLW1kX192aWRlby1jb3ZlclxcXFxcIiBocmVmPVxcXFxcImh0dHA6Ly9cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51cmwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFxcXCJ2aWRlby1tZF9fdGl0bGUtcHJldlxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvc3Bhbj48YnI+XFxcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcXFwidmlkZW8tbWRfX2ltZy1jb250XFxcXFwiPjxpbWcgc3JjPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucHJldiA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuc3JjIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxcIiBhbHQ9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wcmV2IDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5hbHQgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPjwvc3Bhbj5cXFxcbiAgICAgICAgICAgIDwvYT5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG5cIjtcXG59LFwiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwidmlkZW8tbWRcXFxcXCI+XFxcXG5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudmlkZW9zIDogZGVwdGgwKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCJcXFxcbjwvZGl2PjwhLS0gdmlkZW8tbWQgLS0+XFxcXG5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAnbWFzdGVyLWJsb2NrLXdvcmsnLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItYmxvY2svbWFzdGVyLWJsb2NrLXdvcmsvaW5kZXguanMnKSwgcHJvcGVydGllczoge1wibmFtZVwiOlwibWFzdGVyLWJsb2NrLXdvcmtcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgIDx0ZD5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5vcGVuIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5vcGVuIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm9wZW5cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjxicj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5jbG9zZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY2xvc2UgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiY2xvc2VcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvdGQ+XFxcXG5cIjtcXG59LFwiM1wiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBidWZmZXIgPSBcIlwiO1xcbiAgc3RhY2sxID0gKChoZWxwZXJzLmlzIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlzKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnR5cGUgOiBkZXB0aDApLCBcIj09XCIsIDEsIHtcIm5hbWVcIjpcImlzXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg0LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pKTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyO1xcbn0sXCI0XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uO1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9saT5cXFxcblwiO1xcbn0sXCI2XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGJ1ZmZlciA9IFwiXCI7XFxuICBzdGFjazEgPSAoKGhlbHBlcnMuaXMgfHwgKGRlcHRoMCAmJiBkZXB0aDAuaXMpIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudHlwZSA6IGRlcHRoMCksIFwiPT1cIiwgMiwge1wibmFtZVwiOlwiaXNcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDQsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSkpO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgbGFtYmRhPXRoaXMubGFtYmRhLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgYnVmZmVyID0gXCI8ZGl2IGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBcXFxcXCI+XFxcXG5cXFxcbiAgICA8dGFibGUgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fdGltZXRhYmxlXFxcXFwiPlxcXFxuICAgICAgICA8dGhlYWQ+XFxcXG4gICAgICAgIDx0cj5cXFxcbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJ0aW1lLWFuZC13b3JrLW1wX19kYXlcXFxcXCI+0J/QvTwvdGQ+XFxcXG4gICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fZGF5XFxcXFwiPtCS0YI8L3RkPlxcXFxuICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2RheVxcXFxcIj7QodGAPC90ZD5cXFxcbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJ0aW1lLWFuZC13b3JrLW1wX19kYXkgdGltZS1hbmQtd29yay1tcF9fZGF5X3RvZGF5XFxcXFwiPtCn0YI8L3RkPlxcXFxuICAgICAgICAgICAgPHRkIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2RheVxcXFxcIj7Qn9GCPC90ZD5cXFxcbiAgICAgICAgICAgIDx0ZCBjbGFzcz1cXFxcXCJ0aW1lLWFuZC13b3JrLW1wX19kYXlcXFxcXCI+0KHQsTwvdGQ+XFxcXG4gICAgICAgICAgICA8dGQgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fZGF5XFxcXFwiPtCS0YE8L3RkPlxcXFxuICAgICAgICA8L3RyPlxcXFxuICAgICAgICA8L3RoZWFkPlxcXFxuICAgICAgICA8dGJvZHk+XFxcXG4gICAgICAgIDx0cj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc2NoZWR1bGUgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiAgICAgICAgPC90cj5cXFxcbiAgICAgICAgPC90Ym9keT5cXFxcbiAgICA8L3RhYmxlPlxcXFxuXFxcXG4gICAgPHAgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fbGlzdC1jYXB0aW9uXFxcXFwiPtCS0YvQtdC30LQg0L3QsCDQtNC+0Lw8L3A+XFxcXG4gICAgPHVsIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2xpc3RcXFxcXCI+XFxcXG4gICAgICAgIDxsaT7QkdC10YHQv9C70LDRgtC90L4g0L/QviDQs9C+0YDQvtC00YM8L2xpPlxcXFxuICAgICAgICA8bGk+0JLRi9C10LfQtCDQt9CwINCz0L7RgNC+0LQg0L/Qu9Cw0YLQvdC+PC9saT5cXFxcbiAgICA8L3VsPlxcXFxuXFxcXG5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2xpc3QtYmlnLWNvbnRcXFxcXCI+XFxcXG4gICAgICAgIDxwIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2xpc3QtY2FwdGlvblxcXFxcIj7QoNCw0LnQvtC90Ysg0L7QsdGB0LvRg9C20LjQstCw0L3QuNGPPC9wPlxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fbGlzdC1jb250XFxcXFwiPlxcXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fbGlzdC1jYXB0aW9uIHRpbWUtYW5kLXdvcmstbXBfX2xpc3QtY2FwdGlvbl9taW5pXFxcXFwiPtCT0L7RgNC+0LQ8L3A+XFxcXG4gICAgICAgICAgICA8dWwgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fbGlzdFxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZGlzdHJpY3QgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgzLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiAgICAgICAgICAgIDwvdWw+XFxcXG4gICAgICAgIDwvZGl2PjwhLS1saXN0LWNvbnQtLT5cXFxcblxcXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2xpc3QtY29udFxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2xpc3QtY2FwdGlvbiB0aW1lLWFuZC13b3JrLW1wX19saXN0LWNhcHRpb25fbWluaVxcXFxcIj7Qn9GA0LjQs9C+0YDQvtC0PC9wPlxcXFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2xpc3RcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmRpc3RyaWN0IDogZGVwdGgwKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oNiwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgICAgICAgICA8L3VsPlxcXFxuICAgICAgICA8L2Rpdj48IS0tbGlzdC1jb250LS0+XFxcXG5cXFxcbiAgICAgICAgPGJyIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2NsZWFyXFxcXFwiPlxcXFxuICAgIDwvZGl2PjwhLS1saXN0LWJpZy1jb250LS0+XFxcXG5cXFxcblxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fbGlzdC1iaWctY29udFxcXFxcIj5cXFxcbiAgICAgICAgPHAgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fbGlzdC1jYXB0aW9uXFxcXFwiPtCe0L/Qu9Cw0YLQsDwvcD5cXFxcblxcXFxuXFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fbGlzdC1jb250XFxcXFwiPlxcXFxuICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fbGlzdC1jYXB0aW9uIHRpbWUtYW5kLXdvcmstbXBfX2xpc3QtY2FwdGlvbl9taW5pXFxcXFwiPtCk0L7RgNC80LAg0YHQvtGC0YDRg9C00L3QuCZzaHk70YfQtdGB0YLQstCwPC9wPlxcXFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2xpc3RcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGxpPtCf0YDQtdC00L7Qv9C70LDRgtCwPC9saT5cXFxcbiAgICAgICAgICAgICAgICA8bGk+0J/QviDRhNCw0LrRgtGDINCy0YvQv9C+0LvQvdC10L3QvdGL0YUg0YDQsNCx0L7RgjwvbGk+XFxcXG4gICAgICAgICAgICAgICAgPGxpPtCg0LDRgdGB0YDQvtGH0LrQsCDQv9C70LDRgtC10LbQsDwvbGk+XFxcXG4gICAgICAgICAgICA8L3VsPlxcXFxuICAgICAgICA8L2Rpdj48IS0tbGlzdC1jb250LS0+XFxcXG5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJ0aW1lLWFuZC13b3JrLW1wX19saXN0LWNvbnRcXFxcXCI+XFxcXG4gICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJ0aW1lLWFuZC13b3JrLW1wX19saXN0LWNhcHRpb24gdGltZS1hbmQtd29yay1tcF9fbGlzdC1jYXB0aW9uX21pbmlcXFxcXCI+0KHQv9C+0YHQvtCx0Ysg0L7Qv9C70LDRgtGLPC9wPlxcXFxuICAgICAgICAgICAgPHVsIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2xpc3RcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGxpPtCd0LDQu9C40YfQvdGL0Lk8L2xpPlxcXFxuICAgICAgICAgICAgICAgIDxsaT7QkdC10LfQvdCw0LvQuNGH0L3Ri9C5XFxcXG4gICAgICAgICAgICAgICAgICAgIDx1bD5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT7QntC/0LvQsNGC0LAg0YfQtdGA0LXQtyDRjdC70LXQutGC0YDQvtC90L3Ri9C1INC/0LvQsNGC0LXQttC90YvQtSDRgdC40YHRgtC10LzRizwvbGk+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+0J7Qv9C70LDRgtCwINC/0L4g0LrRgNC10LTQuNGC0L3QvtC5L9C00LXQsdC10YLQvtCy0L7QuSDQutCw0YDRgtC1PC9saT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT7QntC/0LvQsNGC0LAg0YfQtdGA0LXQtyDRgtC10YDQvNC40L3QsNC70Ys8L2xpPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPtCR0LDQvdC60L7QstGB0LrQuNC5INC/0LXRgNC10LLQvtC0PC9saT5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT7Qn9GA0LXQtNC+0YHRgtCw0LLQu9C10L3QuNC1INGA0LDRgdGB0YDQvtGH0LrQuDwvbGk+XFxcXG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XFxcXG4gICAgICAgICAgICAgICAgPC9saT5cXFxcbiAgICAgICAgICAgIDwvdWw+XFxcXG4gICAgICAgIDwvZGl2PjwhLS1saXN0LWNvbnQtLT5cXFxcbiAgICAgICAgPGJyIGNsYXNzPVxcXFxcInRpbWUtYW5kLXdvcmstbXBfX2NsZWFyXFxcXFwiPlxcXFxuICAgIDwvZGl2PjwhLS1saXN0LWNvbnQtLT5cXFxcbiAgICA8YnIgY2xhc3M9XFxcXFwidGltZS1hbmQtd29yay1tcF9fY2xlYXJcXFxcXCI+XFxcXG5cXFxcbiAgICA8IS0tIEVSUk9SIC0tPlxcXFxuICAgIDxwIHN0eWxlPVxcXFxcImNvbG9yOiByZWQ7IGZvbnQtd2VpZ2h0OiBib2xkXFxcXFwiPi0tLS0tLSBFUlJPUiEgKNGD0YHQu9C+0LLQuNGPIC0g0LLRi9C10LfQtCDQvdCwINC00L7QvCwg0L7Qv9C70LDRgtCwKSAtLS0tLS08L3A+XFxcXG4gICAgISHQv9C10YDQtdC00LXQu9Cw0LXRgiDQuNC70YzRj1xcXFxuICAgINCj0YHQu9C+0LLQuNGPINC+0L/Qu9Cw0YLRizogXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC53b3JrQ29uZGl0aW9uIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5wYXltZW50Rm9ybSA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCJcXFxcbiAgICDQo9GB0LvQvtCy0LjRjyDQvtC/0LvQsNGC0Ys6IFwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAud29ya0NvbmRpdGlvbiA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuY29vcEZvcm0gOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXG4gICAg0JLRi9C10LfQtCDQvdCwINC00L7QvDogXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC53b3JrQ29uZGl0aW9uIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5jb21taW5nIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIlxcXFxuICAgIDwhLS0gRVJST1IgLS0+XFxcXG48L2Rpdj5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAnbWFzdGVyLW1pbmljYXJkJywgY29uc3RydWN0b3I6IHJlcXVpcmUoJy4vY2F0YmVycnlfY29tcG9uZW50cy9tYXN0ZXIvbWFzdGVyLW1pbmljYXJkL21hc3Rlci1taW5pY2FyZC9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJtYXN0ZXItbWluaWNhcmRcIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwibWFzdGVyLW1pbmljYXJkX2ZyZWVcIjtcXG4gIH0sXCIzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBsYW1iZGE9dGhpcy5sYW1iZGE7XFxuICByZXR1cm4gXCIgICAgICAgICAgICA8aSBjbGFzcz1cXFxcXCJtYXN0ZXItbWluaWNhcmRfX2xpa2VcXFxcXCI+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcImxpa2VcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCIgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC52a0xpa2VzIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5jb3VudExpa2VzIDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIjwvaT5cXFxcblwiO1xcbn0sXCI1XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgbGFtYmRhPXRoaXMubGFtYmRhLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3Npbmc7XFxuICByZXR1cm4gXCIgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJtYXN0ZXItbWluaWNhcmRfX3RvLXBhZ2VcXFxcXCIgaHJlZj1cXFxcXCIvXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wYWdlIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5udW1iZXIgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiPtCd0LAg0YHRgtGA0LDQvdC40YbRgyDQvNCw0YHRgtC10YDQsDxpPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJzdHJlbGthXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiPC9pPjwvYT5cXFxcblwiO1xcbn0sXCI3XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBsYW1iZGE9dGhpcy5sYW1iZGE7XFxuICByZXR1cm4gXCIgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1taW5pY2FyZF9fY29tcGFueVxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxzcGFuPjxpbWcgY2xhc3M9XFxcXFwibWFzdGVyLW1pbmljYXJkX19sb2dvXFxcXFwiIHNyYz1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmltZ1NyYyB8fCAoZGVwdGgwICYmIGRlcHRoMC5pbWdTcmMpIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb21wYW55IDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5pbWdJRCA6IHN0YWNrMSksIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5udWxsIDogZGVwdGgwKSwgNzAsIHtcIm5hbWVcIjpcImltZ1NyY1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCJcXFxcXCIgYWx0PVxcXFxcIlxcXFxcIj48L3NwYW4+XFxcXG4gICAgICAgICAgICA8c3Bhbj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmNvbXBhbnkgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLm5hbWUgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiPC9zcGFuPlxcXFxuICAgICAgICA8L3A+XFxcXG5cIjtcXG59LFwiOVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIm1hc3Rlci1taW5pY2FyZF9fc2VydmljZXNfaGFsZlwiO1xcbiAgfSxcIjExXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIGxhbWJkYT10aGlzLmxhbWJkYSwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICA8bGk+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYShkZXB0aDAsIGRlcHRoMCkpXFxuICAgICsgXCI8L2xpPlxcXFxuXCI7XFxufSxcIjEzXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGxhbWJkYT10aGlzLmxhbWJkYSwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgYnVmZmVyID0gXCIgICAgICAgIDx1bCBjbGFzcz1cXFxcXCJtYXN0ZXItY29udGVudC13aWRnZXRcXFxcXCI+XFxcXG4gICAgICAgICAgICA8bGkgY2xhc3M9XFxcXFwiXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzW1xcJ2lmXFwnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucGFnZSA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuc2FsZXMgOiBzdGFjazEpLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMTQsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgYnVmZmVyICs9IFwiIG1hc3Rlci1jb250ZW50LXdpZGdldF9fZ2lmdFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8aT5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwiZ2lmdFwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcblxcXFxuICAgICAgICAgICAgICAgIDxkaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1jb250ZW50LXdpZGdldF9faW5mb1xcXFxcIj48c3Bhbj5cXFxcblwiO1xcbiAgc3RhY2sxID0gKChoZWxwZXJzLmlzIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlzKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zYWxlcyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazFbXFwnMFxcJ10gOiBzdGFjazEpKSAhPSBudWxsID8gc3RhY2sxLnR5cGUgOiBzdGFjazEpLCBcIj09XCIsIDEsIHtcIm5hbWVcIjpcImlzXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxNywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgc3RhY2sxID0gKChoZWxwZXJzLmlzIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlzKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zYWxlcyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazFbXFwnMFxcJ10gOiBzdGFjazEpKSAhPSBudWxsID8gc3RhY2sxLnR5cGUgOiBzdGFjazEpLCBcIj09XCIsIDIsIHtcIm5hbWVcIjpcImlzXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxOSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgc3RhY2sxID0gKChoZWxwZXJzLmlzIHx8IChkZXB0aDAgJiYgZGVwdGgwLmlzKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zYWxlcyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazFbXFwnMFxcJ10gOiBzdGFjazEpKSAhPSBudWxsID8gc3RhY2sxLnR5cGUgOiBzdGFjazEpLCBcIj09XCIsIDMsIHtcIm5hbWVcIjpcImlzXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgyMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgYnVmZmVyICs9IFwiICAgICAgICAgICAgICAgICAgICA8L3NwYW4+PC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1jb250ZW50LXdpZGdldF9fdGV4dFxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc2FsZXMgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxW1xcJzBcXCddIDogc3RhY2sxKSkgIT0gbnVsbCA/IHN0YWNrMS50aXRsZSA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCI8L3A+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICA8L2xpPlxcXFxuICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcIlwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnBhZ2UgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmFsYnVtcyA6IHN0YWNrMSksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgyMywgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCIgbWFzdGVyLWNvbnRlbnQtd2lkZ2V0X19waG90b1xcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8aT5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwicGljdHVyZVwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcblxcXFxuICAgICAgICAgICAgICAgIDxkaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1jb250ZW50LXdpZGdldF9faW5mb1xcXFxcIj48c3Bhbj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5hbGJ1bXNDb3VudCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYWxidW1zQ291bnQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiYWxidW1zQ291bnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIiDRhNC+0YLQvtCw0LvRjNCx0L7QvNC+0LI8L3NwYW4+PC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1jb250ZW50LXdpZGdldF9fdGV4dFxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5hbGJ1bXNUaXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYWxidW1zVGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiYWxidW1zVGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvcD5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgIDwvbGk+XFxcXG4gICAgICAgICAgICA8bGkgY2xhc3M9XFxcXFwiXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzW1xcJ2lmXFwnXS5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucGFnZSA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEudmlkZW9zIDogc3RhY2sxKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDI1LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiBtYXN0ZXItY29udGVudC13aWRnZXRfX3ZpZGVvXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxpPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJ2aWRlb1wiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcblxcXFxuICAgICAgICAgICAgICAgIDxkaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1jb250ZW50LXdpZGdldF9faW5mb1xcXFxcIj48c3Bhbj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5pbWdJRCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuaW1nSUQgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiaW1nSURcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvc3Bhbj48L3A+XFxcXG5cXFxcbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcXFwibWFzdGVyLWNvbnRlbnQtd2lkZ2V0X190ZXh0XFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC52aWRlb3MgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxW1xcJzBcXCddIDogc3RhY2sxKSkgIT0gbnVsbCA/IHN0YWNrMS50aXRsZSA6IHN0YWNrMSksIGRlcHRoMCkpXFxuICAgICsgXCI8L3A+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICA8L2xpPlxcXFxuICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcIlwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnBhZ2UgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmNvbW1lbnRzIDogc3RhY2sxKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDI3LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIiBtYXN0ZXItY29udGVudC13aWRnZXRfX2NvbW1lbnRcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGk+XCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcImRpYWxvZ1wiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIjwvaT5cXFxcblxcXFxuICAgICAgICAgICAgICAgIDxkaXY+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1jb250ZW50LXdpZGdldF9faW5mb1xcXFxcIj48c3Bhbj7QoyDQnNCw0YHRgtC10YDQsDo8YnI+PHN0cm9uZz5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24obGFtYmRhKCgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnZrTGlrZXMgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLmNvdW50TGlrZXMgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiINGA0LXQutC+0LzQtdC90LTQsNGG0LjRjzxicj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5jb21tZW50c0NvdW50IHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb21tZW50c0NvdW50IDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImNvbW1lbnRzQ291bnRcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAg0L7RgtC30YvQstC+0LI8L3N0cm9uZz48L3NwYW4+PC9wPlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcIm1hc3Rlci1jb250ZW50LXdpZGdldF9fdGV4dFxcXFxcIj7Cq1wiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb21tZW50cyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazFbXFwnMFxcJ10gOiBzdGFjazEpKSAhPSBudWxsID8gc3RhY2sxLnRleHQgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiwrs8L3A+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICA8L2xpPlxcXFxuICAgICAgICA8L3VsPlxcXFxuXCI7XFxufSxcIjE0XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMTtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNhbGVzIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMVtcXCcwXFwnXSA6IHN0YWNrMSkpICE9IG51bGwgPyBzdGFjazEudGl0bGUgOiBzdGFjazEpLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMTUsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgcmV0dXJuIHN0YWNrMTsgfVxcbiAgZWxzZSB7IHJldHVybiBcXCdcXCc7IH1cXG4gIH0sXCIxNVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcImFjdFwiO1xcbiAgfSxcIjE3XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgINCf0L7QtNCw0YDQvtC6XFxcXG5cIjtcXG4gIH0sXCIxOVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGxhbWJkYT10aGlzLmxhbWJkYSwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAg0KHQutC40LTQutCwIFwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zYWxlcyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazFbXFwnMFxcJ10gOiBzdGFjazEpKSAhPSBudWxsID8gc3RhY2sxLmRpc2NvdW50IDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIiVcXFxcblwiO1xcbn0sXCIyMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGxhbWJkYT10aGlzLmxhbWJkYSwgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb247XFxuICByZXR1cm4gXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgLVwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbihsYW1iZGEoKChzdGFjazEgPSAoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5zYWxlcyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazFbXFwnMFxcJ10gOiBzdGFjazEpKSAhPSBudWxsID8gc3RhY2sxLmRpc2NvdW50IDogc3RhY2sxKSwgZGVwdGgwKSlcXG4gICAgKyBcIiDRgNGD0LEuXFxcXG5cIjtcXG59LFwiMjNcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuYWxidW1zIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMVtcXCcwXFwnXSA6IHN0YWNrMSkpICE9IG51bGwgPyBzdGFjazEubmFtZSA6IHN0YWNrMSksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxNSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyByZXR1cm4gc3RhY2sxOyB9XFxuICBlbHNlIHsgcmV0dXJuIFxcJ1xcJzsgfVxcbiAgfSxcIjI1XCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMTtcXG4gIHN0YWNrMSA9IGhlbHBlcnNbXFwnaWZcXCddLmNhbGwoZGVwdGgwLCAoKHN0YWNrMSA9ICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnZpZGVvcyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazFbXFwnMFxcJ10gOiBzdGFjazEpKSAhPSBudWxsID8gc3RhY2sxLnRpdGxlIDogc3RhY2sxKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDE1LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IHJldHVybiBzdGFjazE7IH1cXG4gIGVsc2UgeyByZXR1cm4gXFwnXFwnOyB9XFxuICB9LFwiMjdcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY29tbWVudHMgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxW1xcJzBcXCddIDogc3RhY2sxKSkgIT0gbnVsbCA/IHN0YWNrMS50ZXh0IDogc3RhY2sxKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDE1LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IHJldHVybiBzdGFjazE7IH1cXG4gIGVsc2UgeyByZXR1cm4gXFwnXFwnOyB9XFxuICB9LFwiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgbGFtYmRhPXRoaXMubGFtYmRhLCBidWZmZXIgPSBcIjxkaXYgY2xhc3M9XFxcXFwiXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzLnVubGVzcy5jYWxsKGRlcHRoMCwgKChzdGFjazEgPSAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAucGFnZSA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEuaWQgOiBzdGFjazEpLCB7XCJuYW1lXCI6XCJ1bmxlc3NcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgYnVmZmVyICs9IFwiIG1hc3Rlci1taW5pY2FyZFxcXFxcIj5cXFxcblxcXFxuICAgIDxkaXYgY2xhc3M9XFxcXFwibWFzdGVyLW1pbmljYXJkX19waG90by1jb250XFxcXFwiPlxcXFxuICAgICAgICA8aW1nIGNsYXNzPVxcXFxcIm1hc3Rlci1taW5pY2FyZF9fcGhvdG9cXFxcXCIgc3JjPVxcXFxcImh0dHA6Ly9hcGktZm0ucHJlc2VudC10bHQucnUvZmlsZXM/a2V5PVwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmltZ0lEIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pbWdJRCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJpbWdJRFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiIGFsdD1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5uYW1lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5uYW1lIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcIm5hbWVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wYWdlIDogZGVwdGgwKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDMsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgYnVmZmVyICs9IFwiICAgIDwvZGl2PlxcXFxuXFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJtYXN0ZXItbWluaWNhcmRfX2NvbnRhY3Qtd3JhcFxcXFxcIj5cXFxcbiAgICAgICAgPGNhdC1tYXN0ZXItcGhvbmUtYnRuIGlkPVxcXFxcIm1hc3Rlci1waG9uZS1idG4tXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMuaWQgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmlkIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcImlkXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSkpXFxuICAgICsgXCJcXFxcXCIgcGhvbmU9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb250YWN0cyA6IGRlcHRoMCkpICE9IG51bGwgPyBzdGFjazEucGhvbmUgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiIHBhZ2U9XFxcXFwiXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKGxhbWJkYSgoKHN0YWNrMSA9IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wYWdlIDogZGVwdGgwKSkgIT0gbnVsbCA/IHN0YWNrMS5udW1iZXIgOiBzdGFjazEpLCBkZXB0aDApKVxcbiAgICArIFwiXFxcXFwiIG93bmVyPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLmlkIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pZCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJpZFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPjwvY2F0LW1hc3Rlci1waG9uZS1idG4+XFxcXG5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsICgoc3RhY2sxID0gKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnBhZ2UgOiBkZXB0aDApKSAhPSBudWxsID8gc3RhY2sxLm51bWJlciA6IHN0YWNrMSksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg1LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiAgICAgICAgPGEgY2xhc3M9XFxcXFwibWFzdGVyLW1pbmljYXJkX19zaG93LXNlcnZpY2VzIGpzLXNlcnZpY2VzLXRvZ2dsZVxcXFxcIiBocmVmPVxcXFxcIiNcXFxcXCI+0J/QvtC60LDQt9Cw0YLRjCDRg9GB0LvRg9Cz0Lg8L2E+XFxcXG4gICAgPC9kaXY+XFxcXG5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5jb21wYW55IDogZGVwdGgwKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDcsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgYnVmZmVyICs9IFwiXFxcXG4gICAgPHAgY2xhc3M9XFxcXFwibWFzdGVyLW1pbmljYXJkX19uYW1lXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm5hbWUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm5hbWUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwibmFtZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuXFxcXG4gICAgPHAgY2xhc3M9XFxcXFwibWFzdGVyLW1pbmljYXJkX19zcGVjXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnNwZWMgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnNwZWMgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwic3BlY1wiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuXFxcXG4gICAgPHVsIGNsYXNzPVxcXFxcIlwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5pc1dpZGdldCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImlmXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg5LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIGJ1ZmZlciArPSBcIiBtYXN0ZXItbWluaWNhcmRfX3NlcnZpY2VzIGpzLW1pbmljYXJkLXNlcnZpY2VzLWN1dFxcXFxcIj5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVycy5lYWNoLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuc2VydmljZXMgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSgxMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCIgICAgPC91bD5cXFxcblwiO1xcbiAgc3RhY2sxID0gaGVscGVyc1tcXCdpZlxcJ10uY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5wYWdlIDogZGVwdGgwKSwge1wibmFtZVwiOlwiaWZcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDEzLCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIlxcXFxuPC9kaXY+XFxcXG5cXFxcblxcXFxuPGRpdiBjbGFzcz1cXFxcXCJmcmFtZSBjYWxsYmFja1xcXFxcIj5cXFxcblxcXFxuPC9kaXY+XFxcXG5cXFxcblxcXFxuXCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J30sXG57bmFtZTogJ21hc3Rlci1waG9uZS1idG4nLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL21hc3Rlci9tYXN0ZXItbWluaWNhcmQvbWFzdGVyLXBob25lLWJ0bi9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJtYXN0ZXItcGhvbmUtYnRuXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiMVwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbjtcXG4gIHJldHVybiBcIiAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcInBob25lLWJ0bl9fdXJsXFxcXFwiIGhyZWY9XFxcXFwiL1wiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnBhZ2UgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnBhZ2UgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwicGFnZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPtC10YnQtSDQutC+0L3RgtCw0LrRgtGLPC9hPlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgaGVscGVyLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGJ1ZmZlciA9IFwiPGRpdiBjbGFzcz1cXFxcXCJwaG9uZS1idG5cXFxcXCI+XFxcXG4gICAgPHAgY2xhc3M9XFxcXFwicGhvbmUtYnRuX190aXAganMtbWFzdGVyLXBob25lLXRpcFxcXFxcIj5cXFxcbiAgICAgICAg0J/QvtC20LDQu9GD0LnRgdGC0LAg0YHQutCw0LbQuNGC0LUg0LzQsNGB0YLQtdGA0YMg0YfRgtC+INC90LDRiNC70Lgg0LXQs9C+INC90LAg0L3QsNGI0LXQvCDRgdCw0LnRgtC1XFxcXG4gICAgICAgIDxpIGNsYXNzPVxcXFxcImpzLWNsb3NlLXRpcFxcXFxcIj5cIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwiY2xvc2VcIiwge1wibmFtZVwiOlwiaWNvblwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSkpXFxuICAgICsgXCI8L2k+XFxcXG4gICAgPC9wPlxcXFxuICAgIDxidXR0b24gY2xhc3M9XFxcXFwicGhvbmUtYnRuX19idXR0b24ganMtc2hvdy1waG9uZVxcXFxcIiBkYXRhLWlkPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLm93bmVyIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5vd25lciA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJvd25lclwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlxcXFxuICAgICAgICDQn9C+0LrQsNC30LDRgtGMINGC0LXQu9C10YTQvtC9XFxcXG4gICAgPC9idXR0b24+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJwaG9uZS1idG5fX3Bob25lLWRldGFpbHMganMtc2hvdy1waG9uZS1kZXRhaWxzXFxcXFwiPlxcXFxuICAgICAgICA8cCBjbGFzcz1cXFxcXCJwaG9uZS1idG5fX3Bob25lXFxcXFwiPlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnBob25lIHx8IChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5waG9uZSA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJwaG9uZVwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiPC9wPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzW1xcJ2lmXFwnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnBhZ2UgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgPC9kaXY+XFxcXG48L2Rpdj5cXFxcblwiO1xcbn0sXCJ1c2VEYXRhXCI6dHJ1ZX0nLCBlcnJvclRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICByZXR1cm4gXCJcXFxcblwiO1xcbiAgfSxcInVzZURhdGFcIjp0cnVlfSd9LFxue25hbWU6ICdkb3AtZnVuY3Rpb24nLCBjb25zdHJ1Y3RvcjogcmVxdWlyZSgnLi9jYXRiZXJyeV9jb21wb25lbnRzL3BhZ2UvcGFnZS1tYWluL2RvcC1mdW5jdGlvbi9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJkb3AtZnVuY3Rpb25cIixcInRlbXBsYXRlXCI6XCIuL3RlbXBsYXRlLmhic1wiLFwiZXJyb3JUZW1wbGF0ZVwiOlwiLi9lcnJvci5oYnNcIixcImxvZ2ljXCI6XCJpbmRleC5qc1wifSwgdGVtcGxhdGVTb3VyY2U6ICd7XCIxXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCIgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cXFxcXCJiZWNvbWUtbWFzdGVyX19pdGVtXFxcXFwiPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzW1xcJ2lmXFwnXS5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLmljb24gOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJpZlwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMiwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5wcm9ncmFtKDQsIGRhdGEpLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCIgICAgICAgICAgICAgICAgICAgIDwvbGk+XFxcXG5cIjtcXG59LFwiMlwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcImJlY29tZS1tYXN0ZXJfX2l0ZW0tbGluayBiZWNvbWUtbWFzdGVyX19pdGVtLWxpbmtfaG92ZXJcXFxcXCIgaHJlZj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51cmwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFxcXCJiZWNvbWUtbWFzdGVyX19pY29uXFxcXFwiPjwvc3Bhbj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjtcXG4gIHN0YWNrMSA9ICgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGl0bGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRpdGxlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XFxcXG5cIjtcXG59LFwiNFwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIiAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcImJlY29tZS1tYXN0ZXJfX2l0ZW0tbGlua1xcXFxcIiBocmVmPVxcXFxcIlwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlciA9IChoZWxwZXIgPSBoZWxwZXJzLnVybCB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudXJsIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInVybFwiLFwiaGFzaFwiOnt9LFwiZGF0YVwiOmRhdGF9KSA6IGhlbHBlcikpKVxcbiAgICArIFwiXFxcXFwiPlwiO1xcbiAgc3RhY2sxID0gKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy50aXRsZSB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAudGl0bGUgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwidGl0bGVcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICByZXR1cm4gYnVmZmVyICsgXCI8L2E+XFxcXG5cIjtcXG59LFwiNlwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHZhciBzdGFjazEsIGhlbHBlciwgZnVuY3Rpb25UeXBlPVwiZnVuY3Rpb25cIiwgaGVscGVyTWlzc2luZz1oZWxwZXJzLmhlbHBlck1pc3NpbmcsIGVzY2FwZUV4cHJlc3Npb249dGhpcy5lc2NhcGVFeHByZXNzaW9uLCBidWZmZXIgPSBcIiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcImFib3V0LWNvbXBhbnlfX2l0ZW1cXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJhYm91dC1jb21wYW55X19pdGVtLWxpbmtcXFxcXCIgaHJlZj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51cmwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cIjtcXG4gIHN0YWNrMSA9ICgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGl0bGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRpdGxlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiPC9hPlxcXFxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxcXFxuXCI7XFxufSxcIjhcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBidWZmZXIgPSBcIiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXFxcImJheWRhX19pdGVtLWN1YmVcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMudW5sZXNzLmNhbGwoZGVwdGgwLCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuZW1wdHkgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJ1bmxlc3NcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDksIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiICAgICAgICAgICAgICAgICAgICA8L2xpPlxcXFxuXCI7XFxufSxcIjlcIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgc3RhY2sxLCBoZWxwZXIsIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCIsIGhlbHBlck1pc3Npbmc9aGVscGVycy5oZWxwZXJNaXNzaW5nLCBlc2NhcGVFeHByZXNzaW9uPXRoaXMuZXNjYXBlRXhwcmVzc2lvbiwgYnVmZmVyID0gXCIgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJiYXlkYV9faXRlbS1jdWJlLWxpbmtcXFxcXCIgaHJlZj1cXFxcXCJcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy51cmwgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnVybCA6IGRlcHRoMCkpICE9IG51bGwgPyBoZWxwZXIgOiBoZWxwZXJNaXNzaW5nKSwodHlwZW9mIGhlbHBlciA9PT0gZnVuY3Rpb25UeXBlID8gaGVscGVyLmNhbGwoZGVwdGgwLCB7XCJuYW1lXCI6XCJ1cmxcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIlxcXFxcIj5cIjtcXG4gIHN0YWNrMSA9ICgoaGVscGVyID0gKGhlbHBlciA9IGhlbHBlcnMudGl0bGUgfHwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLnRpdGxlIDogZGVwdGgwKSkgIT0gbnVsbCA/IGhlbHBlciA6IGhlbHBlck1pc3NpbmcpLCh0eXBlb2YgaGVscGVyID09PSBmdW5jdGlvblR5cGUgPyBoZWxwZXIuY2FsbChkZXB0aDAsIHtcIm5hbWVcIjpcInRpdGxlXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pIDogaGVscGVyKSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgcmV0dXJuIGJ1ZmZlciArIFwiPC9hPlxcXFxuXCI7XFxufSxcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgdmFyIHN0YWNrMSwgYnVmZmVyID0gXCI8ZGl2IGNsYXNzPVxcXFxcImRvcC1mdW5jdGlvblxcXFxcIj5cXFxcbiAgICA8ZGl2IGNsYXNzPVxcXFxcImRvcC1mdW5jdGlvbl9faW5uZXJcXFxcXCI+XFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiYmVjb21lLW1hc3RlclxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiYmVjb21lLW1hc3Rlcl9faW5uZXJcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJiZWNvbWUtbWFzdGVyX190aXRsZSBkb3AtZnVuY3Rpb24tYmxvY2stanNcXFxcXCI+0JzQsNGB0YLQtdGA0LDQvDwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFxcXCJiZWNvbWUtbWFzdGVyX19tZW51XFxcXFwiPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tZW51TWFzdGVyIDogZGVwdGgwKSwge1wibmFtZVwiOlwiZWFjaFwiLFwiaGFzaFwiOnt9LFwiZm5cIjp0aGlzLnByb2dyYW0oMSwgZGF0YSksXCJpbnZlcnNlXCI6dGhpcy5ub29wLFwiZGF0YVwiOmRhdGF9KTtcXG4gIGlmIChzdGFjazEgIT0gbnVsbCkgeyBidWZmZXIgKz0gc3RhY2sxOyB9XFxuICBidWZmZXIgKz0gXCIgICAgICAgICAgICAgICAgPC91bD5cXFxcbiAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJhYm91dC1jb21wYW55XFxcXFwiPlxcXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJhYm91dC1jb21wYW55X19pbm5lclxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImFib3V0LWNvbXBhbnlfX3RpdGxlIGRvcC1mdW5jdGlvbi1ibG9jay1qc1xcXFxcIj7QniDQutC+0LzQv9Cw0L3QuNC4PC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzPVxcXFxcImFib3V0LWNvbXBhbnlfX21lbnVcXFxcXCI+XFxcXG5cIjtcXG4gIHN0YWNrMSA9IGhlbHBlcnMuZWFjaC5jYWxsKGRlcHRoMCwgKGRlcHRoMCAhPSBudWxsID8gZGVwdGgwLm1lbnVBYm91dCA6IGRlcHRoMCksIHtcIm5hbWVcIjpcImVhY2hcIixcImhhc2hcIjp7fSxcImZuXCI6dGhpcy5wcm9ncmFtKDYsIGRhdGEpLFwiaW52ZXJzZVwiOnRoaXMubm9vcCxcImRhdGFcIjpkYXRhfSk7XFxuICBpZiAoc3RhY2sxICE9IG51bGwpIHsgYnVmZmVyICs9IHN0YWNrMTsgfVxcbiAgYnVmZmVyICs9IFwiICAgICAgICAgICAgICAgIDwvdWw+XFxcXG4gICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiYmF5ZGFcXFxcXCI+XFxcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImJheWRhX19pbm5lclxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXFxcImJheWRhX190aXRsZSBkb3AtZnVuY3Rpb24tYmxvY2stanNcXFxcXCI+0KDQsNC30LLQu9C10YfQtdC90LjRjzwvZGl2PlxcXFxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cXFxcXCJiYXlkYV9fbWVudS1jdWJlXFxcXFwiPlxcXFxuXCI7XFxuICBzdGFjazEgPSBoZWxwZXJzLmVhY2guY2FsbChkZXB0aDAsIChkZXB0aDAgIT0gbnVsbCA/IGRlcHRoMC5tZW51QmF5ZGEgOiBkZXB0aDApLCB7XCJuYW1lXCI6XCJlYWNoXCIsXCJoYXNoXCI6e30sXCJmblwiOnRoaXMucHJvZ3JhbSg4LCBkYXRhKSxcImludmVyc2VcIjp0aGlzLm5vb3AsXCJkYXRhXCI6ZGF0YX0pO1xcbiAgaWYgKHN0YWNrMSAhPSBudWxsKSB7IGJ1ZmZlciArPSBzdGFjazE7IH1cXG4gIHJldHVybiBidWZmZXIgKyBcIiAgICAgICAgICAgICAgICA8L3VsPlxcXFxuICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDwvZGl2PlxcXFxuICAgIDwvZGl2PlxcXFxuPC9kaXY+XFxcXG5cIjtcXG59LFwidXNlRGF0YVwiOnRydWV9JywgZXJyb3JUZW1wbGF0ZVNvdXJjZTogJ3tcImNvbXBpbGVyXCI6WzYsXCI+PSAyLjAuMC1iZXRhLjFcIl0sXCJtYWluXCI6ZnVuY3Rpb24oZGVwdGgwLGhlbHBlcnMscGFydGlhbHMsZGF0YSkge1xcbiAgcmV0dXJuIFwiXFxcXG5cIjtcXG4gIH0sXCJ1c2VEYXRhXCI6dHJ1ZX0nfSxcbntuYW1lOiAnbWFpbi1mdW5jdGlvbicsIGNvbnN0cnVjdG9yOiByZXF1aXJlKCcuL2NhdGJlcnJ5X2NvbXBvbmVudHMvcGFnZS9wYWdlLW1haW4vbWFpbi1mdW5jdGlvbi9pbmRleC5qcycpLCBwcm9wZXJ0aWVzOiB7XCJuYW1lXCI6XCJtYWluLWZ1bmN0aW9uXCIsXCJ0ZW1wbGF0ZVwiOlwiLi90ZW1wbGF0ZS5oYnNcIixcImVycm9yVGVtcGxhdGVcIjpcIi4vZXJyb3IuaGJzXCIsXCJsb2dpY1wiOlwiaW5kZXguanNcIn0sIHRlbXBsYXRlU291cmNlOiAne1wiY29tcGlsZXJcIjpbNixcIj49IDIuMC4wLWJldGEuMVwiXSxcIm1haW5cIjpmdW5jdGlvbihkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XFxuICB2YXIgaGVscGVyLCBoZWxwZXJNaXNzaW5nPWhlbHBlcnMuaGVscGVyTWlzc2luZywgZXNjYXBlRXhwcmVzc2lvbj10aGlzLmVzY2FwZUV4cHJlc3Npb24sIGZ1bmN0aW9uVHlwZT1cImZ1bmN0aW9uXCI7XFxuICByZXR1cm4gXCI8ZGl2IGNsYXNzPVxcXFxcIm1haW4tZnVuY3Rpb25cXFxcXCI+XFxcXG4gICAgPGRpdiBjbGFzcz1cXFxcXCJtYWluLWZ1bmN0aW9uX19pbm5lclxcXFxcIj5cXFxcbiAgICAgICAgPGNhdC1zZWFyY2ggaWQ9XFxcXFwic2VhcmNoXFxcXFwiPjwvY2F0LXNlYXJjaD5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJvclxcXFxcIj7QuNC70Lg8L2Rpdj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmaW5kLW1hc3RlciBqcy1maW5kLW1hc3RlclxcXFxcIj5cXFxcbiAgICAgICAgICAgIDxhIGNsYXNzPVxcXFxcImZpbmQtbWFzdGVyX19pbm5lclxcXFxcIiBocmVmPVxcXFxcIi9jYXRhbG9nXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiZmluZC1tYXN0ZXJfX2lubmVyLXJlbFxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJmaW5kLW1hc3Rlcl9faWNvblxcXFxcIj5cXFxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICsgZXNjYXBlRXhwcmVzc2lvbigoKGhlbHBlcnMuaWNvbiB8fCAoZGVwdGgwICYmIGRlcHRoMC5pY29uKSB8fCBoZWxwZXJNaXNzaW5nKS5jYWxsKGRlcHRoMCwgXCJtYW4taW4tc3VuXCIsIFwiaWNvbl93aGl0ZVwiLCB7XCJuYW1lXCI6XCJpY29uXCIsXCJoYXNoXCI6e30sXCJkYXRhXCI6ZGF0YX0pKSlcXG4gICAgKyBcIlxcXFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJmaW5kLW1hc3Rlcl9fdGl0bGVcXFxcXCI+0JLRi9Cx0LXRgNC4INCc0LDRgdGC0LXRgNCwPC9wPlxcXFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFxcXCJmaW5kLW1hc3Rlcl9fYnRuXFxcXFwiPtCjINC90LDRgSBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXIgPSAoaGVscGVyID0gaGVscGVycy5jb3VudE1hc3RlciB8fCAoZGVwdGgwICE9IG51bGwgPyBkZXB0aDAuY291bnRNYXN0ZXIgOiBkZXB0aDApKSAhPSBudWxsID8gaGVscGVyIDogaGVscGVyTWlzc2luZyksKHR5cGVvZiBoZWxwZXIgPT09IGZ1bmN0aW9uVHlwZSA/IGhlbHBlci5jYWxsKGRlcHRoMCwge1wibmFtZVwiOlwiY291bnRNYXN0ZXJcIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkgOiBoZWxwZXIpKSlcXG4gICAgKyBcIjwvc3Bhbj5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgIDwvYT5cXFxcbiAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiY2FsbC1iYWNrXFxcXFwiPlxcXFxuICAgICAgICAgICAgPGEgY2xhc3M9XFxcXFwiY2FsbC1iYWNrX19pbm5lclxcXFxcIiBocmVmPVxcXFxcIi9yZXF1ZXN0XFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiY2FsbC1iYWNrX19pbm5lci1yZWxcXFxcXCI+XFxcXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiY2FsbC1iYWNrX19pY29uXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgKyBlc2NhcGVFeHByZXNzaW9uKCgoaGVscGVycy5pY29uIHx8IChkZXB0aDAgJiYgZGVwdGgwLmljb24pIHx8IGhlbHBlck1pc3NpbmcpLmNhbGwoZGVwdGgwLCBcInN0YXItaW4tc3VuXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICArIGVzY2FwZUV4cHJlc3Npb24oKChoZWxwZXJzLmljb24gfHwgKGRlcHRoMCAmJiBkZXB0aDAuaWNvbikgfHwgaGVscGVyTWlzc2luZykuY2FsbChkZXB0aDAsIFwic3Rhci1saW5lXCIsIHtcIm5hbWVcIjpcImljb25cIixcImhhc2hcIjp7fSxcImRhdGFcIjpkYXRhfSkpKVxcbiAgICArIFwiXFxcXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuXFxcXG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXFxcImNhbGwtYmFja19fdGl0bGVcXFxcXCI+0JfQsNC60LDQttC4INGD0YHQu9GD0LPRgzwvcD5cXFxcblxcXFxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFxcXCJjYWxsLWJhY2tfX3RleHRcXFxcXCI+0JzRiyDQsdC10YHQv9C70LDRgtC90L4g0L7RgtC/0YDQsNCy0LjQvCDQstCw0YjRgyDQt9Cw0Y/QstC60YMg0LLRgdC10Lwg0L/QvtC00YXQvtC00Y/RidC40Lwg0JzQsNGB0YLQtdGA0LDQvDwvcD5cXFxcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcXFwiY2FsbC1iYWNrX19idG5cXFxcXCI+0KHQvtC30LTQsNGC0Ywg0LfQsNGP0LLQutGDPC9zcGFuPlxcXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICAgICAgPC9hPlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJjYXRhbG9nc1xcXFxcIj5cXFxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiY2F0YWxvZ3NfX2lubmVyXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcXFwiY2F0YWxvZ3NfX3NlcnZpY2VzXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cXFxcXCJjYXRhbG9nc19fc2VydmljZXMtbGlua1xcXFxcIiBocmVmPVxcXFxcIi9jYXRhbG9nXFxcXFwiPtCS0LXRgdGMINC60LDRgtCw0LvQvtCzINGD0YHQu9GD0LM8L2E+XFxcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxcXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFxcXCJjYXRhbG9nc19fZG9wXFxcXFwiPlxcXFxuICAgICAgICAgICAgICAgICAgICA8Y2F0LWNhdGFsb2ctbGlzdCBpZD1cXFxcXCJjYXRhbG9nLWxpc3RcXFxcXCIgZGF0YS1tb2Q9XFxcXFwicGFnZV9tYWluXFxcXFwiPjwvY2F0LWNhdGFsb2ctbGlzdD5cXFxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXFxcbiAgICAgICAgICAgIDwvZGl2PlxcXFxuICAgICAgICA8L2Rpdj5cXFxcbiAgICA8L2Rpdj5cXFxcbjwvZGl2PlxcXFxuXCI7XFxufSxcInVzZURhdGFcIjp0cnVlfScsIGVycm9yVGVtcGxhdGVTb3VyY2U6ICd7XCJjb21waWxlclwiOls2LFwiPj0gMi4wLjAtYmV0YS4xXCJdLFwibWFpblwiOmZ1bmN0aW9uKGRlcHRoMCxoZWxwZXJzLHBhcnRpYWxzLGRhdGEpIHtcXG4gIHJldHVybiBcIlxcXFxuXCI7XFxuICB9LFwidXNlRGF0YVwiOnRydWV9J31cbl07XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuXHRyb3V0ZURlZmluaXRpb25zID0gcmVxdWlyZSgnLi9yb3V0ZXMuanMnKSB8fCBbXSxcblx0Q2F0YmVycnkgPSByZXF1aXJlKCcuL25vZGVfbW9kdWxlcy9jYXRiZXJyeS9icm93c2VyL0NhdGJlcnJ5LmpzJyksXG5cdExvZ2dlciA9IHJlcXVpcmUoJy4vbm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2Jyb3dzZXIvTG9nZ2VyLmpzJyksXG5cdEJvb3RzdHJhcHBlckJhc2UgPVxuXHRcdHJlcXVpcmUoJy4vbm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2xpYi9iYXNlL0Jvb3RzdHJhcHBlckJhc2UuanMnKSxcblx0U3RvcmVEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9ub2RlX21vZHVsZXMvY2F0YmVycnkvbGliL1N0b3JlRGlzcGF0Y2hlcicpLFxuXHRNb2R1bGVBcGlQcm92aWRlciA9XG5cdFx0cmVxdWlyZSgnLi9ub2RlX21vZHVsZXMvY2F0YmVycnkvYnJvd3Nlci9wcm92aWRlcnMvTW9kdWxlQXBpUHJvdmlkZXInKSxcblx0Q29va2llV3JhcHBlciA9IHJlcXVpcmUoJy4vbm9kZV9tb2R1bGVzL2NhdGJlcnJ5L2Jyb3dzZXIvQ29va2llV3JhcHBlcicpO1xuXG52YXIgREVCVUdfRE9DVU1FTlRfVVBEQVRFRCA9ICdEb2N1bWVudCB1cGRhdGVkICglZCBzdG9yZShzKSBjaGFuZ2VkKScsXG5cdERFQlVHX0NPTVBPTkVOVF9CT1VORCA9ICdDb21wb25lbnQgXCIlc1wiIGlzIGJvdW5kJyxcblx0REVCVUdfQ09NUE9ORU5UX1VOQk9VTkQgPSAnQ29tcG9uZW50IFwiJXNcIiBpcyB1bmJvdW5kJztcblxudXRpbC5pbmhlcml0cyhCb290c3RyYXBwZXIsIEJvb3RzdHJhcHBlckJhc2UpO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBicm93c2VyIENhdGJlcnJ5J3MgYm9vdHN0cmFwcGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCb290c3RyYXBwZXJCYXNlXG4gKi9cbmZ1bmN0aW9uIEJvb3RzdHJhcHBlcigpIHtcblx0Qm9vdHN0cmFwcGVyQmFzZS5jYWxsKHRoaXMsIENhdGJlcnJ5KTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmVzIENhdGJlcnJ5J3Mgc2VydmljZSBsb2NhdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ09iamVjdCBBcHBsaWNhdGlvbiBjb25maWcgb2JqZWN0LlxuICogQHBhcmFtIHtTZXJ2aWNlTG9jYXRvcn0gbG9jYXRvciBTZXJ2aWNlIGxvY2F0b3IgdG8gY29uZmlndXJlLlxuICovXG5Cb290c3RyYXBwZXIucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChjb25maWdPYmplY3QsIGxvY2F0b3IpIHtcblx0Qm9vdHN0cmFwcGVyQmFzZS5wcm90b3R5cGUuY29uZmlndXJlLmNhbGwodGhpcywgY29uZmlnT2JqZWN0LCBsb2NhdG9yKTtcblxuXHQvLyBpZiBicm93c2VyIHN0aWxsIGRvZXMgbm90IGhhdmUgcHJvbWlzZXMgdGhlbiBhZGQgaXQuXG5cdGlmICghKCdQcm9taXNlJyBpbiB3aW5kb3cpKSB7XG5cdFx0d2luZG93LlByb21pc2UgPSBsb2NhdG9yLnJlc29sdmUoJ3Byb21pc2UnKTtcblx0fVxuXG5cdGxvY2F0b3IucmVnaXN0ZXIoJ3N0b3JlRGlzcGF0Y2hlcicsIFN0b3JlRGlzcGF0Y2hlciwgY29uZmlnT2JqZWN0LCB0cnVlKTtcblx0bG9jYXRvci5yZWdpc3Rlcihcblx0XHQnbW9kdWxlQXBpUHJvdmlkZXInLCBNb2R1bGVBcGlQcm92aWRlciwgY29uZmlnT2JqZWN0LCB0cnVlXG5cdCk7XG5cdGxvY2F0b3IucmVnaXN0ZXIoJ2Nvb2tpZVdyYXBwZXInLCBDb29raWVXcmFwcGVyLCBjb25maWdPYmplY3QsIHRydWUpO1xuXG5cdGxvY2F0b3IucmVnaXN0ZXJJbnN0YW5jZSgnd2luZG93Jywgd2luZG93KTtcblxuXHR2YXIgbG9nZ2VyQ29uZmlnID0gY29uZmlnT2JqZWN0LmxvZ2dlciB8fCB7fSxcblx0XHRsb2dnZXIgPSBuZXcgTG9nZ2VyKGxvZ2dlckNvbmZpZy5sZXZlbHMpO1xuXHRsb2NhdG9yLnJlZ2lzdGVySW5zdGFuY2UoJ2xvZ2dlcicsIGxvZ2dlcik7XG5cdHdpbmRvdy5vbmVycm9yID0gZnVuY3Rpb24gZXJyb3JIYW5kbGVyKG1zZywgdXJpLCBsaW5lKSB7XG5cdFx0bG9nZ2VyLmZhdGFsKHVyaSArICc6JyArIGxpbmUgKyAnICcgKyBtc2cpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXHR2YXIgZXZlbnRCdXMgPSBsb2NhdG9yLnJlc29sdmUoJ2V2ZW50QnVzJyk7XG5cdHRoaXMuX3dyYXBFdmVudHNXaXRoTG9nZ2VyKGNvbmZpZ09iamVjdCwgZXZlbnRCdXMsIGxvZ2dlcik7XG5cblx0cm91dGVEZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZURlZmluaXRpb24pIHtcblx0XHRsb2NhdG9yLnJlZ2lzdGVySW5zdGFuY2UoJ3JvdXRlRGVmaW5pdGlvbicsIHJvdXRlRGVmaW5pdGlvbik7XG5cdH0pO1xuXG5cdHN0b3Jlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZSkge1xuXHRcdGxvY2F0b3IucmVnaXN0ZXJJbnN0YW5jZSgnc3RvcmUnLCBzdG9yZSk7XG5cdH0pO1xuXG5cdGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG5cdFx0bG9jYXRvci5yZWdpc3Rlckluc3RhbmNlKCdjb21wb25lbnQnLCBjb21wb25lbnQpO1xuXHR9KTtcbn07XG5cbi8qKlxuICogV3JhcHMgZXZlbnQgYnVzIHdpdGggbG9nIG1lc3NhZ2VzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBBcHBsaWNhdGlvbiBjb25maWcuXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZXZlbnRCdXMgRXZlbnQgZW1pdHRlciB0aGF0IGltcGxlbWVudHMgZXZlbnQgYnVzLlxuICogQHBhcmFtIHtMb2dnZXJ9IGxvZ2dlciBMb2dnZXIgdG8gd3JpdGUgbWVzc2FnZXMuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkJvb3RzdHJhcHBlci5wcm90b3R5cGUuX3dyYXBFdmVudHNXaXRoTG9nZ2VyID1cblx0ZnVuY3Rpb24gKGNvbmZpZywgZXZlbnRCdXMsIGxvZ2dlcikge1xuXHRcdEJvb3RzdHJhcHBlckJhc2UucHJvdG90eXBlLl93cmFwRXZlbnRzV2l0aExvZ2dlclxuXHRcdFx0LmNhbGwodGhpcywgY29uZmlnLCBldmVudEJ1cywgbG9nZ2VyKTtcblxuXHRcdHZhciBpc1JlbGVhc2UgPSBCb29sZWFuKGNvbmZpZy5pc1JlbGVhc2UpO1xuXHRcdGlmIChpc1JlbGVhc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZXZlbnRCdXNcblx0XHRcdC5vbignZG9jdW1lbnRVcGRhdGVkJywgZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKHV0aWwuZm9ybWF0KERFQlVHX0RPQ1VNRU5UX1VQREFURUQsIGFyZ3MubGVuZ3RoKSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdjb21wb25lbnRCb3VuZCcsIGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyh1dGlsLmZvcm1hdChcblx0XHRcdFx0XHRERUJVR19DT01QT05FTlRfQk9VTkQsXG5cdFx0XHRcdFx0YXJncy5lbGVtZW50LnRhZ05hbWUgKyAoYXJncy5pZCA/ICcjJyArIGFyZ3MuaWQgOiAnJylcblx0XHRcdFx0KSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdjb21wb25lbnRVbmJvdW5kJywgZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKHV0aWwuZm9ybWF0KFxuXHRcdFx0XHRcdERFQlVHX0NPTVBPTkVOVF9VTkJPVU5ELFxuXHRcdFx0XHRcdGFyZ3MuZWxlbWVudC50YWdOYW1lICsgKGFyZ3MuaWQgPyAnIycgKyBhcmdzLmlkIDogJycpXG5cdFx0XHRcdCkpO1xuXHRcdFx0fSk7XG5cdH07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEJvb3RzdHJhcHBlcigpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNhdGJlcnJ5ID0gcmVxdWlyZSgnY2F0YmVycnknKSxcbi8vIHRoaXMgY29uZmlnIHdpbGwgYmUgcmVwbGFjZWQgYnkgYC4vY29uZmlnL2Jyb3dzZXIuanNvbmAgd2hlbiBidWlsZGluZ1xuLy8gYmVjYXVzZSBvZiBgYnJvd3NlcmAgZmllbGQgaW4gYHBhY2thZ2UuanNvbmBcbiAgICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZy9lbnZpcm9ubWVudC5qc29uJyksXG4gICAgdGVtcGxhdGVFbmdpbmUgPSByZXF1aXJlKCcuL3NwZWNpYWxfbW9kdWxlcy9jYXRiZXJyeS1oYW5kbGViYXJzJyksXG4gICAgaGVscGVycyA9IHJlcXVpcmUoJy4vc3BlY2lhbF9tb2R1bGVzL2NhdGJlcnJ5LWhhbmRsZWJhcnMtaGVscGVycycpLFxuICAgIGNhdCA9IGNhdGJlcnJ5LmNyZWF0ZShjb25maWcpO1xuXG4vLyByZWdpc3RlciB0ZW1wbGF0ZSBwcm92aWRlciB0byBDYXRiZXJyeSBTZXJ2aWNlIExvY2F0b3JcbnRlbXBsYXRlRW5naW5lLnJlZ2lzdGVyKGNhdC5sb2NhdG9yKTtcbmhlbHBlcnMucmVnaXN0ZXIoY2F0LmxvY2F0b3IpXG5cbmNhdC5zdGFydFdoZW5SZWFkeSgpO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tbW9uSDE7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwiY29tbW9uLWgxXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbW1vbkgxKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuQ29tbW9uSDEucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dC5hdHRyaWJ1dGVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5Db21tb25IMS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5Db21tb25IMS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbW1vblBhZ2luYXRvcjtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJjb21tb24tcGFnaW5hdG9yXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbW1vblBhZ2luYXRvcigpIHtcbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5Db21tb25QYWdpbmF0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1vZGVsID0gdGhpcy4kY29udGV4dC5hdHRyaWJ1dGVzLm1vZGVsO1xuICAgIGlmICghbW9kZWwpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImlzLXBhZ2luYXRvclwiOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuc2VuZEFjdGlvbihcInNldE1vZGVsXCIsIG1vZGVsKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi4kY29udGV4dC5nZXRTdG9yZURhdGEoKTtcbiAgICAgICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbkNvbW1vblBhZ2luYXRvci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGljazoge1xuICAgICAgICAgICAgJy5wYWdpbmF0b3JfX251bWJlcic6IHRoaXMuX2hhbmRsZUNsaWNrXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cbkNvbW1vblBhZ2luYXRvci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuQ29tbW9uUGFnaW5hdG9yLnByb3RvdHlwZS5faGFuZGxlQ2xpY2sgPSBmdW5jdGlvbigpe1xuICAgIHdpbmRvdy5zY3JvbGxUbygwLDApO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQnJlYWRjcnVtcHM7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwiYnJlYWRjcnVtcHNcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnJlYWRjcnVtcHMoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5CcmVhZGNydW1wcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5CcmVhZGNydW1wcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGljazoge1xuICAgICAgICAgICAgJy5qcy1wYXJlbnQtcnViJzogdGhpcy5fY2xpY2tIYW5kbGVyLFxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5CcmVhZGNydW1wcy5wcm90b3R5cGUuX2NsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAvL3ZhciBlbCA9IG9iai50YXJnZXQ7XG4gICAgdmFyIHBvcyA9ICQoJy5qcy1wYXJlbnQtcnViJykucG9zaXRpb24oKS5sZWZ0ICsgJCgnLmpzLXBhcmVudC1ydWInKS53aWR0aCgpO1xuICAgICQoJy5qcy1icmVhZGNydW1icy1saXN0JykuY3NzKCdsZWZ0JywgcG9zKS50b2dnbGUoKTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cbkJyZWFkY3J1bXBzLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9wQ2F0YWxvZ3M7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwiZG9wLWNhdGFsb2dzXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERvcENhdGFsb2dzKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuRG9wQ2F0YWxvZ3MucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB7XG4gICAgICAgICdkYXRhLW1vZCc6IHRoaXMuJGNvbnRleHQuYXR0cmlidXRlc1snZGF0YS1tb2QnXSxcbiAgICAgICAgY2F0YWxvZ3M6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1cmw6IFwiL3NhbGVcIixcbiAgICAgICAgICAgICAgICBpY286IFwiZ2lmdFwiLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcItCf0L7QuNGB0Log0L/QviDRgdC60LjQtNC60LVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1cmw6IFwiL3ZpZGVvXCIsXG4gICAgICAgICAgICAgICAgaWNvOiBcInZpZGVvXCIsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwi0J/QvtC40YHQuiDQv9C+INCy0LjQtNC10L5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1cmw6IFwiL3NvdmV0eVwiLFxuICAgICAgICAgICAgICAgIGljbzogXCJxd2VzdGlvblwiLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcItCh0LXQutGA0LXRgtGLINCc0LDRgdGC0LXRgNC+0LJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1cmw6IFwiL2NvbXBhbnlcIixcbiAgICAgICAgICAgICAgICBpY286IFwiY2FzZVwiLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcItCa0LDRgtCw0LvQvtCzINGE0LjRgNC8XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbkRvcENhdGFsb2dzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cbkRvcENhdGFsb2dzLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnQ7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwiZG9jdW1lbnRcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRG9jdW1lbnQoKSB7IH1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcImhlYWRcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGVhZCgpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cbkhlYWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKCk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcImxvYWRlclwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMb2FkZXIoKSB7IH1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hc3RlckJsb2NrQWJvdXQ7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwibWFzdGVyLWJsb2NrLWFib3V0XCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hc3RlckJsb2NrQWJvdXQoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5NYXN0ZXJCbG9ja0Fib3V0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuJGNvbnRleHQuYXR0cmlidXRlc1snbWFzdGVyLXBhZ2UnXSkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY29udGV4dC5nZXRTdG9yZURhdGEoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmFib3V0RWR1YyA9IGRhdGEuYWJvdXRFZHVjLnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIik7XG4gICAgICAgICAgICAgICAgZGF0YS5hYm91dEV4cCA9IGRhdGEuYWJvdXRFeHAucmVwbGFjZSgvXFxuL2csIFwiPGJyPlwiKTtcbiAgICAgICAgICAgICAgICBkYXRhLmFib3V0QWRkSW5mbyA9IGRhdGEuYWJvdXRBZGRJbmZvLnJlcGxhY2UoL1xcbi9nLCBcIjxicj5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvdXRFZHVjOiBkYXRhLmFib3V0RWR1YyxcbiAgICAgICAgICAgICAgICAgICAgYWJvdXRFeHA6IGRhdGEuYWJvdXRFeHAsXG4gICAgICAgICAgICAgICAgICAgIGFib3V0QWRkSW5mbzogZGF0YS5hYm91dEFkZEluZm9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbk1hc3RlckJsb2NrQWJvdXQucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuTWFzdGVyQmxvY2tBYm91dC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hc3RlckJsb2NrQXJ0aWNsZTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJtYXN0ZXItYmxvY2stYXJ0aWNsZVwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYXN0ZXJCbG9ja0FydGljbGUoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5NYXN0ZXJCbG9ja0FydGljbGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy4kY29udGV4dC5hdHRyaWJ1dGVzWydtYXN0ZXItcGFnZSddKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEuYXJ0aWNsZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmF1dGhvciA9IGRhdGEubmFtZTsgLy/QtNC+0LHQsNCy0LvRj9C10Lwg0LDQstGC0L7RgNCwINC00LvRjyDQutCw0LbQtNC+0Lkg0YHRgtCw0YLRjNC4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhLmFydGljbGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhcnRpY2xlczogZGF0YS5hcnRpY2xlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuTWFzdGVyQmxvY2tBcnRpY2xlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cbk1hc3RlckJsb2NrQXJ0aWNsZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hc3RlckJsb2NrTGluaztcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJtYXN0ZXItYmxvY2stbGlua1wiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYXN0ZXJCbG9ja0xpbmsoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5NYXN0ZXJCbG9ja0xpbmsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy4kY29udGV4dC5hdHRyaWJ1dGVzWydtYXN0ZXItcGFnZSddKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YS5jb250YWN0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdHM6IGRhdGEuY29udGFjdHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbk1hc3RlckJsb2NrTGluay5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5NYXN0ZXJCbG9ja0xpbmsucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNYXN0ZXJCbG9ja1Bob3RvO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm1hc3Rlci1ibG9jay1waG90b1wiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYXN0ZXJCbG9ja1Bob3RvKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuTWFzdGVyQmxvY2tQaG90by5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLiRjb250ZXh0LmF0dHJpYnV0ZXNbJ21hc3Rlci1wYWdlJ10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhLmFsYnVtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWxidW1zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiAxOTkxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3duZXJUeXBlXCI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvd25lcklEXCI6IDEwMTksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwi0JDQu9GM0LHQvtC8IOKEljFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0YXR1c1wiOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGhvdG9zXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiA2Mzg1MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWxidW1JRFwiOiAxOTkxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbWdJRFwiOiBcIjU2OTM0NTg2MjMwNDFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IDYzODU0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbGJ1bUlEXCI6IDE5OTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImltZ0lEXCI6IFwiNTY5MzQ1ODY4YmJiM1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogNjM4NTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFsYnVtSURcIjogMTk5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW1nSURcIjogXCI1NjkzNDU4NzAxMzY3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiA2Mzg1NixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWxidW1JRFwiOiAxOTkxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbWdJRFwiOiBcIjU2OTM0NTg3NzE4NDBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IDYzODU3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbGJ1bUlEXCI6IDE5OTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImltZ0lEXCI6IFwiNTY5MzQ1ODdkOGUwNVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogNjM4NTgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFsYnVtSURcIjogMTk5MSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW1nSURcIjogXCI1NjkzNDU4ODQ1ZWI0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiA2Mzg1OSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWxidW1JRFwiOiAxOTkxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbWdJRFwiOiBcIjU2OTM0NTg4YWY3NjZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IDE5OTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvd25lclR5cGVcIjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm93bmVySURcIjogMTA1OCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCLQodC10YDRgtC40YTQuNC60LDRgtGLXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdGF0dXNcIjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBob3Rvc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogNjQwNjgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFsYnVtSURcIjogMTk5MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW1nSURcIjogXCI1NjkzNDViYTIwZGM5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiA2NDA2OSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWxidW1JRFwiOiAxOTkzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbWdJRFwiOiBcIjU2OTM0NWJhODBmODRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IDY0MDcwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbGJ1bUlEXCI6IDE5OTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImltZ0lEXCI6IFwiNTY5MzQ1YmFlYjRkOVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogNjQwNzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFsYnVtSURcIjogMTk5MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW1nSURcIjogXCI1NjkzNDViYjVmOTJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiA2NDA3MixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWxidW1JRFwiOiAxOTkzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbWdJRFwiOiBcIjU2OTM0NWJjNmFlZThcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IDg4MzMyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhbGJ1bUlEXCI6IDE5OTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImltZ0lEXCI6IFwiNTY5MzUwM2U2MTI4NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogODgzMzMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFsYnVtSURcIjogMTk5MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW1nSURcIjogXCI1NjkzNTAzZWM1Mzc3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiAxMTk3NjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFsYnVtSURcIjogMTk5MyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW1nSURcIjogXCI1NjkzNmUwODQ5YWU5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuTWFzdGVyQmxvY2tQaG90by5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWxidW0gPSAkKCcucGhvdG8tbWRfX2FsYnVtLWNvdmVyJyk7XG4gICAgdmFyIGFsYnVtQ29udCA9ICQoJy5waG90by1tZF9fYWxidW0tY29udCcpO1xuICAgIHZhciBhbGJ1bVBob3RvcyA9ICQoJy5waG90by1tZF9faW1nLXByZXYnKTtcbiAgICBhbGJ1bS5iaW5kKCdjbGljaycsIHNob3dBbGJ1bSk7XG4gICAgYWxidW1QaG90b3MuYmluZCgnY2xpY2snLCBzaG93QWxidW1JbWcpO1xuICAgIGFsYnVtLmZpcnN0KCkuYWRkQ2xhc3MoJ2FjdCcpO1xuXG4gICAgZnVuY3Rpb24gc2hvd0FsYnVtKCkge1xuICAgICAgICBhbGJ1bUNvbnQuaGlkZSgpO1xuICAgICAgICBhbGJ1bS5yZW1vdmVDbGFzcygnYWN0Jyk7XG4gICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2FjdCcpO1xuICAgICAgICAkKCcjY29udC0nICsgKCQodGhpcykuYXR0cignaWQnKSkpLnNob3coKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dBbGJ1bUltZygpIHtcbiAgICAgICAgJC5mYW5jeWJveChhbGJ1bVBob3Rvcywge1xuICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgIGluZGV4IDogYWxidW1QaG90b3MuaW5kZXgodGhpcyksXG4gICAgICAgICAgICBoZWxwZXJzOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheToge1xuICAgICAgICAgICAgICAgICAgICBsb2NrZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuTWFzdGVyQmxvY2tQaG90by5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhbGJ1bSA9ICQoJy5waG90by1tZF9fYWxidW0tY292ZXInKTtcbiAgICB2YXIgYWxidW1QaG90b3MgPSAkKCcucGhvdG8tbWRfX2ltZy1wcmV2Jyk7XG5cbiAgICBhbGJ1bS51bmJpbmQoJ2NsaWNrJyk7XG4gICAgYWxidW1QaG90b3MudW5iaW5kKCdjbGljaycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNYXN0ZXJCbG9ja1JldmlldztcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJtYXN0ZXItYmxvY2stcmV2aWV3XCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hc3RlckJsb2NrUmV2aWV3KCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuTWFzdGVyQmxvY2tSZXZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy4kY29udGV4dC5hdHRyaWJ1dGVzWydtYXN0ZXItcGFnZSddKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmtMaWtlcy5kYXRhID0gSlNPTi5wYXJzZShkYXRhLnZrTGlrZXMuZGF0YSk7XG4gICAgICAgICAgICAgICAgZGF0YS52a0xpa2VzLmRhdGEubGVuZ3RoID0gOTsgLy/Rg9C60L7RgNCw0YfQuNCy0LDQtdC8INC80LDRgdGB0LjQsiDQtNC+IDkg0Y3Qu9C10LzQtdC90YLQvtCyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhLmNvbW1lbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50czogZGF0YS5jb21tZW50cy5yZXZlcnNlKCksXG4gICAgICAgICAgICAgICAgICAgIHZrTGlrZXM6IGRhdGEudmtMaWtlcyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbWdJRDogZGF0YS5pbWdJRFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuTWFzdGVyQmxvY2tSZXZpZXcucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuTWFzdGVyQmxvY2tSZXZpZXcucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNYXN0ZXJCbG9ja1NhbGU7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwibWFzdGVyLWJsb2NrLXNhbGVcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWFzdGVyQmxvY2tTYWxlKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuTWFzdGVyQmxvY2tTYWxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuJGNvbnRleHQuYXR0cmlidXRlc1snbWFzdGVyLXBhZ2UnXSkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY29udGV4dC5nZXRTdG9yZURhdGEoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEuc2FsZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNhbGVzOiBkYXRhLnNhbGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5NYXN0ZXJCbG9ja1NhbGUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNhbGUgPSAkKCcuc2FsZScpO1xuICAgIHNhbGUuZmluZCgnYScpLmJpbmQoJ2NsaWNrJywgc2hvd1NhbGVQb3B1cCk7XG5cbiAgICBmdW5jdGlvbiBzaG93U2FsZVBvcHVwKCkge1xuICAgICAgICB2YXIgdG1wID0gJCh0aGlzKS5wYXJlbnQoKS5jbG9uZSgpO1xuICAgICAgICB0bXAuYWRkQ2xhc3MoJ3BvcHVwJyk7XG4gICAgICAgICQuZmFuY3lib3gub3Blbih0bXAsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBoZWxwZXJzOiB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheToge1xuICAgICAgICAgICAgICAgICAgICBsb2NrZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuTWFzdGVyQmxvY2tTYWxlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFzdGVyQmxvY2tTZXJ2aWNlO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm1hc3Rlci1ibG9jay1zZXJ2aWNlXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hc3RlckJsb2NrU2VydmljZSgpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cbk1hc3RlckJsb2NrU2VydmljZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLiRjb250ZXh0LmF0dHJpYnV0ZXNbJ21hc3Rlci1wYWdlJ10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgICAgICBkYXRhLnNlcnZpY2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAn0K3QutGB0L/QtdGA0YIg0L/QviDRgNCw0LfQstC40YLQuNGOICjQutC+0LzRhNC+0YDRgtC90YvRhSwg0L3QsNC00LXQttC90YvRhSwg0LHQu9Cw0LPQvtC/0L7Qu9GD0YfQvdGL0YUsINC00L7QstC10YDQuNGC0LXQu9GM0L3Ri9GFKSDRgdC10LzQtdC50L3Ri9GFINC+0YLQvdC+0YjQtdC90LjQuScsXG4gICAgICAgICAgICAgICAgICAgICfQn9GB0LjRhdC+0LvQvtCz0LjRh9C10YHQutC+0LUg0YHQvtC/0YDQvtCy0L7QttC00LXQvdC40LUg0YHQtdC80YzQuCDQvtGCINCX0JDQk9Ch0LAg0Lgg0L/QviDQttC40LfQvdC4JyxcbiAgICAgICAgICAgICAgICAgICAgJ9Cf0YHQuNGF0L7Qu9C+0LPQuNGPINGB0LXQvNC10LnQvdGL0YUg0L7RgtC90L7RiNC10L3QuNC5JyxcbiAgICAgICAgICAgICAgICAgICAgJ9Cf0YHQuNGF0L7RgtC10YDQsNC/0LjRjyAo0LjQvdC00LjQstC40LTRg9Cw0LvRjNC90LDRjyDQuCDQs9GA0YPQv9C/0L7QstCw0Y8pJyxcbiAgICAgICAgICAgICAgICAgICAgJ9Cb0LjRh9C90YvQtSDQv9GA0L7QsdC70LXQvNGLIOKAkyDQsdC10YHQv9C+0LrQvtC50YHRgtCy0LAg0Lgg0YHRgtGA0LDRhdC4LCDQvdC10YPQstC10YDQtdC90L3QvtGB0YLRjCDQsiDRgdC10LHQtSwg0LTQtdC/0YDQtdGB0YHQuNGPJyxcbiAgICAgICAgICAgICAgICAgICAgJ9Ce0LTQuNC90L7Rh9C10YHRgtCy0L4sINC90LUg0YHQutC70LDQtNGL0LLQsNC10YLRgdGPINC70LjRh9C90LDRjyDQttC40LfQvdGMJyxcbiAgICAgICAgICAgICAgICAgICAgJ9Cf0YDQvtCx0LvQtdC80Ysg0LIg0L7QsdGJ0LXQvdC40Lgg4oCTINGB0LvQvtC20L3QvtGB0YLQuCDQstC+INCy0LfQsNC40LzQvtC+0YLQvdC+0YjQtdC90LjRj9GFLCDQvdC10L/QvtC90LjQvNCw0L3QuNC1JyxcbiAgICAgICAgICAgICAgICAgICAgJ9Cf0YHQuNGF0L7RgdC+0LzQsNGC0LjRh9C10YHQutC40LUg0YDQsNGB0YHRgtGA0L7QudGB0YLQstCwINGDINC00LXRgtC10Lkg0Lgg0LLQt9GA0L7RgdC70YvRhScsXG4gICAgICAgICAgICAgICAgICAgICfQl9Cw0LLQuNGB0LjQvNC+0YHRgtGMICjQsNC70LrQvtCz0L7Qu9GM0L3QsNGPLCDQvdC40LrQvtGC0LjQvdC+0LLQsNGPLCDQuNCz0YDQvtCy0LDRjyDQuCDRgi7QtC4pJyxcbiAgICAgICAgICAgICAgICAgICAgJ9Cf0L7QstGL0YjQtdC90L3QsNGPINC60L7QvdGE0LvQuNC60YLQvdC+0YHRgtGMLCDQutC+0L3RhNC70LjQutGC0Ysg0L3QsCDRgNCw0LHQvtGC0LUg0Lgg0L3QtSDRgtC+0LvRjNC60L4nLFxuICAgICAgICAgICAgICAgICAgICAn0J/RgdC40YXQvtC70L7Qs9C40Y8g0LTQtdGC0YHQutC+LdGA0L7QtNC40YLQtdC70YzRgdC60LjRhSDQvtGC0L3QvtGI0LXQvdC40LknLFxuICAgICAgICAgICAgICAgICAgICAn0J/RgdC40YXQvtC00LjQsNCz0L3QvtGB0YLQuNC60LAnLFxuICAgICAgICAgICAgICAgICAgICAn0KTQuNC90LDQvdGB0L7QstC+0LUg0LHQu9Cw0LPQvtC/0L7Qu9GD0YfQuNC1INGB0LXQvNGM0Lgg4oCTINC00LXQvdGM0LPQuCDQuCDRgdC10LzQtdC50L3Ri9C1INC60L7QvdGE0LvQuNC60YLRiywg0LzQvtC4INCy0LfQsNC40LzQvtC+0YLQvdC+0YjQtdC90LjRjyDRgSDQtNC10L3RjNCz0LDQvNC4LCDRgNCw0LfQstC40YLQuNC1INGE0LjQvdCw0L3RgdC+0LLQvtC5INCz0YDQsNC80L7RgtC90L7RgdGC0LgsINGE0LjQvdCw0L3RgdC+0LLRi9C5INC00LjQsNCz0L3QvtC3JyxcbiAgICAgICAgICAgICAgICAgICAgJ9Ce0YDQs9Cw0L3QuNC30LDRhtC40L7QvdC90LDRjyDQv9GB0LjRhdC+0LvQvtCz0LjRjyDQuCDQsdC40LfQvdC10YEt0YLRgNC10L3QuNC90LPQuCcsXG4gICAgICAgICAgICAgICAgICAgICfQktC+0L/RgNC+0YHRiyDQstC+0YHQv9C40YLQsNC90LjRjyDQuCDRgNCw0LfQstC40YLQuNGPJyxcbiAgICAgICAgICAgICAgICAgICAgJ9Cf0YHQuNGF0L7Qu9C+0LPQuNGH0LXRgdC60L7QtSDQutC+0L3RgdGD0LvRjNGC0LjRgNC+0LLQsNC90LjQtScsXG4gICAgICAgICAgICAgICAgICAgICfQmNC90LTQuNCy0LjQtNGD0LDQu9GM0L3QsNGPINC/0YHQuNGF0L7RgtC10YDQsNC/0LjRjycsXG4gICAgICAgICAgICAgICAgICAgICfQk9GA0YPQv9C/0L7QstCw0Y8g0L/RgdC40YXQvtGC0LXRgNCw0L/QuNGPJyxcbiAgICAgICAgICAgICAgICAgICAgJ9CU0LXRgtGB0LrQvi3RgNC+0LTQuNGC0LXQu9GM0YHQutC40LUg0L7RgtC90L7RiNC10L3QuNGPJyxcbiAgICAgICAgICAgICAgICAgICAgJ9Cf0YDQvtCx0LvQtdC80Ysg0YHQtdC80LXQudC90YvRhSDQvtGC0L3QvtGI0LXQvdC40LknLFxuICAgICAgICAgICAgICAgICAgICAn0J/RgNC+0LHQu9C10LzRiyDQstC30LDQuNC80L7QvtGC0L3QvtGI0LXQvdC40LknLFxuICAgICAgICAgICAgICAgICAgICAn0JvQuNGH0L3QvtGB0YLQvdGL0LUg0L/RgNC+0LHQu9C10LzRiycsXG4gICAgICAgICAgICAgICAgICAgICfQn9GB0LjRhdC+0YHQvtC80LDRgtC40YfQtdGB0LrQuNC1INGA0LDRgdGB0YLRgNC+0LnRgdGC0LLQsCcsXG4gICAgICAgICAgICAgICAgICAgICfQrdC60LfQuNGB0YLQtdC90YbQuNCw0LvRjNC90YvQtSDQstC+0L/RgNC+0YHRiycsXG4gICAgICAgICAgICAgICAgICAgICfQoNCw0LHQvtGC0LAg0YHQviDRgdC90LDQvNC4INC4INC80LjRhNCw0LzQuCdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZHNWYWxTdW0gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZHNWYWxIYWxmU3VtID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgcGFydDEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcGFydDIgPSBbXTtcblxuICAgICAgICAgICAgICAgIGRhdGEuc2VydmljZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdmFyIGZpZWxkc1ZhbEhhbGZTdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGRzVmFsTGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkc1ZhbExlbmd0aCA9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRzVmFsTGVuZ3RoIDwgMzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkc1ZhbExlbmd0aCA9IDMwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkc1ZhbFN1bSArPSBmaWVsZHNWYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGF0YS5zZXJ2aWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkc1ZhbExlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmaWVsZHNWYWxMZW5ndGggPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkc1ZhbEhhbGZTdW0gPCBmaWVsZHNWYWxTdW0gLyAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0MS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydDIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaWVsZHNWYWxIYWxmU3VtICs9IGZpZWxkc1ZhbExlbmd0aDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkYXRhLnNlcnZpY2VzID0gW107XG4gICAgICAgICAgICAgICAgZGF0YS5zZXJ2aWNlcy5wYXJ0MSA9IHBhcnQxO1xuICAgICAgICAgICAgICAgIGRhdGEuc2VydmljZXMucGFydDIgPSBwYXJ0MjtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEuc2VydmljZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZpY2VzOiBkYXRhLnNlcnZpY2VzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5NYXN0ZXJCbG9ja1NlcnZpY2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuTWFzdGVyQmxvY2tTZXJ2aWNlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFzdGVyQmxvY2tWaWRlbztcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJtYXN0ZXItYmxvY2stdmlkZW9cIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWFzdGVyQmxvY2tWaWRlbygpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cbk1hc3RlckJsb2NrVmlkZW8ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy4kY29udGV4dC5hdHRyaWJ1dGVzWydtYXN0ZXItcGFnZSddKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YS52aWRlb3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvczogZGF0YS52aWRlb3NcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbk1hc3RlckJsb2NrVmlkZW8ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpZGVvID0gJCgnLnZpZGVvLW1kX192aWRlby1jb3ZlcicpO1xuICAgIHZpZGVvLmJpbmQoJ2NsaWNrJywgc2hvd1ZpZGVvKTtcblxuICAgIGZ1bmN0aW9uIHNob3dWaWRlbygpIHtcbiAgICAgICAgJC5mYW5jeWJveC5vcGVuKHRoaXMsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICB0eXBlOiAnaWZyYW1lJyxcbiAgICAgICAgICAgIGhlbHBlcnM6IHtcbiAgICAgICAgICAgICAgICBvdmVybGF5OiB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2tlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5NYXN0ZXJCbG9ja1ZpZGVvLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCgnLnZpZGVvLW1kX192aWRlby1jb3ZlcicpLnVuYmluZCgnY2xpY2snKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFzdGVyQmxvY2tXb3JrO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm1hc3Rlci1ibG9jay13b3JrXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hc3RlckJsb2NrV29yaygpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cbk1hc3RlckJsb2NrV29yay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLiRjb250ZXh0LmF0dHJpYnV0ZXNbJ21hc3Rlci1wYWdlJ10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBBcnIgPSBuZXcgQXJyYXkoNyk7XG4gICAgICAgICAgICAgICAgZGF0YS5zY2hlZHVsZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ub3BlbiA9IGl0ZW0ub3Blbi5zdWJzdHIoMCwgNSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2xvc2UgPSBpdGVtLmNsb3NlLnN1YnN0cigwLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcEFycltpdGVtLmRheSAtIDFdID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkYXRhLnNjaGVkdWxlID0gdGVtcEFycjtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZTogZGF0YS5zY2hlZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdHJpY3Q6IGRhdGEuZGlzdHJpY3RzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrQ29uZGl0aW9uOiBkYXRhLndvcmtDb25kaXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbk1hc3RlckJsb2NrV29yay5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5NYXN0ZXJCbG9ja1dvcmsucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gTWFzdGVyRmlsdGVyO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm1hc3Rlci1maWx0ZXJcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWFzdGVyRmlsdGVyKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuTWFzdGVyRmlsdGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwYXRoLCBjdXJyZW50VGFnO1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBwYXRoID0gJy8nICsgZGF0YS5ydWJyaWthLnBhcmVudC51bmlxdWUgKyAnLycgKyBkYXRhLnJ1YnJpa2EudW5pcXVlO1xuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi4kY29udGV4dC5nZXRTdG9yZURhdGEoJ21hc3Rlci9NYXN0ZXJMaXN0JylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobWFzdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhtYXN0ZXIpLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25OYW1lOiBcIm1hc3RlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcItCc0LDRgdGC0LXRgNCwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvOiBcIm1hblwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKCdtYXN0ZXIvTWFzdGVyVmlkZW8nKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKE9iamVjdC5rZXlzKG1hc3RlcikubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXRoICsgJy92aWRlbycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uTmFtZTogXCJ2aWRlb1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwi0JLQuNC00LXQviDQnNCw0YHRgtC10YDQvtCyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY286IFwidmlkZW9cIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gc2VsZi4kY29udGV4dC5nZXRTdG9yZURhdGEoJ21hc3Rlci9NYXN0ZXJWaWRlbycpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc2FsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoT2JqZWN0LmtleXMobWFzdGVyKS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHBhdGggKyAnL3NhbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbk5hbWU6IFwic2FsZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwi0KHQutC40LTQutC4INCc0LDRgdGC0LXRgNC+0LJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGljbzogXCJnaWZ0XCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuIHNlbGYuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKCdtYXN0ZXIvTWFzdGVyVmlkZW8nKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNlY3JldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiAoT2JqZWN0LmtleXMobWFzdGVyKS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHBhdGggKyAnL3NvdmV0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uTmFtZTogXCJzb3ZldHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcItCh0LXQutGA0LXRgtGLINCc0LDRgdGC0LXRgNC+0LJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGljbzogXCJxd2VzdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBzZWxmLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnbWFzdGVyL01hc3RlclZpZGVvJylcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjb21wYW55KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYgKE9iamVjdC5rZXlzKG1hc3RlcikubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBwYXRoICsgJy9jb21wYW55JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25OYW1lOiBcImNvbXBhbnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcItCa0LDRgtCw0LvQvtCzINGE0LjRgNC8XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpY286IFwiY2FzZVwiXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kZWNvcmVPcGVuU2VjdGlvbihyZXN1bHQsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2ZpbHRlclNlY3Rpb246IHJlc3VsdH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG59O1xuLyoqXG4gKiDQlNC10LrQsNGA0LjRgNC+0LLQsNC90LjQtSDQvtGC0LrRgNGL0YLQvtC5INGB0LXQutGG0LjQuCAo0LTQvtCx0LDQstC70LXQvdC40LUg0YLQtdCz0L7Qsiwg0L7RgNGC0LjRgNC+0LLQutC4KVxuICogQHBhcmFtIHJlc3VsdCDQvNCw0YHRgdC40LIg0LTQu9GPINC00LXQutC+0YDQuNGA0L7QstCw0L3QuNGPXG4gKiBAcGFyYW0gcnVicmlrYSDRgNGD0LHRgNC40LrQsCDQuNC3INGB0YLQvtGA0LBcbiAqIEBwcml2YXRlXG4gKi9cbk1hc3RlckZpbHRlci5wcm90b3R5cGUuX2RlY29yZU9wZW5TZWN0aW9uID0gZnVuY3Rpb24gKHJlc3VsdCwgZGF0YSkge1xuICAgIHZhciBjdXJyZW50U2VjdGlvbiA9IGRhdGEuc2VjdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChyZXN1bHRbaV0uc2VjdGlvbk5hbWUgPT0gY3VycmVudFNlY3Rpb24pIHtcblxuICAgICAgICAgICAgdmFyIHRhZ3MgPSB0aGlzLl9nZXRUYWdzKGRhdGEpO1xuICAgICAgICAgICAgcmVzdWx0W2ldLm9wZW5TZWN0aW9uID0ge3RhZ3NHcm91cDogdGFnc307XG4gICAgICAgICAgICBpZiAoY3VycmVudFNlY3Rpb24gPT0gJ21hc3RlcnMnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldLm9wZW5TZWN0aW9uLnNvcnRCeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ1cmxcIjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtZXRob2RcIjogXCJnZXRcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqINCf0LXRgNC10YHRgtGA0L7QudC60LAg0YLQtdCz0L7QslxuICogQHBhcmFtIHRhZ3NKc29uINGC0Y3Qs9C4INC40LcganNvblxuICogQHBhcmFtIHBhdGgg0LDQsdGB0L7Qu9GO0YLQvdGL0Lkg0YDQvtC00LjRgtC10LvRjNGB0LrQuNC5INC/0YPRgtGMINC00LvRjyDRgdGB0YvQu9C+0Log0LIg0YLQtdCz0LDRhVxuICogQHBhcmFtIGN1cnJlbnRUYWcg0YLQtdC60YPRidC40Lkg0YLQtdCzINC00LvRjyDQstGL0LTQtdC70LXQvdC40Y9cbiAqIEByZXR1cm5zIHtBcnJheX0g0YLQtdCz0Lgg0YDQsNC30LHQuNGC0YvQtSDQv9C+INCz0YDRg9C/0L/QsNC8XG4gKiBAcHJpdmF0ZVxuICovXG5NYXN0ZXJGaWx0ZXIucHJvdG90eXBlLl9nZXRUYWdzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgcGF0aCA9ICcvJyArIGRhdGEucnVicmlrYS5wYXJlbnQudW5pcXVlICsgJy8nICsgZGF0YS5ydWJyaWthLnVuaXF1ZTtcbiAgICB2YXIgdGFnc0pzb24gPSBkYXRhLnJ1YnJpa2EudGFncztcbiAgICB2YXIgY3VycmVudFRhZyA9IGRhdGEudGFnLnVuaXF1ZSA7XG4gICAgdmFyIGN1cnJlbnRTZWN0aW9uID0gZGF0YS5zZWN0aW9uO1xuICAgIHZhciB0YWdzID0gW107XG5cbiAgICBPYmplY3Qua2V5cyh0YWdzSnNvbilcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSB0YWdzSnNvbltuXTtcbiAgICAgICAgICAgIHRhZy5pc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIXRhZ3NbdGFnLmdyb3VwXSlcbiAgICAgICAgICAgICAgICB0YWdzW3RhZy5ncm91cF0gPSBbXTtcblxuICAgICAgICAgICAgaWYgKHRhZy51bmlxdWUgPT0gY3VycmVudFRhZykge1xuICAgICAgICAgICAgICAgIHRhZy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGFnLnVybEJhY2sgPSBwYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWN0aW9uID09ICdtYXN0ZXInKSB7XG4gICAgICAgICAgICAgICAgdGFnLnBhdGggPSBwYXRoICsgJy8nICsgdGFnLnVuaXF1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFnLnBhdGggPSBwYXRoICsgJy8nICsgdGFnLnVuaXF1ZSArICcvJyArIGN1cnJlbnRTZWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YWdzW3RhZy5ncm91cF0ucHVzaCh0YWcpO1xuICAgICAgICB9KTtcblxuICAgIC8v0YHQvtGA0YLQuNGA0YPQtdC8XG4gICAgdmFyIHRhZ3NHcm91cCA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHRhZ3MpLnNvcnQoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGFnc0dyb3VwLnB1c2goe1xuICAgICAgICAgICAgdGl0bGU6IGtleSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3Nba2V5XVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFnc0dyb3VwO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5NYXN0ZXJGaWx0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xpY2s6IHtcbiAgICAgICAgICAgICcuanMtZmlsdGVyLXRvZ2dsZS1idG4uYWN0aXZlJzogdGhpcy5fY2xpY2tTZWN0aW9uXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NYXN0ZXJGaWx0ZXIucHJvdG90eXBlLl9jbGlja1NlY3Rpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGRvbSA9IG9iai50YXJnZXQ7XG4gICAgdmFyIGVsO1xuICAgIGlmICghKCQoZG9tKS5oYXNDbGFzcygnanMtZmlsdGVyLXRvZ2dsZS1idG4nKSAmJiAkKGRvbSkuaGFzQ2xhc3MoJ2FjdGl2ZScpKSlcbiAgICAgICAgZWwgPSAkKGRvbSkucGFyZW50cygnLmpzLWZpbHRlci10b2dnbGUtYnRuJyk7XG4gICAgZWxzZVxuICAgICAgICBlbCA9ICQoZG9tKTtcbiAgICBlbC5wYXJlbnQoKS5maW5kKCcuanMtZmlsdGVyLXRvZ2dsZS1zZWN0aW9uJykuc2xpZGVUb2dnbGUoKTtcbiAgICBlbC5maW5kKCcuZmlsdGVyLXNlY3Rpb25fX2Fycm93LWljb24nKS50b2dnbGVDbGFzcygnZG93bicpO1xufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5NYXN0ZXJGaWx0ZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNYXN0ZXJMaXN0O1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm1hc3Rlci1saXN0XCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hc3Rlckxpc3QoJHNlcnZpY2VMb2NhdG9yKSB7XG4vLyB3ZSBjYW4gdXNlIHdpbmRvdyBmcm9tIHRoZSBsb2NhdG9yIGluIGEgYnJvd3NlciBvbmx5XG4gICAgaWYgKHRoaXMuJGNvbnRleHQuaXNCcm93c2VyKSB7XG4gICAgICAgIHRoaXMuX3dpbmRvdyA9ICRzZXJ2aWNlTG9jYXRvci5yZXNvbHZlKCd3aW5kb3cnKTtcbiAgICAgICAgdGhpcy5faGFuZGxlU2Nyb2xsID0gdGhpcy5faGFuZGxlU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cbk1hc3Rlckxpc3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dC5nZXRTdG9yZURhdGEoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuTWFzdGVyTGlzdC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYWxsTWluaWNhcmRTZXJ2aWNlc0N1dCk7XG4gICAgdGhpcy5fd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2hhbmRsZVNjcm9sbCk7XG59O1xuXG5NYXN0ZXJMaXN0LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2FsbE1pbmljYXJkU2VydmljZXNDdXQpO1xuICAgIHRoaXMuX3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9oYW5kbGVTY3JvbGwpO1xuICAgIHRoaXMuJGNvbnRleHQuY29sbGVjdEdhcmJhZ2UoKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyB3aW5kb3cgc2Nyb2xsIGZvciBpbmZpbml0ZSBzY3JvbGwgbG9hZGluZy5cbiAqIEBwcml2YXRlXG4gKi9cbk1hc3Rlckxpc3QucHJvdG90eXBlLl9oYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3aW5kb3dIZWlnaHQgPSB0aGlzLl93aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgIHNjcm9sbFRvcCA9IHRoaXMuX3dpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgZG9jID0gdGhpcy5fd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHNjcm9sbCB0byB0aGUgYm90dG9tIG9mIHRoZSBwYWdlIGxvYWQgbW9yZSBpdGVtc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdGhpcy5faXNCdXN5ICYmXG4gICAgICAgICAgICAoc2Nyb2xsVG9wID49IChkb2Muc2Nyb2xsSGVpZ2h0IC0gd2luZG93SGVpZ2h0ICogMikgfHxcbiAgICAgICAgICAgIGRvYy5zY3JvbGxIZWlnaHQgPD0gd2luZG93SGVpZ2h0KVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuX2lzQnVzeSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzRmluaXNoKSB7XG4gICAgICAgICAgICAgICAgJCgnI3dhaXQtc3Bpbm5lcicpLnNob3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkTW9yZUl0ZW1zKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGZpbmlzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2lzRmluaXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2lzQnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnI3dhaXQtc3Bpbm5lcicpLmZhZGVPdXQoODAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59O1xuTWFzdGVyTGlzdC5wcm90b3R5cGUuX2lzQnVzeSA9IGZhbHNlO1xuTWFzdGVyTGlzdC5wcm90b3R5cGUuX2lzRmluaXNoID0gZmFsc2U7XG4vKipcbiAqIExvYWRzIG1vcmUgaXRlbXMgdG8gZmVlZC5cbiAqIEBwcml2YXRlXG4gKi9cbk1hc3Rlckxpc3QucHJvdG90eXBlLl9sb2FkTW9yZUl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LnNlbmRBY3Rpb24oJ2dldE5leHRQYWdlJyk7XG59O1xuXG5NYXN0ZXJMaXN0LnByb3RvdHlwZS5fYWxsTWluaWNhcmRTZXJ2aWNlc0N1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKCcubWFzdGVyLW1pbmljYXJkJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtaW5pY2FyZFNlcnZpY2VzID0gJCh0aGlzKS5maW5kKCcubWFzdGVyLW1pbmljYXJkX19zZXJ2aWNlcycpO1xuICAgICAgICB2YXIgc2VydmljZXNMaXN0ID0gbWluaWNhcmRTZXJ2aWNlcy5maW5kKCdsaScpO1xuICAgICAgICB2YXIgbWF4SGVpZ2h0ID1cbiAgICAgICAgICAgICQodGhpcykuaGVpZ2h0KCkgLSAoJCh0aGlzKS5maW5kKCcubWFzdGVyLW1pbmljYXJkX19uYW1lJykuaGVpZ2h0KCkgKyAkKHRoaXMpLmZpbmQoJy5tYXN0ZXItbWluaWNhcmRfX3NwZWMnKS5oZWlnaHQoKSk7XG4gICAgICAgIHZhciBzZXJ2aWNlc0NvdW50ID0gbWluaWNhcmRTZXJ2aWNlcy5maW5kKCdsaScpLmxlbmd0aDtcblxuICAgICAgICBpZiAobWluaWNhcmRTZXJ2aWNlcy5oZWlnaHQoKSA+IG1heEhlaWdodCkge1xuICAgICAgICAgICAgd2hpbGUgKG1pbmljYXJkU2VydmljZXMuaGVpZ2h0KCkgPiBtYXhIZWlnaHQgJiYgc2VydmljZXNDb3VudCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgJChzZXJ2aWNlc0xpc3Rbc2VydmljZXNDb3VudCAtIDFdKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgc2VydmljZXNDb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChtaW5pY2FyZFNlcnZpY2VzLmhlaWdodCgpICsgMTApIDwgbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAobWluaWNhcmRTZXJ2aWNlcy5oZWlnaHQoKSA8IG1heEhlaWdodCAmJiBpIDwgc2VydmljZXNDb3VudCArIDEpIHtcbiAgICAgICAgICAgICAgICAkKHNlcnZpY2VzTGlzdFtpXSkuc2hvdygpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaW5pY2FyZFNlcnZpY2VzLmhlaWdodCgpID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgJChzZXJ2aWNlc0xpc3RbaSAtIDFdKS5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNYXN0ZXJNaW5pY2FyZDtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJtYXN0ZXItbWluaWNhcmRcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWFzdGVyTWluaWNhcmQoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5NYXN0ZXJNaW5pY2FyZC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dC5nZXRTdG9yZURhdGEoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBtYXN0ZXJJRCA9IHNlbGYuJGNvbnRleHQuYXR0cmlidXRlc1snbWFzdGVyLWlkJ107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXS5pZCA9PSBtYXN0ZXJJRCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChtYXN0ZXIpIHtcbiAgICAgICAgICAgIGlmICghbWFzdGVyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChtYXN0ZXIucGFnZSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIChtYXN0ZXIucGFnZS5zYWxlcyAmJiBtYXN0ZXIuc2FsZXNbMF0pIHx8XG4gICAgICAgICAgICAgICAgICAgIChtYXN0ZXIucGFnZS5hbGJ1bXMgJiYgbWFzdGVyLmFsYnVtc1swXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1hc3Rlci5wYWdlLnZpZGVvcyAmJiBtYXN0ZXIudmlkZW9zWzBdKSB8fFxuICAgICAgICAgICAgICAgICAgICAobWFzdGVyLnBhZ2UuY29tbWVudHMgJiYgbWFzdGVyLmNvbW1lbnRzWzBdKVxuICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBtYXN0ZXIuaXNXaWRnZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hc3Rlci5wYWdlICYmIG1hc3Rlci5wYWdlLmFsYnVtcyAmJiBtYXN0ZXIuYWxidW1zKSB7XG4gICAgICAgICAgICAgICAgbWFzdGVyLmFsYnVtc0NvdW50ID0gbWFzdGVyLmFsYnVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbWFzdGVyLmFsYnVtc1RpdGxlID0gW107XG4gICAgICAgICAgICAgICAgbWFzdGVyLmFsYnVtcy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBtYXN0ZXIuYWxidW1zVGl0bGUucHVzaChlbC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtYXN0ZXIuYWxidW1zVGl0bGUgPSBtYXN0ZXIuYWxidW1zVGl0bGUuam9pbignLCAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXN0ZXIucGFnZSAmJiBtYXN0ZXIucGFnZS5jb21tZW50cyAmJiBtYXN0ZXIuY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICBtYXN0ZXIuY29tbWVudHNDb3VudCA9IG1hc3Rlci5jb21tZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VydmljZXNOb3JtYWxseSA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobWFzdGVyLnNlcnZpY2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VydmljZSA9IG1hc3Rlci5zZXJ2aWNlc1tpdGVtXTtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlID0gc2VydmljZS5yZXBsYWNlKC9cXHUwMEEwL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlc05vcm1hbGx5LnB1c2goc2VydmljZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hc3Rlci5zZXJ2aWNlcyA9IHNlcnZpY2VzTm9ybWFsbHk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKE9iamVjdC5rZXlzKG1hc3Rlci5zZXJ2aWNlcykpO1xuICAgICAgICAgICAgcmV0dXJuIG1hc3RlcjtcbiAgICAgICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbk1hc3Rlck1pbmljYXJkLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICQoJy5tYXN0ZXItY29udGVudC13aWRnZXQgbGknKS5iaW5kKCdtb3VzZWVudGVyJywgc2hvd1dpZGdldFRhYik7XG5cbiAgICAkKCcubWFzdGVyLWNvbnRlbnQtd2lkZ2V0JykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykuZmluZCgnLmFjdCcpLmZpcnN0KCkuYWRkQ2xhc3MoJ3Nob3cnKTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBzaG93V2lkZ2V0VGFiKCkge1xuICAgICAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcygnYWN0JykpIHtcbiAgICAgICAgICAgICQodGhpcykuc2libGluZ3MoKS5yZW1vdmVDbGFzcygnc2hvdycpO1xuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnc2hvdycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWluaWNhcmRTZXJ2aWNlc0N1dCgpO1xuICAgIHJldHVybiB7fTtcbn07XG5NYXN0ZXJNaW5pY2FyZC5wcm90b3R5cGUuX21pbmljYXJkU2VydmljZXNDdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1pbmljYXJkID0gJCgnIycgKyB0aGlzLiRjb250ZXh0LmVsZW1lbnQuaWQpO1xuICAgIHZhciBtaW5pY2FyZFNlcnZpY2VzID0gbWluaWNhcmQuZmluZCgnLm1hc3Rlci1taW5pY2FyZF9fc2VydmljZXMnKTtcbiAgICB2YXIgbWF4SGVpZ2h0ID1cbiAgICAgICAgbWluaWNhcmQuZmluZCgnLm1hc3Rlci1taW5pY2FyZCcpLmhlaWdodCgpIC0gKG1pbmljYXJkLmZpbmQoJy5tYXN0ZXItbWluaWNhcmRfX25hbWUnKS5oZWlnaHQoKSArIG1pbmljYXJkLmZpbmQoJy5tYXN0ZXItbWluaWNhcmRfX3NwZWMnKS5oZWlnaHQoKSk7XG4gICAgdmFyIHNlcnZpY2VzQ291bnQgPSBtaW5pY2FyZFNlcnZpY2VzLmZpbmQoJ2xpJykubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG1pbmljYXJkU2VydmljZXMuaGVpZ2h0KCkgPiBtYXhIZWlnaHQgJiYgc2VydmljZXNDb3VudCAhPSAwKSB7XG4gICAgICAgICQobWluaWNhcmRTZXJ2aWNlcy5maW5kKCdsaScpW3NlcnZpY2VzQ291bnRdKS5oaWRlKCk7XG4gICAgICAgIHNlcnZpY2VzQ291bnQtLTtcbiAgICB9XG59O1xuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5NYXN0ZXJNaW5pY2FyZC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICQoJy5tYXN0ZXItY29udGVudC13aWRnZXQgbGknKS51bmJpbmQoJ21vdXNlZW50ZXInKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFzdGVyUGhvbmVCdG47XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwibWFzdGVyLXBob25lLWJ0blwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYXN0ZXJQaG9uZUJ0bigpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cbk1hc3RlclBob25lQnRuLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuYXR0cmlidXRlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuTWFzdGVyUGhvbmVCdG4ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xpY2s6IHtcbiAgICAgICAgICAgICcuanMtc2hvdy1waG9uZSc6IHRoaXMuX2NsaWNrUGhvbmVIYW5kbGVyLFxuICAgICAgICAgICAgJy5qcy1jbG9zZS10aXAnOiB0aGlzLl9jbGlja0Nsb3NlVGlwSGFuZGxlclxuICAgICAgICB9XG4gICAgfVxufTtcblxuTWFzdGVyUGhvbmVCdG4ucHJvdG90eXBlLl9jbGlja1Bob25lSGFuZGxlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZWwgPSBvYmoudGFyZ2V0O1xuICAgICQoZWwpLmhpZGUoKTtcbiAgICAkKGVsKS5zaWJsaW5ncygnLmpzLXNob3ctcGhvbmUtZGV0YWlscycpLnNob3coKTtcbiAgICAkKGVsKS5jbG9zZXN0KCcubWFzdGVyLW1pbmljYXJkJykuZmluZCgnLmpzLW1hc3Rlci1waG9uZS10aXAnKS5mYWRlSW4oNDAwKS5kZWxheSg0MDAwKS5mYWRlT3V0KDUwMCk7XG59O1xuTWFzdGVyUGhvbmVCdG4ucHJvdG90eXBlLl9jbGlja0Nsb3NlVGlwSGFuZGxlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZWwgPSBvYmoudGFyZ2V0O1xuICAgICQoZWwpLmNsb3Nlc3QoJy5qcy1tYXN0ZXItcGhvbmUtdGlwJykuc3RvcCgpLmZhZGVPdXQoNTAwKTtcbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuTWFzdGVyUGhvbmVCdG4ucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNYXN0ZXJQYWdlO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm1hc3Rlci1wYWdlXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hc3RlclBhZ2UoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5NYXN0ZXJQYWdlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKCkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEuY29tcGFueSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pO1xufTtcblxuTWFzdGVyUGFnZS5wcm90b3R5cGUuX3RhID0gbnVsbDtcbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuTWFzdGVyUGFnZS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWVudSA9ICQoJy5tZW51LW1wJyk7XG4gICAgdmFyIG1lbnVPZmZzZXQgPSBtZW51Lm9mZnNldCgpO1xuICAgIHZhciB0YSA9ICQoJ3RleHRhcmVhJyk7XG5cbiAgICAkKHdpbmRvdykuYmluZCgnc2Nyb2xsJywgZml4ZWRTZWN0aW9uTWVudSk7XG4gICAgJCh3aW5kb3cpLmJpbmQoJ3Njcm9sbCcsIG1lbnVIaWdobGlnaHQpO1xuICAgICQoJy5tZW51LW1wIGEnKS5iaW5kKCdjbGljaycsIHNjcm9sbFRvU2VjdGlvbik7XG4gICAgJCgnLmNvbnRhY3RzLW1wX19zaG93LWNvbnRhY3QnKS5iaW5kKCdjbGljaycsIHNob3dDb250YWN0KTtcbiAgICAkKCcuanMtc2hvdy1jYWxsYmFjay1wb3B1cCcpLmJpbmQoJ2NsaWNrJywgc2hvd0NhbGxiYWNrUG9wdXApO1xuICAgIGF1dG9zaXplKHRhKTtcblxuICAgIC8v0L/QvtC60LDQt9Cw0YLRjCDQutC+0L3RgtCw0LrRgtGLXG4gICAgZnVuY3Rpb24gc2hvd0NvbnRhY3QoKSB7XG4gICAgICAgICQodGhpcykuY2xvc2VzdCgnLmNvbnRhY3RzLW1wX19jYXAnKS5oaWRlKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL9C/0LvQsNCy0LDRjtGJ0LXQs9C+INC80LXQvdGOXG4gICAgZnVuY3Rpb24gZml4ZWRTZWN0aW9uTWVudSgpIHtcbiAgICAgICAgaWYgKCQod2luZG93KS5zY3JvbGxUb3AoKSArIDMwID4gbWVudU9mZnNldC50b3ApIHtcbiAgICAgICAgICAgIG1lbnUuYWRkQ2xhc3MoJ2ZpeGVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZW51LnJlbW92ZUNsYXNzKCdmaXhlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy/RgdC60YDQvtC70Lsg0LTQviDRgdC10LrRhtC40LhcbiAgICBmdW5jdGlvbiBtZW51SGlnaGxpZ2h0KCkge1xuICAgICAgICAkKCcubWFzdGVyLXBhZ2VfX3NlY3Rpb24tY29udCcpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCQod2luZG93KS5zY3JvbGxUb3AoKSArIDUwID4gJCh0aGlzKS5vZmZzZXQoKS50b3AgJiYgJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgMzAgPCAkKHRoaXMpLm9mZnNldCgpLnRvcCArICQodGhpcykuaW5uZXJIZWlnaHQoKSkge1xuICAgICAgICAgICAgICAgIG1lbnUuZmluZCgnLmFjdCcpLnJlbW92ZUNsYXNzKCdhY3QnKTtcbiAgICAgICAgICAgICAgICBtZW51LmZpbmQoJ1tocmVmPSMnICsgJCh0aGlzKS5jaGlsZHJlbigpLmF0dHIoJ2lkJykgKyAnXScpLmFkZENsYXNzKCdhY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy/QvdCw0LLQuNCz0LDRhtC40Lgg0LLQvdGD0YLRgNC4INGB0YLRgNCw0L3QuNGG0Ysg0LzQsNGB0YLQtdGA0LBcbiAgICBmdW5jdGlvbiBzY3JvbGxUb1NlY3Rpb24oKSB7XG4gICAgICAgICQod2luZG93KS51bmJpbmQoJ3Njcm9sbCcsIG1lbnVIaWdobGlnaHQpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQod2luZG93KS5iaW5kKCdzY3JvbGwnLCBtZW51SGlnaGxpZ2h0KTtcbiAgICAgICAgfSwgMTA1MCk7XG4gICAgICAgIG1lbnUuZmluZCgnLmFjdCcpLnJlbW92ZUNsYXNzKCdhY3QnKTtcbiAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnYWN0Jyk7XG4gICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgICAgIHNjcm9sbFRvcDogJCgkKHRoaXMpLmF0dHIoJ2hyZWYnKSkub2Zmc2V0KCkudG9wIC0gNTBcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL9C/0L7QutCw0LfQsNGC0YwgcG9wdXAgLSDQt9Cw0LrQsNC30LDRgtGMINC30LLQvtC90L7QulxuICAgIGZ1bmN0aW9uIHNob3dDYWxsYmFja1BvcHVwKCkge1xuICAgICAgICB2YXIgZm9ybSA9ICQoJy5jYWxsYmFjay1wb3B1cCcpO1xuICAgICAgICAkLmZhbmN5Ym94Lm9wZW4oZm9ybSwge1xuICAgICAgICAgICAgcGFkZGluZzogMFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuTWFzdGVyUGFnZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuXG4gICAgJCh3aW5kb3cpLnVuYmluZCgnc2Nyb2xsJyk7XG4gICAgJCgnLm1lbnUtbXAnKS5maW5kKCdhJykudW5iaW5kKCdjbGljaycpO1xuICAgICQoJy5jb250YWN0cy1tcF9fc2hvdy1jb250YWN0JykudW5iaW5kKCdjbGljaycpO1xuICAgICQoJy5qcy1zaG93LWNhbGxiYWNrLXBvcHVwJykudW5iaW5kKCdjbGljaycpO1xuICAgIGV2dC5pbml0RXZlbnQoJ2F1dG9zaXplOmRlc3Ryb3knLCB0cnVlLCBmYWxzZSk7XG4gICAgdGEuZGlzcGF0Y2hFdmVudChldnQpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFzdGVyUmVjb21tZW5kZWQ7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwibWFzdGVyLXJlY29tbWVuZGVkXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hc3RlclJlY29tbWVuZGVkKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuTWFzdGVyUmVjb21tZW5kZWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL3JldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiaXMtcmVjb21tZW5kZWQtbWFzdGVyc1wiOiB0cnVlLFxuICAgICAgICBcInVybC1hcnJvdy1sZWZ0XCI6IFwiNDA0XCIsXG4gICAgICAgIFwidXJsLWFycm93LXJpZ2h0XCI6IFwiNDA0XCIsXG4gICAgICAgIFwicmVjb21tZW5kZWQtbWFzdGVyXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm1hc3Rlci11cmxcIjogXCI0MDRcIixcbiAgICAgICAgICAgICAgICBcInNyY1wiOiBcIi9pbWcvYXNzZXRzL21hc3Rlcl9yZWNvbW1lbmRlZC8zNzIwLmpwZ1wiLFxuICAgICAgICAgICAgICAgIFwiYWx0XCI6IFwi0JrQvdGP0LfQtdCyINCQLtCuLlwiLFxuICAgICAgICAgICAgICAgIFwibWFzdGVyLW5hbWVcIjogXCLQmtC90Y/Qt9C10LIg0JAu0K4uXCIsXG4gICAgICAgICAgICAgICAgXCJyZWNvbW1lbmRhdGlvbi1udW1iZXJcIjogXCIyNyDRh9C10LvQvtCy0LXQulwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibWFzdGVyLXVybFwiOiBcIjQwNFwiLFxuICAgICAgICAgICAgICAgIFwic3JjXCI6IFwiL2ltZy9hc3NldHMvbWFzdGVyX3JlY29tbWVuZGVkLzQ2MTcuanBnXCIsXG4gICAgICAgICAgICAgICAgXCJhbHRcIjogXCLQpdCw0LvRjNC30L7QsiDQkC5cIixcbiAgICAgICAgICAgICAgICBcIm1hc3Rlci1uYW1lXCI6IFwi0KXQsNC70YzQt9C+0LIg0JAuXCIsXG4gICAgICAgICAgICAgICAgXCJyZWNvbW1lbmRhdGlvbi1udW1iZXJcIjogXCI2INGH0LXQu9C+0LLQtdC6XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJtYXN0ZXItdXJsXCI6IFwiNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJzcmNcIjogXCIvaW1nL2Fzc2V0cy9tYXN0ZXJfcmVjb21tZW5kZWQvNzQyOC5qcGdcIixcbiAgICAgICAgICAgICAgICBcImFsdFwiOiBcItCR0YPQu9Cz0LDQutC+0LIg0JIu0JAuXCIsXG4gICAgICAgICAgICAgICAgXCJtYXN0ZXItbmFtZVwiOiBcItCR0YPQu9Cz0LDQutC+0LIg0JIu0JAuXCIsXG4gICAgICAgICAgICAgICAgXCJyZWNvbW1lbmRhdGlvbi1udW1iZXJcIjogXCI1INGH0LXQu9C+0LLQtdC6XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJtYXN0ZXItdXJsXCI6IFwiNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJzcmNcIjogXCIvaW1nL2Fzc2V0cy9tYXN0ZXJfcmVjb21tZW5kZWQvMzcyMC5qcGdcIixcbiAgICAgICAgICAgICAgICBcImFsdFwiOiBcItCa0L3Rj9C30LXQsiDQkC7Qri5cIixcbiAgICAgICAgICAgICAgICBcIm1hc3Rlci1uYW1lXCI6IFwi0JrQvdGP0LfQtdCyINCQLtCuLlwiLFxuICAgICAgICAgICAgICAgIFwicmVjb21tZW5kYXRpb24tbnVtYmVyXCI6IFwiMjcg0YfQtdC70L7QstC10LpcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm1hc3Rlci11cmxcIjogXCI0MDRcIixcbiAgICAgICAgICAgICAgICBcInNyY1wiOiBcIi9pbWcvYXNzZXRzL21hc3Rlcl9yZWNvbW1lbmRlZC80NjE3LmpwZ1wiLFxuICAgICAgICAgICAgICAgIFwiYWx0XCI6IFwi0KXQsNC70YzQt9C+0LIg0JAuXCIsXG4gICAgICAgICAgICAgICAgXCJtYXN0ZXItbmFtZVwiOiBcItCl0LDQu9GM0LfQvtCyINCQLlwiLFxuICAgICAgICAgICAgICAgIFwicmVjb21tZW5kYXRpb24tbnVtYmVyXCI6IFwiNiDRh9C10LvQvtCy0LXQulwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibWFzdGVyLXVybFwiOiBcIjQwNFwiLFxuICAgICAgICAgICAgICAgIFwic3JjXCI6IFwiL2ltZy9hc3NldHMvbWFzdGVyX3JlY29tbWVuZGVkLzc0MjguanBnXCIsXG4gICAgICAgICAgICAgICAgXCJhbHRcIjogXCLQkdGD0LvQs9Cw0LrQvtCyINCSLtCQLlwiLFxuICAgICAgICAgICAgICAgIFwibWFzdGVyLW5hbWVcIjogXCLQkdGD0LvQs9Cw0LrQvtCyINCSLtCQLlwiLFxuICAgICAgICAgICAgICAgIFwicmVjb21tZW5kYXRpb24tbnVtYmVyXCI6IFwiNSDRh9C10LvQvtCy0LXQulwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwibWFzdGVyLXVybFwiOiBcIjQwNFwiLFxuICAgICAgICAgICAgICAgIFwic3JjXCI6IFwiL2ltZy9hc3NldHMvbWFzdGVyX3JlY29tbWVuZGVkLzM3MjAuanBnXCIsXG4gICAgICAgICAgICAgICAgXCJhbHRcIjogXCLQmtC90Y/Qt9C10LIg0JAu0K4uXCIsXG4gICAgICAgICAgICAgICAgXCJtYXN0ZXItbmFtZVwiOiBcItCa0L3Rj9C30LXQsiDQkC7Qri5cIixcbiAgICAgICAgICAgICAgICBcInJlY29tbWVuZGF0aW9uLW51bWJlclwiOiBcIjI3INGH0LXQu9C+0LLQtdC6XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJtYXN0ZXItdXJsXCI6IFwiNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJzcmNcIjogXCIvaW1nL2Fzc2V0cy9tYXN0ZXJfcmVjb21tZW5kZWQvNDYxNy5qcGdcIixcbiAgICAgICAgICAgICAgICBcImFsdFwiOiBcItCl0LDQu9GM0LfQvtCyINCQLlwiLFxuICAgICAgICAgICAgICAgIFwibWFzdGVyLW5hbWVcIjogXCLQpdCw0LvRjNC30L7QsiDQkC5cIixcbiAgICAgICAgICAgICAgICBcInJlY29tbWVuZGF0aW9uLW51bWJlclwiOiBcIjYg0YfQtdC70L7QstC10LpcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcIm1hc3Rlci11cmxcIjogXCI0MDRcIixcbiAgICAgICAgICAgICAgICBcInNyY1wiOiBcIi9pbWcvYXNzZXRzL21hc3Rlcl9yZWNvbW1lbmRlZC83NDI4LmpwZ1wiLFxuICAgICAgICAgICAgICAgIFwiYWx0XCI6IFwi0JHRg9C70LPQsNC60L7QsiDQki7QkC5cIixcbiAgICAgICAgICAgICAgICBcIm1hc3Rlci1uYW1lXCI6IFwi0JHRg9C70LPQsNC60L7QsiDQki7QkC5cIixcbiAgICAgICAgICAgICAgICBcInJlY29tbWVuZGF0aW9uLW51bWJlclwiOiBcIjUg0YfQtdC70L7QstC10LpcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5NYXN0ZXJSZWNvbW1lbmRlZC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJpbmRTbGljaygpO1xufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5NYXN0ZXJSZWNvbW1lbmRlZC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudW5iaW5kU2xpY2soKTtcbn07XG5cbk1hc3RlclJlY29tbWVuZGVkLnByb3RvdHlwZS5iaW5kU2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCgnLm1hc3Rlcl9yZWNvbW1lbmRlZF9fc2xpZGVyJykuc2xpY2soe1xuICAgICAgICBkb3RzOiBmYWxzZSxcbiAgICAgICAgaW5maW5pdGU6IGZhbHNlLFxuICAgICAgICBzcGVlZDogNzAwLFxuICAgICAgICBzbGlkZXNUb1Nob3c6IDQsXG4gICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAzLFxuICAgICAgICBwcmV2QXJyb3c6ICc8ZGl2IGNsYXNzPVwic2xpY2stcHJldlwiPicgK1xuICAgICAgICAnPHN2ZyBjbGFzcz1cImljb24gaWNvbl9zdHJlbGthXCIgdGl0bGU9XCJpY29uX3N0cmVsa2FcIiByb2xlPVwiaW1nXCI+JyArXG4gICAgICAgICc8dXNlIHhsaW5rOmhyZWY9XCIvaWNvbi1zdmcvc3ZnLXN5bWJvbHMuc3ZnI2ljb25fc3RyZWxrYVwiLz4nICtcbiAgICAgICAgJzwvc3ZnPicgK1xuICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgbmV4dEFycm93OiAnPGRpdiBjbGFzcz1cInNsaWNrLW5leHRcIj4nICtcbiAgICAgICAgJzxzdmcgY2xhc3M9XCJpY29uIGljb25fc3RyZWxrYVwiIHRpdGxlPVwiaWNvbl9zdHJlbGthXCIgcm9sZT1cImltZ1wiPicgK1xuICAgICAgICAnPHVzZSB4bGluazpocmVmPVwiL2ljb24tc3ZnL3N2Zy1zeW1ib2xzLnN2ZyNpY29uX3N0cmVsa2FcIi8+JyArXG4gICAgICAgICc8L3N2Zz4nICtcbiAgICAgICAgJzwvZGl2PidcbiAgICB9KTtcbn07XG5NYXN0ZXJSZWNvbW1lbmRlZC5wcm90b3R5cGUudW5iaW5kU2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCgnLm1hc3Rlcl9yZWNvbW1lbmRlZF9fc2xpZGVyJykuc2xpY2soXCJ1bnNsaWNrXCIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFzdGVyUnVicmlrYTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJtYXN0ZXItcnVicmlrYVwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYXN0ZXJSdWJyaWthKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuTWFzdGVyUnVicmlrYS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5NYXN0ZXJSdWJyaWthLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cbk1hc3RlclJ1YnJpa2EucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBPdGhlck5ld3NJdGVtO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm90aGVyLW5ld3MtaXRlbVwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPdGhlck5ld3NJdGVtKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuT3RoZXJOZXdzSXRlbS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5PdGhlck5ld3NJdGVtLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cbk90aGVyTmV3c0l0ZW0ucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBPdGhlck5ld3M7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwib3RoZXItbmV3c1wiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPdGhlck5ld3MoKSB7XG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuT3RoZXJOZXdzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbk90aGVyTmV3cy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5PdGhlck5ld3MucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBPdGhlclJlY29tbWVuZGF0aW9uO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm90aGVyLXJlY29tbWVuZGF0aW9uXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE90aGVyUmVjb21tZW5kYXRpb24oKSB7XG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuT3RoZXJSZWNvbW1lbmRhdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbk90aGVyUmVjb21tZW5kYXRpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuT3RoZXJSZWNvbW1lbmRhdGlvbi5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE90aGVyVmFjYW5jeUl0ZW07XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwib3RoZXItdmFjYW5jeS1pdGVtXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE90aGVyVmFjYW5jeUl0ZW0oKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5PdGhlclZhY2FuY3lJdGVtLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbk90aGVyVmFjYW5jeUl0ZW0ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuT3RoZXJWYWNhbmN5SXRlbS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE90aGVyVmFjYW5jeTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJvdGhlci12YWNhbmN5XCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE90aGVyVmFjYW5jeSgpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cbk90aGVyVmFjYW5jeS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgpXG4gICAgICAgIC50aGVuIChmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWNhbmN5OiByZXNcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5PdGhlclZhY2FuY3kucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuT3RoZXJWYWNhbmN5LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUnViaWthdG9yO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcInJ1YmlrYXRvclwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSdWJpa2F0b3IoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5SdWJpa2F0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5SdWJpa2F0b3IucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuUnViaWthdG9yLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnZUNvbnRhY3Q7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicGFnZS1jb250YWN0XCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhZ2VDb250YWN0KCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuUGFnZUNvbnRhY3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBcInBob25lXCI6IFwiKDg0ODIpIDc0MS0xNDdcIixcbiAgICAgICAgXCJlbWFpbFwiOiBcImluZm9AZmFjZW1hc3Rlci5ydVwiLFxuICAgICAgICBcImFkcmVzc1wiOiBcItCzLiDQotC+0LvRjNGP0YLRgtC4LCDRg9C7LiDQkNCy0YLQvtGB0YLRgNC+0LjRgtC10LvQtdC5IDQx0JAtMVwiXG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5QYWdlQ29udGFjdC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5QYWdlQ29udGFjdC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VGZWVkYmFjaztcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJwYWdlLWZlZWRiYWNrXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhZ2VGZWVkYmFjaygpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cblBhZ2VGZWVkYmFjay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblBhZ2VGZWVkYmFjay5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5QYWdlRmVlZGJhY2sucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlTG9naW47XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicGFnZS1sb2dpblwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYWdlTG9naW4oKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5QYWdlTG9naW4ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5QYWdlTG9naW4ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuUGFnZUxvZ2luLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9wRnVuY3Rpb247XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwiZG9wLWZ1bmN0aW9uXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERvcEZ1bmN0aW9uKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuRG9wRnVuY3Rpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBcIm1lbnVNYXN0ZXJcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwidXJsXCI6IFwiL3JlZ2lzdHJhdGlvblwiLFxuICAgICAgICAgICAgICAgIFwidGl0bGVcIjogXCLQodGC0LDRgtGMINCc0LDRgdGC0LXRgNC+0LxcIixcbiAgICAgICAgICAgICAgICBcImljb25cIjogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInVybFwiOiBcIi9yZWNvbW1lbmRhdGlvblwiLFxuICAgICAgICAgICAgICAgIFwidGl0bGVcIjogXCLQnNCw0YHRgtC10YDQsCDQviDRgdCw0LnRgtC1XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJtZW51QWJvdXRcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwidXJsXCI6IFwiL25ld3NcIixcbiAgICAgICAgICAgICAgICBcInRpdGxlXCI6IFwi0J3QvtCy0L7RgdGC0LhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInVybFwiOiBcIi92YWNhbmN5XCIsXG4gICAgICAgICAgICAgICAgXCJ0aXRsZVwiOiBcItCS0LDQutCw0L3RgdC40LhcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcIm1lbnVCYXlkYVwiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJ1cmxcIjogXCIvNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0aXRsZVwiOiBcItCa0L7QvdC60YPRgNGB0Ysg0LPQsNC30LXRgtGLINCf0YDQtdC30LXQvdGCXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJ1cmxcIjogXCIvNDA0XCIsXG4gICAgICAgICAgICAgICAgXCJ0aXRsZVwiOiBcItCc0LDRgNGI0YDRg9GC0LrQuCDQotC+0LvRjNGP0YLRgtC4INGBIDAxLjAxLjIwMTVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInVybFwiOiBcIi80MDRcIixcbiAgICAgICAgICAgICAgICBcInRpdGxlXCI6IFwi0JTQsNGH0L3Ri9C1INC/0LXRgNC10LLQvtC30LrQuFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwiZW1wdHlcIjogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5Eb3BGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5Eb3BGdW5jdGlvbi5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1haW47XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwibWFpblwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYWluKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuTWFpbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbk1haW4ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuTWFpbi5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1haW5GdW5jdGlvbjtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJtYWluLWZ1bmN0aW9uXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1haW5GdW5jdGlvbigpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cbk1haW5GdW5jdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIGNvdW50TWFzdGVyOiAnMSAyMzQg0JzQsNGB0YLQtdGA0LAnXG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuTWFpbkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cbk1haW5GdW5jdGlvbi5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VNYXN0ZXJQYWdlO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcInBhZ2UtbWFzdGVyLXBhZ2VcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGFnZU1hc3RlclBhZ2UoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5QYWdlTWFzdGVyUGFnZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblBhZ2VNYXN0ZXJQYWdlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cblBhZ2VNYXN0ZXJQYWdlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnZU1hc3RlclJ1YnJpa2E7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicGFnZS1tYXN0ZXItcnVicmlrYVwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYWdlTWFzdGVyUnVicmlrYSgpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cblBhZ2VNYXN0ZXJSdWJyaWthLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuUGFnZU1hc3RlclJ1YnJpa2EucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuUGFnZU1hc3RlclJ1YnJpa2EucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlTmV3c0l0ZW07XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicGFnZS1uZXdzLWl0ZW1cIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGFnZU5ld3NJdGVtKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuUGFnZU5ld3NJdGVtLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblBhZ2VOZXdzSXRlbS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5QYWdlTmV3c0l0ZW0ucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlTmV3cztcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJwYWdlLW5ld3NcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGFnZU5ld3MoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5QYWdlTmV3cy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblBhZ2VOZXdzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cblBhZ2VOZXdzLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnZU9mZXJ0YTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJwYWdlLW9mZXJ0YVwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYWdlT2ZlcnRhKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuUGFnZU9mZXJ0YS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblBhZ2VPZmVydGEucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuUGFnZU9mZXJ0YS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VSZWNvbW1lbmRhdGlvbjtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJwYWdlLXJlY29tbWVuZGF0aW9uXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhZ2VSZWNvbW1lbmRhdGlvbigpIHtcbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5QYWdlUmVjb21tZW5kYXRpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuUGFnZVJlY29tbWVuZGF0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cblBhZ2VSZWNvbW1lbmRhdGlvbi5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VSZWdpc3RyYXRpb247XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicGFnZS1yZWdpc3RyYXRpb25cIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGFnZVJlZ2lzdHJhdGlvbigpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cblBhZ2VSZWdpc3RyYXRpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5QYWdlUmVnaXN0cmF0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cblBhZ2VSZWdpc3RyYXRpb24ucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlUmVxdWVzdDtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJwYWdlLXJlcXVlc3RcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGFnZVJlcXVlc3QoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5QYWdlUmVxdWVzdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblBhZ2VSZXF1ZXN0LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cblBhZ2VSZXF1ZXN0LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnZVNhbGVDYXRhbG9nO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcInBhZ2Utc2FsZS1jYXRhbG9nXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhZ2VTYWxlQ2F0YWxvZygpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cblBhZ2VTYWxlQ2F0YWxvZy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblBhZ2VTYWxlQ2F0YWxvZy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5QYWdlU2FsZUNhdGFsb2cucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlU292ZXR5Q2F0YWxvZztcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJwYWdlLXNvdmV0eS1jYXRhbG9nXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhZ2VTb3ZldHlDYXRhbG9nKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuUGFnZVNvdmV0eUNhdGFsb2cucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5QYWdlU292ZXR5Q2F0YWxvZy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5QYWdlU292ZXR5Q2F0YWxvZy5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VWYWNhbmN5SXRlbTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJwYWdlLXZhY2FuY3ktaXRlbVwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYWdlVmFjYW5jeUl0ZW0oKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5QYWdlVmFjYW5jeUl0ZW0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5QYWdlVmFjYW5jeUl0ZW0ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuUGFnZVZhY2FuY3lJdGVtLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnZVZhY2FuY3k7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicGFnZS12YWNhbmN5XCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhZ2VWYWNhbmN5KCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuUGFnZVZhY2FuY3kucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5QYWdlVmFjYW5jeS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5QYWdlVmFjYW5jeS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VWaWRlb0NhdGFsb2c7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicGFnZS12aWRlby1jYXRhbG9nXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhZ2VWaWRlb0NhdGFsb2coKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5QYWdlVmlkZW9DYXRhbG9nLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblBhZ2VWaWRlb0NhdGFsb2cucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuUGFnZVZpZGVvQ2F0YWxvZy5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VzQ29udGVudDtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJwYWdlcy1jb250ZW50XCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhZ2VzQ29udGVudCgpIHsgfVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cblBhZ2VzQ29udGVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy4kY29udGV4dC5nZXRTdG9yZURhdGEoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICovXG5QYWdlc0NvbnRlbnQucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuaGlkZUxvYWRlcigpO1xufTtcblxuLyoqXG4gKiBIaWRlcyBsb2FkZXIgaW4gdGVtcGxhdGUuXG4gKi9cblBhZ2VzQ29udGVudC5wcm90b3R5cGUuaGlkZUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGxvYWRlcnMgPSB0aGlzLiRjb250ZXh0LmVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NhdC1sb2FkZXInKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsb2FkZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0bG9hZGVyc1tpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHR9XG5cdHdpbmRvdy5zY3JvbGxUbygwLDApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBGb290ZXI7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicGFnZXMtZm9vdGVyXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZvb3RlcigpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cbkZvb3Rlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmtzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgXCJ1cmxcIjogXCIvb2ZlcnRhXCIsXG4gICAgICAgICAgICAgICAgXCJ0aXRsZVwiOiBcItCe0YTQtdGA0YLQsFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwidXJsXCI6IFwiL2NvbnRhY3RcIixcbiAgICAgICAgICAgICAgICBcInRpdGxlXCI6IFwi0JrQvtC90YLQsNC60YLRi1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIFwidXJsXCI6IFwiL2ZlZWRiYWNrXCIsXG4gICAgICAgICAgICAgICAgXCJ0aXRsZVwiOiBcItCe0LHRgNCw0YLQvdCw0Y8g0YHQstGP0LfRjFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cbkZvb3Rlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd2luZG93SGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuICAgICQoJy50by10b3AnKS5jaGlsZHJlbignYScpLmJpbmQoJ2NsaWNrJywgc2Nyb2xsVG9Ub3ApO1xuICAgICQod2luZG93KS5iaW5kKCdzY3JvbGwnLCBpc1Zpc2libGVUb1RvcCk7XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxUb1RvcCgpIHtcbiAgICAgICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xuICAgICAgICAgICAgc2Nyb2xsVG9wOiAwXG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWaXNpYmxlVG9Ub3AoKSB7XG4gICAgICAgIGlmICh3aW5kb3dIZWlnaHQgLyAyID4gJCh3aW5kb3cpLnNjcm9sbFRvcCgpKSB7XG4gICAgICAgICAgICAkKCcudG8tdG9wJykuZmFkZU91dCg0MDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCgnLnRvLXRvcCcpLmZhZGVJbig0MDApO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5Gb290ZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKCcudG8tdG9wJykuY2hpbGRyZW4oJ2EnKS51bmJpbmQoJ2NsaWNrJyk7XG4gICAgJCh3aW5kb3cpLnVuYmluZCgnc2Nyb2xsJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VzSGVhZGVyO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcInBhZ2VzLWhlYWRlclwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYWdlc0hlYWRlcigpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cblBhZ2VzSGVhZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmhlYWRlcjtcbiAgICAgICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblBhZ2VzSGVhZGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cblBhZ2VzSGVhZGVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQQUdFUyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb25maWcvcGFnZXMuanNvblwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlc05hdmlnYXRpb247XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicGFnZXMtbmF2aWdhdGlvblwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYWdlc05hdmlnYXRpb24oKSB7XG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuUGFnZXNOYXZpZ2F0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVudTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxpbms6ICcvY2F0YWxvZycsXG4gICAgICAgICAgICAgICAgbmFtZTogUEFHRVMuY2F0YWxvZy50aXRsZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsaW5rOiAnL3JlcXVlc3QnLFxuICAgICAgICAgICAgICAgIG5hbWU6IFBBR0VTLnJlcXVlc3QudGl0bGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGluazogJy9yZWdpc3RyYXRpb24nLFxuICAgICAgICAgICAgICAgIG5hbWU6IFBBR0VTLnJlZ2lzdHJhdGlvbi50aXRsZVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVnaXN0cmF0aW9uQWJvdXQ7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicmVnaXN0cmF0aW9uLWFib3V0XCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJlZ2lzdHJhdGlvbkFib3V0KCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuUmVnaXN0cmF0aW9uQWJvdXQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5SZWdpc3RyYXRpb25BYm91dC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5SZWdpc3RyYXRpb25BYm91dC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZ2lzdHJhdGlvbkZhcTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJyZWdpc3RyYXRpb24tZmFxXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJlZ2lzdHJhdGlvbkZhcSgpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cblJlZ2lzdHJhdGlvbkZhcS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblJlZ2lzdHJhdGlvbkZhcS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5SZWdpc3RyYXRpb25GYXEucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWdpc3RyYXRpb25Gb3JtO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcInJlZ2lzdHJhdGlvbi1mb3JtXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJlZ2lzdHJhdGlvbkZvcm0oKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5SZWdpc3RyYXRpb25Gb3JtLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBcIi9yZWctbWFzdGVyL3N1Y2Nlc3MuanNvblwiLFxuICAgICAgICB1cmxMSzogXCI0MDRcIixcbiAgICAgICAgbWV0aG9kOiBcImdldFwiXG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5SZWdpc3RyYXRpb25Gb3JtLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cblJlZ2lzdHJhdGlvbkZvcm0ucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWdpc3RyYXRpb25IZWFkZXI7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicmVnaXN0cmF0aW9uLWhlYWRlclwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZWdpc3RyYXRpb25IZWFkZXIoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5SZWdpc3RyYXRpb25IZWFkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5SZWdpc3RyYXRpb25IZWFkZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuUmVnaXN0cmF0aW9uSGVhZGVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVnaXN0cmF0aW9uTW9yZVBhZ2U7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicmVnaXN0cmF0aW9uLW1vcmUtcGFnZVwiIGNvbXBvbmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZWdpc3RyYXRpb25Nb3JlUGFnZSgpIHtcblxufVxuXG4vKipcbiAqIEdldHMgZGF0YSBjb250ZXh0IGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBEYXRhIGNvbnRleHRcbiAqIGZvciB0ZW1wbGF0ZSBlbmdpbmUuXG4gKi9cblJlZ2lzdHJhdGlvbk1vcmVQYWdlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuUmVnaXN0cmF0aW9uTW9yZVBhZ2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuUmVnaXN0cmF0aW9uTW9yZVBhZ2UucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWdpc3RyYXRpb25QcmljZTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJyZWdpc3RyYXRpb24tcHJpY2VcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmVnaXN0cmF0aW9uUHJpY2UoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5SZWdpc3RyYXRpb25QcmljZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblJlZ2lzdHJhdGlvblByaWNlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsaWNrOiB7XG4gICAgICAgICAgICAnLnRhYi1jb250ZW50X19uYW1lJzogdGhpcy5fY2xpY2tIYW5kbGVcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuUmVnaXN0cmF0aW9uUHJpY2UucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuUmVnaXN0cmF0aW9uUHJpY2UucHJvdG90eXBlLl9jbGlja0hhbmRsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZWwgPSAkKG9iai50YXJnZXQpO1xuICAgIGlmICghZWwuaGFzQ2xhc3MoJ3RhYi1jb250ZW50X19uYW1lJykpXG4gICAgICAgIGVsID0gZWwucGFyZW50cygnLnRhYi1jb250ZW50X19uYW1lJyk7XG5cbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50cygnLnRhYi1jb250ZW50Jyk7XG4gICAgaWYgKHBhcmVudC5oYXNDbGFzcygndGFiLWNvbnRlbnRfYWN0aXZlJykpXG4gICAgICAgIHJldHVybjtcbiAgICAkKCcudGFiLWNvbnRlbnRfYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ3RhYi1jb250ZW50X2FjdGl2ZScpO1xuICAgIHBhcmVudC5hZGRDbGFzcygndGFiLWNvbnRlbnRfYWN0aXZlJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZ2lzdHJhdGlvbldoeVdlO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IENhdC1jb21wb25lbnQgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjY2F0LWNvbXBvbmVudHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcInJlZ2lzdHJhdGlvbi13aHktd2VcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmVnaXN0cmF0aW9uV2h5V2UoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5SZWdpc3RyYXRpb25XaHlXZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvdW50OiB7XG4gICAgICAgICAgICBtYXN0ZXI6IFwiMSAwMDBcIixcbiAgICAgICAgICAgIG1hc3Rlck5hbWU6IFwi0LzQsNGB0YLQtdGA0L7Qsjxicj7QvdCwINGB0LDQudGC0LVcIixcbiAgICAgICAgICAgIHZpc2l0czogXCIxMiAwMDBcIixcbiAgICAgICAgICAgIG9yZGVyczogXCIxIDAwMFwiXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblJlZ2lzdHJhdGlvbldoeVdlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cblJlZ2lzdHJhdGlvbldoeVdlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2F0YWxvZztcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJjYXRhbG9nXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENhdGFsb2coKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5DYXRhbG9nLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcnVicmlrYXRvcjogZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBldmVudCBiaW5kaW5nIHNldHRpbmdzIGZvciB0aGUgY29tcG9uZW50LlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gQmluZGluZyBzZXR0aW5ncy5cbiAqL1xuQ2F0YWxvZy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGljazoge1xuICAgICAgICAgICAgJy5qcy1ydWJyaWthLWxpc3QnOiB0aGlzLl9jbGlja0hhbmRsZXIsXG4gICAgICAgICAgICAnLmpzLXJ1YnJpa2EtY29sbGFwc2VkJzogdGhpcy5fY2xpY2tBbGxIYW5kbGVyXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5DYXRhbG9nLnByb3RvdHlwZS5fY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBlbCA9IG9iai50YXJnZXQ7XG4gICAgJChlbCkucGFyZW50cygnLnJ1YnJpa2EtbGlzdCcpLmZpbmQoJy5ydWJyaWthLWxpc3RfX2xpc3QnKS50b2dnbGUoKTtcbn1cblxuQ2F0YWxvZy5wcm90b3R5cGUuX2NsaWNrQWxsSGFuZGxlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZWwgPSBvYmoudGFyZ2V0O1xuICAgIHZhciBzZWxmID0gJChlbCkucGFyZW50cygnLmpzLXJ1YnJpa2EtY29sbGFwc2VkJyk7XG5cbiAgICB2YXIgY2wgPSAnbWFzdGVyLXJ1YnJpa2F0b3ItcGFnZSc7XG4gICAgdmFyIGNsX2NvbCA9IGNsICsgJ19jb2xsYXBzZWQnO1xuICAgIHZhciBlbCA9ICQoJy5tYXN0ZXItcnVicmlrYXRvci1wYWdlJyk7XG5cbiAgICBpZiAoZWwuaGFzQ2xhc3MoY2xfY29sKSkge1xuICAgICAgICBlbC5yZW1vdmVDbGFzcyhjbF9jb2wpO1xuICAgICAgICAkKCcucnVicmlrYS1saXN0X19saXN0Jykuc2hvdygpO1xuICAgICAgICBzZWxmLmZpbmQoJy5ydWJyaWthLWxpc3RfX25hbWUnKS5odG1sKCfQodCy0LXRgNC90YPRgtGMINCy0YHQtSDRgNGD0LHRgNC40LrQuCcpXG4gICAgICAgICAgICAuZW5kKCkuZmluZCgnLnJ1YnJpa2EtbGlzdF9faWNvbicpLmFkZENsYXNzKCdydWJyaWthLWxpc3RfX2ljb25fcm90YXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwuYWRkQ2xhc3MoY2xfY29sKTtcbiAgICAgICAgJCgnLnJ1YnJpa2EtbGlzdF9fbGlzdCcpLmhpZGUoKTtcbiAgICAgICAgc2VsZi5maW5kKCcucnVicmlrYS1saXN0X19uYW1lJykuaHRtbCgn0KDQsNC30LLQtdGA0L3Rg9GC0Ywg0LLRgdC1INGA0YPQsdGA0LjQutC4JylcbiAgICAgICAgICAgIC5lbmQoKS5maW5kKCcucnVicmlrYS1saXN0X19pY29uJykucmVtb3ZlQ2xhc3MoJ3J1YnJpa2EtbGlzdF9faWNvbl9yb3RhdGUnKTtcbiAgICB9XG59XG4vKipcbiAqIERvZXMgY2xlYW5pbmcgZm9yIGV2ZXJ5dGhpbmcgdGhhdCBoYXZlIE5PVCBiZWVuIHNldCBieSAuYmluZCgpIG1ldGhvZC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2V8dW5kZWZpbmVkfSBQcm9taXNlIG9yIG5vdGhpbmcuXG4gKi9cbkNhdGFsb2cucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gU2FsZTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJzYWxlXCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFNhbGUoKSB7XG5cbn1cblxuLyoqXG4gKiBHZXRzIGRhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gRGF0YSBjb250ZXh0XG4gKiBmb3IgdGVtcGxhdGUgZW5naW5lLlxuICovXG5TYWxlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblNhbGUucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuU2FsZS5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlYXJjaDtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJzZWFyY2hcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU2VhcmNoKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuU2VhcmNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgbW9kaWZpY2F0b3I6IHRoaXMuJGNvbnRleHQuYXR0cmlidXRlcy5tb2RpZmljYXRvcixcbiAgICB1cmw6ICcnLFxuICAgIG1ldGhvZDogJydcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5TZWFyY2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbi8qKlxuICogRG9lcyBjbGVhbmluZyBmb3IgZXZlcnl0aGluZyB0aGF0IGhhdmUgTk9UIGJlZW4gc2V0IGJ5IC5iaW5kKCkgbWV0aG9kLlxuICogVGhpcyBtZXRob2QgaXMgb3B0aW9uYWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZXx1bmRlZmluZWR9IFByb21pc2Ugb3Igbm90aGluZy5cbiAqL1xuU2VhcmNoLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmljZVJlcXVlc3Q7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgQ2F0LWNvbXBvbmVudCBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNjYXQtY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwic2VydmljZS1yZXF1ZXN0XCIgY29tcG9uZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2VSZXF1ZXN0KCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuU2VydmljZVJlcXVlc3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGV2ZW50IGJpbmRpbmcgc2V0dGluZ3MgZm9yIHRoZSBjb21wb25lbnQuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBCaW5kaW5nIHNldHRpbmdzLlxuICovXG5TZXJ2aWNlUmVxdWVzdC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5TZXJ2aWNlUmVxdWVzdC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKCkge1xuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2lhbDtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBDYXQtY29tcG9uZW50IGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI2NhdC1jb21wb25lbnRzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJzb2NpYWxcIiBjb21wb25lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU29jaWFsKCkge1xuXG59XG5cbi8qKlxuICogR2V0cyBkYXRhIGNvbnRleHQgZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IERhdGEgY29udGV4dFxuICogZm9yIHRlbXBsYXRlIGVuZ2luZS5cbiAqL1xuU29jaWFsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgdXJsOiAnaHR0cDovL3ZrLmNvbS9mbV9tZicsXG4gICAgICBpY286ICd2aydcbiAgICB9LFxuICAgIHtcbiAgICAgIHVybDogJ2h0dHA6Ly93d3cuZmFjZWJvb2suY29tL2ZhY2UubWFzdCcsXG4gICAgICBpY286ICdmYidcbiAgICB9LFxuICAgIHtcbiAgICAgIHVybDogJ2h0dHA6Ly93d3cub2Rub2tsYXNzbmlraS5ydS9mYWNlbWFzdGVyJyxcbiAgICAgIGljbzogJ29rJ1xuICAgIH0sXG4gICAge1xuICAgICAgdXJsOiAnaHR0cDovL3R3aXR0ZXIuY29tL0ZhY2VtYXN0ZXJSdScsXG4gICAgICBpY286ICd0dydcbiAgICB9XG4gIF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgZXZlbnQgYmluZGluZyBzZXR0aW5ncyBmb3IgdGhlIGNvbXBvbmVudC5cbiAqIFRoaXMgbWV0aG9kIGlzIG9wdGlvbmFsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IEJpbmRpbmcgc2V0dGluZ3MuXG4gKi9cblNvY2lhbC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcblxuLyoqXG4gKiBEb2VzIGNsZWFuaW5nIGZvciBldmVyeXRoaW5nIHRoYXQgaGF2ZSBOT1QgYmVlbiBzZXQgYnkgLmJpbmQoKSBtZXRob2QuXG4gKiBUaGlzIG1ldGhvZCBpcyBvcHRpb25hbC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfHVuZGVmaW5lZH0gUHJvbWlzZSBvciBub3RoaW5nLlxuICovXG5Tb2NpYWwucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFBBR0VTID0gcmVxdWlyZShcIi4uL2NvbmZpZy9wYWdlcy5qc29uXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJyZWFkY3J1bXBzO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IFN0b3JlIGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI3N0b3Jlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwiYnJlYWRjcnVtcHNcIiBzdG9yZS5cbiAqIEBwYXJhbSB7VUhSfSAkdWhyIFVuaXZlcnNhbCBIVFRQIHJlcXVlc3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnJlYWRjcnVtcHMoJHVocikge1xuICAgIHRoaXMuX3VociA9ICR1aHI7XG4gICAgdGhpcy4kY29udGV4dC5zZXREZXBlbmRlbmN5KCdQYWdlcycpO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgdW5pdmVyc2FsIEhUVFAgcmVxdWVzdCB0byBkbyBpdCBpbiBpc29tb3JwaGljIHdheS5cbiAqIEB0eXBlIHtVSFJ9XG4gKiBAcHJpdmF0ZVxuICovXG5CcmVhZGNydW1wcy5wcm90b3R5cGUuX3VociA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBsaWZldGltZSBvZiBkYXRhIChpbiBtaWxsaXNlY29uZHMpIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhpcyBzdG9yZS5cbiAqIEB0eXBlIHtudW1iZXJ9IExpZmV0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuQnJlYWRjcnVtcHMucHJvdG90eXBlLiRsaWZldGltZSA9IDYwMDAwO1xuXG4vKipcbiAqIExvYWRzIGRhdGEgZnJvbSByZW1vdGUgc291cmNlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IExvYWRlZCBkYXRhLlxuICovXG5CcmVhZGNydW1wcy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJyY3JtcCA9IFtdO1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnUGFnZXMnKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICAgICAgaWYgKHBhZ2UuY3VycmVudCA9PSBcIm1hc3Rlci1ydWJyaWthXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2xvYWRGb3JSdWJyaWthKCk7XG5cbiAgICAgICAgICAgIGlmIChwYWdlLmN1cnJlbnQgPT0gXCJuZXdzLWl0ZW1cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbG9hZEZvck5ld3NJdGVtKCk7XG5cbiAgICAgICAgICAgIGJyY3JtcC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogUEFHRVNbcGFnZS5jdXJyZW50XS50aXRsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYnJjcm1wO1xuICAgICAgICB9KTtcbn07XG5cbkJyZWFkY3J1bXBzLnByb3RvdHlwZS5fbG9hZEZvclJ1YnJpa2EgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnVGFnJylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBsaW5rcztcbiAgICAgICAgICAgIGlmIChkYXRhLnRhZy51bmlxdWUpIHtcbiAgICAgICAgICAgICAgICBsaW5rcyA9IHNlbGYuX2dldEZvclRhZyhkYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlua3MgPSBzZWxmLl9nZXRGb3JSdWJyaWthKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmtzO1xuICAgICAgICB9KTtcbn07XG5cbkJyZWFkY3J1bXBzLnByb3RvdHlwZS5fZ2V0Rm9yVGFnID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbGlua3MgPSB0aGlzLl9nZXRGb3JSdWJBbmRUYWcoZGF0YSk7XG4gICAgbGlua3MucHVzaCh7XG4gICAgICAgIHRpdGxlOiBkYXRhLnJ1YnJpa2EubmFtZSxcbiAgICAgICAgdXJsOiAnLycgKyBkYXRhLnJ1YnJpa2EucGFyZW50LnVuaXF1ZSArICcvJyArIGRhdGEucnVicmlrYS51bmlxdWVcbiAgICB9KTtcbiAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgdGl0bGU6IGRhdGEudGFnLm5hbWVcbiAgICB9KTtcbiAgICByZXR1cm4gbGlua3M7XG59O1xuXG5CcmVhZGNydW1wcy5wcm90b3R5cGUuX2dldEZvclJ1YnJpa2EgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsaW5rcyA9IHRoaXMuX2dldEZvclJ1YkFuZFRhZyhkYXRhKTtcbiAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgdGl0bGU6IGRhdGEucnVicmlrYS5uYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmtzO1xufTtcblxuQnJlYWRjcnVtcHMucHJvdG90eXBlLl9nZXRGb3JSdWJBbmRUYWcgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBwb2RydWJyaWtzID0gZGF0YS5ydWJyaWthLm5lYXJieTtcbiAgICB2YXIgbGlua3NQb2RydWJyaWtzID0gW107XG4gICAgdmFyIGxpbmtzID0gW107XG5cbiAgICBPYmplY3Qua2V5cyhwb2RydWJyaWtzKVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobnVtKSB7XG4gICAgICAgICAgICBpZiAocG9kcnVicmlrc1tudW1dLnN0YXR1cyA9PSAxKVxuICAgICAgICAgICAgICAgIGxpbmtzUG9kcnVicmlrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHBvZHJ1YnJpa3NbbnVtXS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB1cmw6ICcvJyArIGRhdGEucnVicmlrYS5wYXJlbnQudW5pcXVlICsgJy8nICsgcG9kcnVicmlrc1tudW1dLnVuaXF1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIGxpbmtzLnB1c2goe1xuICAgICAgICB0aXRsZTogXCLQmtCw0YLQsNC70L7QsyDRg9GB0LvRg9CzXCIsXG4gICAgICAgIHVybDogXCIvY2F0YWxvZ1wiXG4gICAgfSk7XG5cbiAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgdGl0bGU6IGRhdGEucnVicmlrYS5wYXJlbnQubmFtZSxcbiAgICAgICAgdXJsOiBcIi9cIiArIGRhdGEucnVicmlrYS5wYXJlbnQudW5pcXVlLFxuICAgICAgICBsaW5rczogbGlua3NQb2RydWJyaWtzXG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmtzO1xufTtcblxuQnJlYWRjcnVtcHMucHJvdG90eXBlLl9sb2FkRm9yTmV3c0l0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnb3RoZXIvTmV3c0l0ZW0nKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGxpbmtzID0gW107XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCLQndC+0LLQvtGB0YLQuFwiLFxuICAgICAgICAgICAgICAgIHVybDogXCIvbmV3c1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsaW5rcztcbiAgICAgICAgfSk7XG59O1xuLyoqXG4gKiBIYW5kbGVzIGFjdGlvbiBuYW1lZCBcInNvbWUtYWN0aW9uXCIgZnJvbSBhbnkgY29tcG9uZW50LlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IFJlc3BvbnNlIHRvIGNvbXBvbmVudC5cbiAqL1xuQnJlYWRjcnVtcHMucHJvdG90eXBlLmhhbmRsZVNvbWVBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSGVyZSB5b3UgY2FuIGNhbGwgdGhpcy4kY29udGV4dC5jaGFuZ2VkKCkgaWYgeW91IGtub3dcbiAgICAvLyB0aGF0IHJlbW90ZSBkYXRhIHNvdXJjZSBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgIC8vIEFsc28geW91IGNhbiBoYXZlIG1hbnkgaGFuZGxlIG1ldGhvZHMgZm9yIG90aGVyIGFjdGlvbnMuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUEFHRVMgPSByZXF1aXJlKFwiLi4vY29uZmlnL3BhZ2VzLmpzb25cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhZDtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBTdG9yZSBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNzdG9yZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcImhlYWRcIiBzdG9yZS5cbiAqIEBwYXJhbSB7VUhSfSAkdWhyIFVuaXZlcnNhbCBIVFRQIHJlcXVlc3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGVhZCgkdWhyKSB7XG4gICAgdGhpcy5fdWhyID0gJHVocjtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gXCJtYWluXCI7XG4gICAgdGhpcy4kY29udGV4dC5zZXREZXBlbmRlbmN5KCdQYWdlcycpO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgdW5pdmVyc2FsIEhUVFAgcmVxdWVzdCB0byBkbyBpdCBpbiBpc29tb3JwaGljIHdheS5cbiAqIEB0eXBlIHtVSFJ9XG4gKiBAcHJpdmF0ZVxuICovXG5IZWFkLnByb3RvdHlwZS5fdWhyID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IGxpZmV0aW1lIG9mIGRhdGEgKGluIG1pbGxpc2Vjb25kcykgdGhhdCBpcyByZXR1cm5lZCBieSB0aGlzIHN0b3JlLlxuICogQHR5cGUge251bWJlcn0gTGlmZXRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5IZWFkLnByb3RvdHlwZS4kbGlmZXRpbWUgPSA2MDAwMDtcblxuLyoqXG4gKiBMb2FkcyBkYXRhIGZyb20gcmVtb3RlIHNvdXJjZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBMb2FkZWQgZGF0YS5cbiAqL1xuSGVhZC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuZ2V0U3RvcmVEYXRhKCdQYWdlcycpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgICAgICBpZiAocGFnZS5jdXJyZW50ID09IFwibWFzdGVyLXJ1YnJpa2FcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbG9hZEZvclJ1YnJpa2EoKTtcbiAgICAgICAgICAgIGlmIChwYWdlLmN1cnJlbnQgPT0gXCJuZXdzLWl0ZW1cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbG9hZEZvck5ld3NJdGVtKCk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gUEFHRVNbcGFnZS5jdXJyZW50XTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy90aXRsZTogZGF0YS50aXRsZSArICcuIEZhY2VNYXN0ZXIucnUuINCh0L/QtdGG0LjQsNC70LjRgdGC0Ysg0KLQvtC70YzRj9GC0YLQuCcsXG4gICAgICAgICAgICAgICAgLy9kZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAvL2tleXdvcmRzOiBkYXRhLmtleXdvcmRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufTtcblxuSGVhZC5wcm90b3R5cGUuX2xvYWRGb3JSdWJyaWthID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnVGFnJylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGRhdGEuY3VycmVudFNlby5oZWFkVGl0bGUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRhdGEuY3VycmVudFNlby5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBrZXl3b3JkczogZGF0YS5jdXJyZW50U2VvLmtleXdvcmRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufTtcblxuSGVhZC5wcm90b3R5cGUuX2xvYWRGb3JOZXdzSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dC5nZXRTdG9yZURhdGEoJ290aGVyL05ld3NJdGVtJylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRhdGEucHJldmlldyxcbiAgICAgICAgICAgICAgICBrZXl3b3JkczogJ9C90L7QstC+0YHRgtGMLCBmYWNlbWFzdGVyJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG4vKipcbiAqIEhhbmRsZXMgYWN0aW9uIG5hbWVkIFwic29tZS1hY3Rpb25cIiBmcm9tIGFueSBjb21wb25lbnQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gUmVzcG9uc2UgdG8gY29tcG9uZW50LlxuICovXG5IZWFkLnByb3RvdHlwZS5oYW5kbGVTZXRDdXJyZW50UGFnZSA9IGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgdGhpcy4kY29udGV4dC5jaGFuZ2VkKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUEFHRVMgPSByZXF1aXJlKFwiLi4vY29uZmlnL3BhZ2VzLmpzb25cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnZXM7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgU3RvcmUgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjc3RvcmVzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJQYWdlc1wiIHN0b3JlLlxuICogQHBhcmFtIHtPYmplY3R9ICRjb25maWcgQXBwbGljYXRpb24gY29uZmlnLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBhZ2VzKCRjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSAkY29uZmlnO1xuICAgIHRoaXMuJGNvbnRleHQuc2V0RGVwZW5kZW5jeSgnVGFnJyk7XG59XG5cbi8qKlxuICogQ3VycmVudCBhcHBsaWNhdGlvbiBjb25maWcuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuUGFnZXMucHJvdG90eXBlLl9jb25maWcgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgbGlmZXRpbWUgb2YgZGF0YSAoaW4gbWlsbGlzZWNvbmRzKSB0aGF0IGlzIHJldHVybmVkIGJ5IHRoaXMgc3RvcmUuXG4gKiBAdHlwZSB7bnVtYmVyfSBMaWZldGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblBhZ2VzLnByb3RvdHlwZS4kbGlmZXRpbWUgPSAzNjAwMDAwO1xuXG4vKipcbiAqIExvYWRzIGRhdGEgZnJvbSByZW1vdGUgc291cmNlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IExvYWRlZCBkYXRhLlxuICovXG5QYWdlcy5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRQYWdlID0gc2VsZi4kY29udGV4dC5zdGF0ZS5wYWdlO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgxKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhZ2UgPT0gXCJtYXN0ZXItcnVicmlrYVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnVGFnJyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhZ2UgPT0gXCJtYXN0ZXItcGFnZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnbWFzdGVyL01hc3Rlckl0ZW0nKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZSA9PSBcIm5ld3MtaXRlbVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnb3RoZXIvTmV3c0l0ZW0nKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZSA9PSBcInZhY2FuY3ktaXRlbVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnb3RoZXIvVmFjYW5jeUl0ZW0nKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UGFnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLiRjb250ZXh0LnJlZGlyZWN0KCcvbWFpbicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIVBBR0VTLmhhc093blByb3BlcnR5KGN1cnJlbnRQYWdlKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuJGNvbnRleHQubm90Rm91bmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50OiBjdXJyZW50UGFnZSxcbiAgICAgICAgICAgICAgICBpc0FjdGl2ZToge30sXG5cbiAgICAgICAgICAgICAgICBoZWFkZXI6IHNlbGYuZ2V0SGVhZGVyRGF0YSgpLFxuICAgICAgICAgICAgICAgIGZvb3Rlcjogc2VsZi5nZXRGb290ZXJEYXRhKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhQQUdFUylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaXNBY3RpdmVbcGFnZV0gPSAoY3VycmVudFBhZ2UgPT09IHBhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG59O1xuXG5QYWdlcy5wcm90b3R5cGUuZ2V0SGVhZGVyRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2aXNpdENvdW50OiAnMTIgMzIzINC/0L7RgdC10YnQtdC90LjQuScsXG4gICAgICAgIGlzR3Vlc3Q6IHRydWVcbiAgICB9O1xufTtcblxuUGFnZXMucHJvdG90eXBlLmdldEZvb3RlckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGhvbmU6ICcoODQ4MikgNzQtNDQtMTknXG4gICAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2luYXRvcjtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBTdG9yZSBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNzdG9yZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIlBhZ2luYXRvclwiIHN0b3JlLlxuICogQHBhcmFtIHtVSFJ9ICR1aHIgVW5pdmVyc2FsIEhUVFAgcmVxdWVzdC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYWdpbmF0b3IoJHVocikge1xuICAgIHRoaXMuX3VociA9ICR1aHI7XG4gICAgdGhpcy5fbW9kZWw7XG59XG5cbi8qKlxuICogQ3VycmVudCB1bml2ZXJzYWwgSFRUUCByZXF1ZXN0IHRvIGRvIGl0IGluIGlzb21vcnBoaWMgd2F5LlxuICogQHR5cGUge1VIUn1cbiAqIEBwcml2YXRlXG4gKi9cblBhZ2luYXRvci5wcm90b3R5cGUuX3VociA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBsaWZldGltZSBvZiBkYXRhIChpbiBtaWxsaXNlY29uZHMpIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhpcyBzdG9yZS5cbiAqIEB0eXBlIHtudW1iZXJ9IExpZmV0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuUGFnaW5hdG9yLnByb3RvdHlwZS4kbGlmZXRpbWUgPSA2MDAwMDtcblxuLyoqXG4gKiBMb2FkcyBkYXRhIGZyb20gcmVtb3RlIHNvdXJjZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBMb2FkZWQgZGF0YS5cbiAqL1xuUGFnaW5hdG9yLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fbW9kZWwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3VycmVudFBhZ2UgPSB0aGlzLiRjb250ZXh0LnN0YXRlLmN1cnJlbnRQYWdlIHx8IDE7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLiRjb250ZXh0LmdldFN0b3JlRGF0YShzZWxmLl9tb2RlbCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLiRjb250ZXh0LnNlbmRBY3Rpb24oc2VsZi5fbW9kZWwsIFwiZ2V0UGFnaW5hdG9yXCIpXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YVsnaXMtcGFnaW5hdG9yJ10gPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBkYXRhLmN1cnJlbnQgLSA0IDwgMCA/IDEgOiBkYXRhLmN1cnJlbnQgLSA0O1xuICAgICAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgOSA8IGRhdGEuY291bnQgPyBzdGFydCArIDkgOiBkYXRhLmNvdW50O1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIFwiaXMtc2VsZWN0ZWRcIjogKGRhdGEuY3VycmVudCA9PSBpKSxcbiAgICAgICAgICAgICAgICAgICAgXCJ1cmxcIjogZGF0YS51cmwgKyBpLFxuICAgICAgICAgICAgICAgICAgICBcIm51bWJlclwiOiBpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHNlbGYuX21vZGVsLFxuICAgICAgICAgICAgICAgIFwiaXMtcGFnaW5hdG9yXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBkYXRhLnVybCArIDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGRhdGEudXJsICsgZGF0YS5jb3VudFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGlzdDogbGlzdFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBhY3Rpb24gbmFtZWQgXCJzb21lLWFjdGlvblwiIGZyb20gYW55IGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBSZXNwb25zZSB0byBjb21wb25lbnQuXG4gKi9cblBhZ2luYXRvci5wcm90b3R5cGUuaGFuZGxlU2V0TW9kZWwgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xufTtcblBhZ2luYXRvci5wcm90b3R5cGUuaGFuZGxlR2V0Q3VycmVudFBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQuc3RhdGUuY3VycmVudFBhZ2UgfHwgMTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUYWc7XG5cbi8qXG4gKiBUaGlzIGlzIGEgQ2F0YmVycnkgU3RvcmUgZmlsZS5cbiAqIE1vcmUgZGV0YWlscyBjYW4gYmUgZm91bmQgaGVyZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjc3RvcmVzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgXCJ0YWdcIiBzdG9yZS5cbiAqIEBwYXJhbSB7VUhSfSAkdWhyIFVuaXZlcnNhbCBIVFRQIHJlcXVlc3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVGFnKCR1aHIpIHtcbiAgICB0aGlzLl91aHIgPSAkdWhyO1xuICAgIHRoaXMuJGNvbnRleHQuc2V0RGVwZW5kZW5jeSgncnVicmlrYS9SdWJyaWthJyk7XG59XG5cbi8qKlxuICogQ3VycmVudCB1bml2ZXJzYWwgSFRUUCByZXF1ZXN0IHRvIGRvIGl0IGluIGlzb21vcnBoaWMgd2F5LlxuICogQHR5cGUge1VIUn1cbiAqIEBwcml2YXRlXG4gKi9cblRhZy5wcm90b3R5cGUuX3VociA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBsaWZldGltZSBvZiBkYXRhIChpbiBtaWxsaXNlY29uZHMpIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhpcyBzdG9yZS5cbiAqIEB0eXBlIHtudW1iZXJ9IExpZmV0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuVGFnLnByb3RvdHlwZS4kbGlmZXRpbWUgPSA2MDAwMDtcblxuLyoqXG4gKiBMb2FkcyBkYXRhIGZyb20gcmVtb3RlIHNvdXJjZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBMb2FkZWQgZGF0YS5cbiAqL1xuVGFnLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuJGNvbnRleHQuc3RhdGUuc2VjdGlvbiB8fCAnbWFzdGVyJztcbiAgICB2YXIgdGFnID0gdGhpcy4kY29udGV4dC5zdGF0ZS50YWcgfHwgJyc7XG4gICAgdmFyIGRhdGEgPSB7fTtcblxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YShcInJ1YnJpa2EvUnVicmlrYVwiKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocnVicmlrYSkge1xuICAgICAgICAgICAgZGF0YS5ydWJyaWthID0gcnVicmlrYTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gJ2h0dHA6Ly9hcGktZm0ucHJlc2VudC10bHQucnUvdGFnJztcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6ICdbXCJhbmRcIixbXCI9XCIsIFwidW5pcXVlXCIsIFwiJyArIHRhZyArICdcIl0sW1wiPVwiLFwic3RhdHVzXCIsXCIxXCJdXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBhbmQ6ICdzZW8nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl91aHIuZ2V0KHBhdGgsIG9wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMuY29kZSA+PSA0MDAgJiYgcmVzdWx0LnN0YXR1cy5jb2RlIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5zdGF0dXMudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbnRlbnRbMF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICh0YWdEYXRhKSB7XG4gICAgICAgICAgICBpZiAodGFnICYmIHRhZ0RhdGEgPT0ge30pXG4gICAgICAgICAgICAgICAgc2VsZi4kY29udGV4dC5ub3RGb3VuZCgpO1xuXG4gICAgICAgICAgICBkYXRhLnRhZyA9IHRhZ0RhdGE7XG4gICAgICAgICAgICBkYXRhLnNlY3Rpb24gPSBzZWN0aW9uO1xuICAgICAgICAgICAgZGF0YS5jdXJyZW50U2VvID0gdGFnID8gc2VsZi5fZ2V0Q3VycmVudFNlbyhkYXRhLnRhZywgZGF0YS5zZWN0aW9uKSA6IHNlbGYuX2dldEN1cnJlbnRTZW8oZGF0YS5ydWJyaWthLCBkYXRhLnNlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGFjdGlvbiBuYW1lZCBcInNvbWUtYWN0aW9uXCIgZnJvbSBhbnkgY29tcG9uZW50LlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IFJlc3BvbnNlIHRvIGNvbXBvbmVudC5cbiAqL1xuVGFnLnByb3RvdHlwZS5oYW5kbGVTb21lQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEhlcmUgeW91IGNhbiBjYWxsIHRoaXMuJGNvbnRleHQuY2hhbmdlZCgpIGlmIHlvdSBrbm93XG4gICAgLy8gdGhhdCByZW1vdGUgZGF0YSBzb3VyY2UgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAvLyBBbHNvIHlvdSBjYW4gaGF2ZSBtYW55IGhhbmRsZSBtZXRob2RzIGZvciBvdGhlciBhY3Rpb25zLlxufTtcblxuVGFnLnByb3RvdHlwZS5fZ2V0Q3VycmVudFNlbyA9IGZ1bmN0aW9uIChkYXRhLCBzZWN0aW9uKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgc2VvID0gZGF0YS5zZW87XG5cbiAgICBPYmplY3Qua2V5cyhzZW8pXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uID09IHNlb1trZXldLnNlY3Rpb24pXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc2VvW2tleV07XG4gICAgICAgIH0pO1xuICAgIGlmICghcmVzdWx0KVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZFRpdGxlOiBkYXRhLm5hbWUsXG4gICAgICAgICAgICBwYWdlVGl0bGU6IGRhdGEubmFtZVxuICAgICAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRhdGVGb3JtYXQgPSByZXF1aXJlKCcuLi8uLi9saWIvdXRpbC9EYXRlRm9ybWF0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFzdGVySXRlbTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBTdG9yZSBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNzdG9yZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm1hc3Rlci9NYXN0ZXJJdGVtXCIgc3RvcmUuXG4gKiBAcGFyYW0ge1VIUn0gJHVociBVbml2ZXJzYWwgSFRUUCByZXF1ZXN0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hc3Rlckl0ZW0oJHVocikge1xuICAgIHRoaXMuX3VociA9ICR1aHI7XG59XG5cbi8qKlxuICogQ3VycmVudCB1bml2ZXJzYWwgSFRUUCByZXF1ZXN0IHRvIGRvIGl0IGluIGlzb21vcnBoaWMgd2F5LlxuICogQHR5cGUge1VIUn1cbiAqIEBwcml2YXRlXG4gKi9cbk1hc3Rlckl0ZW0ucHJvdG90eXBlLl91aHIgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgbGlmZXRpbWUgb2YgZGF0YSAoaW4gbWlsbGlzZWNvbmRzKSB0aGF0IGlzIHJldHVybmVkIGJ5IHRoaXMgc3RvcmUuXG4gKiBAdHlwZSB7bnVtYmVyfSBMaWZldGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbk1hc3Rlckl0ZW0ucHJvdG90eXBlLiRsaWZldGltZSA9IDYwMDAwO1xuXG4vKipcbiAqIExvYWRzIGRhdGEgZnJvbSByZW1vdGUgc291cmNlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IExvYWRlZCBkYXRhLlxuICovXG5NYXN0ZXJJdGVtLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaWQgPSB0aGlzLiRjb250ZXh0LnN0YXRlLml0ZW07XG4gICAgaWYgKCFpZClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgbm93ID0gZGF0ZUZvcm1hdChub3csIFwieXl5eS1tbS1kZFwiKTtcbiAgICB2YXIgcGF0aCA9ICdodHRwOi8vYXBpLWZtLnByZXNlbnQtdGx0LnJ1L21hc3Rlci1wYWdlJztcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZmlsdGVyOiAnW1wiYW5kXCIsIFtcIj1cIixcIm51bWJlclwiLCBcIicgKyBpZCArICdcIl0sW1wiPD1cIiwgXCJkYXRlU3RhcnRcIiwgXCInICsgbm93ICsgJ1wiXSxbXCI+PVwiLCBcImRhdGVFbmRcIiwgXCInICsgbm93ICsgJ1wiXV0nXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl91aHIuZ2V0KHBhdGgsIG9wdGlvbnMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzLmNvZGUgPj0gNDAwICYmIHJlc3VsdC5zdGF0dXMuY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuc3RhdHVzLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHNlbGYuJGNvbnRleHQubm90Rm91bmQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb250ZW50WzBdO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICAgICAgdmFyIHBhdGhNID0gJ2h0dHA6Ly9hcGktZm0ucHJlc2VudC10bHQucnUvbWFzdGVyJztcbiAgICAgICAgICAgIHZhciBvcHRpb25NID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAnW1wiYW5kXCIsIFtcIj1cIiwgXCJpZFwiLCBcIicgKyBwYWdlLm1hc3RlcklEICsgJ1wiXSxbXCI9XCIsXCJwdWJsaWNTdGF0dXNcIiwgXCIxXCJdXScsXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZDogJ2NvbnRhY3RzLGFydGljbGVzLGNvbW1lbnRzLGRpc3RyaWN0cyxhbGJ1bXMsc2FsZXMsc2NoZWR1bGUsdmlkZW9zLHdvcmtDb25kaXRpb24sY2FsbGJhY2tzLHZrTGlrZXMscnVicmlrYSx0YWdzLGNvbXBhbnknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl91aHIuZ2V0KHBhdGhNLCBvcHRpb25NKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMuY29kZSA+PSA0MDAgJiYgcmVzdWx0LnN0YXR1cy5jb2RlIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LnN0YXR1cy50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLiRjb250ZXh0Lm5vdEZvdW5kKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSByZXN1bHQuY29udGVudFswXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5zZXJ2aWNlcyA9IEpTT04ucGFyc2UoZGF0YS5zZXJ2aWNlcyk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuaXNCbG9jayA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZpY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3M6IHBhZ2Uuc2VydmljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCLQo9GB0LvRg9Cz0LhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwi0KPRgdC70L7QstC40Y8g0YDQsNCx0L7RgtGLXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2FsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VzczogcGFnZS5zYWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcItCh0LrQuNC00LrQuCDQuCDQv9C+0LTQsNGA0LrQuFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogKGRhdGEuc2FsZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm91dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcItCeINGB0LXQsdC1XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLmFib3V0RWR1YyB8fCBkYXRhLmFib3V0RXhwIHx8ZGF0YS5hYm91dEFkZEluZm9cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnRpY2xlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzOiBwYWdlLmFydGljbGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwi0J/QvtC70LXQt9C90L4g0L/QvtGH0LjRgtCw0YLRjFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogKGRhdGEuYXJ0aWNsZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwaG90bzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VzczogcGFnZS5hbGJ1bXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCLQpNC+0YLQvlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogKGRhdGEuYWxidW1zLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3M6IHBhZ2UudmlkZW9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwi0JLQuNC00LXQvlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogKGRhdGEudmlkZW9zLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VzczogcGFnZS5saW5rcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcItCh0YHRi9C70LrQuFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogKGRhdGEubGlua3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2aWV3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzOiBwYWdlLmNvbW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwi0J7RgtC30YvQstGLINC4INGA0LXQutC+0LzQtdC90LTQsNGG0LjQuFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnBhZ2UgPSBwYWdlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYWN0aW9uIG5hbWVkIFwic29tZS1hY3Rpb25cIiBmcm9tIGFueSBjb21wb25lbnQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gUmVzcG9uc2UgdG8gY29tcG9uZW50LlxuICovXG5NYXN0ZXJJdGVtLnByb3RvdHlwZS5oYW5kbGVTb21lQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEhlcmUgeW91IGNhbiBjYWxsIHRoaXMuJGNvbnRleHQuY2hhbmdlZCgpIGlmIHlvdSBrbm93XG4gICAgLy8gdGhhdCByZW1vdGUgZGF0YSBzb3VyY2UgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAvLyBBbHNvIHlvdSBjYW4gaGF2ZSBtYW55IGhhbmRsZSBtZXRob2RzIGZvciBvdGhlciBhY3Rpb25zLlxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNYXN0ZXJMaXN0O1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IFN0b3JlIGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI3N0b3Jlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwibWFzdGVyL21hc3Rlckxpc3RcIiBzdG9yZS5cbiAqIEBwYXJhbSB7VUhSfSAkdWhyIFVuaXZlcnNhbCBIVFRQIHJlcXVlc3QudGhpc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hc3Rlckxpc3QoJHVocikge1xuICAgIHRoaXMuX3VociA9ICR1aHI7XG4gICAgdGhpcy5fY3VycmVudEZlZWQgPSBbXTtcbiAgICB0aGlzLiRjb250ZXh0LnNldERlcGVuZGVuY3koJ1RhZycpO1xufVxuXG5NYXN0ZXJMaXN0LnByb3RvdHlwZS5fY3VycmVudEZlZWQgPSBudWxsO1xuTWFzdGVyTGlzdC5wcm90b3R5cGUuX2N1cnJlbnRQYWdlID0gMTtcbk1hc3Rlckxpc3QucHJvdG90eXBlLl9pc0ZpbmlzaGVkID0gZmFsc2U7XG5cbi8qKlxuICogQ3VycmVudCB1bml2ZXJzYWwgSFRUUCByZXF1ZXN0IHRvIGRvIGl0IGluIGlzb21vcnBoaWMgd2F5LlxuICogQHR5cGUge1VIUn1cbiAqIEBwcml2YXRlXG4gKi9cbk1hc3Rlckxpc3QucHJvdG90eXBlLl91aHIgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgbGlmZXRpbWUgb2YgZGF0YSAoaW4gbWlsbGlzZWNvbmRzKSB0aGF0IGlzIHJldHVybmVkIGJ5IHRoaXMgc3RvcmUuXG4gKiBAdHlwZSB7bnVtYmVyfSBMaWZldGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbk1hc3Rlckxpc3QucHJvdG90eXBlLiRsaWZldGltZSA9IDYwMDAwO1xuXG4vKipcbiAqIExvYWRzIGRhdGEgZnJvbSByZW1vdGUgc291cmNlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IExvYWRlZCBkYXRhLlxuICovXG5NYXN0ZXJMaXN0LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0LmdldFN0b3JlRGF0YSgnVGFnJylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgICAgaWYgKCF0YWcucnVicmlrYSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLl9jbGVhckZlZWQodGFnKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9sb2FkRGF0YVBlclBhZ2Uoc2VsZi5fY3VycmVudFBhZ2UsIHRhZy5ydWJyaWthLmlkLCB0YWcudGFnLmlkKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQgfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2lzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9jdXJyZW50RmVlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fc3RydWNydXJSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2N1cnJlbnRGZWVkID0gc2VsZi5fY3VycmVudEZlZWQuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fY3VycmVudEZlZWQ7XG4gICAgICAgIH0pO1xufTtcbk1hc3Rlckxpc3QucHJvdG90eXBlLl9jbGVhckZlZWQgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgdGhpcy5fY3VycmVudFJ1YnJpa2EgPSB0aGlzLl9jdXJyZW50UnVicmlrYSB8fCB0YWcucnVicmlrYS5pZDtcbiAgICB0aGlzLl9jdXJyZW50VGFnID0gdGhpcy5fY3VycmVudFRhZyB8fCB0YWcudGFnLmlkO1xuICAgIGlmICh0aGlzLl9jdXJyZW50UnVicmlrYSAhPSB0YWcucnVicmlrYS5pZCB8fCB0aGlzLl9jdXJyZW50VGFnICE9IHRhZy50YWcuaWQpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEZlZWQgPSBbXTtcbiAgICAgICAgdGhpcy5fY3VycmVudFBhZ2UgPSAxO1xuICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRSdWJyaWthID0gdGFnLnJ1YnJpa2EuaWQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYWcgPSB0YWcudGFnLmlkO1xuICAgIH1cbn07XG5NYXN0ZXJMaXN0LnByb3RvdHlwZS5fbG9hZERhdGFQZXJQYWdlID0gZnVuY3Rpb24gKHBhZ2UsIHJ1YnJpa2FJRCwgdGFnSUQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBhdGggPSAnaHR0cDovL2FwaS1mbS5wcmVzZW50LXRsdC5ydS9tYXN0ZXIvYWN0aXZlJztcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZmlsdGVyOiAnW1wiYW5kXCIsW1wiPVwiLCBcInJ1YnJpa2FJRFwiLCBcIicgKyBydWJyaWthSUQgKyAnXCJdXScsXG4gICAgICAgICAgICBleHBhbmQ6ICdjb21tZW50cyxzYWxlcyx2aWRlb3MsdmtMaWtlcyxhbGJ1bXMsY29udGFjdHMscGFnZSxjb21wYW55JyxcbiAgICAgICAgICAgIG9yZGVyOiAnc29ydCcsXG4gICAgICAgICAgICBwYWdlOiBwYWdlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0YWdJRCkge1xuICAgICAgICBwYXRoID0gJ2h0dHA6Ly9hcGktZm0ucHJlc2VudC10bHQucnUvbWFzdGVyL2J5dGFnLycgKyB0YWdJRDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5fdWhyLmdldChwYXRoLCBvcHRpb25zKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cy5jb2RlID49IDQwMCAmJiByZXN1bHQuc3RhdHVzLmNvZGUgPCA2MDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LnN0YXR1cy50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29udGVudDtcbiAgICAgICAgfSk7XG59O1xuXG5NYXN0ZXJMaXN0LnByb3RvdHlwZS5fc3RydWNydXJSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKG1hc3Rlcikge1xuICAgICAgICBtYXN0ZXIuc2VydmljZXMgPSBKU09OLnBhcnNlKG1hc3Rlci5zZXJ2aWNlcyk7XG4gICAgICAgIGlmIChtYXN0ZXIudmtMaWtlcykge1xuICAgICAgICAgICAgbWFzdGVyLnZrTGlrZXMuY291bnRMaWtlcyA9IG1hc3Rlci52a0xpa2VzLmNvdW50TGlrZXMgPyBtYXN0ZXIudmtMaWtlcy5jb3VudExpa2VzIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hc3Rlci52a0xpa2VzID0ge307XG4gICAgICAgICAgICBtYXN0ZXIudmtMaWtlcy5jb3VudExpa2VzID0gMDtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8qKlxuICogSGFuZGxlcyBhY3Rpb24gbmFtZWQgXCJzb21lLWFjdGlvblwiIGZyb20gYW55IGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBSZXNwb25zZSB0byBjb21wb25lbnQuXG4gKi9cbk1hc3Rlckxpc3QucHJvdG90eXBlLmhhbmRsZUdldE5leHRQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5fY3VycmVudEZlZWQgfHwgc2VsZi5fY3VycmVudEZlZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgc2VsZi5fY3VycmVudFBhZ2UrKztcbiAgICAgICAgICAgIHNlbGYuJGNvbnRleHQuY2hhbmdlZCgpO1xuICAgICAgICB9KTtcblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNYXN0ZXJTb3ZldHk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuXHRcdFN0b3JlUGFnaW5hdG9yID0gcmVxdWlyZSgnLi4vLi4vbGliL1N0b3JlUGFnaW5hdG9yJyk7XG5cbnV0aWwuaW5oZXJpdHMoTWFzdGVyU292ZXR5LCBTdG9yZVBhZ2luYXRvcik7XG5cbmZ1bmN0aW9uIE1hc3RlclNvdmV0eSgpIHtcblx0U3RvcmVQYWdpbmF0b3IuY2FsbCh0aGlzKTtcblx0dGhpcy5fcGF0aCA9ICdodHRwOi8vYXBpLWZtLnByZXNlbnQtdGx0LnJ1L2FydGljbGUvYWN0aXZlJztcblx0dGhpcy5fb3B0aW9ucyA9IHtcblx0XHRkYXRhOiB7XG5cdFx0XHRvcmRlcjogJ2lkIERFU0MnXG5cdFx0fVxuXHR9O1xuXHR0aGlzLl91cmwgPSBcIi9zb3ZldHkvcGFnZS9cIjtcblx0dGhpcy5fY2F0YWxvZyA9IHRoaXMuJGNvbnRleHQuc3RhdGUuY2F0YWxvZztcblx0aWYgKHRoaXMuX2NhdGFsb2cpIHtcblx0XHR0aGlzLl9vcHRpb25zLmRhdGEuZmlsdGVyID0gJ1tbXCI9XCIsXCJydWJyaWthSURcIixcIicgKyB0aGlzLl9jYXRhbG9nICsgJ1wiXV0nO1xuXHRcdHRoaXMuX3VybCA9IFwiL3NvdmV0eS9jYXRhbG9nL1wiICsgdGhpcy5fY2F0YWxvZyArIFwiL3BhZ2UvXCI7XG5cdH1cbn0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFzdGVyVmlkZW87XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuICAgIFN0b3JlUGFnaW5hdG9yID0gcmVxdWlyZSgnLi4vLi4vbGliL1N0b3JlUGFnaW5hdG9yJyk7XG5cbnV0aWwuaW5oZXJpdHMoTWFzdGVyVmlkZW8sIFN0b3JlUGFnaW5hdG9yKTtcblxuZnVuY3Rpb24gTWFzdGVyVmlkZW8oKSB7XG4gICAgU3RvcmVQYWdpbmF0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9wYXRoID0gJ2h0dHA6Ly9hcGktZm0ucHJlc2VudC10bHQucnUvdmlkZW8vYWN0aXZlJztcbiAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBvcmRlcjogJ2lkIERFU0MnXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IFwiL3ZpZGVvL3BhZ2UvXCI7XG4gICAgdGhpcy5fY2F0YWxvZyA9IHRoaXMuJGNvbnRleHQuc3RhdGUuY2F0YWxvZztcbiAgICBpZiAodGhpcy5fY2F0YWxvZykge1xuICAgICAgICB0aGlzLl9vcHRpb25zLmRhdGEuZmlsdGVyID0gJ1tbXCI9XCIsXCJydWJyaWthSURcIixcIicgKyB0aGlzLl9jYXRhbG9nICsgJ1wiXV0nO1xuICAgICAgICB0aGlzLl91cmwgPSBcIi92aWRlby9jYXRhbG9nL1wiICsgdGhpcy5fY2F0YWxvZyArIFwiL3BhZ2UvXCI7XG4gICAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWNvbW1lbmRlZDtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBTdG9yZSBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNzdG9yZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm1hc3Rlci9SZWNvbW1lbmRlZFwiIHN0b3JlLlxuICogQHBhcmFtIHtVSFJ9ICR1aHIgVW5pdmVyc2FsIEhUVFAgcmVxdWVzdC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZWNvbW1lbmRlZCgkdWhyKSB7XG5cdHRoaXMuX3VociA9ICR1aHI7XG59XG5cbi8qKlxuICogQ3VycmVudCB1bml2ZXJzYWwgSFRUUCByZXF1ZXN0IHRvIGRvIGl0IGluIGlzb21vcnBoaWMgd2F5LlxuICogQHR5cGUge1VIUn1cbiAqIEBwcml2YXRlXG4gKi9cblJlY29tbWVuZGVkLnByb3RvdHlwZS5fdWhyID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IGxpZmV0aW1lIG9mIGRhdGEgKGluIG1pbGxpc2Vjb25kcykgdGhhdCBpcyByZXR1cm5lZCBieSB0aGlzIHN0b3JlLlxuICogQHR5cGUge251bWJlcn0gTGlmZXRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5SZWNvbW1lbmRlZC5wcm90b3R5cGUuJGxpZmV0aW1lID0gNjAwMDA7XG5cbi8qKlxuICogTG9hZHMgZGF0YSBmcm9tIHJlbW90ZSBzb3VyY2UuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gTG9hZGVkIGRhdGEuXG4gKi9cblJlY29tbWVuZGVkLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHQvLyBIZXJlIHlvdSBjYW4gZG8gYW55IEhUVFAgcmVxdWVzdHMgdXNpbmcgdGhpcy5fdWhyLlxuXHQvLyBQbGVhc2UgcmVhZCBkZXRhaWxzIGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5LXVoci5cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhY3Rpb24gbmFtZWQgXCJzb21lLWFjdGlvblwiIGZyb20gYW55IGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBSZXNwb25zZSB0byBjb21wb25lbnQuXG4gKi9cblJlY29tbWVuZGVkLnByb3RvdHlwZS5oYW5kbGVTb21lQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQvLyBIZXJlIHlvdSBjYW4gY2FsbCB0aGlzLiRjb250ZXh0LmNoYW5nZWQoKSBpZiB5b3Uga25vd1xuXHQvLyB0aGF0IHJlbW90ZSBkYXRhIHNvdXJjZSBoYXMgYmVlbiBjaGFuZ2VkLlxuXHQvLyBBbHNvIHlvdSBjYW4gaGF2ZSBtYW55IGhhbmRsZSBtZXRob2RzIGZvciBvdGhlciBhY3Rpb25zLlxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBOZXdzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBTdG9yZVBhZ2luYXRvciA9IHJlcXVpcmUoJy4uLy4uL2xpYi9TdG9yZVBhZ2luYXRvcicpO1xuXG51dGlsLmluaGVyaXRzKE5ld3MsIFN0b3JlUGFnaW5hdG9yKTtcblxuZnVuY3Rpb24gTmV3cygpIHtcbiAgICBTdG9yZVBhZ2luYXRvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3BhdGggPSAnaHR0cDovL2FwaS1mbS5wcmVzZW50LXRsdC5ydS9hYm91dC1uZXdzJztcbiAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBmaWx0ZXI6ICdbXCJhbmRcIixbXCI9XCIsXCJzdGF0dXNcIixcIjFcIl1dJyxcbiAgICAgICAgICAgIG9yZGVyOiAnZGF0ZSBERVNDJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBcIi9uZXdzL3BhZ2UvXCI7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5ld3NJdGVtO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IFN0b3JlIGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI3N0b3Jlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwib3RoZXIvTmV3c0l0ZW1cIiBzdG9yZS5cbiAqIEBwYXJhbSB7VUhSfSAkdWhyIFVuaXZlcnNhbCBIVFRQIHJlcXVlc3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTmV3c0l0ZW0oJHVocikge1xuICAgIHRoaXMuX3VociA9ICR1aHI7XG59XG5cbi8qKlxuICogQ3VycmVudCB1bml2ZXJzYWwgSFRUUCByZXF1ZXN0IHRvIGRvIGl0IGluIGlzb21vcnBoaWMgd2F5LlxuICogQHR5cGUge1VIUn1cbiAqIEBwcml2YXRlXG4gKi9cbk5ld3NJdGVtLnByb3RvdHlwZS5fdWhyID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IGxpZmV0aW1lIG9mIGRhdGEgKGluIG1pbGxpc2Vjb25kcykgdGhhdCBpcyByZXR1cm5lZCBieSB0aGlzIHN0b3JlLlxuICogQHR5cGUge251bWJlcn0gTGlmZXRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5OZXdzSXRlbS5wcm90b3R5cGUuJGxpZmV0aW1lID0gNjAwMDA7XG5cbi8qKlxuICogTG9hZHMgZGF0YSBmcm9tIHJlbW90ZSBzb3VyY2UuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gTG9hZGVkIGRhdGEuXG4gKi9cbk5ld3NJdGVtLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaXRlbSA9IHRoaXMuJGNvbnRleHQuc3RhdGUuaXRlbTtcbiAgICB2YXIgcGF0aCA9ICdodHRwOi8vYXBpLWZtLnByZXNlbnQtdGx0LnJ1L2Fib3V0LW5ld3MnO1xuICAgIGlmICghaXRlbSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIG9wdGlvbiA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZmlsdGVyOiAnW1wiYW5kXCIsW1wiPVwiLFwiaWRcIixcIicgKyBpdGVtICsgJ1wiXSxbXCI9XCIsIFwic3RhdHVzXCIsIFwiMVwiXV0nXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl91aHIuZ2V0KHBhdGgsIG9wdGlvbilcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzLmNvZGUgPj0gNDAwICYmIHJlc3VsdC5zdGF0dXMuY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuc3RhdHVzLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIHNlbGYuJGNvbnRleHQubm90Rm91bmQoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb250ZW50WzBdO1xuICAgICAgICB9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBhY3Rpb24gbmFtZWQgXCJzb21lLWFjdGlvblwiIGZyb20gYW55IGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBSZXNwb25zZSB0byBjb21wb25lbnQuXG4gKi9cbk5ld3NJdGVtLnByb3RvdHlwZS5oYW5kbGVTb21lQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gSGVyZSB5b3UgY2FuIGNhbGwgdGhpcy4kY29udGV4dC5jaGFuZ2VkKCkgaWYgeW91IGtub3dcbiAgICAvLyB0aGF0IHJlbW90ZSBkYXRhIHNvdXJjZSBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgIC8vIEFsc28geW91IGNhbiBoYXZlIG1hbnkgaGFuZGxlIG1ldGhvZHMgZm9yIG90aGVyIGFjdGlvbnMuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY29tbWVuZGF0aW9uO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBTdG9yZVBhZ2luYXRvciA9IHJlcXVpcmUoJy4uLy4uL2xpYi9TdG9yZVBhZ2luYXRvcicpO1xuXG51dGlsLmluaGVyaXRzKFJlY29tbWVuZGF0aW9uLCBTdG9yZVBhZ2luYXRvcik7XG5cbmZ1bmN0aW9uIFJlY29tbWVuZGF0aW9uKCkge1xuICAgIFN0b3JlUGFnaW5hdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcGF0aCA9ICdodHRwOi8vYXBpLWZtLnByZXNlbnQtdGx0LnJ1L2Fib3V0LWNvbW1lbnQnO1xuICAgIHRoaXMuX3VybCA9IFwiL3JlY29tbWVuZGF0aW9uL3BhZ2UvXCI7XG59IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRhdGVGb3JtYXQgPSByZXF1aXJlKCcuLi8uLi9saWIvdXRpbC9EYXRlRm9ybWF0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmFjYW5jeTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBTdG9yZSBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNzdG9yZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm90aGVyL3ZhY2FuY3lcIiBzdG9yZS5cbiAqIEBwYXJhbSB7VUhSfSAkdWhyIFVuaXZlcnNhbCBIVFRQIHJlcXVlc3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVmFjYW5jeSgkdWhyKSB7XG4gICAgdGhpcy5fdWhyID0gJHVocjtcbn1cblxuLyoqXG4gKiBDdXJyZW50IHVuaXZlcnNhbCBIVFRQIHJlcXVlc3QgdG8gZG8gaXQgaW4gaXNvbW9ycGhpYyB3YXkuXG4gKiBAdHlwZSB7VUhSfVxuICogQHByaXZhdGVcbiAqL1xuVmFjYW5jeS5wcm90b3R5cGUuX3VociA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBsaWZldGltZSBvZiBkYXRhIChpbiBtaWxsaXNlY29uZHMpIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhpcyBzdG9yZS5cbiAqIEB0eXBlIHtudW1iZXJ9IExpZmV0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuVmFjYW5jeS5wcm90b3R5cGUuJGxpZmV0aW1lID0gNjAwMDA7XG5cbi8qKlxuICogTG9hZHMgZGF0YSBmcm9tIHJlbW90ZSBzb3VyY2UuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gTG9hZGVkIGRhdGEuXG4gKi9cblZhY2FuY3kucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGggPSAnaHR0cDovL2FwaS1mbS5wcmVzZW50LXRsdC5ydS9hYm91dC12YWNhbmN5JztcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBub3cgPSBkYXRlRm9ybWF0KG5vdywgXCJ5eXl5LW1tLWRkXCIpO1xuICAgIG5vdyA9IFwiMjAxNC0wMy0yMFwiOyAvL9C00LvRjyDRgtC10YHRgtCwIC0g0YPQsdGA0LDRgtGMIVxuXG4gICAgdmFyIG9wdGlvbiA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZmlsdGVyOiAnW1wiYW5kXCIsW1wiPD1cIixcImNyZWF0ZURhdGVcIixcIicgKyBub3cgKyAnXCJdLFtcIj49XCIsIFwiZW5kRGF0ZVwiLCBcIicgKyBub3cgKyAnXCJdLFtcIj1cIiwgXCJzdGF0dXNcIiwgXCIxXCJdXSdcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX3Voci5nZXQocGF0aCwgb3B0aW9uKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cy5jb2RlID49IDQwMCAmJiByZXN1bHQuc3RhdHVzLmNvZGUgPCA2MDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LnN0YXR1cy50ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb250ZW50O1xuICAgICAgICB9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBhY3Rpb24gbmFtZWQgXCJzb21lLWFjdGlvblwiIGZyb20gYW55IGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBSZXNwb25zZSB0byBjb21wb25lbnQuXG4gKi9cblZhY2FuY3kucHJvdG90eXBlLmhhbmRsZVNvbWVBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSGVyZSB5b3UgY2FuIGNhbGwgdGhpcy4kY29udGV4dC5jaGFuZ2VkKCkgaWYgeW91IGtub3dcbiAgICAvLyB0aGF0IHJlbW90ZSBkYXRhIHNvdXJjZSBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgIC8vIEFsc28geW91IGNhbiBoYXZlIG1hbnkgaGFuZGxlIG1ldGhvZHMgZm9yIG90aGVyIGFjdGlvbnMuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGF0ZUZvcm1hdCA9IHJlcXVpcmUoJy4uLy4uL2xpYi91dGlsL0RhdGVGb3JtYXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWYWNhbmN5SXRlbTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBTdG9yZSBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNzdG9yZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcIm90aGVyL3ZhY2FuY3lJdGVtXCIgc3RvcmUuXG4gKiBAcGFyYW0ge1VIUn0gJHVociBVbml2ZXJzYWwgSFRUUCByZXF1ZXN0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFZhY2FuY3lJdGVtKCR1aHIpIHtcbiAgICB0aGlzLl91aHIgPSAkdWhyO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgdW5pdmVyc2FsIEhUVFAgcmVxdWVzdCB0byBkbyBpdCBpbiBpc29tb3JwaGljIHdheS5cbiAqIEB0eXBlIHtVSFJ9XG4gKiBAcHJpdmF0ZVxuICovXG5WYWNhbmN5SXRlbS5wcm90b3R5cGUuX3VociA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBsaWZldGltZSBvZiBkYXRhIChpbiBtaWxsaXNlY29uZHMpIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhpcyBzdG9yZS5cbiAqIEB0eXBlIHtudW1iZXJ9IExpZmV0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuVmFjYW5jeUl0ZW0ucHJvdG90eXBlLiRsaWZldGltZSA9IDYwMDAwO1xuXG4vKipcbiAqIExvYWRzIGRhdGEgZnJvbSByZW1vdGUgc291cmNlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IExvYWRlZCBkYXRhLlxuICovXG5WYWNhbmN5SXRlbS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGlkID0gdGhpcy4kY29udGV4dC5zdGF0ZS5pdGVtO1xuICAgIGlmICghaWQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgcGF0aCA9ICdodHRwOi8vYXBpLWZtLnByZXNlbnQtdGx0LnJ1L2Fib3V0LXZhY2FuY3knO1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIG5vdyA9IGRhdGVGb3JtYXQobm93LCBcInl5eXktbW0tZGRcIik7XG4gICAgbm93ID0gXCIyMDE0LTAzLTIwXCI7IC8v0LTQu9GPINGC0LXRgdGC0LAgLSDRg9Cx0YDQsNGC0YwhXG5cbiAgICB2YXIgb3B0aW9uID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBmaWx0ZXI6ICdbXCJhbmRcIixbXCI9XCIsIFwiaWRcIiwgXCInICsgaWQgKyAnXCJdLFtcIjw9XCIsXCJjcmVhdGVEYXRlXCIsXCInICsgbm93ICsgJ1wiXSxbXCI+PVwiLCBcImVuZERhdGVcIiwgXCInICsgbm93ICsgJ1wiXSxbXCI9XCIsIFwic3RhdHVzXCIsIFwiMVwiXV0nXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl91aHIuZ2V0KHBhdGgsIG9wdGlvbilcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMuY29kZSA+PSA0MDAgJiYgcmVzdWx0LnN0YXR1cy5jb2RlIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5zdGF0dXMudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgc2VsZi4kY29udGV4dC5ub3RGb3VuZCgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LmNvbnRlbnRbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb250ZW50WzBdO1xuICAgICAgICB9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBhY3Rpb24gbmFtZWQgXCJzb21lLWFjdGlvblwiIGZyb20gYW55IGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBSZXNwb25zZSB0byBjb21wb25lbnQuXG4gKi9cblZhY2FuY3lJdGVtLnByb3RvdHlwZS5oYW5kbGVTb21lQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEhlcmUgeW91IGNhbiBjYWxsIHRoaXMuJGNvbnRleHQuY2hhbmdlZCgpIGlmIHlvdSBrbm93XG4gICAgLy8gdGhhdCByZW1vdGUgZGF0YSBzb3VyY2UgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAvLyBBbHNvIHlvdSBjYW4gaGF2ZSBtYW55IGhhbmRsZSBtZXRob2RzIGZvciBvdGhlciBhY3Rpb25zLlxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSdWJyaWthO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IFN0b3JlIGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI3N0b3Jlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwicnVicmlrYS9SdWJyaWthXCIgc3RvcmUuXG4gKiBAcGFyYW0ge1VIUn0gJHVociBVbml2ZXJzYWwgSFRUUCByZXF1ZXN0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJ1YnJpa2EoJHVocikge1xuICAgIHRoaXMuX3VociA9ICR1aHI7XG59XG5cbi8qKlxuICogQ3VycmVudCB1bml2ZXJzYWwgSFRUUCByZXF1ZXN0IHRvIGRvIGl0IGluIGlzb21vcnBoaWMgd2F5LlxuICogQHR5cGUge1VIUn1cbiAqIEBwcml2YXRlXG4gKi9cblJ1YnJpa2EucHJvdG90eXBlLl91aHIgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgbGlmZXRpbWUgb2YgZGF0YSAoaW4gbWlsbGlzZWNvbmRzKSB0aGF0IGlzIHJldHVybmVkIGJ5IHRoaXMgc3RvcmUuXG4gKiBAdHlwZSB7bnVtYmVyfSBMaWZldGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblJ1YnJpa2EucHJvdG90eXBlLiRsaWZldGltZSA9IDYwMDAwO1xuXG4vKipcbiAqIExvYWRzIGRhdGEgZnJvbSByZW1vdGUgc291cmNlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IExvYWRlZCBkYXRhLlxuICovXG5SdWJyaWthLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcnVicmlrYSA9IHRoaXMuJGNvbnRleHQuc3RhdGUucnVicmlrYTtcbiAgICB2YXIgcG9kcnVicmlrYSA9IHRoaXMuJGNvbnRleHQuc3RhdGUucG9kcnVicmlrYTtcblxuICAgIGlmICghcG9kcnVicmlrYSkge1xuICAgICAgICBzZWxmLiRjb250ZXh0Lm5vdEZvdW5kKCk7XG4gICAgfVxuXG4gICAgdmFyIHVybCA9ICdodHRwOi8vYXBpLWZtLnByZXNlbnQtdGx0LnJ1L3J1YnJpa2EnO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBmaWx0ZXI6ICdbXCJhbmRcIiwgW1wiPVwiLCBcInVuaXF1ZVwiLCBcIicgKyBwb2RydWJyaWthICsgJ1wiXSxbXCI9XCIsXCJzdGF0dXNcIixcIjFcIl1dJyxcbiAgICAgICAgICAgIGV4cGFuZDogXCJ0YWdzLHBhcmVudCxuZWFyYnksc2VvXCJcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX3Voci5nZXQodXJsLCBvcHRpb25zKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cy5jb2RlID49IDQwMCAmJiByZXN1bHQuc3RhdHVzLmNvZGUgPCA2MDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LnN0YXR1cy50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICBzZWxmLiRjb250ZXh0Lm5vdEZvdW5kKCk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gcmVzdWx0LmNvbnRlbnRbMF07XG5cbiAgICAgICAgICAgIGlmIChkYXRhLnBhcmVudElEID09IDApXG4gICAgICAgICAgICAgICAgc2VsZi4kY29udGV4dC5ub3RGb3VuZCgpO1xuXG4gICAgICAgICAgICBpZiAocnVicmlrYSAhPSBkYXRhLnBhcmVudC51bmlxdWUpXG4gICAgICAgICAgICAgICAgc2VsZi4kY29udGV4dC5ub3RGb3VuZCgpO1xuXG4gICAgICAgICAgICBkYXRhLnBvZHJ1YnJpa2EgPSBwb2RydWJyaWthO1xuICAgICAgICAgICAgZGF0YS5ydWJyaWthID0gcnVicmlrYTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBhY3Rpb24gbmFtZWQgXCJzb21lLWFjdGlvblwiIGZyb20gYW55IGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBSZXNwb25zZSB0byBjb21wb25lbnQuXG4gKi8iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUnVicmlrYXRvcjtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBTdG9yZSBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNzdG9yZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcInJ1YnJpa2EvUnVicmlrYXRvclwiIHN0b3JlLlxuICogQHBhcmFtIHtVSFJ9ICR1aHIgVW5pdmVyc2FsIEhUVFAgcmVxdWVzdC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSdWJyaWthdG9yKCR1aHIpIHtcbiAgICB0aGlzLl91aHIgPSAkdWhyO1xuICAgIHRoaXMuX3BhdGggPSAnaHR0cDovL2FwaS1mbS5wcmVzZW50LXRsdC5ydS9ydWJyaWthJztcbiAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBmaWx0ZXI6ICdbXCJhbmRcIixbXCI9XCIsIFwic3RhdHVzXCIsIFwiMVwiXV0nLFxuICAgICAgICAgICAgZXhwYW5kOiAnbWFzdGVyQ291bnQnLFxuICAgICAgICAgICAgb3JkZXI6ICdzb3J0JyxcbiAgICAgICAgICAgIGxpbWl0OiAzMDBcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICogQ3VycmVudCB1bml2ZXJzYWwgSFRUUCByZXF1ZXN0IHRvIGRvIGl0IGluIGlzb21vcnBoaWMgd2F5LlxuICogQHR5cGUge1VIUn1cbiAqIEBwcml2YXRlXG4gKi9cblJ1YnJpa2F0b3IucHJvdG90eXBlLl91aHIgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgbGlmZXRpbWUgb2YgZGF0YSAoaW4gbWlsbGlzZWNvbmRzKSB0aGF0IGlzIHJldHVybmVkIGJ5IHRoaXMgc3RvcmUuXG4gKiBAdHlwZSB7bnVtYmVyfSBMaWZldGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cblJ1YnJpa2F0b3IucHJvdG90eXBlLiRsaWZldGltZSA9IDYwMDAwMDtcblxuLyoqXG4gKiBMb2FkcyBkYXRhIGZyb20gcmVtb3RlIHNvdXJjZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBMb2FkZWQgZGF0YS5cbiAqL1xuXG5SdWJyaWthdG9yLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl91aHIuZ2V0KHRoaXMuX3BhdGgsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzLmNvZGUgPj0gNDAwICYmIHJlc3VsdC5zdGF0dXMuY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuc3RhdHVzLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXN1bHQuY29udGVudDtcbiAgICAgICAgICAgIHZhciBwb2RydWJyaWtzVHJlZSA9IHt9O1xuICAgICAgICAgICAgdmFyIHJvb3RUcmVlID0ge307XG4gICAgICAgICAgICB2YXIgcm9vdFRyZWVDb3VudCA9IHt9O1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwucGFyZW50SUQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFRyZWVbZWwuc29ydF0gPSB7ZWw6IGVsfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcG9kcnVicmlrc1RyZWVbZWwucGFyZW50SURdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvZHJ1YnJpa3NUcmVlW2VsLnBhcmVudElEXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9kcnVicmlrc1RyZWVbZWwucGFyZW50SURdLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFRyZWVDb3VudFtlbC5wYXJlbnRJRF0gPSArZWwubWFzdGVyQ291bnQgKyAocm9vdFRyZWVDb3VudFtlbC5wYXJlbnRJRF0gPyByb290VHJlZUNvdW50W2VsLnBhcmVudElEXSA6ICAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyb290VHJlZSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvZHJ1YnJpa3NUcmVlW3Jvb3RUcmVlW2tleV0uZWwuaWRdLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUgPiBiLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByb290VHJlZVtrZXldLnBvZHJ1YnJpa3MgPSBwb2RydWJyaWtzVHJlZVtyb290VHJlZVtrZXldLmVsLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFRyZWVba2V5XS5jb3VudCA9IHJvb3RUcmVlQ291bnRbcm9vdFRyZWVba2V5XS5lbC5pZF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdFRyZWU7XG4gICAgICAgIH0pO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGFjdGlvbiBuYW1lZCBcInNvbWUtYWN0aW9uXCIgZnJvbSBhbnkgY29tcG9uZW50LlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IFJlc3BvbnNlIHRvIGNvbXBvbmVudC5cbiAqL1xuUnVicmlrYXRvci5wcm90b3R5cGUuaGFuZGxlU29tZUFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBIZXJlIHlvdSBjYW4gY2FsbCB0aGlzLiRjb250ZXh0LmNoYW5nZWQoKSBpZiB5b3Uga25vd1xuICAgIC8vIHRoYXQgcmVtb3RlIGRhdGEgc291cmNlIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgLy8gQWxzbyB5b3UgY2FuIGhhdmUgbWFueSBoYW5kbGUgbWV0aG9kcyBmb3Igb3RoZXIgYWN0aW9ucy5cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUnVicmlrYXRvckNvbXBhbnk7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuXHRcdFJ1YnJpa2F0b3IgPSByZXF1aXJlKCcuL1J1YnJpa2F0b3InKTtcblxudXRpbC5pbmhlcml0cyhSdWJyaWthdG9yQ29tcGFueSwgUnVicmlrYXRvcik7XG5cbmZ1bmN0aW9uIFJ1YnJpa2F0b3JDb21wYW55KCkge1xuXHRSdWJyaWthdG9yLmNhbGwodGhpcyk7XG5cdHRoaXMuX3BhdGggPSAnaHR0cDovL2FwaS1mbS5wcmVzZW50LXRsdC5ydS9ydWJyaWthLWNvbXBhbnknO1xuXHR0aGlzLl9vcHRpb25zID0ge1xuXHRcdGRhdGE6IHtcblx0XHRcdGZpbHRlcjogJ1tcImFuZFwiLFtcIj1cIiwgXCJzdGF0dXNcIiwgXCIxXCJdXScsXG5cdFx0XHRvcmRlcjogJ3NvcnQnLFxuXHRcdFx0bGltaXQ6IDIwMFxuXHRcdH1cblx0fTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUnVicmlrYXRvclBhcmVudDtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBTdG9yZSBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNzdG9yZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcInJ1YnJpa2EvUnVicmlrYXRvclBhcmVudFwiIHN0b3JlLlxuICogQHBhcmFtIHtVSFJ9ICR1aHIgVW5pdmVyc2FsIEhUVFAgcmVxdWVzdC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSdWJyaWthdG9yUGFyZW50KCR1aHIpIHtcbiAgICB0aGlzLl91aHIgPSAkdWhyO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgdW5pdmVyc2FsIEhUVFAgcmVxdWVzdCB0byBkbyBpdCBpbiBpc29tb3JwaGljIHdheS5cbiAqIEB0eXBlIHtVSFJ9XG4gKiBAcHJpdmF0ZVxuICovXG5SdWJyaWthdG9yUGFyZW50LnByb3RvdHlwZS5fdWhyID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IGxpZmV0aW1lIG9mIGRhdGEgKGluIG1pbGxpc2Vjb25kcykgdGhhdCBpcyByZXR1cm5lZCBieSB0aGlzIHN0b3JlLlxuICogQHR5cGUge251bWJlcn0gTGlmZXRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5SdWJyaWthdG9yUGFyZW50LnByb3RvdHlwZS4kbGlmZXRpbWUgPSA2MDAwMDtcblxuLyoqXG4gKiBMb2FkcyBkYXRhIGZyb20gcmVtb3RlIHNvdXJjZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBMb2FkZWQgZGF0YS5cbiAqL1xuUnVicmlrYXRvclBhcmVudC5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aCA9ICdodHRwOi8vYXBpLWZtLnByZXNlbnQtdGx0LnJ1L3J1YnJpa2EnO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBmaWx0ZXI6ICdbXCJhbmRcIixbXCI9XCIsIFwicGFyZW50SURcIiwgXCIwXCJdXScsXG4gICAgICAgICAgICBvcmRlcjogJ25hbWUnLFxuICAgICAgICAgICAgbGltaXQ6IDIwMFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5fdWhyLmdldChwYXRoLCBvcHRpb25zKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cy5jb2RlID49IDQwMCAmJiByZXN1bHQuc3RhdHVzLmNvZGUgPCA2MDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LnN0YXR1cy50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuY29udGVudDtcbiAgICAgICAgfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYWN0aW9uIG5hbWVkIFwic29tZS1hY3Rpb25cIiBmcm9tIGFueSBjb21wb25lbnQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gUmVzcG9uc2UgdG8gY29tcG9uZW50LlxuICovXG5SdWJyaWthdG9yUGFyZW50LnByb3RvdHlwZS5oYW5kbGVTb21lQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEhlcmUgeW91IGNhbiBjYWxsIHRoaXMuJGNvbnRleHQuY2hhbmdlZCgpIGlmIHlvdSBrbm93XG4gICAgLy8gdGhhdCByZW1vdGUgZGF0YSBzb3VyY2UgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAvLyBBbHNvIHlvdSBjYW4gaGF2ZSBtYW55IGhhbmRsZSBtZXRob2RzIGZvciBvdGhlciBhY3Rpb25zLlxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSdWJyaWthdG9yU2FsZTtcblxuLypcbiAqIFRoaXMgaXMgYSBDYXRiZXJyeSBTdG9yZSBmaWxlLlxuICogTW9yZSBkZXRhaWxzIGNhbiBiZSBmb3VuZCBoZXJlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2F0YmVycnkvY2F0YmVycnkvYmxvYi9tYXN0ZXIvZG9jcy9pbmRleC5tZCNzdG9yZXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBcInJ1YnJpa2EvcnVicmlrYXRvclNhbGVcIiBzdG9yZS5cbiAqIEBwYXJhbSB7VUhSfSAkdWhyIFVuaXZlcnNhbCBIVFRQIHJlcXVlc3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUnVicmlrYXRvclNhbGUoJHVocikge1xuICAgIHRoaXMuX3VociA9ICR1aHI7XG4gICAgdGhpcy5fcGF0aCA9ICdodHRwOi8vYXBpLWZtLnByZXNlbnQtdGx0LnJ1L3J1YnJpa2EnO1xuICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGZpbHRlcjogJ1tcImFuZFwiLFtcIj1cIiwgXCJzdGF0dXNcIiwgXCIxXCJdXScsXG4gICAgICAgICAgICBleHBhbmQ6ICdzYWxlQ291bnQnLFxuICAgICAgICAgICAgb3JkZXI6ICdzb3J0JyxcbiAgICAgICAgICAgIGxpbWl0OiAzMDBcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZ3JvdXBzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcItCg0LXQvNC+0L3Rgiwg0YHRgtGA0L7QuNGC0LXQu9GM0YHRgtCy0L4sINC40L3RgtC10YDRjNC10YBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuSUQ6IFs4NiwgODcsIDg4LCAxMDJdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwi0JfQtNC+0YDQvtCy0YzQtSwg0LrRgNCw0YHQvtGC0LAsINC80L7QtNCwXCIsXG4gICAgICAgICAgICBjaGlsZHJlbklEOiBbMjQsIDE0MywgMTEzLCAyNywgMTMyXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcItCe0YLQtNGL0YUg0Lgg0L/RgNCw0LfQtNC90LjQutC4XCIsXG4gICAgICAgICAgICBjaGlsZHJlbklEOiBbMzYsIDEwMywgMTI1LCAxNDldXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwi0JrQvtC90YHRg9C70YzRgtCw0YbQuNC4XCIsXG4gICAgICAgICAgICBjaGlsZHJlbklEOiBbNSwgMTE0XVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcItCQ0LLRgtC+0YPRgdC70YPQs9C4INC4INC00L7RgdGC0LDQstC60LBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuSUQ6IFsxOSwgMTA2XVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcItCd0LXQtNCy0LjQttC40LzQvtGB0YLRjFwiLFxuICAgICAgICAgICAgY2hpbGRyZW5JRDogWzFdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwi0KLQtdGF0L3QuNC60LBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuSUQ6IFs0Ml1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCLQlNGA0LjQs9C40LUg0YPRgdC70YPQs9C4XCIsXG4gICAgICAgICAgICBjaGlsZHJlbklEOiBbXVxuICAgICAgICB9XG4gICAgXTtcbiAgICB0aGlzLl9wYXJlbnRUb0dyb3VwID0ge307XG4gICAgdGhpcy5sb2FkUnVicmlrcyA9IGZhbHNlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLl9ncm91cHNbaV07XG4gICAgICAgIGVsLmNoaWxkcmVuSUQuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHNlbGYuX3BhcmVudFRvR3JvdXBbaWRdID0gaTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEN1cnJlbnQgdW5pdmVyc2FsIEhUVFAgcmVxdWVzdCB0byBkbyBpdCBpbiBpc29tb3JwaGljIHdheS5cbiAqIEB0eXBlIHtVSFJ9XG4gKiBAcHJpdmF0ZVxuICovXG5SdWJyaWthdG9yU2FsZS5wcm90b3R5cGUuX3VociA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBsaWZldGltZSBvZiBkYXRhIChpbiBtaWxsaXNlY29uZHMpIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhpcyBzdG9yZS5cbiAqIEB0eXBlIHtudW1iZXJ9IExpZmV0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuUnVicmlrYXRvclNhbGUucHJvdG90eXBlLiRsaWZldGltZSA9IDYwMDAwO1xuXG4vKipcbiAqIExvYWRzIGRhdGEgZnJvbSByZW1vdGUgc291cmNlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IExvYWRlZCBkYXRhLlxuICovXG5SdWJyaWthdG9yU2FsZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRSdWJyaWthID0gc2VsZi4kY29udGV4dC5zdGF0ZS5jYXRhbG9nO1xuXG4gICAgaWYgKHNlbGYubG9hZFJ1YnJpa3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjdGl2ZTogY3VycmVudFJ1YnJpa2EsXG4gICAgICAgICAgICBsaXN0OiBzZWxmLl9ncm91cHNcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbG9hZERhdGEoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRSdWJyaWtzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBjdXJyZW50UnVicmlrYSxcbiAgICAgICAgICAgICAgICBsaXN0OiBzZWxmLl9ncm91cHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59O1xuLyoqXG4gKiDQl9Cw0LPRgNGD0LfQutCwINGA0YPQsdGA0LjQutCw0YLQvtGA0LAg0Lgg0L/QtdGA0LXRgdGC0YDQvtC50LrQsCDQv9C+0LQg0L3Rg9C20L3Ri9C5INGE0L7RgNC80LDRglxuICogQHJldHVybnMgeyp9XG4gKiBAcHJpdmF0ZVxuICovXG5SdWJyaWthdG9yU2FsZS5wcm90b3R5cGUuX2xvYWREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHJldHVybiB0aGlzLl91aHIuZ2V0KHRoaXMuX3BhdGgsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzLmNvZGUgPj0gNDAwICYmIHJlc3VsdC5zdGF0dXMuY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuc3RhdHVzLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXN1bHQuY29udGVudDtcbiAgICAgICAgICAgIHZhciBkYXRhTGV2ZWwgPSB7fTtcblxuICAgICAgICAgICAgLy/RgdC90LDRh9Cw0YLQsCDQstGL0YHRgtGA0LDQuNCy0LDQtdC8INC00YDQtdCy0L7QstC40LTQvdGD0Y4g0YHRgtGA0YPQutGC0YPRgNGDXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnBhcmVudElEID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhTGV2ZWxbZWwuaWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxldmVsW2VsLmlkXSA9IHtyb290OiBlbCwgY2hpbGQ6IFtdLCBzYWxlQ291bnQ6IDB9O1xuICAgICAgICAgICAgICAgICAgICBkYXRhTGV2ZWxbZWwuaWRdLnJvb3QgPSBlbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGFyZW50VG9Hcm91cFtlbC5pZF0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9ncm91cHNbc2VsZi5fZ3JvdXBzLmxlbmd0aCAtIDFdLmNoaWxkcmVuSUQucHVzaChlbC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFMZXZlbFtlbC5wYXJlbnRJRF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGV2ZWxbZWwucGFyZW50SURdID0ge3Jvb3Q6IHt9LCBjaGlsZDogW10sIHNhbGVDb3VudDogMH07XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YUxldmVsW2VsLnBhcmVudElEXS5zYWxlQ291bnQgKz0gK2VsLnNhbGVDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUxldmVsW2VsLnBhcmVudElEXS5jaGlsZC5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy/Qt9Cw0YLQtdC8INC/0YDQuNGG0LXQv9C70Y/QtdC8INC6INCz0LvQsNCy0L3QvtC80YMg0LTQtdGA0LXQstGDXG4gICAgICAgICAgICBzZWxmLl9ncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgIGVsLnNhbGVDb3VudCA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWwuY2hpbGRyZW5JRC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBlbC5jaGlsZHJlbklEWzBdO1xuICAgICAgICAgICAgICAgICAgICBlbC5zYWxlQ291bnQgPSBkYXRhTGV2ZWxbaWRdLnNhbGVDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUxldmVsW2lkXS5yb290ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLnB1c2goZGF0YUxldmVsW2lkXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW5JRC5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuc2FsZUNvdW50ICs9IGRhdGFMZXZlbFtpZF0uc2FsZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4ucHVzaChkYXRhTGV2ZWxbaWRdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xufTtcbi8qKlxuICogSGFuZGxlcyBhY3Rpb24gbmFtZWQgXCJzb21lLWFjdGlvblwiIGZyb20gYW55IGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD58T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBSZXNwb25zZSB0byBjb21wb25lbnQuXG4gKi9cblJ1YnJpa2F0b3JTYWxlLnByb3RvdHlwZS5oYW5kbGVTb21lQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEhlcmUgeW91IGNhbiBjYWxsIHRoaXMuJGNvbnRleHQuY2hhbmdlZCgpIGlmIHlvdSBrbm93XG4gICAgLy8gdGhhdCByZW1vdGUgZGF0YSBzb3VyY2UgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAvLyBBbHNvIHlvdSBjYW4gaGF2ZSBtYW55IGhhbmRsZSBtZXRob2RzIGZvciBvdGhlciBhY3Rpb25zLlxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gU2FsZUJ5UnVicmlrYTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgU3RvcmVQYWdpbmF0b3IgPSByZXF1aXJlKCcuLi8uLi9saWIvU3RvcmVQYWdpbmF0b3InKTtcbi8qKlxuICog0L3QsNGB0LvQtdC00YPQtdC80YHRjyDQvtGCINC/0LDQs9C40L3QsNGC0L7RgNCwINC00LvRjyDQv9C+0YHRgtGA0LDQvdC40YfQvdC+0Lkg0L3QsNCy0LjQs9Cw0YbQuNC4XG4gKi9cbnV0aWwuaW5oZXJpdHMoU2FsZUJ5UnVicmlrYSwgU3RvcmVQYWdpbmF0b3IpO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IFN0b3JlIGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI3N0b3Jlc1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIFwic2FsZS9TYWxlQnlSdWJyaWthXCIgc3RvcmUuXG4gKiBAcGFyYW0ge1VIUn0gJHVociBVbml2ZXJzYWwgSFRUUCByZXF1ZXN0LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFNhbGVCeVJ1YnJpa2EoJHVocikge1xuICAgIFN0b3JlUGFnaW5hdG9yLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLiRjb250ZXh0LnNldERlcGVuZGVuY3koXCJydWJyaWthL1J1YnJpa2F0b3JTYWxlXCIpO1xuICAgIHRoaXMuX3BhdGggPSAnaHR0cDovL2FwaS1mbS5wcmVzZW50LXRsdC5ydS9zYWxlL2FjdGl2ZSc7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZXhwYW5kOiAnb3duZXInXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEN1cnJlbnQgdW5pdmVyc2FsIEhUVFAgcmVxdWVzdCB0byBkbyBpdCBpbiBpc29tb3JwaGljIHdheS5cbiAqIEB0eXBlIHtVSFJ9XG4gKiBAcHJpdmF0ZVxuICovXG5TYWxlQnlSdWJyaWthLnByb3RvdHlwZS5fdWhyID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IGxpZmV0aW1lIG9mIGRhdGEgKGluIG1pbGxpc2Vjb25kcykgdGhhdCBpcyByZXR1cm5lZCBieSB0aGlzIHN0b3JlLlxuICogQHR5cGUge251bWJlcn0gTGlmZXRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICovXG5TYWxlQnlSdWJyaWthLnByb3RvdHlwZS4kbGlmZXRpbWUgPSA2MDAwMDtcbi8qKlxuICog0KXRgNCw0L3QuNC70LjRidC1INC00LvRjyDRgNGD0LHRgNC40LrQsNGC0L7RgNCwXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5TYWxlQnlSdWJyaWthLnByb3RvdHlwZS5fcnVicmlrYXRvciA9IFtdO1xuXG4vKipcbiAqINCj0YHRgtCw0L3QsNCy0LvQuNCy0LDQtdC8INC30L3QsNGH0LXQvdC40LUg0LTQu9GPIHVybCDQsiDQv9Cw0LPQuNC90LDRgtC+0YDQtVxuICog0JLRi9C30L7QstC10Lwg0Y3RgtC+0YIg0LzQtdGC0L7QtCwg0LrQvtCz0LTQsCDRg9C30L3QsNC10Lwg0YLQtdC60YPRidGD0Y4g0YDRg9Cx0YDQuNC60YNcbiAqIEBwYXJhbSBydWJyaWthXG4gKiBAcHJpdmF0ZVxuICovXG5TYWxlQnlSdWJyaWthLnByb3RvdHlwZS5fc2V0VXJsRm9yUGFnZSA9IGZ1bmN0aW9uIChydWJyaWthKSB7XG4gICAgdGhpcy5fdXJsID0gXCIvc2FsZS9jYXRhbG9nL1wiICsgcnVicmlrYSArIFwiL3BhZ2UvXCI7XG59O1xuXG4vKipcbiAqIExvYWRzIGRhdGEgZnJvbSByZW1vdGUgc291cmNlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IExvYWRlZCBkYXRhLlxuICovXG5TYWxlQnlSdWJyaWthLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vINCy0YvRj9GB0L3QuNC8INGC0LXQutGD0YnRg9GOINGB0YLRgNCw0L3QuNGG0YNcbiAgICAgICAgICAgIHJldHVybiBzZWxmLiRjb250ZXh0LnNlbmRBY3Rpb24oXCJQYWdpbmF0b3JcIiwgXCJnZXRDdXJyZW50UGFnZVwiKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgICAgICAgIC8v0YPRgdGC0LDQvdC+0LLQuNC8INC30L3QsNGH0LXQvdC40Y8g0LTQu9GPINGB0YLRgNCw0L3QuNGG0YtcbiAgICAgICAgICAgIHNlbGYuX2N1cnJlbnRQYWdlID0gcGFnZTtcbiAgICAgICAgICAgIHNlbGYuX29wdGlvbnMuZGF0YS5wYWdlID0gcGFnZTtcbiAgICAgICAgICAgIC8v0LLRi9GP0YHQvdC40Lwg0YLQtdC60YPRidC40LUg0LTQsNC90L3Ri9C1INC/0L4g0YDRg9Cx0YDQuNC60LVcbiAgICAgICAgICAgIHJldHVybiBzZWxmLiRjb250ZXh0LmdldFN0b3JlRGF0YShcInJ1YnJpa2EvUnVicmlrYXRvclNhbGVcIilcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJ1YnJpa2F0b3IpIHtcbiAgICAgICAgICAgIC8v0LfQsNC/0L7QvNC90LjQvCDQstC10YHRjCDRgNGD0LHRgNC40LrQsNGC0L7RgCDQsiDQv9C10YDQtdC80LXQvdC90L7QuVxuICAgICAgICAgICAgc2VsZi5fcnVicmlrYXRvciA9IHJ1YnJpa2F0b3IubGlzdDtcbiAgICAgICAgICAgIC8v0LXRgdC70Lgg0L3QtdGCINCw0LrRgtC40LLQvdC+0Lkg0YDRg9Cx0YDQuNC60Lgg0LfQvdCw0YfQuNGCINGN0YLQviDQs9C70LDQstC90LDRjyDRgdGC0YDQsNC90LjRhtCwXG4gICAgICAgICAgICBpZiAoIXJ1YnJpa2F0b3IuYWN0aXZlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9nZXREYXRhRm9yTWFpblBhZ2UoKTsvL9GB0YTQvtGA0LzQuNGA0YPQtdC8INC00LDQvdC90YvQtSDQtNC70Y8g0LPQu9Cw0LLQvdC+0Lkg0YHRgtGA0LDQvdC40YbRi1xuXG4gICAgICAgICAgICAvL9C40L3QsNGH0LXQtSDRgdGE0L7RgNC80LjRgNGD0LXQvCDQtNCw0L3QvdGL0LUg0LTQu9GPINGA0YPQsdGA0LjQutC4XG4gICAgICAgICAgICAvL9C90L4g0LTQu9GPINC90LDRh9Cw0LvQsCDRg9GB0YLQsNC90L7QstC40LwgdXJsINC00LvRjyDQvdCw0LLQuNCz0LDRhtC40Lgg0L/QviDRgtC10LrRg9GJ0LXQuSDRgNGD0LHRgNC40LrQtVxuICAgICAgICAgICAgc2VsZi5fc2V0VXJsRm9yUGFnZShydWJyaWthdG9yLmFjdGl2ZSk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZ2V0RGF0YUZvclJ1YnJpa2FQYWdlKHJ1YnJpa2F0b3IuYWN0aXZlKTtcbiAgICAgICAgfSk7XG59O1xuLyoqXG4gKiDQpNC+0YDQvNC40YDQvtCy0LDQvdC40LUg0LTQsNC90L3Ri9GFINC00LvRjyDQs9C70LDQstC90L7QuSDRgdGC0YDQsNC90LjRhtGLINC60LDRgtCw0LvQvtCz0LAg0YHQutC40LTQvtC6XG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqIEBwcml2YXRlXG4gKi9cblNhbGVCeVJ1YnJpa2EucHJvdG90eXBlLl9nZXREYXRhRm9yTWFpblBhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlcyA9IFtdOy8v0LzQsNGB0YHQuNCyINC00LvRjyDQv9GA0L7QvNC40YHQvtCyXG5cbiAgICAvL9Ch0YTQvtGA0LzQuNGA0YPQtdC8INGB0L/QuNGB0L7QuiBpZCDQv9C+INCz0YDRg9C/0L/QsNC8INGA0YPQsdGA0LjQuiwg0LTQu9GPINGC0L7Qs9C+INGH0YLQvtCx0Ysg0LTQvtGB0YLQsNGC0Ywg0L/QviA0INCw0LrRhtC40Lgg0LTQu9GPINC60LDQttC00L7QuSDQs9GA0YPQv9C/0YtcbiAgICB0aGlzLl9ydWJyaWthdG9yLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBsaXN0SUQgPSBbXTtcbiAgICAgICAgZWwuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLmNoaWxkLmZvckVhY2goZnVuY3Rpb24gKHJ1YnJpa2EpIHtcbiAgICAgICAgICAgICAgICBsaXN0SUQucHVzaChydWJyaWthLmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy/QtNC70Y8g0LrQsNC20LTQvtCz0L4g0LTQtdC70LDQtdC8INC30LDQv9GA0L7RgSDQuiBhcGlcbiAgICAgICAgcHJvbWlzZXMucHVzaChzZWxmLl9nZXRTYWxlRGF0YShsaXN0SUQpKTtcbiAgICB9KTtcbiAgICAvL9C20LTQtdC8INC60L7Qs9C00LAg0LLRgdC1INC/0YDQvtC80LjRgdGLINCy0YvQv9C+0LvQvdGP0YLRgdGPXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAvL9C30LDRgtC10Lwg0LTQvtCx0LDQstC40Lwg0Log0LTQsNC90L3Ri9C8INC/0L4g0YDRg9Cx0YDQuNC60LDQvCDQv9GA0LjQvdCw0LTQu9C10LbQsNGJ0LjQtSDQuNC8INGB0LrQuNC00LrQuFxuICAgICAgICAudGhlbihmdW5jdGlvbiAoc2FsZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9ydWJyaWthdG9yLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fcnVicmlrYXRvcltpXS5zYWxlID0gc2FsZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vINC4INC+0YLQtNCw0LTQuNC8INCy0YHQtSDRjdGC0L4g0LIgaGJzXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcnVicmlrYXRvcjtcbiAgICAgICAgfSk7XG59O1xuXG4vKipcbiAqINCk0L7RgNC80LjRgNC+0LLQsNC90LjQtSDQtNCw0L3QvdGL0YUg0LTQu9GPINGB0YLRgNCw0L3QuNGG0Ysg0YDRg9Cx0YDQuNC60Lgg0LrQsNGC0LDQu9C+0LPQsCDRgdC60LjQtNC+0LpcbiAqIEBwYXJhbSBjdXJyZW50UnVicmlrYSDRgtC10LrRg9Cw0Y8g0YDRg9Cx0YDQuNC60LBcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICogQHByaXZhdGVcbiAqL1xuU2FsZUJ5UnVicmlrYS5wcm90b3R5cGUuX2dldERhdGFGb3JSdWJyaWthUGFnZSA9IGZ1bmN0aW9uIChjdXJyZW50UnVicmlrYSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGlzdElEID0gW107XG5cbiAgICAvL9C/0LXRgNC10LHQtdGA0LXQvCDQstC10YHRjCDRgNGD0LHRgNC40LrQsNGC0L7RgCDQuCDQvtGC0LzQtdGC0LjQvCDQsNC60YLQuNCy0L3QvtGB0YLRjNGOINGC0LUg0LLQtdGC0LLQuCDQutC+0YLQvtGA0YvQtSDQvdC10L7QsdGF0L7QtNC40LzQviDQvtGC0LrRgNGL0YLRjFxuICAgIC8v0YLQsNC60LbQtSDRgdGA0LDQt9GDINC/0L7QtNCz0L7RgtC+0LLQuNC8INGB0L/QuNGB0L7QuiBpZCDQtNC70Y8g0LfQsNC/0YDQvtGB0LAg0L/QviDQsNC60YbQuNGP0LxcbiAgICB0aGlzLl9ydWJyaWthdG9yLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIGVsLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucm9vdCAmJiBjaGlsZC5yb290LmlkID09IGN1cnJlbnRSdWJyaWthKSB7XG4gICAgICAgICAgICAgICAgZWwuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGlsZC5yb290LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VycmVudFJ1YnJpa2EgPSBjaGlsZC5yb290O1xuXG4gICAgICAgICAgICAgICAgY2hpbGQuY2hpbGQuZm9yRWFjaChmdW5jdGlvbiAocnVicmlrYSkge1xuICAgICAgICAgICAgICAgICAgICBydWJyaWthLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsaXN0SUQucHVzaChydWJyaWthLmlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuY2hpbGQuZm9yRWFjaChmdW5jdGlvbiAocnVicmlrYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVicmlrYS5pZCA9PSBjdXJyZW50UnVicmlrYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVicmlrYS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJvb3QuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSdWJyaWthID0gcnVicmlrYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJRC5wdXNoKHJ1YnJpa2EuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVicmlrYS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5yb290KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJvb3QuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vcHRpb25zLmRhdGEuZmlsdGVyID0gJ1tcImFuZFwiLCBbXCJpblwiLCBcInJ1YnJpa2FJRFwiLFsnICsgbGlzdElELmpvaW4oJywnKSArICddXV0nO1xuICAgIHRoaXMuX29wdGlvbnMuZGF0YS5saW1pdCA9IDIwO1xuICAgIHJldHVybiB0aGlzLl91aHIuZ2V0KHRoaXMuX3BhdGgsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzLmNvZGUgPj0gNDAwICYmIHJlc3VsdC5zdGF0dXMuY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuc3RhdHVzLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5fcGFnZUNvdW50ID0gcmVzdWx0LnN0YXR1cy5oZWFkZXJzWyd4LXBhZ2luYXRpb24tcGFnZS1jb3VudCddO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb250ZW50O1xuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoc2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZTogc2VsZi5fY3VycmVudFBhZ2UsXG4gICAgICAgICAgICAgICAgY3VycmVudFJ1YnJpa2E6IGN1cnJlbnRSdWJyaWthLFxuICAgICAgICAgICAgICAgIHJ1YnJpa2F0b3I6IHNlbGYuX3J1YnJpa2F0b3IsXG4gICAgICAgICAgICAgICAgc2FsZTogc2FsZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG59O1xuXG4vKipcbiAqINCS0L7Qt9Cy0YDQsNGJ0LDQtdGCINGB0L/QuNGB0L7QuiDQsNC60YbQuNC5INC/0L4g0YHQv9C40YHQutGDIGlkINGA0YPQsdGA0LjQutC4XG4gKiBAcGFyYW0gaWQg0LzQsNGB0LjQuNCyINGB0L/QuNGB0L7QuiBpZCDRgNGD0LHRgNC40LpcbiAqIEByZXR1cm5zIHsqfVxuICogQHByaXZhdGVcbiAqL1xuU2FsZUJ5UnVicmlrYS5wcm90b3R5cGUuX2dldFNhbGVEYXRhID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5kYXRhLmZpbHRlciA9ICdbXCJhbmRcIiwgW1wiaW5cIiwgXCJydWJyaWthSURcIixbJyArIGlkLmpvaW4oJywnKSArICddXV0nO1xuICAgIHRoaXMuX29wdGlvbnMuZGF0YS5saW1pdCA9IDQ7XG4gICAgcmV0dXJuIHRoaXMuX3Voci5nZXQodGhpcy5fcGF0aCwgdGhpcy5fb3B0aW9ucylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMuY29kZSA+PSA0MDAgJiYgcmVzdWx0LnN0YXR1cy5jb2RlIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5zdGF0dXMudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNvbnRlbnQ7XG4gICAgICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEhhbmRsZXMgYWN0aW9uIG5hbWVkIFwic29tZS1hY3Rpb25cIiBmcm9tIGFueSBjb21wb25lbnQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fE9iamVjdHxudWxsfHVuZGVmaW5lZH0gUmVzcG9uc2UgdG8gY29tcG9uZW50LlxuICovXG5TYWxlQnlSdWJyaWthLnByb3RvdHlwZS5oYW5kbGVTb21lQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEhlcmUgeW91IGNhbiBjYWxsIHRoaXMuJGNvbnRleHQuY2hhbmdlZCgpIGlmIHlvdSBrbm93XG4gICAgLy8gdGhhdCByZW1vdGUgZGF0YSBzb3VyY2UgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAvLyBBbHNvIHlvdSBjYW4gaGF2ZSBtYW55IGhhbmRsZSBtZXRob2RzIGZvciBvdGhlciBhY3Rpb25zLlxufTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcblx0XCJ0aXRsZVwiOiBcIkZhY2VNYXN0ZXIucnVcIixcblx0XCJpc1JlbGVhc2VcIjogdHJ1ZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm1haW5cIjoge1xuICAgIFwidGl0bGVcIjogXCLQn9C+0LjRgdC6INCc0LDRgdGC0LXRgNC+0LIg0LIg0YHRhNC10YDQtSDRg9GB0LvRg9CzXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcItCf0L7QuNGB0Log0JzQsNGB0YLQtdGA0L7QsiDQsiDRgdGE0LXRgNC1INGD0YHQu9GD0LNcIixcbiAgICBcImtleXdvcmRzXCI6IFwi0L/QvtC40YHQuiDRg9GB0LvRg9CzLCDQvNCw0YHRgtC10YDQsCwg0YHQv9C10YbQuNCw0LvQuNGB0YLRiyDQotC+0LvRjNGP0YLRgtC4XCJcbiAgfSxcbiAgXCJjYXRhbG9nXCI6IHtcbiAgICBcInRpdGxlXCI6IFwi0JrQsNGC0LDQu9C+0LMg0YPRgdC70YPQs1wiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICBcImtleXdvcmRzXCI6IFwiXCJcbiAgfSxcbiAgXCJyZXF1ZXN0XCI6IHtcbiAgICBcInRpdGxlXCI6IFwi0JfQsNC60LDQt9Cw0YLRjCDRg9GB0LvRg9Cz0YNcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgXCJrZXl3b3Jkc1wiOiBcIlwiXG4gIH0sXG4gIFwicmVnaXN0cmF0aW9uXCI6IHtcbiAgICBcInRpdGxlXCI6IFwi0KHRgtCw0YLRjCDQnNCw0YHRgtC10YDQvtC8XCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgIFwia2V5d29yZHNcIjogXCJcIlxuICB9LFxuICBcImxvZ2luXCI6IHtcbiAgICBcInRpdGxlXCI6IFwi0JLRhdC+0LQg0LTQu9GPINCc0LDRgdGC0LXRgNC+0LJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgXCJrZXl3b3Jkc1wiOiBcIlwiXG4gIH0sXG4gIFwic2FsZVwiOiB7XG4gICAgXCJ0aXRsZVwiOiBcIiDQmtCw0YLQsNC70L7QsyDRgdC60LjQtNC60Lgg0Lgg0L/QvtC00LDRgNC60LhcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgXCJrZXl3b3Jkc1wiOiBcIlwiXG4gIH0sXG4gIFwidmlkZW9cIjoge1xuICAgIFwidGl0bGVcIjogXCLQktC40LTQtdC+INCc0LDRgdGC0LXRgNC+0LJcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgXCJrZXl3b3Jkc1wiOiBcIlwiXG4gIH0sXG4gIFwic292ZXR5XCI6IHtcbiAgICBcInRpdGxlXCI6IFwi0KHQtdC60YDQtdGC0Ysg0LzQsNGB0YLQtdGA0L7QslwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICBcImtleXdvcmRzXCI6IFwiXCJcbiAgfSxcbiAgXCJjb21wYW55XCI6IHtcbiAgICBcInRpdGxlXCI6IFwi0JrQsNGC0LDQu9C+0LMg0LrQvtC80L/QsNC90LjQuVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJcIixcbiAgICBcImtleXdvcmRzXCI6IFwiXCJcbiAgfSxcbiAgXCJyZWNvbW1lbmRhdGlvblwiOiB7XG4gICAgXCJ0aXRsZVwiOiBcItCg0LXQutC+0LzQtdC90LTQsNGG0LjQuCDQnNCw0YHRgtC10YDQvtCyXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcItCg0LXQutC+0LzQtdC90LTQsNGG0LjQuCDQnNCw0YHRgtC10YDQvtCyXCIsXG4gICAgXCJrZXl3b3Jkc1wiOiBcItC+0YLQt9GL0LLRiywg0YDQtdC60L7QvNC10L3QtNCw0YbQuNC4XCJcbiAgfSxcbiAgXCJuZXdzXCI6IHtcbiAgICBcInRpdGxlXCI6IFwi0J3QvtCy0L7RgdGC0LhcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgXCJrZXl3b3Jkc1wiOiBcIlwiXG4gIH0sXG4gIFwidmFjYW5jeVwiOiB7XG4gICAgXCJ0aXRsZVwiOiBcItCS0LDQutCw0L3RgdC40LhcIixcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiXCIsXG4gICAgXCJrZXl3b3Jkc1wiOiBcIlwiXG4gIH0sXG4gIFwib2ZlcnRhXCI6IHtcbiAgICBcInRpdGxlXCI6IFwi0J7RhNC10YDRgtCwXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgIFwia2V5d29yZHNcIjogXCJcIlxuICB9LFxuICBcImNvbnRhY3RcIjoge1xuICAgIFwidGl0bGVcIjogXCLQmtC+0L3RgtCw0LrRgtGLXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgIFwia2V5d29yZHNcIjogXCJcIlxuICB9LFxuICBcImZlZWRiYWNrXCI6IHtcbiAgICBcInRpdGxlXCI6IFwi0J7QsdGA0LDRgtC90LDRjyDRgdCy0Y/Qt9GMXCIsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIlwiLFxuICAgIFwia2V5d29yZHNcIjogXCJcIlxuICB9LFxuICBcIm1hc3Rlci1ydWJyaWthXCI6IHt9LFxuICBcIm1hc3Rlci1wYWdlXCI6IHt9LFxuICBcIm5ld3MtaXRlbVwiOiB7fSxcbiAgXCJ2YWNhbmN5LWl0ZW1cIjoge30sXG4gIFwia29ua3Vycy1pdGVtXCI6IHt9XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3JlUGFnaW5hdG9yO1xuXG4vKlxuICogVGhpcyBpcyBhIENhdGJlcnJ5IFN0b3JlIGZpbGUuXG4gKiBNb3JlIGRldGFpbHMgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRiZXJyeS9jYXRiZXJyeS9ibG9iL21hc3Rlci9kb2NzL2luZGV4Lm1kI3N0b3Jlc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtVSFJ9ICR1aHIgVW5pdmVyc2FsIEhUVFAgcmVxdWVzdC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdG9yZVBhZ2luYXRvcigpIHtcbiAgICB0aGlzLl91aHIgPSB0aGlzLiRjb250ZXh0LmxvY2F0b3IucmVzb2x2ZSgndWhyJyk7XG4gICAgdGhpcy5fcGFnZUNvdW50ID0gMTtcbiAgICB0aGlzLl9jdXJyZW50UGFnZSA9IDE7XG4gICAgdGhpcy5fcGF0aCA9ICcnO1xuICAgIHRoaXMuX29wdGlvbnMgPSB7ZGF0YToge319O1xuICAgIHRoaXMuX3VybCA9ICcnO1xuXG4gICAgdGhpcy4kY29udGV4dC5zZXREZXBlbmRlbmN5KFwiUGFnaW5hdG9yXCIpO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgdW5pdmVyc2FsIEhUVFAgcmVxdWVzdCB0byBkbyBpdCBpbiBpc29tb3JwaGljIHdheS5cbiAqIEB0eXBlIHtVSFJ9XG4gKiBAcHJpdmF0ZVxuICovXG5TdG9yZVBhZ2luYXRvci5wcm90b3R5cGUuX3VociA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBsaWZldGltZSBvZiBkYXRhIChpbiBtaWxsaXNlY29uZHMpIHRoYXQgaXMgcmV0dXJuZWQgYnkgdGhpcyBzdG9yZS5cbiAqIEB0eXBlIHtudW1iZXJ9IExpZmV0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuU3RvcmVQYWdpbmF0b3IucHJvdG90eXBlLiRsaWZldGltZSA9IDYwMDAwO1xuXG4vKipcbiAqIExvYWRzIGRhdGEgZnJvbSByZW1vdGUgc291cmNlLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0PnxPYmplY3R8bnVsbHx1bmRlZmluZWR9IExvYWRlZCBkYXRhLlxuICovXG5TdG9yZVBhZ2luYXRvci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgxKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi4kY29udGV4dC5zZW5kQWN0aW9uKFwiUGFnaW5hdG9yXCIsIFwiZ2V0Q3VycmVudFBhZ2VcIik7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgICAgICBzZWxmLl9jdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICBzZWxmLl9vcHRpb25zLmRhdGEucGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fdWhyLmdldChwYXRoLCBzZWxmLl9vcHRpb25zKVxuICAgICAgICB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cy5jb2RlID49IDQwMCAmJiByZXN1bHQuc3RhdHVzLmNvZGUgPCA2MDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LnN0YXR1cy50ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5fcGFnZUNvdW50ID0gcmVzdWx0LnN0YXR1cy5oZWFkZXJzWyd4LXBhZ2luYXRpb24tcGFnZS1jb3VudCddO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZTogc2VsZi5fY3VycmVudFBhZ2UsXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmNvbnRlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xufTtcblxuXG5TdG9yZVBhZ2luYXRvci5wcm90b3R5cGUuaGFuZGxlR2V0UGFnaW5hdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcGFnZUNvdW50IHx8IHRoaXMuX3BhZ2VDb3VudCA9PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcImlzLXBhZ2luYXRvclwiOiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIFwiaXMtcGFnaW5hdG9yXCI6IHRydWUsXG4gICAgICAgIFwidXJsXCI6IHRoaXMuX3VybCxcbiAgICAgICAgXCJjb3VudFwiOiB0aGlzLl9wYWdlQ291bnQsXG4gICAgICAgIFwiY3VycmVudFwiOiB0aGlzLl9jdXJyZW50UGFnZVxuICAgIH07XG59OyIsIi8qXG4gKiBEYXRlIEZvcm1hdCAxLjIuM1xuICogKGMpIDIwMDctMjAwOSBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT5cbiAqIE1JVCBsaWNlbnNlXG4gKlxuICogSW5jbHVkZXMgZW5oYW5jZW1lbnRzIGJ5IFNjb3R0IFRyZW5kYSA8c2NvdHQudHJlbmRhLm5ldD5cbiAqIGFuZCBLcmlzIEtvd2FsIDxjaXhhci5jb20vfmtyaXMua293YWwvPlxuICpcbiAqIEFjY2VwdHMgYSBkYXRlLCBhIG1hc2ssIG9yIGEgZGF0ZSBhbmQgYSBtYXNrLlxuICogUmV0dXJucyBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIGRhdGUgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZGF0ZS90aW1lLlxuICogVGhlIG1hc2sgZGVmYXVsdHMgdG8gZGF0ZUZvcm1hdC5tYXNrcy5kZWZhdWx0LlxuICovXG5cbnZhciBkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhclx0dG9rZW4gPSAvZHsxLDR9fG17MSw0fXx5eSg/Onl5KT98KFtIaE1zVHRdKVxcMT98W0xsb1NaXXxcIlteXCJdKlwifCdbXiddKicvZyxcbiAgICAgICAgdGltZXpvbmUgPSAvXFxiKD86W1BNQ0VBXVtTRFBdVHwoPzpQYWNpZmljfE1vdW50YWlufENlbnRyYWx8RWFzdGVybnxBdGxhbnRpYykgKD86U3RhbmRhcmR8RGF5bGlnaHR8UHJldmFpbGluZykgVGltZXwoPzpHTVR8VVRDKSg/OlstK11cXGR7NH0pPylcXGIvZyxcbiAgICAgICAgdGltZXpvbmVDbGlwID0gL1teLStcXGRBLVpdL2csXG4gICAgICAgIHBhZCA9IGZ1bmN0aW9uICh2YWwsIGxlbikge1xuICAgICAgICAgICAgdmFsID0gU3RyaW5nKHZhbCk7XG4gICAgICAgICAgICBsZW4gPSBsZW4gfHwgMjtcbiAgICAgICAgICAgIHdoaWxlICh2YWwubGVuZ3RoIDwgbGVuKSB2YWwgPSBcIjBcIiArIHZhbDtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH07XG5cbiAgICAvLyBSZWdleGVzIGFuZCBzdXBwb3J0aW5nIGZ1bmN0aW9ucyBhcmUgY2FjaGVkIHRocm91Z2ggY2xvc3VyZVxuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgbWFzaywgdXRjKSB7XG4gICAgICAgIHZhciBkRiA9IGRhdGVGb3JtYXQ7XG5cbiAgICAgICAgLy8gWW91IGNhbid0IHByb3ZpZGUgdXRjIGlmIHlvdSBza2lwIG90aGVyIGFyZ3MgKHVzZSB0aGUgXCJVVEM6XCIgbWFzayBwcmVmaXgpXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGUpID09IFwiW29iamVjdCBTdHJpbmddXCIgJiYgIS9cXGQvLnRlc3QoZGF0ZSkpIHtcbiAgICAgICAgICAgIG1hc2sgPSBkYXRlO1xuICAgICAgICAgICAgZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhc3NpbmcgZGF0ZSB0aHJvdWdoIERhdGUgYXBwbGllcyBEYXRlLnBhcnNlLCBpZiBuZWNlc3NhcnlcbiAgICAgICAgZGF0ZSA9IGRhdGUgPyBuZXcgRGF0ZShkYXRlKSA6IG5ldyBEYXRlO1xuICAgICAgICBpZiAoaXNOYU4oZGF0ZSkpIHRocm93IFN5bnRheEVycm9yKFwiaW52YWxpZCBkYXRlXCIpO1xuXG4gICAgICAgIG1hc2sgPSBTdHJpbmcoZEYubWFza3NbbWFza10gfHwgbWFzayB8fCBkRi5tYXNrc1tcImRlZmF1bHRcIl0pO1xuXG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgdGhlIHV0YyBhcmd1bWVudCB2aWEgdGhlIG1hc2tcbiAgICAgICAgaWYgKG1hc2suc2xpY2UoMCwgNCkgPT0gXCJVVEM6XCIpIHtcbiAgICAgICAgICAgIG1hc2sgPSBtYXNrLnNsaWNlKDQpO1xuICAgICAgICAgICAgdXRjID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhclx0XyA9IHV0YyA/IFwiZ2V0VVRDXCIgOiBcImdldFwiLFxuICAgICAgICAgICAgZCA9IGRhdGVbXyArIFwiRGF0ZVwiXSgpLFxuICAgICAgICAgICAgRCA9IGRhdGVbXyArIFwiRGF5XCJdKCksXG4gICAgICAgICAgICBtID0gZGF0ZVtfICsgXCJNb250aFwiXSgpLFxuICAgICAgICAgICAgeSA9IGRhdGVbXyArIFwiRnVsbFllYXJcIl0oKSxcbiAgICAgICAgICAgIEggPSBkYXRlW18gKyBcIkhvdXJzXCJdKCksXG4gICAgICAgICAgICBNID0gZGF0ZVtfICsgXCJNaW51dGVzXCJdKCksXG4gICAgICAgICAgICBzID0gZGF0ZVtfICsgXCJTZWNvbmRzXCJdKCksXG4gICAgICAgICAgICBMID0gZGF0ZVtfICsgXCJNaWxsaXNlY29uZHNcIl0oKSxcbiAgICAgICAgICAgIG8gPSB1dGMgPyAwIDogZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpLFxuICAgICAgICAgICAgZmxhZ3MgPSB7XG4gICAgICAgICAgICAgICAgZDogICAgZCxcbiAgICAgICAgICAgICAgICBkZDogICBwYWQoZCksXG4gICAgICAgICAgICAgICAgZGRkOiAgZEYuaTE4bi5kYXlOYW1lc1tEXSxcbiAgICAgICAgICAgICAgICBkZGRkOiBkRi5pMThuLmRheU5hbWVzW0QgKyA3XSxcbiAgICAgICAgICAgICAgICBtOiAgICBtICsgMSxcbiAgICAgICAgICAgICAgICBtbTogICBwYWQobSArIDEpLFxuICAgICAgICAgICAgICAgIG1tbTogIGRGLmkxOG4ubW9udGhOYW1lc1ttXSxcbiAgICAgICAgICAgICAgICBtbW1tOiBkRi5pMThuLm1vbnRoTmFtZXNbbSArIDEyXSxcbiAgICAgICAgICAgICAgICB5eTogICBTdHJpbmcoeSkuc2xpY2UoMiksXG4gICAgICAgICAgICAgICAgeXl5eTogeSxcbiAgICAgICAgICAgICAgICBoOiAgICBIICUgMTIgfHwgMTIsXG4gICAgICAgICAgICAgICAgaGg6ICAgcGFkKEggJSAxMiB8fCAxMiksXG4gICAgICAgICAgICAgICAgSDogICAgSCxcbiAgICAgICAgICAgICAgICBISDogICBwYWQoSCksXG4gICAgICAgICAgICAgICAgTTogICAgTSxcbiAgICAgICAgICAgICAgICBNTTogICBwYWQoTSksXG4gICAgICAgICAgICAgICAgczogICAgcyxcbiAgICAgICAgICAgICAgICBzczogICBwYWQocyksXG4gICAgICAgICAgICAgICAgbDogICAgcGFkKEwsIDMpLFxuICAgICAgICAgICAgICAgIEw6ICAgIHBhZChMID4gOTkgPyBNYXRoLnJvdW5kKEwgLyAxMCkgOiBMKSxcbiAgICAgICAgICAgICAgICB0OiAgICBIIDwgMTIgPyBcImFcIiAgOiBcInBcIixcbiAgICAgICAgICAgICAgICB0dDogICBIIDwgMTIgPyBcImFtXCIgOiBcInBtXCIsXG4gICAgICAgICAgICAgICAgVDogICAgSCA8IDEyID8gXCJBXCIgIDogXCJQXCIsXG4gICAgICAgICAgICAgICAgVFQ6ICAgSCA8IDEyID8gXCJBTVwiIDogXCJQTVwiLFxuICAgICAgICAgICAgICAgIFo6ICAgIHV0YyA/IFwiVVRDXCIgOiAoU3RyaW5nKGRhdGUpLm1hdGNoKHRpbWV6b25lKSB8fCBbXCJcIl0pLnBvcCgpLnJlcGxhY2UodGltZXpvbmVDbGlwLCBcIlwiKSxcbiAgICAgICAgICAgICAgICBvOiAgICAobyA+IDAgPyBcIi1cIiA6IFwiK1wiKSArIHBhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApICogMTAwICsgTWF0aC5hYnMobykgJSA2MCwgNCksXG4gICAgICAgICAgICAgICAgUzogICAgW1widGhcIiwgXCJzdFwiLCBcIm5kXCIsIFwicmRcIl1bZCAlIDEwID4gMyA/IDAgOiAoZCAlIDEwMCAtIGQgJSAxMCAhPSAxMCkgKiBkICUgMTBdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBtYXNrLnJlcGxhY2UodG9rZW4sIGZ1bmN0aW9uICgkMCkge1xuICAgICAgICAgICAgcmV0dXJuICQwIGluIGZsYWdzID8gZmxhZ3NbJDBdIDogJDAuc2xpY2UoMSwgJDAubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KCk7XG5cbi8vIFNvbWUgY29tbW9uIGZvcm1hdCBzdHJpbmdzXG5kYXRlRm9ybWF0Lm1hc2tzID0ge1xuICAgIFwiZGVmYXVsdFwiOiAgICAgIFwiZGRkIG1tbSBkZCB5eXl5IEhIOk1NOnNzXCIsXG4gICAgc2hvcnREYXRlOiAgICAgIFwibS9kL3l5XCIsXG4gICAgbWVkaXVtRGF0ZTogICAgIFwibW1tIGQsIHl5eXlcIixcbiAgICBsb25nRGF0ZTogICAgICAgXCJtbW1tIGQsIHl5eXlcIixcbiAgICBmdWxsRGF0ZTogICAgICAgXCJkZGRkLCBtbW1tIGQsIHl5eXlcIixcbiAgICBzaG9ydFRpbWU6ICAgICAgXCJoOk1NIFRUXCIsXG4gICAgbWVkaXVtVGltZTogICAgIFwiaDpNTTpzcyBUVFwiLFxuICAgIGxvbmdUaW1lOiAgICAgICBcImg6TU06c3MgVFQgWlwiLFxuICAgIGlzb0RhdGU6ICAgICAgICBcInl5eXktbW0tZGRcIixcbiAgICBpc29UaW1lOiAgICAgICAgXCJISDpNTTpzc1wiLFxuICAgIGlzb0RhdGVUaW1lOiAgICBcInl5eXktbW0tZGQnVCdISDpNTTpzc1wiLFxuICAgIGlzb1V0Y0RhdGVUaW1lOiBcIlVUQzp5eXl5LW1tLWRkJ1QnSEg6TU06c3MnWidcIlxufTtcblxuLy8gSW50ZXJuYXRpb25hbGl6YXRpb24gc3RyaW5nc1xuZGF0ZUZvcm1hdC5pMThuID0ge1xuICAgIGRheU5hbWVzOiBbXG4gICAgICAgIFwiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIsXG4gICAgICAgIFwiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIlxuICAgIF0sXG4gICAgbW9udGhOYW1lczogW1xuICAgICAgICBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiLFxuICAgICAgICBcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJcbiAgICBdXG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBkYXRlRm9ybWF0OyIsIi8qXG4gKiBjYXRiZXJyeVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBEZW5pcyBSZWNoa3Vub3YgYW5kIHByb2plY3QgY29udHJpYnV0b3JzLlxuICpcbiAqIGNhdGJlcnJ5J3MgbGljZW5zZSBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgbGljZW5zZSBhcHBsaWVzIHRvIGFsbCBwYXJ0cyBvZiBjYXRiZXJyeSB0aGF0IGFyZSBub3QgZXh0ZXJuYWxseVxuICogbWFpbnRhaW5lZCBsaWJyYXJpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhdGJlcnJ5O1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcblx0Q2F0YmVycnlCYXNlID0gcmVxdWlyZSgnLi4vbGliL2Jhc2UvQ2F0YmVycnlCYXNlJyk7XG5cbnV0aWwuaW5oZXJpdHMoQ2F0YmVycnksIENhdGJlcnJ5QmFzZSk7XG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIGJyb3dzZXIgdmVyc2lvbiBvZiBDYXRiZXJyeS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2F0YmVycnlCYXNlXG4gKi9cbmZ1bmN0aW9uIENhdGJlcnJ5KCkge1xuXHRDYXRiZXJyeUJhc2UuY2FsbCh0aGlzKTtcbn1cblxuLyoqXG4gKiBDdXJyZW50IHJlcXVlc3Qgcm91dGVyLlxuICogQHR5cGUge1JlcXVlc3RSb3V0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5DYXRiZXJyeS5wcm90b3R5cGUuX3JvdXRlciA9IG51bGw7XG5cbi8qKlxuICogV3JhcHMgY3VycmVudCBIVE1MIGRvY3VtZW50IHdpdGggQ2F0YmVycnkgZXZlbnQgaGFuZGxlcnMuXG4gKi9cbkNhdGJlcnJ5LnByb3RvdHlwZS53cmFwRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuX3JvdXRlciA9IHRoaXMubG9jYXRvci5yZXNvbHZlKCdyZXF1ZXN0Um91dGVyJyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBDYXRiZXJyeSBhcHBsaWNhdGlvbiB3aGVuIERPTSBpcyByZWFkeS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIGZvciBub3RoaW5nLlxuICovXG5DYXRiZXJyeS5wcm90b3R5cGUuc3RhcnRXaGVuUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh3aW5kb3cuY2F0YmVycnkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH1cblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCkge1xuXHRcdHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi53cmFwRG9jdW1lbnQoKTtcblx0XHRcdHdpbmRvdy5jYXRiZXJyeSA9IHNlbGY7XG5cdFx0XHRmdWxmaWxsKCk7XG5cdFx0fSk7XG5cdH0pO1xufTsiLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDb29raWVXcmFwcGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcblx0Q29va2llV3JhcHBlckJhc2UgPSByZXF1aXJlKCcuLi9saWIvYmFzZS9Db29raWVXcmFwcGVyQmFzZScpO1xuXG51dGlsLmluaGVyaXRzKENvb2tpZVdyYXBwZXIsIENvb2tpZVdyYXBwZXJCYXNlKTtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgYnJvd3NlciBjb29raWUgd3JhcHBlci5cbiAqIEBwYXJhbSB7V2luZG93fSAkd2luZG93IFdpbmRvdyBvYmplY3QuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29va2llV3JhcHBlcigkd2luZG93KSB7XG5cdENvb2tpZVdyYXBwZXJCYXNlLmNhbGwodGhpcyk7XG5cdHRoaXMuX3dpbmRvdyA9ICR3aW5kb3c7XG59XG5cbi8qKlxuICogQ3VycmVudCBicm93c2VyIHdpbmRvdy5cbiAqIEB0eXBlIHtXaW5kb3d9XG4gKiBAcHJpdmF0ZVxuICovXG5Db29raWVXcmFwcGVyLnByb3RvdHlwZS5fd2luZG93ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIGN1cnJlbnQgY29va2llIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvb2tpZSBzdHJpbmcuXG4gKi9cbkNvb2tpZVdyYXBwZXIucHJvdG90eXBlLmdldENvb2tpZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuX3dpbmRvdy5kb2N1bWVudC5jb29raWUgP1xuXHRcdHRoaXMuX3dpbmRvdy5kb2N1bWVudC5jb29raWUudG9TdHJpbmcoKSA6XG5cdFx0Jyc7XG59O1xuXG4vKipcbiAqIFNldHMgY29va2llIHRvIHRoaXMgd3JhcHBlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29raWVTZXR1cCBDb29raWUgc2V0dXAgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGNvb2tpZVNldHVwLmtleSBDb29raWUga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGNvb2tpZVNldHVwLnZhbHVlIENvb2tpZSB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyP30gY29va2llU2V0dXAubWF4QWdlIE1heCBjb29raWUgYWdlIGluIHNlY29uZHMuXG4gKiBAcGFyYW0ge0RhdGU/fSBjb29raWVTZXR1cC5leHBpcmVzIEV4cGlyZSBkYXRlLlxuICogQHBhcmFtIHtzdHJpbmc/fSBjb29raWVTZXR1cC5wYXRoIFVSSSBwYXRoIGZvciBjb29raWUuXG4gKiBAcGFyYW0ge3N0cmluZz99IGNvb2tpZVNldHVwLmRvbWFpbiBDb29raWUgZG9tYWluLlxuICogQHBhcmFtIHtib29sZWFuP30gY29va2llU2V0dXAuc2VjdXJlIElzIGNvb2tpZSBzZWN1cmVkLlxuICogQHBhcmFtIHtib29sZWFuP30gY29va2llU2V0dXAuaHR0cE9ubHkgSXMgY29va2llIEhUVFAgb25seS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvb2tpZSBzZXR1cCBzdHJpbmcuXG4gKi9cbkNvb2tpZVdyYXBwZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChjb29raWVTZXR1cCkge1xuXHR2YXIgY29va2llID0gdGhpcy5fY29udmVydFRvQ29va2llU2V0dXAoY29va2llU2V0dXApO1xuXHR0aGlzLl93aW5kb3cuZG9jdW1lbnQuY29va2llID0gY29va2llO1xuXHRyZXR1cm4gY29va2llO1xufTsiLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudFJlbmRlcmVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcblx0bW9ycGhkb20gPSByZXF1aXJlKCdtb3JwaGRvbScpLFxuXHRlcnJvckhlbHBlciA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXJzL2Vycm9ySGVscGVyJyksXG5cdG1vZHVsZUhlbHBlciA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXJzL21vZHVsZUhlbHBlcicpLFxuXHRoclRpbWVIZWxwZXIgPSByZXF1aXJlKCcuLi9saWIvaGVscGVycy9oclRpbWVIZWxwZXInKSxcblx0RG9jdW1lbnRSZW5kZXJlckJhc2UgPSByZXF1aXJlKCcuLi9saWIvYmFzZS9Eb2N1bWVudFJlbmRlcmVyQmFzZScpO1xuXG51dGlsLmluaGVyaXRzKERvY3VtZW50UmVuZGVyZXIsIERvY3VtZW50UmVuZGVyZXJCYXNlKTtcblxudmFyIFdBUk5fSURfTk9UX1NQRUNJRklFRCA9ICdDb21wb25lbnQgXCIlc1wiIGRvZXMgbm90IGhhdmUgYW4gSUQsIHNraXBwaW5nLi4uJyxcblx0V0FSTl9TQU1FX0lEID1cblx0XHQnVGhlIGR1cGxpY2F0ZWQgSUQgXCIlc1wiIGhhcyBiZWVuIGZvdW5kLCBza2lwcGluZyBjb21wb25lbnQgXCIlc1wiLi4uJztcblxudmFyIFNQRUNJQUxfSURTID0ge1xuXHRcdCQkaGVhZDogJyQkaGVhZCcsXG5cdFx0JCRkb2N1bWVudDogJyQkZG9jdW1lbnQnXG5cdH0sXG5cdFRBR19OQU1FUyA9IHtcblx0XHRUSVRMRTogJ1RJVExFJyxcblx0XHRIVE1MOiAnSFRNTCcsXG5cdFx0SEVBRDogJ0hFQUQnLFxuXHRcdEJBU0U6ICdCQVNFJyxcblx0XHRTVFlMRTogJ1NUWUxFJyxcblx0XHRTQ1JJUFQ6ICdTQ1JJUFQnLFxuXHRcdE5PU0NSSVBUOiAnTk9TQ1JJUFQnLFxuXHRcdE1FVEE6ICdNRVRBJyxcblx0XHRMSU5LOiAnTElOSydcblx0fSxcblx0Tk9ERV9UWVBFUyA9IHtcblx0XHRFTEVNRU5UX05PREU6IDEsXG5cdFx0VEVYVF9OT0RFOiAzLFxuXHRcdFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTogNyxcblx0XHRDT01NRU5UX05PREU6IDhcblx0fSxcblx0RVJST1JfQ1JFQVRFX1dST05HX0FSR1VNRU5UUyA9ICdUYWcgbmFtZSBzaG91bGQgYmUgYSBzdHJpbmcgJyArXG5cdFx0J2FuZCBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhbiBvYmplY3QnLFxuXHRFUlJPUl9DUkVBVEVfV1JPTkdfTkFNRSA9ICdDb21wb25lbnQgZm9yIHRhZyBcIiVzXCIgbm90IGZvdW5kJyxcblx0RVJST1JfQ1JFQVRFX1dST05HX0lEID0gJ1RoZSBJRCBpcyBub3Qgc3BlY2lmaWVkIG9yIGFscmVhZHkgdXNlZCcsXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTUvV0QtdWlldmVudHMtMjAxNTAzMTkvI2V2ZW50LXR5cGVzLWxpc3Rcblx0Tk9OX0JVQkJMSU5HX0VWRU5UUyA9IHtcblx0XHRhYm9ydDogdHJ1ZSxcblx0XHRibHVyOiB0cnVlLFxuXHRcdGVycm9yOiB0cnVlLFxuXHRcdGZvY3VzOiB0cnVlLFxuXHRcdGxvYWQ6IHRydWUsXG5cdFx0bW91c2VlbnRlcjogdHJ1ZSxcblx0XHRtb3VzZWxlYXZlOiB0cnVlLFxuXHRcdHJlc2l6ZTogdHJ1ZSxcblx0XHR1bmxvYWQ6IHRydWVcblx0fTtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgZG9jdW1lbnQgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge1NlcnZpY2VMb2NhdG9yfSAkc2VydmljZUxvY2F0b3IgTG9jYXRvciB0byByZXNvbHZlIGRlcGVuZGVuY2llcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRG9jdW1lbnRSZW5kZXJlckJhc2VcbiAqL1xuZnVuY3Rpb24gRG9jdW1lbnRSZW5kZXJlcigkc2VydmljZUxvY2F0b3IpIHtcblx0RG9jdW1lbnRSZW5kZXJlckJhc2UuY2FsbCh0aGlzLCAkc2VydmljZUxvY2F0b3IpO1xuXHR0aGlzLl9jb21wb25lbnRJbnN0YW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHR0aGlzLl9jb21wb25lbnRFbGVtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdHRoaXMuX2NvbXBvbmVudEJpbmRpbmdzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0dGhpcy5fY3VycmVudENoYW5nZWRTdG9yZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHR0aGlzLl93aW5kb3cgPSAkc2VydmljZUxvY2F0b3IucmVzb2x2ZSgnd2luZG93Jyk7XG5cdHRoaXMuX2xvZ2dlciA9ICRzZXJ2aWNlTG9jYXRvci5yZXNvbHZlKCdsb2dnZXInKTtcblx0dGhpcy5fY29uZmlnID0gJHNlcnZpY2VMb2NhdG9yLnJlc29sdmUoJ2NvbmZpZycpO1xuXHR0aGlzLl9zdG9yZURpc3BhdGNoZXIgPSAkc2VydmljZUxvY2F0b3IucmVzb2x2ZSgnc3RvcmVEaXNwYXRjaGVyJyk7XG5cblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdHRoaXMuX2V2ZW50QnVzLm9uKCdzdG9yZUNoYW5nZWQnLCBmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG5cdFx0c2VsZi5fY3VycmVudENoYW5nZWRTdG9yZXNbc3RvcmVOYW1lXSA9IHRydWU7XG5cdFx0aWYgKHNlbGYuX2lzU3RhdGVDaGFuZ2luZykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRzZWxmLl91cGRhdGVTdG9yZUNvbXBvbmVudHMoKTtcblx0fSk7XG59XG5cbi8qKlxuICogQ3VycmVudCBhcHBsaWNhdGlvbiBjb25maWcuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX2NvbmZpZyA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBsb2dnZXIuXG4gKiBAdHlwZSB7TG9nZ2VyfVxuICogQHByaXZhdGVcbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX2xvZ2dlciA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBzdG9yZSBkaXNwYXRjaGVyLlxuICogQHR5cGUge1N0b3JlRGlzcGF0Y2hlcn1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX3N0b3JlRGlzcGF0Y2hlciA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBzZXQgb2YgY29tcG9uZW50IGluc3RhbmNlcyBieSB1bmlxdWUga2V5cy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fY29tcG9uZW50SW5zdGFuY2VzID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHNldCBvZiBjb21wb25lbnQgZWxlbWVudHMgYnkgdW5pcXVlIGtleXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX2NvbXBvbmVudEVsZW1lbnRzID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHNldCBvZiBjb21wb25lbnQgYmluZGluZ3MgYnkgdW5pcXVlIGtleXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX2NvbXBvbmVudEJpbmRpbmdzID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHJvdXRpbmcgY29udGV4dC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fY3VycmVudFJvdXRpbmdDb250ZXh0ID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHNldCBvZiBjaGFuZ2VkIHN0b3Jlcy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fY3VycmVudENoYW5nZWRTdG9yZXMgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvbWlzZSBmb3IgcmVuZGVyZWQgcGFnZS5cbiAqIEB0eXBlIHtQcm9taXNlfVxuICogQHByaXZhdGVcbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlcmVkUHJvbWlzZSA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBzdGF0ZSBvZiB1cGRhdGluZyBjb21wb25lbnRzLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5faXNVcGRhdGluZyA9IGZhbHNlO1xuXG4vKipcbiAqIEN1cnJlbnQgYXdhaXRpbmcgcm91dGluZy5cbiAqIEB0eXBlIHt7c3RhdGU6IE9iamVjdCwgcm91dGluZ0NvbnRleHQ6IE9iamVjdH19XG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fYXdhaXRpbmdSb3V0aW5nID0gbnVsbDtcblxuLyoqXG4gKiBTZXRzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBOZXcgc3RhdGUgb2YgYXBwbGljYXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gcm91dGluZ0NvbnRleHQgUm91dGluZyBjb250ZXh0LlxuICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgZm9yIG5vdGhpbmcuXG4gKi9cbkRvY3VtZW50UmVuZGVyZXIucHJvdG90eXBlLmluaXRXaXRoU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHJvdXRpbmdDb250ZXh0KSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0cmV0dXJuIHNlbGYuX2dldFByb21pc2VGb3JSZWFkeVN0YXRlKClcblx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLl9jdXJyZW50Um91dGluZ0NvbnRleHQgPSByb3V0aW5nQ29udGV4dDtcblx0XHRcdHJldHVybiBzZWxmLl9zdG9yZURpc3BhdGNoZXIuc2V0U3RhdGUoc3RhdGUsIHJvdXRpbmdDb250ZXh0KTtcblx0XHR9KVxuXHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gc2VsZi5fY29tcG9uZW50TG9hZGVyLmdldENvbXBvbmVudHNCeU5hbWVzKCksXG5cdFx0XHRcdGVsZW1lbnRzID0gc2VsZi5fZmluZENvbXBvbmVudHMoXG5cdFx0XHRcdFx0c2VsZi5fd2luZG93LmRvY3VtZW50LmJvZHksIGNvbXBvbmVudHMsIHRydWVcblx0XHRcdFx0KTtcblx0XHRcdGVsZW1lbnRzLnVuc2hpZnQoc2VsZi5fd2luZG93LmRvY3VtZW50LmhlYWQpO1xuXHRcdFx0ZWxlbWVudHMudW5zaGlmdChzZWxmLl93aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblx0XHRcdHJldHVybiBzZWxmLl9pbml0aWFsV3JhcChjb21wb25lbnRzLCBlbGVtZW50cyk7XG5cdFx0fSk7XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgbmV3IHN0YXRlIG9mIGFwcGxpY2F0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIE5ldyBzdGF0ZSBvZiBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSByb3V0aW5nQ29udGV4dCBSb3V0aW5nIGNvbnRleHQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBmb3Igbm90aGluZy5cbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHN0YXRlLCByb3V0aW5nQ29udGV4dCkge1xuXHR0aGlzLl9hd2FpdGluZ1JvdXRpbmcgPSB7XG5cdFx0c3RhdGU6IHN0YXRlLFxuXHRcdHJvdXRpbmdDb250ZXh0OiByb3V0aW5nQ29udGV4dFxuXHR9O1xuXHRpZiAodGhpcy5faXNTdGF0ZUNoYW5naW5nKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JlbmRlcmVkUHJvbWlzZTtcblx0fVxuXG5cdC8vIHdlIHNob3VsZCBzZXQgdGhpcyBmbGFnIHRvIGF2b2lkIFwic3RvcmVDaGFuZ2VkXCJcblx0Ly8gZXZlbnQgaGFuZGxpbmcgZm9yIG5vd1xuXHR0aGlzLl9pc1N0YXRlQ2hhbmdpbmcgPSB0cnVlO1xuXG5cdHZhciBzZWxmID0gdGhpcztcblx0c2VsZi5fcmVuZGVyZWRQcm9taXNlID0gdGhpcy5fZ2V0UHJvbWlzZUZvclJlYWR5U3RhdGUoKVxuXHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIGFuZCB0aGVuIHdlIHVwZGF0ZSBhbGwgY29tcG9uZW50cyBvZiB0aGVzZSBzdG9yZXMgaW4gYSBiYXRjaC5cblx0XHRcdHJldHVybiBzZWxmLl91cGRhdGVTdG9yZUNvbXBvbmVudHMoKTtcblx0XHR9KVxuXHRcdC5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdlcnJvcicsIHJlYXNvbik7XG5cdFx0fSlcblx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLl9pc1N0YXRlQ2hhbmdpbmcgPSBmYWxzZTtcblx0XHR9KTtcblxuXHRyZXR1cm4gdGhpcy5fcmVuZGVyZWRQcm9taXNlO1xufTtcblxuLyoqXG4gKiBSZW5kZXJzIGNvbXBvbmVudCBpbnRvIEhUTUwgZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBIVE1MIGVsZW1lbnQgb2YgY29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdD99IHJlbmRlcmluZ0NvbnRleHQgUmVuZGVyaW5nIGNvbnRleHQgZm9yIGdyb3VwIHJlbmRlcmluZy5cbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQ29tcG9uZW50ID1cblx0ZnVuY3Rpb24gKGVsZW1lbnQsIHJlbmRlcmluZ0NvbnRleHQpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0cmV0dXJuIHRoaXMuX2dldFByb21pc2VGb3JSZWFkeVN0YXRlKClcblx0XHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGlkID0gc2VsZi5fZ2V0SWQoZWxlbWVudCk7XG5cdFx0XHRcdGlmICghaWQpIHtcblx0XHRcdFx0XHRzZWxmLl9sb2dnZXIud2Fybihcblx0XHRcdFx0XHRcdHV0aWwuZm9ybWF0KFdBUk5fSURfTk9UX1NQRUNJRklFRCwgY29tcG9uZW50TmFtZSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghcmVuZGVyaW5nQ29udGV4dCkge1xuXHRcdFx0XHRcdHJlbmRlcmluZ0NvbnRleHQgPSBzZWxmLl9jcmVhdGVSZW5kZXJpbmdDb250ZXh0KFtdKTtcblx0XHRcdFx0XHRyZW5kZXJpbmdDb250ZXh0LnJvb3RJZHNbaWRdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjb21wb25lbnROYW1lID0gbW9kdWxlSGVscGVyLmdldE9yaWdpbmFsQ29tcG9uZW50TmFtZShcblx0XHRcdFx0XHRcdGVsZW1lbnQudGFnTmFtZVxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0aGFkQ2hpbGRyZW4gPSBlbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSxcblx0XHRcdFx0XHRjb21wb25lbnQgPSByZW5kZXJpbmdDb250ZXh0LmNvbXBvbmVudHNbY29tcG9uZW50TmFtZV0sXG5cdFx0XHRcdFx0aW5zdGFuY2UgPSBzZWxmLl9jb21wb25lbnRJbnN0YW5jZXNbaWRdO1xuXG5cdFx0XHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlkIGluIHJlbmRlcmluZ0NvbnRleHQucmVuZGVyZWRJZHMpIHtcblx0XHRcdFx0XHRzZWxmLl9sb2dnZXIud2Fybihcblx0XHRcdFx0XHRcdHV0aWwuZm9ybWF0KFdBUk5fU0FNRV9JRCwgaWQsIGNvbXBvbmVudE5hbWUpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZW5kZXJpbmdDb250ZXh0LnJlbmRlcmVkSWRzW2lkXSA9IHRydWU7XG5cblx0XHRcdFx0aWYgKCFpbnN0YW5jZSkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuJGNvbnRleHQgPVxuXHRcdFx0XHRcdFx0c2VsZi5fZ2V0Q29tcG9uZW50Q29udGV4dChjb21wb25lbnQsIGVsZW1lbnQpO1xuXHRcdFx0XHRcdGluc3RhbmNlID0gc2VsZi5fc2VydmljZUxvY2F0b3IucmVzb2x2ZUluc3RhbmNlKFxuXHRcdFx0XHRcdFx0Y29tcG9uZW50LmNvbnN0cnVjdG9yLCByZW5kZXJpbmdDb250ZXh0LmNvbmZpZ1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0aW5zdGFuY2UuJGNvbnRleHQgPSBjb21wb25lbnQuY29uc3RydWN0b3IucHJvdG90eXBlLiRjb250ZXh0O1xuXHRcdFx0XHRcdHNlbGYuX2NvbXBvbmVudEluc3RhbmNlc1tpZF0gPSBpbnN0YW5jZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBldmVudEFyZ3MgPSB7XG5cdFx0XHRcdFx0bmFtZTogY29tcG9uZW50TmFtZSxcblx0XHRcdFx0XHRjb250ZXh0OiBpbnN0YW5jZS4kY29udGV4dFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHNlbGYuX2NvbXBvbmVudEVsZW1lbnRzW2lkXSA9IGVsZW1lbnQ7XG5cblx0XHRcdFx0dmFyIHN0YXJ0VGltZSA9IGhyVGltZUhlbHBlci5nZXQoKTtcblx0XHRcdFx0c2VsZi5fZXZlbnRCdXMuZW1pdCgnY29tcG9uZW50UmVuZGVyJywgZXZlbnRBcmdzKTtcblxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdFx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHVuYmluZCB0aGUgd2hvbGUgaGllcmFyY2h5IG9ubHkgYXRcblx0XHRcdFx0XHRcdC8vIHRoZSBiZWdpbm5pbmcgYW5kIG5vdCBmb3IgbmV3IGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRpZiAoIShpZCBpbiByZW5kZXJpbmdDb250ZXh0LnJvb3RJZHMpIHx8XG5cdFx0XHRcdFx0XHRcdCFoYWRDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBzZWxmLl91bmJpbmRBbGwoZWxlbWVudCwgcmVuZGVyaW5nQ29udGV4dCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0XHRcdFx0c2VsZi5fZXZlbnRCdXMuZW1pdCgnZXJyb3InLCByZWFzb24pO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0aWYgKGluc3RhbmNlLiRjb250ZXh0LmVsZW1lbnQgIT09IGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0aW5zdGFuY2UuJGNvbnRleHQgPSBzZWxmLl9nZXRDb21wb25lbnRDb250ZXh0KFxuXHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudCwgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHJlbmRlck1ldGhvZCA9IG1vZHVsZUhlbHBlci5nZXRNZXRob2RUb0ludm9rZShcblx0XHRcdFx0XHRcdFx0aW5zdGFuY2UsICdyZW5kZXInXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1vZHVsZUhlbHBlci5nZXRTYWZlUHJvbWlzZShyZW5kZXJNZXRob2QpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKGRhdGFDb250ZXh0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY29tcG9uZW50LnRlbXBsYXRlLnJlbmRlcihkYXRhQ29udGV4dCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNlbGYuX2hhbmRsZVJlbmRlckVycm9yKFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50LCBjb21wb25lbnQsIHJlYXNvblxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC50aGVuKGZ1bmN0aW9uIChodG1sKSB7XG5cdFx0XHRcdFx0XHR2YXIgaXNIZWFkID0gZWxlbWVudC50YWdOYW1lID09PSBUQUdfTkFNRVMuSEVBRDtcblx0XHRcdFx0XHRcdGlmIChodG1sID09PSAnJyAmJiBpc0hlYWQpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFyIHRtcEVsZW1lbnQgPSBzZWxmLl9jcmVhdGVUZW1wb3JhcnlFbGVtZW50KGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0dG1wRWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuXG5cdFx0XHRcdFx0XHRpZiAoaXNIZWFkKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuX21lcmdlSGVhZChlbGVtZW50LCB0bXBFbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRtb3JwaGRvbShlbGVtZW50LCB0bXBFbGVtZW50LCB7XG5cdFx0XHRcdFx0XHRcdG9uQmVmb3JlTW9ycGhFbENoaWxkcmVuOiBmdW5jdGlvbiAoZm91bmRFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZvdW5kRWxlbWVudCA9PT0gZWxlbWVudCB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0IXNlbGYuX2lzQ29tcG9uZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZW5kZXJpbmdDb250ZXh0LmNvbXBvbmVudHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvdW5kRWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHZhciBwcm9taXNlcyA9IHNlbGYuX2ZpbmRDb21wb25lbnRzKFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50LCByZW5kZXJpbmdDb250ZXh0LmNvbXBvbmVudHMsIGZhbHNlXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdC5tYXAoZnVuY3Rpb24gKGlubmVyQ29tcG9uZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHNlbGYucmVuZGVyQ29tcG9uZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0aW5uZXJDb21wb25lbnQsIHJlbmRlcmluZ0NvbnRleHRcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRldmVudEFyZ3MuaHJUaW1lID0gaHJUaW1lSGVscGVyLmdldChzdGFydFRpbWUpO1xuXHRcdFx0XHRcdFx0ZXZlbnRBcmdzLnRpbWUgPSBoclRpbWVIZWxwZXIudG9NaWxsaXNlY29uZHMoXG5cdFx0XHRcdFx0XHRcdGV2ZW50QXJncy5oclRpbWVcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdjb21wb25lbnRSZW5kZXJlZCcsIGV2ZW50QXJncyk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2VsZi5fYmluZENvbXBvbmVudChlbGVtZW50KTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdC8vIGNvbGxlY3RpbmcgZ2FyYmFnZSBvbmx5IHdoZW5cblx0XHRcdFx0XHRcdC8vIHRoZSBlbnRpcmUgcmVuZGVyaW5nIGlzIGZpbmlzaGVkXG5cdFx0XHRcdFx0XHRpZiAoIShpZCBpbiByZW5kZXJpbmdDb250ZXh0LnJvb3RJZHMpIHx8XG5cdFx0XHRcdFx0XHRcdCFoYWRDaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzZWxmLl9jb2xsZWN0UmVuZGVyaW5nR2FyYmFnZShyZW5kZXJpbmdDb250ZXh0KTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdlcnJvcicsIHJlYXNvbik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0fTtcblxuLyoqXG4gKiBHZXRzIGNvbXBvbmVudCBpbnN0YW5jZSBieSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQgSUQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IENvbXBvbmVudCBpbnN0YW5jZS5cbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q29tcG9uZW50QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuXHRyZXR1cm4gdGhpcy5fY29tcG9uZW50SW5zdGFuY2VzW2lkXSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBHZXRzIGNvbXBvbmVudCBpbnN0YW5jZSBieSBhIERPTSBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IENvbXBvbmVudCdzIEVsZW1lbnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IENvbXBvbmVudCBpbnN0YW5jZS5cbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q29tcG9uZW50QnlFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0aWYgKCFlbGVtZW50KSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIGlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUobW9kdWxlSGVscGVyLkFUVFJJQlVURV9JRCk7XG5cdHJldHVybiB0aGlzLmdldENvbXBvbmVudEJ5SWQoaWQpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCBldmVyeSBpbnN0YW5jZSBvZiBjb21wb25lbnQgaGFzIGVsZW1lbnQgb24gdGhlIHBhZ2UgYW5kXG4gKiByZW1vdmVzIGFsbCByZWZlcmVuY2VzIHRvIGNvbXBvbmVudHMgcmVtb3ZlZCBmcm9tIERPTS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIGZvciBub3RoaW5nLlxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5jb2xsZWN0R2FyYmFnZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRyZXR1cm4gdGhpcy5fZ2V0UHJvbWlzZUZvclJlYWR5U3RhdGUoKVxuXHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBwcm9taXNlcyA9IFtdO1xuXHRcdFx0T2JqZWN0LmtleXMoc2VsZi5fY29tcG9uZW50RWxlbWVudHMpXG5cdFx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0XHRcdGlmIChTUEVDSUFMX0lEUy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGVsZW1lbnQgPSBzZWxmLl93aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXHRcdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHByb21pc2UgPSBzZWxmLl91bmJpbmRDb21wb25lbnQoc2VsZi5fY29tcG9uZW50RWxlbWVudHNbaWRdKVxuXHRcdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLl9yZW1vdmVDb21wb25lbnQoaWQpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cHJvbWlzZXMucHVzaChwcm9taXNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZW5kZXJzIGNvbXBvbmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgTmFtZSBvZiBIVE1MIHRhZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzIEVsZW1lbnQgYXR0cmlidXRlcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPEVsZW1lbnQ+fSBQcm9taXNlIGZvciBIVE1MIGVsZW1lbnQgd2l0aCByZW5kZXJlZCBjb21wb25lbnQuXG4gKi9cbkRvY3VtZW50UmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICh0YWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdGlmICh0eXBlb2YgKHRhZ05hbWUpICE9PSAnc3RyaW5nJyB8fCAhYXR0cmlidXRlcyB8fFxuXHRcdHR5cGVvZiAoYXR0cmlidXRlcykgIT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KFxuXHRcdFx0bmV3IEVycm9yKEVSUk9SX0NSRUFURV9XUk9OR19BUkdVTUVOVFMpXG5cdFx0KTtcblx0fVxuXG5cdHZhciBzZWxmID0gdGhpcztcblx0cmV0dXJuIHRoaXMuX2dldFByb21pc2VGb3JSZWFkeVN0YXRlKClcblx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHNlbGYuX2NvbXBvbmVudExvYWRlci5nZXRDb21wb25lbnRzQnlOYW1lcygpLFxuXHRcdFx0XHRjb21wb25lbnROYW1lID0gbW9kdWxlSGVscGVyLmdldE9yaWdpbmFsQ29tcG9uZW50TmFtZSh0YWdOYW1lKTtcblxuXHRcdFx0aWYgKG1vZHVsZUhlbHBlci5pc0hlYWRDb21wb25lbnQoY29tcG9uZW50TmFtZSkgfHxcblx0XHRcdFx0bW9kdWxlSGVscGVyLmlzRG9jdW1lbnRDb21wb25lbnQoY29tcG9uZW50TmFtZSkgfHxcblx0XHRcdFx0IShjb21wb25lbnROYW1lIGluIGNvbXBvbmVudHMpKSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChcblx0XHRcdFx0XHRuZXcgRXJyb3IodXRpbC5mb3JtYXQoRVJST1JfQ1JFQVRFX1dST05HX05BTUUsIHRhZ05hbWUpKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2FmZVRhZ05hbWUgPSBtb2R1bGVIZWxwZXIuZ2V0VGFnTmFtZUZvckNvbXBvbmVudE5hbWUoY29tcG9uZW50TmFtZSk7XG5cblx0XHRcdHZhciBpZCA9IGF0dHJpYnV0ZXNbbW9kdWxlSGVscGVyLkFUVFJJQlVURV9JRF07XG5cdFx0XHRpZiAoIWlkIHx8IGlkIGluIHNlbGYuX2NvbXBvbmVudEluc3RhbmNlcykge1xuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKEVSUk9SX0NSRUFURV9XUk9OR19JRCkpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZWxlbWVudCA9IHNlbGYuX3dpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHNhZmVUYWdOYW1lKTtcblx0XHRcdE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpXG5cdFx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gc2VsZi5yZW5kZXJDb21wb25lbnQoZWxlbWVudClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0XHR9KTtcblx0XHR9KTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIGFsbCByZWZlcmVuY2VzIHRvIHJlbW92ZWQgY29tcG9uZW50cyBkdXJpbmcgcmVuZGVyaW5nIHByb2Nlc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVuZGVyaW5nQ29udGV4dCBDb250ZXh0IG9mIHJlbmRlcmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbkRvY3VtZW50UmVuZGVyZXIucHJvdG90eXBlLl9jb2xsZWN0UmVuZGVyaW5nR2FyYmFnZSA9XG5cdGZ1bmN0aW9uIChyZW5kZXJpbmdDb250ZXh0KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdE9iamVjdC5rZXlzKHJlbmRlcmluZ0NvbnRleHQudW5ib3VuZElkcylcblx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0XHQvLyB0aGlzIGNvbXBvbmVudCBoYXMgYmVlbiByZW5kZXJlZCBhZ2FpbiBhbmQgd2UgZG8gbm90IG5lZWQgdG9cblx0XHRcdFx0Ly8gcmVtb3ZlIGl0LlxuXHRcdFx0XHRpZiAoaWQgaW4gcmVuZGVyaW5nQ29udGV4dC5yZW5kZXJlZElkcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIHNvbWVvbmUgYWRkZWQgYW4gZWxlbWVudCB3aXRoIHRoZSBzYW1lIElEIGR1cmluZyB0aGVcblx0XHRcdFx0Ly8gcmVuZGVyaW5nIHByb2Nlc3Ncblx0XHRcdFx0aWYgKHNlbGYuX3dpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZWxmLl9yZW1vdmVDb21wb25lbnQoaWQpO1xuXHRcdFx0fSk7XG5cdH07XG5cbi8qKlxuICogVW5iaW5kcyBhbGwgZXZlbnQgaGFuZGxlcnMgZnJvbSBzcGVjaWZpZWQgY29tcG9uZW50IGFuZCBhbGwgaXQncyBkZXNjZW5kYW50cy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBDb21wb25lbnQgSFRNTCBlbGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IHJlbmRlcmluZ0NvbnRleHQgQ29udGV4dCBvZiByZW5kZXJpbmcuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBmb3Igbm90aGluZy5cbiAqIEBwcml2YXRlXG4gKi9cbkRvY3VtZW50UmVuZGVyZXIucHJvdG90eXBlLl91bmJpbmRBbGwgPSBmdW5jdGlvbiAoZWxlbWVudCwgcmVuZGVyaW5nQ29udGV4dCkge1xuXHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0cm9vdElkID0gdGhpcy5fZ2V0SWQoZWxlbWVudCksXG5cdFx0cHJvbWlzZXMgPSBbXTtcblxuXHRzZWxmLl9maW5kQ29tcG9uZW50cyhlbGVtZW50LCByZW5kZXJpbmdDb250ZXh0LmNvbXBvbmVudHMsIHRydWUpXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKGlubmVyRWxlbWVudCkge1xuXHRcdFx0dmFyIGlkID0gc2VsZi5fZ2V0SWQoaW5uZXJFbGVtZW50KTtcblx0XHRcdHJlbmRlcmluZ0NvbnRleHQudW5ib3VuZElkc1tpZF0gPSB0cnVlO1xuXHRcdFx0cHJvbWlzZXMucHVzaChzZWxmLl91bmJpbmRDb21wb25lbnQoaW5uZXJFbGVtZW50KSk7XG5cdFx0fSk7XG5cblx0cmVuZGVyaW5nQ29udGV4dC51bmJvdW5kSWRzW3Jvb3RJZF0gPSB0cnVlO1xuXHRwcm9taXNlcy5wdXNoKHRoaXMuX3VuYmluZENvbXBvbmVudChlbGVtZW50KSk7XG5cblx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5cbi8qKlxuICogVW5iaW5kcyBhbGwgZXZlbnQgaGFuZGxlcnMgZnJvbSBzcGVjaWZpZWQgY29tcG9uZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IENvbXBvbmVudCBIVE1MIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBmb3Igbm90aGluZy5cbiAqIEBwcml2YXRlXG4gKi9cbkRvY3VtZW50UmVuZGVyZXIucHJvdG90eXBlLl91bmJpbmRDb21wb25lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHR2YXIgaWQgPSB0aGlzLl9nZXRJZChlbGVtZW50KSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRpbnN0YW5jZSA9IHRoaXMuX2NvbXBvbmVudEluc3RhbmNlc1tpZF07XG5cdGlmICghaW5zdGFuY2UpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH1cblx0aWYgKGlkIGluIHRoaXMuX2NvbXBvbmVudEJpbmRpbmdzKSB7XG5cdFx0T2JqZWN0LmtleXModGhpcy5fY29tcG9uZW50QmluZGluZ3NbaWRdKVxuXHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHRcdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG5cdFx0XHRcdFx0ZXZlbnROYW1lLFxuXHRcdFx0XHRcdHNlbGYuX2NvbXBvbmVudEJpbmRpbmdzW2lkXVtldmVudE5hbWVdLmhhbmRsZXIsXG5cdFx0XHRcdFx0Tk9OX0JVQkJMSU5HX0VWRU5UUy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHRkZWxldGUgdGhpcy5fY29tcG9uZW50QmluZGluZ3NbaWRdO1xuXHR9XG5cdHZhciB1bmJpbmRNZXRob2QgPSBtb2R1bGVIZWxwZXIuZ2V0TWV0aG9kVG9JbnZva2UoaW5zdGFuY2UsICd1bmJpbmQnKTtcblx0cmV0dXJuIG1vZHVsZUhlbHBlci5nZXRTYWZlUHJvbWlzZSh1bmJpbmRNZXRob2QpXG5cdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5fZXZlbnRCdXMuZW1pdCgnY29tcG9uZW50VW5ib3VuZCcsIHtcblx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0aWQ6ICFTUEVDSUFMX0lEUy5oYXNPd25Qcm9wZXJ0eShpZCkgPyBpZCA6IG51bGxcblx0XHRcdH0pO1xuXHRcdH0pXG5cdFx0LmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcblx0XHRcdHNlbGYuX2V2ZW50QnVzLmVtaXQoJ2Vycm9yJywgcmVhc29uKTtcblx0XHR9KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBjb21wb25lbnQgZnJvbSB0aGUgbGlzdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBJRFxuICogQHByaXZhdGVcbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX3JlbW92ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpZCkge1xuXHRkZWxldGUgdGhpcy5fY29tcG9uZW50RWxlbWVudHNbaWRdO1xuXHRkZWxldGUgdGhpcy5fY29tcG9uZW50SW5zdGFuY2VzW2lkXTtcblx0ZGVsZXRlIHRoaXMuX2NvbXBvbmVudEJpbmRpbmdzW2lkXTtcbn07XG5cbi8qKlxuICogQmluZHMgYWxsIHJlcXVpcmVkIGV2ZW50IGhhbmRsZXJzIHRvIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBDb21wb25lbnQgSFRNTCBlbGVtZW50LlxuICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgZm9yIG5vdGhpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fYmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdHZhciBpZCA9IHRoaXMuX2dldElkKGVsZW1lbnQpLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdGluc3RhbmNlID0gdGhpcy5fY29tcG9uZW50SW5zdGFuY2VzW2lkXTtcblx0aWYgKCFpbnN0YW5jZSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0fVxuXG5cdHZhciBiaW5kTWV0aG9kID0gbW9kdWxlSGVscGVyLmdldE1ldGhvZFRvSW52b2tlKGluc3RhbmNlLCAnYmluZCcpO1xuXHRyZXR1cm4gbW9kdWxlSGVscGVyLmdldFNhZmVQcm9taXNlKGJpbmRNZXRob2QpXG5cdFx0LnRoZW4oZnVuY3Rpb24gKGJpbmRpbmdzKSB7XG5cdFx0XHRpZiAoIWJpbmRpbmdzIHx8IHR5cGVvZiAoYmluZGluZ3MpICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdjb21wb25lbnRCb3VuZCcsIHtcblx0XHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0XHRcdGlkOiAhU1BFQ0lBTF9JRFMuaGFzT3duUHJvcGVydHkoaWQpID8gaWQgOiBudWxsXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxmLl9jb21wb25lbnRCaW5kaW5nc1tpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0T2JqZWN0LmtleXMoYmluZGluZ3MpXG5cdFx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0XHRcdFx0XHRldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoZXZlbnROYW1lIGluIHNlbGYuX2NvbXBvbmVudEJpbmRpbmdzW2lkXSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgc2VsZWN0b3JIYW5kbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoYmluZGluZ3NbZXZlbnROYW1lXSlcblx0XHRcdFx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXHRcdFx0XHRcdFx0XHR2YXIgaGFuZGxlciA9IGJpbmRpbmdzW2V2ZW50TmFtZV1bc2VsZWN0b3JdO1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIChoYW5kbGVyKSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRzZWxlY3RvckhhbmRsZXJzW3NlbGVjdG9yXSA9IGhhbmRsZXIuYmluZChpbnN0YW5jZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZWxmLl9jb21wb25lbnRCaW5kaW5nc1tpZF1bZXZlbnROYW1lXSA9IHtcblx0XHRcdFx0XHRcdGhhbmRsZXI6IHNlbGYuX2NyZWF0ZUJpbmRpbmdIYW5kbGVyKFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50LCBzZWxlY3RvckhhbmRsZXJzXG5cdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0c2VsZWN0b3JIYW5kbGVyczogc2VsZWN0b3JIYW5kbGVyc1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFxuXHRcdFx0XHRcdFx0ZXZlbnROYW1lLFxuXHRcdFx0XHRcdFx0c2VsZi5fY29tcG9uZW50QmluZGluZ3NbaWRdW2V2ZW50TmFtZV0uaGFuZGxlcixcblx0XHRcdFx0XHRcdE5PTl9CVUJCTElOR19FVkVOVFMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0c2VsZi5fZXZlbnRCdXMuZW1pdCgnY29tcG9uZW50Qm91bmQnLCB7XG5cdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG5cdFx0XHRcdGlkOiBpZFxuXHRcdFx0fSk7XG5cdFx0fSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgdW5pdmVyc2FsIGV2ZW50IGhhbmRsZXIgZm9yIGRlbGVnYXRlZCBldmVudHMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbXBvbmVudFJvb3QgUm9vdCBlbGVtZW50IG9mIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxlY3RvckhhbmRsZXJzIE1hcCBvZiBldmVudCBoYW5kbGVycyBieSBDU1Mgc2VsZWN0b3JzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBVbml2ZXJzYWwgZXZlbnQgaGFuZGxlciBmb3IgZGVsZWdhdGVkIGV2ZW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbkRvY3VtZW50UmVuZGVyZXIucHJvdG90eXBlLl9jcmVhdGVCaW5kaW5nSGFuZGxlciA9XG5cdGZ1bmN0aW9uIChjb21wb25lbnRSb290LCBzZWxlY3RvckhhbmRsZXJzKSB7XG5cdFx0dmFyIHNlbGVjdG9ycyA9IE9iamVjdC5rZXlzKHNlbGVjdG9ySGFuZGxlcnMpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdHZhciBkaXNwYXRjaGVkRXZlbnQgPSBjcmVhdGVDdXN0b21FdmVudChldmVudCwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0ZWxlbWVudCA9IGV2ZW50LnRhcmdldCxcblx0XHRcdFx0dGFyZ2V0TWF0Y2hlcyA9IGdldE1hdGNoZXNNZXRob2QoZWxlbWVudCksXG5cdFx0XHRcdGlzSGFuZGxlZCA9IHNlbGVjdG9ycy5zb21lKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXHRcdFx0XHRcdGlmICh0YXJnZXRNYXRjaGVzKHNlbGVjdG9yKSkge1xuXHRcdFx0XHRcdFx0c2VsZWN0b3JIYW5kbGVyc1tzZWxlY3Rvcl0oZGlzcGF0Y2hlZEV2ZW50KTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0pO1xuXHRcdFx0aWYgKGlzSGFuZGxlZCB8fCAhZXZlbnQuYnViYmxlcykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHdoaWxlIChlbGVtZW50LnBhcmVudEVsZW1lbnQgJiYgZWxlbWVudCAhPT0gY29tcG9uZW50Um9vdCkge1xuXHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHR0YXJnZXRNYXRjaGVzID0gZ2V0TWF0Y2hlc01ldGhvZChlbGVtZW50KTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoIXRhcmdldE1hdGNoZXMoc2VsZWN0b3JzW2ldKSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlzSGFuZGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0c2VsZWN0b3JIYW5kbGVyc1tzZWxlY3RvcnNbaV1dKGRpc3BhdGNoZWRFdmVudCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaXNIYW5kbGVkKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZWxlbWVudCBpcyBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnRzIEN1cnJlbnQgY29tcG9uZW50cy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBET00gZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbkRvY3VtZW50UmVuZGVyZXIucHJvdG90eXBlLl9pc0NvbXBvbmVudCA9IGZ1bmN0aW9uIChjb21wb25lbnRzLCBlbGVtZW50KSB7XG5cdHZhciBjdXJyZW50Tm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXHRyZXR1cm4gbW9kdWxlSGVscGVyLkNPTVBPTkVOVF9QUkVGSVhfUkVHRVhQLnRlc3QoY3VycmVudE5vZGVOYW1lKSAmJlxuXHRcdChtb2R1bGVIZWxwZXIuZ2V0T3JpZ2luYWxDb21wb25lbnROYW1lKGN1cnJlbnROb2RlTmFtZSkgaW4gY29tcG9uZW50cyk7XG59O1xuXG4vKipcbiAqIEZpbmRzIGFsbCBkZXNjZW5kYW50IGNvbXBvbmVudHMgb2Ygc3BlY2lmaWVkIGNvbXBvbmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFJvb3QgY29tcG9uZW50IEhUTUwgZWxlbWVudCB0byBiZWdpbiBzZWFyY2ggd2l0aC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnRzIE1hcCBvZiBjb21wb25lbnRzIGJ5IG5hbWVzLlxuICogQHBhcmFtIHtib29sZWFufSBnb0luQ29tcG9uZW50cyBHbyBpbnNpZGUgbmVzdGVkIGNvbXBvbmVudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fZmluZENvbXBvbmVudHMgPVxuXHRmdW5jdGlvbiAoZWxlbWVudCwgY29tcG9uZW50cywgZ29JbkNvbXBvbmVudHMpIHtcblx0XHR2YXIgZWxlbWVudHMgPSBbXSxcblx0XHRcdHF1ZXVlID0gW2VsZW1lbnRdLFxuXHRcdFx0Y3VycmVudENoaWxkcmVuLCBpO1xuXG5cdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdGN1cnJlbnRDaGlsZHJlbiA9IHF1ZXVlLnNoaWZ0KCkuY2hpbGROb2Rlcztcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBjdXJyZW50Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Ly8gd2UgbmVlZCBvbmx5IEVsZW1lbnQgbm9kZXNcblx0XHRcdFx0aWYgKGN1cnJlbnRDaGlsZHJlbltpXS5ub2RlVHlwZSAhPT0gMSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYW5kIHRoZXkgc2hvdWxkIGJlIGNvbXBvbmVudHNcblx0XHRcdFx0aWYgKCF0aGlzLl9pc0NvbXBvbmVudChjb21wb25lbnRzLCBjdXJyZW50Q2hpbGRyZW5baV0pKSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjdXJyZW50Q2hpbGRyZW5baV0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGdvSW5Db21wb25lbnRzKSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaChjdXJyZW50Q2hpbGRyZW5baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnRzLnB1c2goY3VycmVudENoaWxkcmVuW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbWVudHM7XG5cdH07XG5cbi8qKlxuICogSGFuZGxlcyBlcnJvciB3aGlsZSByZW5kZXJpbmcuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgQ29tcG9uZW50IEhUTUwgZWxlbWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgRXJyb3IgdG8gaGFuZGxlLlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUHJvbWlzZSBmb3IgSFRNTCBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5faGFuZGxlUmVuZGVyRXJyb3IgPVxuXHRmdW5jdGlvbiAoZWxlbWVudCwgY29tcG9uZW50LCBlcnJvcikge1xuXHRcdHRoaXMuX2V2ZW50QnVzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXG5cdFx0Ly8gZG8gbm90IGNvcnJ1cHQgZXhpc3RlZCBIRUFEIHdoZW4gZXJyb3Igb2NjdXJzXG5cdFx0aWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gVEFHX05BTUVTLkhFQUQpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoJycpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fY29uZmlnLmlzUmVsZWFzZSAmJiBlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVycm9ySGVscGVyLnByZXR0eVByaW50KFxuXHRcdFx0XHRlcnJvciwgdGhpcy5fd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcblx0XHRcdCkpO1xuXHRcdH0gZWxzZSBpZiAoY29tcG9uZW50LmVycm9yVGVtcGxhdGUpIHtcblx0XHRcdHJldHVybiBjb21wb25lbnQuZXJyb3JUZW1wbGF0ZS5yZW5kZXIoZXJyb3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoJycpO1xuXHR9O1xuXG4vKipcbiAqIFVwZGF0ZXMgYWxsIGNvbXBvbmVudHMgdGhhdCBkZXBlbmQgb24gY3VycmVudCBzZXQgb2YgY2hhbmdlZCBzdG9yZXMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBmb3Igbm90aGluZy5cbiAqIEBwcml2YXRlXG4gKi9cbkRvY3VtZW50UmVuZGVyZXIucHJvdG90eXBlLl91cGRhdGVTdG9yZUNvbXBvbmVudHMgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLl9pc1VwZGF0aW5nKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHR9XG5cblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdC8vIGlmIGRvY3VtZW50IGNvbXBvbmVudCBpcyBjaGFuZ2VkIHdlIHNob3VsZCByZWxvYWQgdGhlIHBhZ2Vcblx0dmFyIGRvY3VtZW50U3RvcmUgPSB0aGlzLl93aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcblx0XHRtb2R1bGVIZWxwZXIuQVRUUklCVVRFX1NUT1JFXG5cdCk7XG5cdGlmIChkb2N1bWVudFN0b3JlIGluIHRoaXMuX2N1cnJlbnRDaGFuZ2VkU3RvcmVzKSB7XG5cdFx0dmFyIG5ld0xvY2F0aW9uID0gdGhpcy5fY3VycmVudFJvdXRpbmdDb250ZXh0LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG5cdFx0aWYgKG5ld0xvY2F0aW9uID09PSB0aGlzLl93aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKSkge1xuXHRcdFx0dGhpcy5fd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdH1cblx0XHR0aGlzLl93aW5kb3cubG9jYXRpb24uYXNzaWduKG5ld0xvY2F0aW9uKTtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH1cblxuXHR0aGlzLl9pc1VwZGF0aW5nID0gdHJ1ZTtcblxuXHQvLyBpZiB3ZSBoYXZlIGF3YWl0aW5nIHJvdXRpbmcgd2Ugc2hvdWxkIGFwcGx5IHN0YXRlIHRvIHRoZSBzdG9yZXNcblx0aWYgKHRoaXMuX2F3YWl0aW5nUm91dGluZykge1xuXHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50TG9hZGVyLmdldENvbXBvbmVudHNCeU5hbWVzKCksXG5cdFx0XHRjaGFuZ2VkQnlTdGF0ZSA9IHRoaXMuX3N0b3JlRGlzcGF0Y2hlci5zZXRTdGF0ZShcblx0XHRcdFx0dGhpcy5fYXdhaXRpbmdSb3V0aW5nLnN0YXRlLFxuXHRcdFx0XHR0aGlzLl9hd2FpdGluZ1JvdXRpbmcucm91dGluZ0NvbnRleHRcblx0XHRcdCk7XG5cblx0XHRjaGFuZ2VkQnlTdGF0ZS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRzZWxmLl9jdXJyZW50Q2hhbmdlZFN0b3Jlc1tuYW1lXSA9IHRydWU7XG5cdFx0fSk7XG5cblx0XHQvLyB3ZSBzaG91bGQgdXBkYXRlIGNvbnRleHRzIG9mIHRoZSBzdG9yZXMgd2l0aCB0aGUgbmV3IHJvdXRpbmcgY29udGV4dFxuXHRcdHRoaXMuX2N1cnJlbnRSb3V0aW5nQ29udGV4dCA9IHRoaXMuX2F3YWl0aW5nUm91dGluZy5yb3V0aW5nQ29udGV4dDtcblx0XHRPYmplY3Qua2V5cyh0aGlzLl9jb21wb25lbnRJbnN0YW5jZXMpXG5cdFx0XHQuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcblx0XHRcdFx0dmFyIGluc3RhbmNlID0gc2VsZi5fY29tcG9uZW50SW5zdGFuY2VzW2lkXTtcblx0XHRcdFx0aW5zdGFuY2UuJGNvbnRleHQgPSBzZWxmLl9nZXRDb21wb25lbnRDb250ZXh0KFxuXHRcdFx0XHRcdGNvbXBvbmVudHNbaW5zdGFuY2UuJGNvbnRleHQubmFtZV0sXG5cdFx0XHRcdFx0aW5zdGFuY2UuJGNvbnRleHQuZWxlbWVudFxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0dGhpcy5fYXdhaXRpbmdSb3V0aW5nID0gbnVsbDtcblx0fVxuXG5cdHZhciBjaGFuZ2VkU3RvcmVzID0gT2JqZWN0LmtleXModGhpcy5fY3VycmVudENoYW5nZWRTdG9yZXMpO1xuXHRpZiAoY2hhbmdlZFN0b3Jlcy5sZW5ndGggPT09IDApIHtcblx0XHR0aGlzLl9pc1VwZGF0aW5nID0gZmFsc2U7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHR9XG5cblx0dGhpcy5fY3VycmVudENoYW5nZWRTdG9yZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdHZhciByZW5kZXJpbmdDb250ZXh0ID0gdGhpcy5fY3JlYXRlUmVuZGVyaW5nQ29udGV4dChjaGFuZ2VkU3RvcmVzKSxcblx0XHRwcm9taXNlcyA9IHJlbmRlcmluZ0NvbnRleHQucm9vdHMubWFwKGZ1bmN0aW9uIChyb290KSB7XG5cdFx0XHRyZW5kZXJpbmdDb250ZXh0LnJvb3RJZHNbc2VsZi5fZ2V0SWQocm9vdCldID0gdHJ1ZTtcblx0XHRcdHJldHVybiBzZWxmLnJlbmRlckNvbXBvbmVudChyb290LCByZW5kZXJpbmdDb250ZXh0KTtcblx0XHR9KTtcblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG5cdFx0LmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcblx0XHRcdHNlbGYuX2V2ZW50QnVzLmVtaXQoJ2Vycm9yJywgcmVhc29uKTtcblx0XHR9KVxuXHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGYuX2lzVXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdHNlbGYuX2V2ZW50QnVzLmVtaXQoJ2RvY3VtZW50VXBkYXRlZCcsIGNoYW5nZWRTdG9yZXMpO1xuXHRcdFx0cmV0dXJuIHNlbGYuX3VwZGF0ZVN0b3JlQ29tcG9uZW50cygpO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgbmV3IGFuZCBleGlzdGVkIGhlYWQgZWxlbWVudHMgYW5kIGNoYW5nZSBvbmx5IGRpZmZlcmVuY2UuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGhlYWQgSEVBRCBET00gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gbmV3SGVhZCBOZXcgaGVhZCBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuLypqc2hpbnQgbWF4Y29tcGxleGl0eTpmYWxzZSAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX21lcmdlSGVhZCA9IGZ1bmN0aW9uIChoZWFkLCBuZXdIZWFkKSB7XG5cdGlmICghbmV3SGVhZCkge1xuXHRcdHJldHVybjtcblx0fVxuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0dmFyIG1hcCA9IHRoaXMuX2dldEhlYWRNYXAoaGVhZC5jaGlsZE5vZGVzKSxcblx0XHRjdXJyZW50LCBpLCBrZXksIG9sZEtleSwgb2xkSXRlbSxcblx0XHRzYW1lTWV0YUVsZW1lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRmb3IgKGkgPSAwOyBpIDwgbmV3SGVhZC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y3VycmVudCA9IG5ld0hlYWQuY2hpbGROb2Rlc1tpXTtcblxuXHRcdGlmICghKGN1cnJlbnQubm9kZU5hbWUgaW4gbWFwKSkge1xuXHRcdFx0bWFwW2N1cnJlbnQubm9kZU5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGN1cnJlbnQubm9kZU5hbWUpIHtcblx0XHRcdC8vIHRoZXNlIGVsZW1lbnRzIGNhbiBiZSBvbmx5IHJlcGxhY2VkXG5cdFx0XHRjYXNlIFRBR19OQU1FUy5USVRMRTpcblx0XHRcdGNhc2UgVEFHX05BTUVTLkJBU0U6XG5cdFx0XHRjYXNlIFRBR19OQU1FUy5OT1NDUklQVDpcblx0XHRcdFx0a2V5ID0gdGhpcy5fZ2V0Tm9kZUtleShjdXJyZW50KTtcblx0XHRcdFx0b2xkSXRlbSA9IGhlYWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoY3VycmVudC5ub2RlTmFtZSlbMF07XG5cdFx0XHRcdGlmIChvbGRJdGVtKSB7XG5cdFx0XHRcdFx0b2xkS2V5ID0gdGhpcy5fZ2V0Tm9kZUtleShvbGRJdGVtKTtcblx0XHRcdFx0XHRoZWFkLnJlcGxhY2VDaGlsZChjdXJyZW50LCBvbGRJdGVtKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoZWFkLmFwcGVuZENoaWxkKGN1cnJlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHdoZW4gd2UgZG8gcmVwbGFjZSBvciBhcHBlbmQgY3VycmVudCBpcyByZW1vdmVkIGZyb20gbmV3SGVhZFxuXHRcdFx0XHQvLyB0aGVyZWZvcmUgd2UgbmVlZCB0byBkZWNyZW1lbnQgaW5kZXhcblx0XHRcdFx0aS0tO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gdGhlc2UgZWxlbWVudHMgY2FuIG5vdCBiZSBkZWxldGVkIGZyb20gaGVhZFxuXHRcdFx0Ly8gdGhlcmVmb3JlIHdlIGp1c3QgYWRkIG5ldyBlbGVtZW50cyB0aGF0IGRpZmZlcnMgZnJvbSBleGlzdGVkXG5cdFx0XHRjYXNlIFRBR19OQU1FUy5TVFlMRTpcblx0XHRcdGNhc2UgVEFHX05BTUVTLkxJTks6XG5cdFx0XHRjYXNlIFRBR19OQU1FUy5TQ1JJUFQ6XG5cdFx0XHRcdGtleSA9IHNlbGYuX2dldE5vZGVLZXkoY3VycmVudCk7XG5cdFx0XHRcdGlmICghKGtleSBpbiBtYXBbY3VycmVudC5ub2RlTmFtZV0pKSB7XG5cdFx0XHRcdFx0aGVhZC5hcHBlbmRDaGlsZChjdXJyZW50KTtcblx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHQvLyBtZXRhIGFuZCBvdGhlciBlbGVtZW50cyBjYW4gYmUgZGVsZXRlZFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QgZGVsZXRlIGFuZCBhcHBlbmQgc2FtZSBlbGVtZW50c1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0a2V5ID0gc2VsZi5fZ2V0Tm9kZUtleShjdXJyZW50KTtcblx0XHRcdFx0aWYgKGtleSBpbiBtYXBbY3VycmVudC5ub2RlTmFtZV0pIHtcblx0XHRcdFx0XHRzYW1lTWV0YUVsZW1lbnRzW2tleV0gPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoY3VycmVudCk7XG5cdFx0XHRcdFx0aS0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdGlmIChUQUdfTkFNRVMuTUVUQSBpbiBtYXApIHtcblx0XHQvLyByZW1vdmUgbWV0YSB0YWdzIHdoaWNoIGEgbm90IGluIGEgbmV3IGhlYWQgc3RhdGVcblx0XHRPYmplY3Qua2V5cyhtYXBbVEFHX05BTUVTLk1FVEFdKVxuXHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKG1ldGFLZXkpIHtcblx0XHRcdFx0aWYgKG1ldGFLZXkgaW4gc2FtZU1ldGFFbGVtZW50cykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGhlYWQucmVtb3ZlQ2hpbGQobWFwW1RBR19OQU1FUy5NRVRBXVttZXRhS2V5XSk7XG5cdFx0XHR9KTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXRzIG1hcCBvZiBhbGwgSEVBRCdzIGVsZW1lbnRzLlxuICogQHBhcmFtIHtOb2RlTGlzdH0gaGVhZENoaWxkcmVuIEhlYWQgY2hpbGRyZW4gRE9NIG5vZGVzLlxuICogQHJldHVybnMge09iamVjdH0gTWFwIG9mIEhFQUQgZWxlbWVudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fZ2V0SGVhZE1hcCA9IGZ1bmN0aW9uIChoZWFkQ2hpbGRyZW4pIHtcblx0Ly8gQ3JlYXRlIG1hcCBvZiA8bWV0YT4sIDxsaW5rPiwgPHN0eWxlPiBhbmQgPHNjcmlwdD4gdGFnc1xuXHQvLyBieSB1bmlxdWUga2V5cyB0aGF0IGNvbnRhaW4gYXR0cmlidXRlcyBhbmQgY29udGVudFxuXHR2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcblx0XHRpLCBjdXJyZW50LFxuXHRcdHNlbGYgPSB0aGlzO1xuXG5cdGZvciAoaSA9IDA7IGkgPCBoZWFkQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRjdXJyZW50ID0gaGVhZENoaWxkcmVuW2ldO1xuXHRcdGlmICghKGN1cnJlbnQubm9kZU5hbWUgaW4gbWFwKSkge1xuXHRcdFx0bWFwW2N1cnJlbnQubm9kZU5hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR9XG5cdFx0bWFwW2N1cnJlbnQubm9kZU5hbWVdW3NlbGYuX2dldE5vZGVLZXkoY3VycmVudCldID0gY3VycmVudDtcblx0fVxuXHRyZXR1cm4gbWFwO1xufTtcblxuLyoqXG4gKiBHZXRzIHVuaXF1ZSBlbGVtZW50IGtleSB1c2luZyBlbGVtZW50J3MgYXR0cmlidXRlcyBhbmQgaXRzIGNvbnRlbnQuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgSFRNTCBlbGVtZW50LlxuICogQHJldHVybnMge3N0cmluZ30gVW5pcXVlIGtleSBmb3IgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbkRvY3VtZW50UmVuZGVyZXIucHJvdG90eXBlLl9nZXROb2RlS2V5ID0gZnVuY3Rpb24gKG5vZGUpIHtcblx0dmFyIGN1cnJlbnQsIGksXG5cdFx0YXR0cmlidXRlcyA9IFtdO1xuXG5cdGlmIChub2RlLm5vZGVUeXBlICE9PSBOT0RFX1RZUEVTLkVMRU1FTlRfTk9ERSkge1xuXHRcdHJldHVybiBub2RlLm5vZGVWYWx1ZSB8fCAnJztcblx0fVxuXG5cdGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGN1cnJlbnQgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG5cdFx0XHRhdHRyaWJ1dGVzLnB1c2goY3VycmVudC5uYW1lICsgJz0nICsgY3VycmVudC52YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGF0dHJpYnV0ZXNcblx0XHRcdC5zb3J0KClcblx0XHRcdC5qb2luKCd8JykgKyAnPicgKyBub2RlLnRleHRDb250ZW50O1xufTtcblxuLyoqXG4gKiBEb2VzIGluaXRpYWwgd3JhcHBpbmcgZm9yIGV2ZXJ5IGNvbXBvbmVudCBvbiB0aGUgcGFnZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgQ3VycmVudCBjb21wb25lbnRzIGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBlbGVtZW50IEVsZW1lbnRzIGxpc3QuXG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5faW5pdGlhbFdyYXAgPSBmdW5jdGlvbiAoY29tcG9uZW50cywgZWxlbWVudHMpIHtcblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdGN1cnJlbnQgPSBlbGVtZW50cy5wb3AoKTtcblxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaWQgPSBzZWxmLl9nZXRJZChjdXJyZW50KTtcblx0XHRcdGlmICghaWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29tcG9uZW50TmFtZSA9IG1vZHVsZUhlbHBlci5nZXRPcmlnaW5hbENvbXBvbmVudE5hbWUoXG5cdFx0XHRcdFx0Y3VycmVudC5ub2RlTmFtZVxuXHRcdFx0XHQpO1xuXHRcdFx0aWYgKCEoY29tcG9uZW50TmFtZSBpbiBjb21wb25lbnRzKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgY29uc3RydWN0b3IgPSBjb21wb25lbnRzW2NvbXBvbmVudE5hbWVdLmNvbnN0cnVjdG9yO1xuXHRcdFx0Y29uc3RydWN0b3IucHJvdG90eXBlLiRjb250ZXh0ID0gc2VsZi5fZ2V0Q29tcG9uZW50Q29udGV4dChcblx0XHRcdFx0Y29tcG9uZW50c1tjb21wb25lbnROYW1lXSwgY3VycmVudFxuXHRcdFx0KTtcblxuXHRcdFx0dmFyIGluc3RhbmNlID0gc2VsZi5fc2VydmljZUxvY2F0b3IucmVzb2x2ZUluc3RhbmNlKFxuXHRcdFx0XHRjb25zdHJ1Y3Rvciwgc2VsZi5fY29uZmlnXG5cdFx0XHQpO1xuXHRcdFx0aW5zdGFuY2UuJGNvbnRleHQgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuJGNvbnRleHQ7XG5cdFx0XHRzZWxmLl9jb21wb25lbnRFbGVtZW50c1tpZF0gPSBjdXJyZW50O1xuXHRcdFx0c2VsZi5fY29tcG9uZW50SW5zdGFuY2VzW2lkXSA9IGluc3RhbmNlO1xuXHRcdFx0Ly8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgb2YgdGhlIGNvbXBvbmVudFxuXHRcdFx0c2VsZi5fc3RvcmVEaXNwYXRjaGVyLmdldFN0b3JlKFxuXHRcdFx0XHRjdXJyZW50LmdldEF0dHJpYnV0ZShtb2R1bGVIZWxwZXIuQVRUUklCVVRFX1NUT1JFKVxuXHRcdFx0KTtcblx0XHRcdHNlbGYuX2V2ZW50QnVzLmVtaXQoJ2NvbXBvbmVudFJlbmRlcmVkJywge1xuXHRcdFx0XHRuYW1lOiBjb21wb25lbnROYW1lLFxuXHRcdFx0XHRhdHRyaWJ1dGVzOiBpbnN0YW5jZS4kY29udGV4dC5hdHRyaWJ1dGVzLFxuXHRcdFx0XHRjb250ZXh0OiBpbnN0YW5jZS4kY29udGV4dFxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc2VsZi5fYmluZENvbXBvbmVudChjdXJyZW50KTtcblx0XHR9KVxuXHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLl9pbml0aWFsV3JhcChjb21wb25lbnRzLCBlbGVtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGYuX2V2ZW50QnVzLmVtaXQoXG5cdFx0XHRcdCdkb2N1bWVudFJlbmRlcmVkJywgc2VsZi5fY3VycmVudFJvdXRpbmdDb250ZXh0XG5cdFx0XHQpO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIGNvbXBvbmVudCBjb250ZXh0IHVzaW5nIGJhc2ljIGNvbnRleHQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IENvbXBvbmVudCBkZXRhaWxzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IERPTSBlbGVtZW50IG9mIGNvbXBvbmVudC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IENvbXBvbmVudCBjb250ZXh0LlxuICogQHByaXZhdGVcbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX2dldENvbXBvbmVudENvbnRleHQgPVxuXHRmdW5jdGlvbiAoY29tcG9uZW50LCBlbGVtZW50KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0c3RvcmVOYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUobW9kdWxlSGVscGVyLkFUVFJJQlVURV9TVE9SRSksXG5cdFx0XHRjb21wb25lbnRDb250ZXh0ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9jdXJyZW50Um91dGluZ0NvbnRleHQpO1xuXG5cdFx0Ly8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgb2YgdGhlIGNvbXBvbmVudFxuXHRcdHRoaXMuX3N0b3JlRGlzcGF0Y2hlci5nZXRTdG9yZShzdG9yZU5hbWUpO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29tcG9uZW50Q29udGV4dCwge1xuXHRcdFx0bmFtZToge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcG9uZW50Lm5hbWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiBhdHRyaWJ1dGVzVG9PYmplY3QoZWxlbWVudC5hdHRyaWJ1dGVzKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y29tcG9uZW50Q29udGV4dC5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRjb21wb25lbnRDb250ZXh0LmdldENvbXBvbmVudEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcblx0XHRcdHJldHVybiBzZWxmLmdldENvbXBvbmVudEJ5SWQoaWQpO1xuXHRcdH07XG5cdFx0Y29tcG9uZW50Q29udGV4dC5nZXRDb21wb25lbnRCeUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHNlbGYuZ2V0Q29tcG9uZW50QnlFbGVtZW50KGVsZW1lbnQpO1xuXHRcdH07XG5cdFx0Y29tcG9uZW50Q29udGV4dC5jcmVhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgYXR0cmlidXRlcykge1xuXHRcdFx0cmV0dXJuIHNlbGYuY3JlYXRlQ29tcG9uZW50KHRhZ05hbWUsIGF0dHJpYnV0ZXMpO1xuXHRcdH07XG5cdFx0Y29tcG9uZW50Q29udGV4dC5jb2xsZWN0R2FyYmFnZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBzZWxmLmNvbGxlY3RHYXJiYWdlKCk7XG5cdFx0fTtcblx0XHRjb21wb25lbnRDb250ZXh0LmdldFN0b3JlRGF0YSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjdXJyZW50U3RvcmVOYW1lID0gZWxlbWVudFxuXHRcdFx0XHQuZ2V0QXR0cmlidXRlKG1vZHVsZUhlbHBlci5BVFRSSUJVVEVfU1RPUkUpO1xuXHRcdFx0cmV0dXJuIHNlbGYuX3N0b3JlRGlzcGF0Y2hlclxuXHRcdFx0XHQuZ2V0U3RvcmVEYXRhKGN1cnJlbnRTdG9yZU5hbWUpO1xuXHRcdH07XG5cdFx0Y29tcG9uZW50Q29udGV4dC5zZW5kQWN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcblx0XHRcdHZhciBjdXJyZW50U3RvcmVOYW1lID0gZWxlbWVudFxuXHRcdFx0XHQuZ2V0QXR0cmlidXRlKG1vZHVsZUhlbHBlci5BVFRSSUJVVEVfU1RPUkUpO1xuXHRcdFx0cmV0dXJuIHNlbGYuX3N0b3JlRGlzcGF0Y2hlclxuXHRcdFx0XHQuc2VuZEFjdGlvbihjdXJyZW50U3RvcmVOYW1lLCBuYW1lLCBhcmdzKTtcblx0XHR9O1xuXHRcdGNvbXBvbmVudENvbnRleHQuc2VuZEJyb2FkY2FzdEFjdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fc3RvcmVEaXNwYXRjaGVyXG5cdFx0XHRcdC5zZW5kQnJvYWRjYXN0QWN0aW9uKG5hbWUsIGFyZ3MpO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShjb21wb25lbnRDb250ZXh0KTtcblx0fTtcblxuLyoqXG4gKiBGaW5kcyBhbGwgcmVuZGVyaW5nIHJvb3RzIG9uIHBhZ2UgZm9yIGFsbCBjaGFuZ2VkIHN0b3Jlcy5cbiAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZWRTdG9yZU5hbWVzIExpc3Qgb2Ygc3RvcmUgbmFtZXMgd2hpY2ggaGFzIGJlZW4gY2hhbmdlZC5cbiAqIEByZXR1cm5zIHtBcnJheTxFbGVtZW50Pn0gSFRNTCBlbGVtZW50cyB0aGF0IGFyZSByZW5kZXJpbmcgcm9vdHMuXG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fZmluZFJlbmRlcmluZ1Jvb3RzID0gZnVuY3Rpb24gKGNoYW5nZWRTdG9yZU5hbWVzKSB7XG5cdHZhciBzZWxmID0gdGhpcyxcblx0XHRoZWFkU3RvcmUgPSB0aGlzLl93aW5kb3cuZG9jdW1lbnQuaGVhZC5nZXRBdHRyaWJ1dGUoXG5cdFx0XHRtb2R1bGVIZWxwZXIuQVRUUklCVVRFX1NUT1JFXG5cdFx0KSxcblx0XHRjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50TG9hZGVyLmdldENvbXBvbmVudHNCeU5hbWVzKCksXG5cdFx0Y29tcG9uZW50c0VsZW1lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcblx0XHRzdG9yZU5hbWVzU2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcblx0XHRyb290c1NldCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG5cdFx0cm9vdHMgPSBbXTtcblxuXHQvLyB3ZSBzaG91bGQgZmluZCBhbGwgY29tcG9uZW50cyBhbmQgdGhlbiBsb29raW5nIGZvciByb290c1xuXHRjaGFuZ2VkU3RvcmVOYW1lc1xuXHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0XHRcdHN0b3JlTmFtZXNTZXRbc3RvcmVOYW1lXSA9IHRydWU7XG5cdFx0XHRjb21wb25lbnRzRWxlbWVudHNbc3RvcmVOYW1lXSA9IHNlbGYuX3dpbmRvdy5kb2N1bWVudFxuXHRcdFx0XHQucXVlcnlTZWxlY3RvckFsbChcblx0XHRcdFx0XHQnWycgK1xuXHRcdFx0XHRcdG1vZHVsZUhlbHBlci5BVFRSSUJVVEVfSUQgK1xuXHRcdFx0XHRcdCddJyArXG5cdFx0XHRcdFx0J1snICtcblx0XHRcdFx0XHRtb2R1bGVIZWxwZXIuQVRUUklCVVRFX1NUT1JFICtcblx0XHRcdFx0XHQnPVwiJyArXG5cdFx0XHRcdFx0c3RvcmVOYW1lICtcblx0XHRcdFx0XHQnXCJdJ1xuXHRcdFx0XHQpO1xuXHRcdH0pO1xuXG5cdGlmIChtb2R1bGVIZWxwZXIuSEVBRF9DT01QT05FTlRfTkFNRSBpbiBjb21wb25lbnRzICYmXG5cdFx0aGVhZFN0b3JlIGluIHN0b3JlTmFtZXNTZXQpIHtcblx0XHRyb290c1NldFt0aGlzLl9nZXRJZCh0aGlzLl93aW5kb3cuZG9jdW1lbnQuaGVhZCldID0gdHJ1ZTtcblx0XHRyb290cy5wdXNoKHRoaXMuX3dpbmRvdy5kb2N1bWVudC5oZWFkKTtcblx0fVxuXG5cdGNoYW5nZWRTdG9yZU5hbWVzXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuXHRcdFx0dmFyIGN1cnJlbnQsIGN1cnJlbnRJZCxcblx0XHRcdFx0bGFzdFJvb3QsIGxhc3RSb290SWQsXG5cdFx0XHRcdGN1cnJlbnRTdG9yZSwgY3VycmVudENvbXBvbmVudE5hbWU7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50c0VsZW1lbnRzW3N0b3JlTmFtZV0ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y3VycmVudCA9IGNvbXBvbmVudHNFbGVtZW50c1tzdG9yZU5hbWVdW2ldO1xuXHRcdFx0XHRjdXJyZW50SWQgPSBjb21wb25lbnRzRWxlbWVudHNbc3RvcmVOYW1lXVtpXVxuXHRcdFx0XHRcdC5nZXRBdHRyaWJ1dGUobW9kdWxlSGVscGVyLkFUVFJJQlVURV9JRCk7XG5cdFx0XHRcdGxhc3RSb290ID0gY3VycmVudDtcblx0XHRcdFx0bGFzdFJvb3RJZCA9IGN1cnJlbnRJZDtcblx0XHRcdFx0Y3VycmVudENvbXBvbmVudE5hbWUgPSBtb2R1bGVIZWxwZXIuZ2V0T3JpZ2luYWxDb21wb25lbnROYW1lKFxuXHRcdFx0XHRcdGN1cnJlbnQudGFnTmFtZVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHdoaWxlIChjdXJyZW50LnBhcmVudEVsZW1lbnQpIHtcblx0XHRcdFx0XHRjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdGN1cnJlbnRJZCA9IHNlbGYuX2dldElkKGN1cnJlbnQpO1xuXHRcdFx0XHRcdGN1cnJlbnRTdG9yZSA9IGN1cnJlbnQuZ2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdFx0bW9kdWxlSGVscGVyLkFUVFJJQlVURV9TVE9SRVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBzdG9yZSBkaWQgbm90IGNoYW5nZSBzdGF0ZVxuXHRcdFx0XHRcdGlmICghY3VycmVudFN0b3JlIHx8ICEoY3VycmVudFN0b3JlIGluIHN0b3JlTmFtZXNTZXQpKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpcyBub3QgYW4gYWN0aXZlIGNvbXBvbmVudFxuXHRcdFx0XHRcdGlmICghKGN1cnJlbnRDb21wb25lbnROYW1lIGluIGNvbXBvbmVudHMpKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsYXN0Um9vdCA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0bGFzdFJvb3RJZCA9IGN1cnJlbnRJZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGFzdFJvb3RJZCBpbiByb290c1NldCkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJvb3RzU2V0W2xhc3RSb290SWRdID0gdHJ1ZTtcblx0XHRcdFx0cm9vdHMucHVzaChsYXN0Um9vdCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0cmV0dXJuIHJvb3RzO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHJlbmRlcmluZyBjb250ZXh0LlxuICogQHBhcmFtIHtBcnJheT99IGNoYW5nZWRTdG9yZXMgTmFtZXMgb2YgY2hhbmdlZCBzdG9yZXMuXG4gKiBAcmV0dXJucyB7e1xuICogICBjb25maWc6IE9iamVjdCxcbiAqICAgcmVuZGVyZWRJZHM6IHt9LFxuICogICB1bmJvdW5kSWRzOiB7fSxcbiAqICAgaXNIZWFkUmVuZGVyZWQ6IGJvb2xlYW4sXG4gKiAgIGJpbmRNZXRob2RzOiBBcnJheSxcbiAqICAgcm91dGluZ0NvbnRleHQ6IE9iamVjdCxcbiAqICAgY29tcG9uZW50czogT2JqZWN0LFxuICogICByb290czogQXJyYXkuPEVsZW1lbnQ+XG4gKiB9fSBUaGUgY29udGV4dCBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fY3JlYXRlUmVuZGVyaW5nQ29udGV4dCA9IGZ1bmN0aW9uIChjaGFuZ2VkU3RvcmVzKSB7XG5cdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50TG9hZGVyLmdldENvbXBvbmVudHNCeU5hbWVzKCk7XG5cblx0cmV0dXJuIHtcblx0XHRjb25maWc6IHRoaXMuX2NvbmZpZyxcblx0XHRyZW5kZXJlZElkczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblx0XHR1bmJvdW5kSWRzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXHRcdGlzSGVhZFJlbmRlcmVkOiBmYWxzZSxcblx0XHRiaW5kTWV0aG9kczogW10sXG5cdFx0cm91dGluZ0NvbnRleHQ6IHRoaXMuX2N1cnJlbnRSb3V0aW5nQ29udGV4dCxcblx0XHRjb21wb25lbnRzOiBjb21wb25lbnRzLFxuXHRcdHJvb3RJZHM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cdFx0cm9vdHM6IGNoYW5nZWRTdG9yZXMgPyB0aGlzLl9maW5kUmVuZGVyaW5nUm9vdHMoY2hhbmdlZFN0b3JlcykgOiBbXVxuXHR9O1xufTtcblxuLyoqXG4gKiBHZXRzIElEIG9mIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IEhUTUwgZWxlbWVudCBvZiBjb21wb25lbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBJRC5cbiAqL1xuRG9jdW1lbnRSZW5kZXJlci5wcm90b3R5cGUuX2dldElkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0aWYgKGVsZW1lbnQgPT09IHRoaXMuX3dpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcblx0XHRyZXR1cm4gU1BFQ0lBTF9JRFMuJCRkb2N1bWVudDtcblx0fVxuXHRpZiAoZWxlbWVudCA9PT0gdGhpcy5fd2luZG93LmRvY3VtZW50LmhlYWQpIHtcblx0XHRyZXR1cm4gU1BFQ0lBTF9JRFMuJCRoZWFkO1xuXHR9XG5cdHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShtb2R1bGVIZWxwZXIuQVRUUklCVVRFX0lEKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyB0ZW1wb3JhcnkgY2xvbmUgb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgRE9NIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY2xvbmUuXG4gKiBAcHJpdmF0ZVxuICovXG5Eb2N1bWVudFJlbmRlcmVyLnByb3RvdHlwZS5fY3JlYXRlVGVtcG9yYXJ5RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdHZhciB0bXAgPSB0aGlzLl93aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50LnRhZ05hbWUpLFxuXHRcdGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdHRtcC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlc1tpXS5uYW1lLCBhdHRyaWJ1dGVzW2ldLnZhbHVlKTtcblx0fVxuXHRyZXR1cm4gdG1wO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBOYW1lZE5vZGVNYXAgb2YgQXR0ciBpdGVtcyB0byBrZXktdmFsdWUgb2JqZWN0IG1hcC5cbiAqIEBwYXJhbSB7TmFtZWROb2RlTWFwfSBhdHRyaWJ1dGVzIExpc3Qgb2YgRWxlbWVudCBhdHRyaWJ1dGVzLlxuICogQHJldHVybnMge09iamVjdH0gTWFwIG9mIGF0dHJpYnV0ZSB2YWx1ZXMgYnkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGF0dHJpYnV0ZXNUb09iamVjdChhdHRyaWJ1dGVzKSB7XG5cdHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRyZXN1bHRbYXR0cmlidXRlc1tpXS5uYW1lXSA9IGF0dHJpYnV0ZXNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIGNyb3NzLWJyb3dzZXIgXCJtYXRjaGVzXCIgbWV0aG9kIGZvciB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBIVE1MIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFwibWF0Y2hlc1wiIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hlc01ldGhvZChlbGVtZW50KSB7XG5cdHZhciBtZXRob2QgPSAoZWxlbWVudC5tYXRjaGVzIHx8XG5cdFx0ZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGVsZW1lbnQub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3IpO1xuXG5cdHJldHVybiBtZXRob2QuYmluZChlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGltaXRhdGlvbiBvZiBvcmlnaW5hbCBFdmVudCBvYmplY3QgYnV0IHdpdGggc3BlY2lmaWVkIGN1cnJlbnRUYXJnZXQuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBPcmlnaW5hbCBldmVudCBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXJyZW50VGFyZ2V0R2V0dGVyIEdldHRlciBmb3IgY3VycmVudFRhcmdldC5cbiAqIEByZXR1cm5zIHtFdmVudH0gV3JhcHBlZCBldmVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXZlbnQoZXZlbnQsIGN1cnJlbnRUYXJnZXRHZXR0ZXIpIHtcblx0dmFyIGNhdEV2ZW50ID0gT2JqZWN0LmNyZWF0ZShldmVudCksXG5cdFx0a2V5cyA9IFtdLFxuXHRcdHByb3BlcnRpZXMgPSB7fTtcblx0Zm9yICh2YXIga2V5IGluIGV2ZW50KSB7XG5cdFx0a2V5cy5wdXNoKGtleSk7XG5cdH1cblx0a2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRpZiAodHlwZW9mIChldmVudFtrZXldKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cHJvcGVydGllc1trZXldID0ge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gZXZlbnRba2V5XS5iaW5kKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRwcm9wZXJ0aWVzW2tleV0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGV2ZW50W2tleV07XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0ZXZlbnRba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xuXG5cdHByb3BlcnRpZXMuY3VycmVudFRhcmdldCA9IHtcblx0XHRnZXQ6IGN1cnJlbnRUYXJnZXRHZXR0ZXJcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2F0RXZlbnQsIHByb3BlcnRpZXMpO1xuXHRPYmplY3Quc2VhbChjYXRFdmVudCk7XG5cdE9iamVjdC5mcmVlemUoY2F0RXZlbnQpO1xuXHRyZXR1cm4gY2F0RXZlbnQ7XG59IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9nZ2VyO1xuXG52YXIgTEVWRUxTID0ge1xuXHRERUJVRzogJ2RlYnVnJyxcblx0VFJBQ0U6ICd0cmFjZScsXG5cdElORk86ICdpbmZvJyxcblx0V0FSTjogJ3dhcm4nLFxuXHRFUlJPUjogJ2Vycm9yJyxcblx0RkFUQUw6ICdmYXRhbCdcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBicm93c2VyIGxvZ2dlci5cbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gbGV2ZWxzIExldmVscyB0byBsb2cuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTG9nZ2VyKGxldmVscykge1xuXHRpZiAodHlwZW9mIChsZXZlbHMpID09PSAnb2JqZWN0Jykge1xuXHRcdHRoaXMuX2xldmVscyA9IGxldmVscztcblx0fVxuXG5cdGlmICh0eXBlb2YgKGxldmVscykgPT09ICdzdHJpbmcnKSB7XG5cdFx0dGhpcy5fbGV2ZWxzID0ge307XG5cdFx0T2JqZWN0LmtleXMoTEVWRUxTKVxuXHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG5cdFx0XHRcdHRoaXMuX2xldmVsc1tMRVZFTFNbbGV2ZWxdXSA9XG5cdFx0XHRcdFx0KGxldmVscy5zZWFyY2goTEVWRUxTW2xldmVsXSkgIT09IC0xKTtcblx0XHRcdH0sIHRoaXMpO1xuXHR9XG5cblx0dGhpcy5kZWJ1ZyA9IHRoaXMuZGVidWcuYmluZCh0aGlzKTtcblx0dGhpcy50cmFjZSA9IHRoaXMudHJhY2UuYmluZCh0aGlzKTtcblx0dGhpcy5pbmZvID0gdGhpcy5pbmZvLmJpbmQodGhpcyk7XG5cdHRoaXMud2FybiA9IHRoaXMud2Fybi5iaW5kKHRoaXMpO1xuXHR0aGlzLmVycm9yID0gdGhpcy5lcnJvci5iaW5kKHRoaXMpO1xuXHR0aGlzLmZhdGFsID0gdGhpcy5mYXRhbC5iaW5kKHRoaXMpO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgbGV2ZWxzIG9mIGxvZ2dpbmcuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5fbGV2ZWxzID0ge1xuXHRkZWJ1ZzogdHJ1ZSxcblx0dHJhY2U6IHRydWUsXG5cdGluZm86IHRydWUsXG5cdHdhcm46IHRydWUsXG5cdGVycm9yOiB0cnVlLFxuXHRmYXRhbDogdHJ1ZVxufTtcblxuLyoqXG4gKiBMb2dzIHRyYWNlIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUcmFjZSBtZXNzYWdlLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0aWYgKCF0aGlzLl9sZXZlbHMudHJhY2UpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoY29uc29sZS5sb2cpIHtcblx0XHRjb25zb2xlLmxvZyhtZXNzYWdlKTtcblx0fVxufTtcblxuLyoqXG4gKiBMb2dzIHRyYWNlIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUcmFjZSBtZXNzYWdlLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0aWYgKCF0aGlzLl9sZXZlbHMuZGVidWcpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoY29uc29sZS5sb2cpIHtcblx0XHRjb25zb2xlLmxvZyhtZXNzYWdlKTtcblx0fVxufTtcblxuLyoqXG4gKiBMb2dzIGluZm8gbWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEluZm9ybWF0aW9uIG1lc3NhZ2UuXG4gKi9cbkxvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdGlmICghdGhpcy5fbGV2ZWxzLmluZm8pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoY29uc29sZS5pbmZvKSB7XG5cdFx0Y29uc29sZS5pbmZvKG1lc3NhZ2UpO1xuXHR9XG59O1xuXG4vKipcbiAqIExvZ3Mgd2FybiBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgV2FybmluZyBtZXNzYWdlLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHRpZiAoIXRoaXMuX2xldmVscy53YXJuKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKGNvbnNvbGUud2Fybikge1xuXHRcdGNvbnNvbGUud2FybihtZXNzYWdlKTtcblx0fVxufTtcbi8qKlxuICogTG9ncyBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd8RXJyb3J9IGVycm9yIEVycm9yIG9iamVjdCBvciBtZXNzYWdlLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG5cdGlmICghdGhpcy5fbGV2ZWxzLmVycm9yKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0d3JpdGVFcnJvcihlcnJvcik7XG59O1xuXG4vKipcbiAqIExvZ3MgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfEVycm9yfSBlcnJvciBFcnJvciBvYmplY3Qgb3IgbWVzc2FnZS5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5mYXRhbCA9IGZ1bmN0aW9uIChlcnJvcikge1xuXHRpZiAoIXRoaXMuX2xldmVscy5mYXRhbCkge1xuXHRcdHJldHVybjtcblx0fVxuXHR3cml0ZUVycm9yKGVycm9yKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGVycm9yIHRvIGNvbnNvbGUuXG4gKiBAcGFyYW0ge0Vycm9yfHN0cmluZ30gZXJyb3IgRXJyb3IgdG8gd3JpdGUuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlRXJyb3IoZXJyb3IpIHtcblx0dHJ5IHtcblx0XHRpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuXHRcdFx0ZXJyb3IgPSB0eXBlb2YgKGVycm9yKSA9PT0gJ3N0cmluZycgPyBuZXcgRXJyb3IoZXJyb3IpIDogbmV3IEVycm9yKCk7XG5cdFx0fVxuXHRcdGlmIChjb25zb2xlLmVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGVycm9yKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHR3cml0ZUVycm9yKGUpO1xuXHR9XG59IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdFJvdXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG5cdFVSSSA9IHJlcXVpcmUoJ2NhdGJlcnJ5LXVyaScpLlVSSTtcblxudmFyIE1PVVNFX1BSSU1BUllfS0VZID0gMCxcblx0SFJFRl9BVFRSSUJVVEVfTkFNRSA9ICdocmVmJyxcblx0VEFSR0VUX0FUVFJJQlVURV9OQU1FID0gJ3RhcmdldCcsXG5cdEFfVEFHX05BTUUgPSAnQScsXG5cdEJPRFlfVEFHX05BTUUgPSAnQk9EWSc7XG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIGJyb3dzZXIgcmVxdWVzdCByb3V0ZXIuXG4gKiBAcGFyYW0ge1NlcnZpY2VMb2NhdG9yfSAkc2VydmljZUxvY2F0b3IgU2VydmljZSBsb2NhdG9yIHRvIHJlc29sdmUgc2VydmljZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmVxdWVzdFJvdXRlcigkc2VydmljZUxvY2F0b3IpIHtcblx0dGhpcy5fZXZlbnRCdXMgPSAkc2VydmljZUxvY2F0b3IucmVzb2x2ZSgnZXZlbnRCdXMnKTtcblx0dGhpcy5fd2luZG93ID0gJHNlcnZpY2VMb2NhdG9yLnJlc29sdmUoJ3dpbmRvdycpO1xuXHR0aGlzLl9kb2N1bWVudFJlbmRlcmVyID0gJHNlcnZpY2VMb2NhdG9yLnJlc29sdmUoJ2RvY3VtZW50UmVuZGVyZXInKTtcblx0dGhpcy5fc3RhdGVQcm92aWRlciA9ICRzZXJ2aWNlTG9jYXRvci5yZXNvbHZlKCdzdGF0ZVByb3ZpZGVyJyk7XG5cdHRoaXMuX2NvbnRleHRGYWN0b3J5ID0gJHNlcnZpY2VMb2NhdG9yLnJlc29sdmUoJ2NvbnRleHRGYWN0b3J5Jyk7XG5cblx0dGhpcy5faXNIaXN0b3J5U3VwcG9ydGVkID0gdGhpcy5fd2luZG93Lmhpc3RvcnkgJiZcblx0XHR0aGlzLl93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbjtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdC8vIGFkZCBldmVudCBoYW5kbGVyc1xuXHRzZWxmLl93cmFwRG9jdW1lbnQoKTtcblxuXHQvLyBzZXQgaW5pdGlhbCBzdGF0ZSBmcm9tIGN1cnJlbnQgVVJJXG5cdHRoaXMuX2NoYW5nZVN0YXRlKG5ldyBVUkkodGhpcy5fd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKCkpKVxuXHRcdC5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLl9oYW5kbGVFcnJvcihyZWFzb24pO1xuXHRcdH0pO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgaW5pdGlhbGl6YXRpb24gZmxhZy5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuUmVxdWVzdFJvdXRlci5wcm90b3R5cGUuX2lzU3RhdGVJbml0aWFsaXplZCA9IGZhbHNlO1xuXG4vKipcbiAqIEN1cnJlbnQgcmVmZXJyZXIuXG4gKiBAdHlwZSB7VVJJfVxuICogQHByaXZhdGVcbiAqL1xuUmVxdWVzdFJvdXRlci5wcm90b3R5cGUuX3JlZmVycmVyID0gJyc7XG5cbi8qKlxuICogQ3VycmVudCBsb2NhdGlvbi5cbiAqIEB0eXBlIHtVUkl9XG4gKiBAcHJpdmF0ZVxuICovXG5SZXF1ZXN0Um91dGVyLnByb3RvdHlwZS5fbG9jYXRpb24gPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgZXZlbnQgYnVzLlxuICogQHR5cGUge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cblJlcXVlc3RSb3V0ZXIucHJvdG90eXBlLl9ldmVudEJ1cyA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBjb250ZXh0IGZhY3RvcnkuXG4gKiBAdHlwZSB7Q29udGV4dEZhY3Rvcnl9XG4gKiBAcHJpdmF0ZVxuICovXG5SZXF1ZXN0Um91dGVyLnByb3RvdHlwZS5fY29udGV4dEZhY3RvcnkgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgc3RhdGUgcHJvdmlkZXIuXG4gKiBAdHlwZSB7U3RhdGVQcm92aWRlcn1cbiAqIEBwcml2YXRlXG4gKi9cblJlcXVlc3RSb3V0ZXIucHJvdG90eXBlLl9zdGF0ZVByb3ZpZGVyID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IGRvY3VtZW50IHJlbmRlcmVyLlxuICogQHR5cGUge0RvY3VtZW50UmVuZGVyZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5SZXF1ZXN0Um91dGVyLnByb3RvdHlwZS5fZG9jdW1lbnRSZW5kZXJlciA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBicm93c2VyIHdpbmRvdy5cbiAqIEB0eXBlIHtXaW5kb3d9XG4gKiBAcHJpdmF0ZVxuICovXG5SZXF1ZXN0Um91dGVyLnByb3RvdHlwZS5fd2luZG93ID0gbnVsbDtcblxuLyoqXG4gKiBUcnVlIGlmIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBoaXN0b3J5IEFQSS5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuUmVxdWVzdFJvdXRlci5wcm90b3R5cGUuX2lzSGlzdG9yeVN1cHBvcnRlZCA9IGZhbHNlO1xuXG4vKipcbiAqIFJvdXRlcyBicm93c2VyIHJlbmRlciByZXF1ZXN0LlxuICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgZm9yIG5vdGhpbmcuXG4gKi9cblJlcXVlc3RSb3V0ZXIucHJvdG90eXBlLnJvdXRlID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdC8vIGJlY2F1c2Ugbm93IGxvY2F0aW9uIHdhcyBub3QgY2hhbmdlIHlldCBhbmRcblx0Ly8gZGlmZmVyZW50IGJyb3dzZXJzIGhhbmRsZSBgcG9wc3RhdGVgIGRpZmZlcmVudGx5XG5cdC8vIHdlIG5lZWQgdG8gZG8gcm91dGUgaW4gbmV4dCBpdGVyYXRpb24gb2YgZXZlbnQgbG9vcFxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbmV3TG9jYXRpb24gPSBuZXcgVVJJKHNlbGYuX3dpbmRvdy5sb2NhdGlvbi50b1N0cmluZygpKSxcblx0XHRcdFx0bmV3QXV0aG9yaXR5ID0gbmV3TG9jYXRpb24uYXV0aG9yaXR5ID9cblx0XHRcdFx0XHRuZXdMb2NhdGlvbi5hdXRob3JpdHkudG9TdHJpbmcoKSA6IG51bGwsXG5cdFx0XHRcdGN1cnJlbnRBdXRob3JpdHkgPSBzZWxmLl9sb2NhdGlvbi5hdXRob3JpdHkgP1xuXHRcdFx0XHRcdHNlbGYuX2xvY2F0aW9uLmF1dGhvcml0eS50b1N0cmluZygpIDogbnVsbDtcblxuXHRcdFx0aWYgKG5ld0xvY2F0aW9uLnNjaGVtZSAhPT0gc2VsZi5fbG9jYXRpb24uc2NoZW1lIHx8XG5cdFx0XHRcdG5ld0F1dGhvcml0eSAhPT0gY3VycmVudEF1dGhvcml0eSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIG9ubHkgVVJJIGZyYWdtZW50IGlzIGNoYW5nZWRcblx0XHRcdHZhciBuZXdRdWVyeSA9IG5ld0xvY2F0aW9uLnF1ZXJ5ID9cblx0XHRcdFx0XHRuZXdMb2NhdGlvbi5xdWVyeS50b1N0cmluZygpIDogbnVsbCxcblx0XHRcdFx0Y3VycmVudFF1ZXJ5ID0gc2VsZi5fbG9jYXRpb24ucXVlcnkgP1xuXHRcdFx0XHRcdHNlbGYuX2xvY2F0aW9uLnF1ZXJ5LnRvU3RyaW5nKCkgOiBudWxsO1xuXHRcdFx0aWYgKG5ld0xvY2F0aW9uLnBhdGggPT09IHNlbGYuX2xvY2F0aW9uLnBhdGggJiZcblx0XHRcdFx0bmV3UXVlcnkgPT09IGN1cnJlbnRRdWVyeSkge1xuXHRcdFx0XHRzZWxmLl9sb2NhdGlvbiA9IG5ld0xvY2F0aW9uO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2VsZi5fY2hhbmdlU3RhdGUobmV3TG9jYXRpb24pO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBTZXRzIGFwcGxpY2F0aW9uIHN0YXRlIHRvIHNwZWNpZmllZCBVUkkuXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25TdHJpbmcgVVJJIHRvIGdvLlxuICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgZm9yIG5vdGhpbmcuXG4gKi9cblJlcXVlc3RSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gKGxvY2F0aW9uU3RyaW5nKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGxvY2F0aW9uID0gbmV3IFVSSShsb2NhdGlvblN0cmluZyk7XG5cdFx0XHRsb2NhdGlvbiA9IGxvY2F0aW9uLnJlc29sdmVSZWxhdGl2ZShzZWxmLl9sb2NhdGlvbik7XG5cdFx0XHRsb2NhdGlvblN0cmluZyA9IGxvY2F0aW9uLnRvU3RyaW5nKCk7XG5cblx0XHRcdHZhciBjdXJyZW50QXV0aG9yaXR5ID0gc2VsZi5fbG9jYXRpb24uYXV0aG9yaXR5ID9cblx0XHRcdFx0XHRzZWxmLl9sb2NhdGlvbi5hdXRob3JpdHkudG9TdHJpbmcoKSA6IG51bGwsXG5cdFx0XHRcdG5ld0F1dGhvcml0eSA9IGxvY2F0aW9uLmF1dGhvcml0eSA/XG5cdFx0XHRcdFx0bG9jYXRpb24uYXV0aG9yaXR5LnRvU3RyaW5nKCkgOiBudWxsO1xuXG5cdFx0XHQvLyB3ZSBtdXN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gZXh0ZXJuYWwgbGluayBiZWZvcmUgbWFwIFVSSVxuXHRcdFx0Ly8gdG8gaW50ZXJuYWwgYXBwbGljYXRpb24gc3RhdGVcblx0XHRcdGlmICghc2VsZi5faXNIaXN0b3J5U3VwcG9ydGVkIHx8XG5cdFx0XHRcdGxvY2F0aW9uLnNjaGVtZSAhPT0gc2VsZi5fbG9jYXRpb24uc2NoZW1lIHx8XG5cdFx0XHRcdG5ld0F1dGhvcml0eSAhPT0gY3VycmVudEF1dGhvcml0eSkge1xuXHRcdFx0XHRzZWxmLl93aW5kb3cubG9jYXRpb24uYXNzaWduKGxvY2F0aW9uU3RyaW5nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc3RhdGUgPSBzZWxmLl9zdGF0ZVByb3ZpZGVyLmdldFN0YXRlQnlVcmkobG9jYXRpb24pO1xuXHRcdFx0aWYgKCFzdGF0ZSkge1xuXHRcdFx0XHRzZWxmLl93aW5kb3cubG9jYXRpb24uYXNzaWduKGxvY2F0aW9uU3RyaW5nKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLl93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoc3RhdGUsICcnLCBsb2NhdGlvblN0cmluZyk7XG5cdFx0XHRyZXR1cm4gc2VsZi5yb3V0ZSgpO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIGN1cnJlbnQgYXBwbGljYXRpb24gc3RhdGUgd2l0aCBuZXcgbG9jYXRpb24uXG4gKiBAcGFyYW0ge1VSSX0gbmV3TG9jYXRpb24gTmV3IGxvY2F0aW9uLlxuICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgZm9yIG5vdGhpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5SZXF1ZXN0Um91dGVyLnByb3RvdHlwZS5fY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAobmV3TG9jYXRpb24pIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLl9sb2NhdGlvbiA9IG5ld0xvY2F0aW9uO1xuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5fc3RhdGVQcm92aWRlci5nZXRTdGF0ZUJ5VXJpKG5ld0xvY2F0aW9uKSxcblx0XHRcdFx0cm91dGluZ0NvbnRleHQgPSBzZWxmLl9jb250ZXh0RmFjdG9yeS5jcmVhdGUoe1xuXHRcdFx0XHRcdHJlZmVycmVyOiBzZWxmLl9yZWZlcnJlciB8fCBzZWxmLl93aW5kb3cuZG9jdW1lbnQucmVmZXJyZXIsXG5cdFx0XHRcdFx0bG9jYXRpb246IHNlbGYuX2xvY2F0aW9uLFxuXHRcdFx0XHRcdHVzZXJBZ2VudDogc2VsZi5fd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcblx0XHRcdFx0fSk7XG5cblx0XHRcdGlmICghc2VsZi5faXNTdGF0ZUluaXRpYWxpemVkKSB7XG5cdFx0XHRcdHNlbGYuX2lzU3RhdGVJbml0aWFsaXplZCA9IHRydWU7XG5cdFx0XHRcdHJldHVybiBzZWxmLl9kb2N1bWVudFJlbmRlcmVyLmluaXRXaXRoU3RhdGUoXG5cdFx0XHRcdFx0c3RhdGUsIHJvdXRpbmdDb250ZXh0XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNlbGYuX2RvY3VtZW50UmVuZGVyZXJcblx0XHRcdFx0LnJlbmRlcihzdGF0ZSwgcm91dGluZ0NvbnRleHQpO1xuXHRcdH0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5fcmVmZXJyZXIgPSBzZWxmLl9sb2NhdGlvbjtcblx0XHR9KTtcbn07XG5cbi8qKlxuICogV3JhcHMgZG9jdW1lbnQgd2l0aCByZXF1aXJlZCBldmVudHMgdG8gcm91dGUgcmVxdWVzdHMuXG4gKiBAcHJpdmF0ZVxuICovXG5SZXF1ZXN0Um91dGVyLnByb3RvdHlwZS5fd3JhcERvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0aWYgKCF0aGlzLl9pc0hpc3RvcnlTdXBwb3J0ZWQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR0aGlzLl93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0c2VsZi5yb3V0ZSgpLmNhdGNoKHNlbGYuX2hhbmRsZUVycm9yLmJpbmQoc2VsZikpO1xuXHR9KTtcblxuXHR0aGlzLl93aW5kb3cuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gQV9UQUdfTkFNRSkge1xuXHRcdFx0c2VsZi5fbGlua0NsaWNrSGFuZGxlcihldmVudCwgZXZlbnQudGFyZ2V0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxpbmsgPSBjbG9zZXN0TGluayhldmVudC50YXJnZXQpO1xuXHRcdFx0aWYgKCFsaW5rKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGYuX2xpbmtDbGlja0hhbmRsZXIoZXZlbnQsIGxpbmspO1xuXHRcdH1cblx0fSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgbGluayBjbGljayBvbiB0aGUgcGFnZS5cbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IEV2ZW50LXJlbGF0ZWQgb2JqZWN0LlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IExpbmsgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cblJlcXVlc3RSb3V0ZXIucHJvdG90eXBlLl9saW5rQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50LCBlbGVtZW50KSB7XG5cdHZhciB0YXJnZXRBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShUQVJHRVRfQVRUUklCVVRFX05BTUUpO1xuXHRpZiAodGFyZ2V0QXR0cmlidXRlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gaWYgbWlkZGxlIG1vdXNlIGJ1dHRvbiB3YXMgY2xpY2tlZFxuXHRpZiAoZXZlbnQuYnV0dG9uICE9PSBNT1VTRV9QUklNQVJZX0tFWSB8fFxuXHRcdGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGxvY2F0aW9uU3RyaW5nID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoSFJFRl9BVFRSSUJVVEVfTkFNRSk7XG5cdGlmICghbG9jYXRpb25TdHJpbmcpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0aWYgKGxvY2F0aW9uU3RyaW5nWzBdID09PSAnIycpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR0aGlzLmdvKGxvY2F0aW9uU3RyaW5nKVxuXHRcdC5jYXRjaCh0aGlzLl9oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBhbGwgZXJyb3JzLlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgRXJyb3IgdG8gaGFuZGxlLlxuICogQHByaXZhdGVcbiAqL1xuUmVxdWVzdFJvdXRlci5wcm90b3R5cGUuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG5cdHRoaXMuX2V2ZW50QnVzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xufTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBhc2NlbmRpbmcgXCJBXCIgZWxlbWVudCBub2RlLlxuICogQHBhcmFtIHtOb2RlfSBlbGVtZW50IERPTSBlbGVtZW50LlxuICogQHJldHVybnMge05vZGV8bnVsbH0gVGhlIGNsb3Nlc3QgXCJBXCIgZWxlbWVudCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBjbG9zZXN0TGluayhlbGVtZW50KSB7XG5cdHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZU5hbWUgIT09IEFfVEFHX05BTUUgJiZcblx0XHRlbGVtZW50Lm5vZGVOYW1lICE9PSBCT0RZX1RBR19OQU1FKSB7XG5cdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblx0fVxuXHRyZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVOYW1lID09PSBBX1RBR19OQU1FID8gZWxlbWVudCA6IG51bGw7XG59IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHQvKipcblx0ICogR2V0cyB0aGUgaGlnaCByZXNvbHV0aW9uIHRpbWUgb3IgdGhlIGRpZmZlcmVuY2UgYmV0d2VlblxuXHQgKiBwcmV2aW91cyBhbmQgY3VycmVudCB0aW1lLlxuXHQgKiBAcGFyYW0ge0FycmF5P30gUHJldmlvdXMgaGlnaCByZXNvbHV0aW9uIHRpbWVzdGFtcC5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgaGlnaCByZXNvbHV0aW9uIHRpbWUuXG5cdCAqL1xuXHRnZXQ6IHJlcXVpcmUoJ2Jyb3dzZXItcHJvY2Vzcy1ocnRpbWUnKSxcblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIHRvIHRleHQgbWVzc2FnZS5cblx0ICogQHBhcmFtIHtBcnJheX1cblx0ICogQHJldHVybnMge3N0cmluZ30gVGltZSBtZXNzYWdlLlxuXHQgKi9cblx0dG9NZXNzYWdlOiByZXF1aXJlKCdwcmV0dHktaHJ0aW1lJyksXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBoaWdoIHJlc29sdXRpb24gdGltZSB0byBtaWxsaXNlY29uZHMgbnVtYmVyLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBoclRpbWUgSGlnaCByZXNvbHV0aW9uIHRpbWUgdHVwbGUuXG5cdCAqL1xuXHR0b01pbGxpc2Vjb25kczogZnVuY3Rpb24gKGhyVGltZSkge1xuXHRcdHJldHVybiBoclRpbWVbMF0gKiAxZTMgKyBNYXRoLnJvdW5kKGhyVGltZVsxXSAvIDFlNik7XG5cdH1cbn07IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50TG9hZGVyO1xuXG52YXIgbW9kdWxlSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vbGliL2hlbHBlcnMvbW9kdWxlSGVscGVyJyksXG5cdHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG5cdExvYWRlckJhc2UgPSByZXF1aXJlKCcuLi8uLi9saWIvYmFzZS9Mb2FkZXJCYXNlJyk7XG5cbnV0aWwuaW5oZXJpdHMoQ29tcG9uZW50TG9hZGVyLCBMb2FkZXJCYXNlKTtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgY29tcG9uZW50IGxvYWRlci5cbiAqIEBwYXJhbSB7U2VydmljZUxvY2F0b3J9ICRzZXJ2aWNlTG9jYXRvciBMb2NhdG9yIHRvIHJlc29sdmUgZGVwZW5kZW5jaWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBMb2FkZXJCYXNlXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudExvYWRlcigkc2VydmljZUxvY2F0b3IpIHtcblx0dGhpcy5fc2VydmljZUxvY2F0b3IgPSAkc2VydmljZUxvY2F0b3I7XG5cdHRoaXMuX2V2ZW50QnVzID0gJHNlcnZpY2VMb2NhdG9yLnJlc29sdmUoJ2V2ZW50QnVzJyk7XG5cdHRoaXMuX3RlbXBsYXRlUHJvdmlkZXIgPSAkc2VydmljZUxvY2F0b3IucmVzb2x2ZSgndGVtcGxhdGVQcm92aWRlcicpO1xuXHRMb2FkZXJCYXNlLmNhbGwodGhpcywgJHNlcnZpY2VMb2NhdG9yLnJlc29sdmVBbGwoJ2NvbXBvbmVudFRyYW5zZm9ybScpKTtcbn1cblxuLyoqXG4gKiBDdXJyZW50IGV2ZW50IGJ1cy5cbiAqIEB0eXBlIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5Db21wb25lbnRMb2FkZXIucHJvdG90eXBlLl9ldmVudEJ1cyA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBzZXJ2aWNlIGxvY2F0b3IuXG4gKiBAdHlwZSB7U2VydmljZUxvY2F0b3J9XG4gKiBAcHJpdmF0ZVxuICovXG5Db21wb25lbnRMb2FkZXIucHJvdG90eXBlLl9zZXJ2aWNlTG9jYXRvciA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCB0ZW1wbGF0ZSBwcm92aWRlci5cbiAqIEB0eXBlIHtUZW1wbGF0ZVByb3ZpZGVyfVxuICogQHByaXZhdGVcbiAqL1xuQ29tcG9uZW50TG9hZGVyLnByb3RvdHlwZS5fdGVtcGxhdGVQcm92aWRlciA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBtYXAgb2YgbG9hZGVkIGNvbXBvbmVudHMgYnkgbmFtZXMuXG4gKiBAdHlwZSB7T2JqZWN0fSBNYXAgb2YgY29tcG9uZW50cyBieSBuYW1lcy5cbiAqIEBwcml2YXRlXG4gKi9cbkNvbXBvbmVudExvYWRlci5wcm90b3R5cGUuX2xvYWRlZENvbXBvbmVudHMgPSBudWxsO1xuXG4vKipcbiAqIExvYWRzIGNvbXBvbmVudHMgd2hlbiBpdCBpcyBpbiBhIGJyb3dzZXIuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBmb3Igbm90aGluZy5cbiAqL1xuQ29tcG9uZW50TG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcy5fbG9hZGVkQ29tcG9uZW50cykge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fbG9hZGVkQ29tcG9uZW50cyk7XG5cdH1cblxuXHR0aGlzLl9sb2FkZWRDb21wb25lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuXHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gc2VsZi5fc2VydmljZUxvY2F0b3IucmVzb2x2ZUFsbCgnY29tcG9uZW50JyksXG5cdFx0XHRcdGNvbXBvbmVudFByb21pc2VzID0gW107XG5cblx0XHRcdC8vIHRoZSBsaXN0IGlzIGEgc3RhY2ssIHdlIHNob3VsZCByZXZlcnNlIGl0XG5cdFx0XHRjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuXHRcdFx0XHRjb21wb25lbnRQcm9taXNlcy51bnNoaWZ0KFxuXHRcdFx0XHRcdHNlbGYuX3Byb2Nlc3NDb21wb25lbnQoY29tcG9uZW50KVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoY29tcG9uZW50UHJvbWlzZXMpO1xuXHRcdH0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcblx0XHRcdGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG5cdFx0XHRcdGlmICghY29tcG9uZW50IHx8IHR5cGVvZiAoY29tcG9uZW50KSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5fbG9hZGVkQ29tcG9uZW50c1tjb21wb25lbnQubmFtZV0gPSBjb21wb25lbnQ7XG5cdFx0XHR9KTtcblx0XHRcdHNlbGYuX2V2ZW50QnVzLmVtaXQoJ2FsbENvbXBvbmVudHNMb2FkZWQnLCBjb21wb25lbnRzKTtcblx0XHRcdHJldHVybiBzZWxmLl9sb2FkZWRDb21wb25lbnRzO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzZXMgY29tcG9uZW50IGFuZCBhcHBseSByZXF1aXJlZCBvcGVyYXRpb25zLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudERldGFpbHMgTG9hZGVkIGNvbXBvbmVudCBkZXRhaWxzLlxuICogQHJldHVybnMge09iamVjdH0gQ29tcG9uZW50IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkNvbXBvbmVudExvYWRlci5wcm90b3R5cGUuX3Byb2Nlc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50RGV0YWlscykge1xuXHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0Y29tcG9uZW50ID0gT2JqZWN0LmNyZWF0ZShjb21wb25lbnREZXRhaWxzKTtcblxuXHRyZXR1cm4gdGhpcy5fYXBwbHlUcmFuc2Zvcm1zKGNvbXBvbmVudClcblx0XHQudGhlbihmdW5jdGlvbiAodHJhbnNmb3JtZWQpIHtcblx0XHRcdGNvbXBvbmVudCA9IHRyYW5zZm9ybWVkO1xuXHRcdFx0c2VsZi5fdGVtcGxhdGVQcm92aWRlci5yZWdpc3RlckNvbXBpbGVkKFxuXHRcdFx0XHRjb21wb25lbnQubmFtZSwgY29tcG9uZW50LnRlbXBsYXRlU291cmNlXG5cdFx0XHQpO1xuXHRcdFx0Y29tcG9uZW50LnRlbXBsYXRlID0ge1xuXHRcdFx0XHRyZW5kZXI6IGZ1bmN0aW9uIChkYXRhQ29udGV4dCkge1xuXHRcdFx0XHRcdHJldHVybiBzZWxmLl90ZW1wbGF0ZVByb3ZpZGVyLnJlbmRlcihcblx0XHRcdFx0XHRcdGNvbXBvbmVudC5uYW1lLCBkYXRhQ29udGV4dFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRpZiAodHlwZW9mIChjb21wb25lbnQuZXJyb3JUZW1wbGF0ZVNvdXJjZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHZhciBlcnJvclRlbXBsYXRlTmFtZSA9IG1vZHVsZUhlbHBlci5nZXROYW1lRm9yRXJyb3JUZW1wbGF0ZShcblx0XHRcdFx0XHRjb21wb25lbnQubmFtZVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRzZWxmLl90ZW1wbGF0ZVByb3ZpZGVyLnJlZ2lzdGVyQ29tcGlsZWQoXG5cdFx0XHRcdFx0ZXJyb3JUZW1wbGF0ZU5hbWUsIGNvbXBvbmVudC5lcnJvclRlbXBsYXRlU291cmNlXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbXBvbmVudC5lcnJvclRlbXBsYXRlID0ge1xuXHRcdFx0XHRcdHJlbmRlcjogZnVuY3Rpb24gKGRhdGFDb250ZXh0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2VsZi5fdGVtcGxhdGVQcm92aWRlci5yZW5kZXIoXG5cdFx0XHRcdFx0XHRcdGVycm9yVGVtcGxhdGVOYW1lLCBkYXRhQ29udGV4dFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdjb21wb25lbnRMb2FkZWQnLCBjb21wb25lbnQpO1xuXHRcdFx0cmV0dXJuIGNvbXBvbmVudDtcblx0XHR9KVxuXHRcdC5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdlcnJvcicsIHJlYXNvbik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9KTtcbn07XG5cbi8qKlxuICogR2V0cyBtYXAgb2YgY29tcG9uZW50cyBieSBuYW1lcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IE1hcCBvZiBjb21wb25lbnRzIGJ5IG5hbWVzLlxuICovXG5Db21wb25lbnRMb2FkZXIucHJvdG90eXBlLmdldENvbXBvbmVudHNCeU5hbWVzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5fbG9hZGVkQ29tcG9uZW50cyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xufTsiLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBTdG9yZUxvYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG5cdExvYWRlckJhc2UgPSByZXF1aXJlKCcuLi8uLi9saWIvYmFzZS9Mb2FkZXJCYXNlJyk7XG5cbnV0aWwuaW5oZXJpdHMoU3RvcmVMb2FkZXIsIExvYWRlckJhc2UpO1xuXG4vKipcbiAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgdGhlIHN0b3JlIGxvYWRlci5cbiAqIEBwYXJhbSB7U2VydmljZUxvY2F0b3J9ICRzZXJ2aWNlTG9jYXRvciBMb2NhdG9yIHRvIHJlc29sdmUgc3RvcmVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBMb2FkZXJCYXNlXG4gKi9cbmZ1bmN0aW9uIFN0b3JlTG9hZGVyKCRzZXJ2aWNlTG9jYXRvcikge1xuXHR0aGlzLl9zZXJ2aWNlTG9jYXRvciA9ICRzZXJ2aWNlTG9jYXRvcjtcblx0dGhpcy5fZXZlbnRCdXMgPSAkc2VydmljZUxvY2F0b3IucmVzb2x2ZSgnZXZlbnRCdXMnKTtcblx0TG9hZGVyQmFzZS5jYWxsKHRoaXMsICRzZXJ2aWNlTG9jYXRvci5yZXNvbHZlQWxsKCdzdG9yZVRyYW5zZm9ybScpKTtcbn1cblxuLyoqXG4gKiBDdXJyZW50IGV2ZW50IGJ1cy5cbiAqIEB0eXBlIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5TdG9yZUxvYWRlci5wcm90b3R5cGUuX2V2ZW50QnVzID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHNlcnZpY2UgbG9jYXRvci5cbiAqIEB0eXBlIHtTZXJ2aWNlTG9jYXRvcn1cbiAqIEBwcml2YXRlXG4gKi9cblN0b3JlTG9hZGVyLnByb3RvdHlwZS5fc2VydmljZUxvY2F0b3IgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgc2V0IG9mIGxvYWRlZCBzdG9yZXMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuU3RvcmVMb2FkZXIucHJvdG90eXBlLl9sb2FkZWRTdG9yZXMgPSBudWxsO1xuXG4vKipcbiAqIExvYWRzIGFsbCBzdG9yZXMgd2hlbiBpdCBpcyBpbiBhIGJyb3dzZXIuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBmb3Igbm90aGluZy5cbiAqL1xuU3RvcmVMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLl9sb2FkZWRTdG9yZXMpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2xvYWRlZFN0b3Jlcyk7XG5cdH1cblxuXHR0aGlzLl9sb2FkZWRTdG9yZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHN0b3JlcyA9IHNlbGYuX3NlcnZpY2VMb2NhdG9yLnJlc29sdmVBbGwoJ3N0b3JlJyksXG5cdFx0XHRcdHN0b3JlUHJvbWlzZXMgPSBbXTtcblxuXHRcdFx0Ly8gdGhlIGxpc3QgaXMgYSBzdGFjaywgd2Ugc2hvdWxkIHJldmVyc2UgaXRcblx0XHRcdHN0b3Jlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZSkge1xuXHRcdFx0XHRzdG9yZVByb21pc2VzLnVuc2hpZnQoXG5cdFx0XHRcdFx0c2VsZi5fZ2V0U3RvcmUoc3RvcmUpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKHN0b3JlUHJvbWlzZXMpO1xuXHRcdH0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKHN0b3Jlcykge1xuXHRcdFx0c3RvcmVzLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlKSB7XG5cdFx0XHRcdGlmICghc3RvcmUgfHwgdHlwZW9mIChzdG9yZSkgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX2xvYWRlZFN0b3Jlc1tzdG9yZS5uYW1lXSA9IHN0b3JlO1xuXHRcdFx0fSk7XG5cdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdhbGxTdG9yZXNMb2FkZWQnLCBzZWxmLl9sb2FkZWRTdG9yZXMpO1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9sb2FkZWRTdG9yZXMpO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzdG9yZSBmcm9tIHN0b3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RvcmVEZXRhaWxzIFN0b3JlIGRldGFpbHMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBQcm9taXNlIGZvciBzdG9yZS5cbiAqIEBwcml2YXRlXG4gKi9cblN0b3JlTG9hZGVyLnByb3RvdHlwZS5fZ2V0U3RvcmUgPSBmdW5jdGlvbiAoc3RvcmVEZXRhaWxzKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0cmV0dXJuIHRoaXMuX2FwcGx5VHJhbnNmb3JtcyhzdG9yZURldGFpbHMpXG5cdFx0LnRoZW4oZnVuY3Rpb24gKHRyYW5zZm9ybWVkKSB7XG5cdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdzdG9yZUxvYWRlZCcsIHRyYW5zZm9ybWVkKTtcblx0XHRcdHJldHVybiB0cmFuc2Zvcm1lZDtcblx0XHR9KVxuXHRcdC5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdlcnJvcicsIHJlYXNvbik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9KTtcbn07XG5cbi8qKlxuICogR2V0cyBzdG9yZXMgbWFwIGJ5IG5hbWVzLlxuICogQHJldHVybnMge09iamVjdH0gTWFwIG9mIHN0b3JlcyBieSBuYW1lcy5cbiAqL1xuU3RvcmVMb2FkZXIucHJvdG90eXBlLmdldFN0b3Jlc0J5TmFtZXMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLl9sb2FkZWRTdG9yZXMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbn07IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlQXBpUHJvdmlkZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpLFxuXHRwcm9wZXJ0eUhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL2xpYi9oZWxwZXJzL3Byb3BlcnR5SGVscGVyJyksXG5cdE1vZHVsZUFwaVByb3ZpZGVyQmFzZSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9iYXNlL01vZHVsZUFwaVByb3ZpZGVyQmFzZScpO1xuXG51dGlsLmluaGVyaXRzKE1vZHVsZUFwaVByb3ZpZGVyLCBNb2R1bGVBcGlQcm92aWRlckJhc2UpO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBtb2R1bGUgQVBJIHByb3ZpZGVyLlxuICogQHBhcmFtIHtTZXJ2aWNlTG9jYXRvcn0gJHNlcnZpY2VMb2NhdG9yIFNlcnZpY2UgbG9jYXRvclxuICogdG8gcmVzb2x2ZSBkZXBlbmRlbmNpZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIE1vZHVsZUFwaVByb3ZpZGVyQmFzZVxuICovXG5mdW5jdGlvbiBNb2R1bGVBcGlQcm92aWRlcigkc2VydmljZUxvY2F0b3IpIHtcblx0TW9kdWxlQXBpUHJvdmlkZXJCYXNlLmNhbGwodGhpcywgJHNlcnZpY2VMb2NhdG9yKTtcblx0cHJvcGVydHlIZWxwZXIuZGVmaW5lUmVhZE9ubHkodGhpcywgJ2lzQnJvd3NlcicsIHRydWUpO1xuXHRwcm9wZXJ0eUhlbHBlci5kZWZpbmVSZWFkT25seSh0aGlzLCAnaXNTZXJ2ZXInLCBmYWxzZSk7XG59XG5cbi8qKlxuICogUmVsb2FkcyB0aGUgcGFnZSBmb3IgaGFuZGxpbmcgXCJub3QgZm91bmRcIiBlcnJvci5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIGZvciBub3RoaW5nLlxuICovXG5Nb2R1bGVBcGlQcm92aWRlci5wcm90b3R5cGUubm90Rm91bmQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB3aW5kb3cgPSB0aGlzLmxvY2F0b3IucmVzb2x2ZSgnd2luZG93Jyk7XG5cdHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufTtcblxuLyoqXG4gKiBSZWRpcmVjdHMgY3VycmVudCBwYWdlIHRvIHNwZWNpZmllZCBVUkkuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpU3RyaW5nIFVSSSB0byByZWRpcmVjdC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIGZvciBub3RoaW5nLlxuICovXG5Nb2R1bGVBcGlQcm92aWRlci5wcm90b3R5cGUucmVkaXJlY3QgPSBmdW5jdGlvbiAodXJpU3RyaW5nKSB7XG5cdHZhciByZXF1ZXN0Um91dGVyID0gdGhpcy5sb2NhdG9yLnJlc29sdmUoJ3JlcXVlc3RSb3V0ZXInKTtcblx0cmV0dXJuIHJlcXVlc3RSb3V0ZXIuZ28odXJpU3RyaW5nKTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIGN1cnJlbnQgbG9jYXRpb24gVVJJJ3MgZnJhZ21lbnQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBmb3Igbm90aGluZy5cbiAqL1xuTW9kdWxlQXBpUHJvdmlkZXIucHJvdG90eXBlLmNsZWFyRnJhZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciB3aW5kb3cgPSB0aGlzLmxvY2F0b3IucmVzb2x2ZSgnd2luZG93JyksXG5cdFx0cG9zaXRpb24gPSB3aW5kb3cuZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG5cdHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG5cdHdpbmRvdy5kb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IHBvc2l0aW9uO1xuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59OyIsIi8qXG4gKiBjYXRiZXJyeVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBEZW5pcyBSZWNoa3Vub3YgYW5kIHByb2plY3QgY29udHJpYnV0b3JzLlxuICpcbiAqIGNhdGJlcnJ5J3MgbGljZW5zZSBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgbGljZW5zZSBhcHBsaWVzIHRvIGFsbCBwYXJ0cyBvZiBjYXRiZXJyeSB0aGF0IGFyZSBub3QgZXh0ZXJuYWxseVxuICogbWFpbnRhaW5lZCBsaWJyYXJpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL0Jvb3RzdHJhcHBlcicpO1xuIiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dEZhY3Rvcnk7XG5cbnZhciBwcm9wZXJ0eUhlbHBlciA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9wZXJ0eUhlbHBlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBjb250ZXh0IGZhY3RvcnkuXG4gKiBAcGFyYW0ge1NlcnZpY2VMb2NhdG9yfSAkc2VydmljZUxvY2F0b3IgTG9jYXRvciB0byByZXNvbHZlIGRlcGVuZGVuY2llcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb250ZXh0RmFjdG9yeSgkc2VydmljZUxvY2F0b3IpIHtcblx0dGhpcy5fc2VydmljZUxvY2F0b3IgPSAkc2VydmljZUxvY2F0b3I7XG59XG5cbi8qKlxuICogQ3VycmVudCBzZXJ2aWNlIGxvY2F0b3IuXG4gKiBAdHlwZSB7U2VydmljZUxvY2F0b3J9XG4gKiBAcHJpdmF0ZVxuICovXG5Db250ZXh0RmFjdG9yeS5wcm90b3R5cGUuX3NlcnZpY2VMb2NhdG9yID0gbnVsbDtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBjb250ZXh0IGZvciBtb2R1bGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGFkZGl0aW9uYWwgQWRkaXRpb25hbCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtVUkl9IGFkZGl0aW9uYWwucmVmZXJyZXIgQ3VycmVudCByZWZlcnJlci5cbiAqIEBwYXJhbSB7VVJJfSBhZGRpdGlvbmFsLmxvY2F0aW9uIEN1cnJlbnQgbG9jYXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkaXRpb25hbC51c2VyQWdlbnQgQ3VycmVudCB1c2VyIGFnZW50LlxuICovXG5Db250ZXh0RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGFkZGl0aW9uYWwpIHtcblx0dmFyIGFwaVByb3ZpZGVyID0gdGhpcy5fc2VydmljZUxvY2F0b3IucmVzb2x2ZSgnbW9kdWxlQXBpUHJvdmlkZXInKSxcblx0XHRjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShhcGlQcm92aWRlcik7XG5cdE9iamVjdC5rZXlzKGFkZGl0aW9uYWwpXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0cHJvcGVydHlIZWxwZXIuZGVmaW5lUmVhZE9ubHkoY29udGV4dCwga2V5LCBhZGRpdGlvbmFsW2tleV0pO1xuXHRcdH0pO1xuXHRyZXR1cm4gY29udGV4dDtcbn07IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gU2VyaWFsV3JhcHBlcjtcblxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG52YXIgRVJST1JfTk9fU1VDSF9NRVRIT0QgPSAnVGhlcmUgaXMgbm8gc3VjaCByZWdpc3RlcmVkIG1ldGhvZCc7XG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgaW5zdGFuY2Ugb2YgdGhlIHNlcmlhbCB3cmFwcGVyIGZvciBwcm9taXNlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTZXJpYWxXcmFwcGVyKCkge1xuXHR0aGlzLl9lbWl0dGVyID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTtcblx0dGhpcy5fZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoMCk7XG5cdHRoaXMuX3RvSW52b2tlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0dGhpcy5faW5Qcm9ncmVzcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogQ3VycmVudCBldmVudCBlbWl0dGVyLlxuICogQHR5cGUge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cblNlcmlhbFdyYXBwZXIucHJvdG90eXBlLl9lbWl0dGVyID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHNldCBvZiBuYW1lZCBtZXRob2RzIHRvIGludm9rZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5TZXJpYWxXcmFwcGVyLnByb3RvdHlwZS5fdG9JbnZva2UgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgc2V0IG9mIGZsYWdzIGlmIHRoZSBtZXRob2QgaXMgaW4gcHJvZ3Jlc3MuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuU2VyaWFsV3JhcHBlci5wcm90b3R5cGUuX2luUHJvZ3Jlc3MgPSBudWxsO1xuXG4vKipcbiAqIEFkZHMgbWV0aG9kIHRvIHRoZSBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSW52b2tlIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBwcm9taXNlLlxuICovXG5TZXJpYWxXcmFwcGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgdG9JbnZva2UpIHtcblx0dGhpcy5fdG9JbnZva2VbbmFtZV0gPSB0b0ludm9rZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG1ldGhvZCB3aXRoIHN1Y2ggbmFtZSB3YXMgcmVnaXN0ZXJlZCB0byB0aGUgc2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBtZXRob2QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBtZXRob2QgbmFtZSBpcyByZWdpc3RlcmVkLlxuICovXG5TZXJpYWxXcmFwcGVyLnByb3RvdHlwZS5pc1JlZ2lzdGVyZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuXHRyZXR1cm4gdHlwZW9mICh0aGlzLl90b0ludm9rZVtuYW1lXSkgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKipcbiAqIEludm9rZXMgbWV0aG9kIHdpdGhvdXQgY29uY3VycmVuY3kuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgZm9yIHJlc3VsdC5cbiAqL1xuU2VyaWFsV3JhcHBlci5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdGlmICghdGhpcy5pc1JlZ2lzdGVyZWQobmFtZSkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKEVSUk9SX05PX1NVQ0hfTUVUSE9EKSk7XG5cdH1cblxuXHRpZiAodGhpcy5faW5Qcm9ncmVzc1tuYW1lXSkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XG5cdFx0XHRzZWxmLl9lbWl0dGVyLm9uY2UobmFtZSwgZnVsZmlsbCk7XG5cdFx0XHRzZWxmLl9lbWl0dGVyLm9uY2UobmFtZSArICctLWVycm9yJywgcmVqZWN0KTtcblx0XHR9KTtcblx0fVxuXG5cdHRoaXMuX2luUHJvZ3Jlc3NbbmFtZV0gPSB0cnVlO1xuXHR0aGlzLl90b0ludm9rZVtuYW1lXSgpXG5cdFx0LnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0c2VsZi5fZW1pdHRlci5lbWl0KG5hbWUsIHJlc3VsdCk7XG5cdFx0XHRzZWxmLl9pblByb2dyZXNzW25hbWVdID0gbnVsbDtcblx0XHR9KVxuXHRcdC5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLl9lbWl0dGVyLmVtaXQobmFtZSArICctLWVycm9yJywgcmVhc29uKTtcblx0XHRcdHNlbGYuX2luUHJvZ3Jlc3NbbmFtZV0gPSBudWxsO1xuXHRcdH0pO1xuXG5cdHJldHVybiB0aGlzLmludm9rZShuYW1lKTtcbn07IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RvcmVEaXNwYXRjaGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcblx0U2VyaWFsV3JhcHBlciA9IHJlcXVpcmUoJy4vU2VyaWFsV3JhcHBlcicpLFxuXHRtb2R1bGVIZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kdWxlSGVscGVyJyk7XG5cbnZhciBFUlJPUl9TVE9SRV9OT1RfRk9VTkQgPSAnU3RvcmUgXCIlc1wiIG5vdCBmb3VuZCcsXG5cdEVSUk9SX1NUQVRFID0gJ1N0YXRlIHNob3VsZCBiZSBzZXQgYmVmb3JlIGFueSByZXF1ZXN0Jyxcblx0REVGQVVMVF9MSUZFVElNRSA9IDYwMDAwO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHN0b3JlIGRpc3BhdGNoZXIuXG4gKiBAcGFyYW0ge1NlcnZpY2VMb2NhdG9yfSAkc2VydmljZUxvY2F0b3IgTG9jYXRvciB0byByZXNvbHZlIGRlcGVuZGVuY2llcy5cbiAqIEBwYXJhbSB7U3RvcmVMb2FkZXJ9ICRzdG9yZUxvYWRlciBTdG9yZSBsb2FkZXIgdG8gbG9hZCBzdG9yZXMuXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gJGV2ZW50QnVzIEV2ZW50IGJ1cyB0byBlbWl0IGV2ZW50cy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdG9yZURpc3BhdGNoZXIoJHNlcnZpY2VMb2NhdG9yLCAkc3RvcmVMb2FkZXIsICRldmVudEJ1cykge1xuXHR0aGlzLl9zZXJ2aWNlTG9jYXRvciA9ICRzZXJ2aWNlTG9jYXRvcjtcblx0dGhpcy5fc3RvcmVMb2FkZXIgPSAkc3RvcmVMb2FkZXI7XG5cdHRoaXMuX2V2ZW50QnVzID0gJGV2ZW50QnVzO1xuXHR0aGlzLl9zdG9yZUluc3RhbmNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdHRoaXMuX2xhc3REYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0dGhpcy5fZGVwZW5kYW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdHRoaXMuX3NlcmlhbFdyYXBwZXIgPSBuZXcgU2VyaWFsV3JhcHBlcigpO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgc2VydmljZSBsb2NhdG9yLlxuICogQHR5cGUge1NlcnZpY2VMb2NhdG9yfVxuICogQHByaXZhdGVcbiAqL1xuU3RvcmVEaXNwYXRjaGVyLnByb3RvdHlwZS5fc2VydmljZUxvY2F0b3IgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgZXZlbnQgYnVzLlxuICogQHR5cGUge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cblN0b3JlRGlzcGF0Y2hlci5wcm90b3R5cGUuX2V2ZW50QnVzID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHN0b3JlIGxvYWRlci5cbiAqIEB0eXBlIHtTdG9yZUxvYWRlcn1cbiAqIEBwcml2YXRlXG4gKi9cblN0b3JlRGlzcGF0Y2hlci5wcm90b3R5cGUuX3N0b3JlTG9hZGVyID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IG1hcCBvZiBhbGwgc3RvcmUgaW5zdGFuY2VzLlxuICogQHR5cGUge251bGx9XG4gKiBAcHJpdmF0ZVxuICovXG5TdG9yZURpc3BhdGNoZXIucHJvdG90eXBlLl9zdG9yZUluc3RhbmNlcyA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBtYXAgb2YgbGFzdCBkYXRhIGZvciBlYWNoIHN0b3JlLlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblN0b3JlRGlzcGF0Y2hlci5wcm90b3R5cGUuX2xhc3REYXRhID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IG1hcCBvZiBsYXN0IHN0YXRlIG9mIHN0b3JlIGRpc3BhdGNoZXIuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuU3RvcmVEaXNwYXRjaGVyLnByb3RvdHlwZS5fbGFzdFN0YXRlID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHNlcmlhbCB3cmFwcGVyLlxuICogQHR5cGUge1NlcmlhbFdyYXBwZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5TdG9yZURpc3BhdGNoZXIucHJvdG90eXBlLl9zZXJpYWxXcmFwcGVyID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IGJhc2ljIGNvbnRleHQgZm9yIGFsbCBzdG9yZSBjb250ZXh0cy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5TdG9yZURpc3BhdGNoZXIucHJvdG90eXBlLl9jdXJyZW50QmFzaWNDb250ZXh0ID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHNldCBvZiBzdG9yZSBkZXBlbmRlbmN5IGdyYXBoLlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblN0b3JlRGlzcGF0Y2hlci5wcm90b3R5cGUuX2RlcGVuZGFudHMgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgc3RvcmUgZGF0YSBhbmQgY3JlYXRlcyBzdG9yZSBpbnN0YW5jZSBpZiByZXF1aXJlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWUgTmFtZSBvZiBzdG9yZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFN0b3JlJ3MgZGF0YS5cbiAqL1xuU3RvcmVEaXNwYXRjaGVyLnByb3RvdHlwZS5nZXRTdG9yZURhdGEgPSBmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG5cdGlmICghdGhpcy5fbGFzdFN0YXRlKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihFUlJPUl9TVEFURSkpO1xuXHR9XG5cdGlmICh0eXBlb2YgKHN0b3JlTmFtZSkgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcblx0fVxuXHRpZiAoc3RvcmVOYW1lIGluIHRoaXMuX2xhc3REYXRhKSB7XG5cdFx0dmFyIGV4aXN0VGltZSA9IERhdGUubm93KCkgLSB0aGlzLl9sYXN0RGF0YVtzdG9yZU5hbWVdLmNyZWF0ZWRBdDtcblx0XHRpZiAoZXhpc3RUaW1lIDw9IHRoaXMuX2xhc3REYXRhW3N0b3JlTmFtZV0ubGlmZXRpbWUpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fbGFzdERhdGFbc3RvcmVOYW1lXS5kYXRhKTtcblx0XHR9XG5cdFx0ZGVsZXRlIHRoaXMuX2xhc3REYXRhW3N0b3JlTmFtZV07XG5cdH1cblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdGxpZmV0aW1lID0gREVGQVVMVF9MSUZFVElNRTtcblx0c2VsZi5fZXZlbnRCdXMuZW1pdCgnc3RvcmVEYXRhTG9hZCcsIHtcblx0XHRuYW1lOiBzdG9yZU5hbWVcblx0fSk7XG5cdHZhciBzdG9yZSA9IHRoaXMuZ2V0U3RvcmUoc3RvcmVOYW1lKTtcblx0aWYgKCFzdG9yZSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXG5cdFx0XHRcdHV0aWwuZm9ybWF0KEVSUk9SX1NUT1JFX05PVF9GT1VORCwgc3RvcmVOYW1lKSlcblx0XHQpO1xuXHR9XG5cdGlmICh0eXBlb2YgKHN0b3JlLiRsaWZldGltZSkgPT09ICdudW1iZXInKSB7XG5cdFx0bGlmZXRpbWUgPSBzdG9yZS4kbGlmZXRpbWU7XG5cdH1cblx0cmV0dXJuIHNlbGYuX3NlcmlhbFdyYXBwZXIuaW52b2tlKHN0b3JlTmFtZSlcblx0XHQudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0c2VsZi5fbGFzdERhdGFbc3RvcmVOYW1lXSA9IHtcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0bGlmZXRpbWU6IGxpZmV0aW1lLFxuXHRcdFx0XHRjcmVhdGVkQXQ6IERhdGUubm93KClcblx0XHRcdH07XG5cdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdzdG9yZURhdGFMb2FkZWQnLCB7XG5cdFx0XHRcdG5hbWU6IHN0b3JlTmFtZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0bGlmZXRpbWU6IGxpZmV0aW1lXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhY3Rpb24gdG8gc3BlY2lmaWVkIHN0b3JlIGFuZCByZXNvbHZlcyBwcm9taXNlcyBpbiBzZXJpYWwgbW9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZU5hbWUgTmFtZSBvZiB0aGUgc3RvcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uTmFtZSBOYW1lIG9mIHRoZSBhY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gYXJncyBBY3Rpb24gYXJndW1lbnRzLlxuICogQHJldHVybnMge1Byb21pc2U8Kj59IFByb21pc2UgZm9yIGFjdGlvbiBoYW5kbGluZyByZXN1bHQuXG4gKi9cblN0b3JlRGlzcGF0Y2hlci5wcm90b3R5cGUuc2VuZEFjdGlvbiA9IGZ1bmN0aW9uIChzdG9yZU5hbWUsIGFjdGlvbk5hbWUsIGFyZ3MpIHtcblx0aWYgKCF0aGlzLl9sYXN0U3RhdGUpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKEVSUk9SX1NUQVRFKSk7XG5cdH1cblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdGFjdGlvbkRldGFpbHMgPSB7XG5cdFx0XHRzdG9yZU5hbWU6IHN0b3JlTmFtZSxcblx0XHRcdGFjdGlvbk5hbWU6IGFjdGlvbk5hbWUsXG5cdFx0XHRhcmdzOiBhcmdzXG5cdFx0fTtcblx0dGhpcy5fZXZlbnRCdXMuZW1pdCgnYWN0aW9uU2VuZCcsIGFjdGlvbkRldGFpbHMpO1xuXHR2YXIgc3RvcmUgPSB0aGlzLmdldFN0b3JlKHN0b3JlTmFtZSk7XG5cdGlmICghc3RvcmUpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFxuXHRcdFx0dXRpbC5mb3JtYXQoRVJST1JfU1RPUkVfTk9UX0ZPVU5ELCBzdG9yZU5hbWUpKVxuXHRcdCk7XG5cdH1cblx0dmFyIGhhbmRsZU1ldGhvZCA9IG1vZHVsZUhlbHBlci5nZXRNZXRob2RUb0ludm9rZShcblx0XHRzdG9yZSwgJ2hhbmRsZScsIGFjdGlvbk5hbWVcblx0KTtcblx0cmV0dXJuIG1vZHVsZUhlbHBlci5nZXRTYWZlUHJvbWlzZShmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGhhbmRsZU1ldGhvZChhcmdzKTtcblx0fSlcblx0XHQudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRzZWxmLl9ldmVudEJ1cy5lbWl0KCdhY3Rpb25TZW50JywgYWN0aW9uRGV0YWlscyk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhY3Rpb24gdG8gZXZlcnkgc3RvcmUgdGhhdCBoYXMgaGFuZGxlIG1ldGhvZCBmb3Igc3VjaCBhY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uTmFtZSBOYW1lIG9mIHRoZSBhY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnIEFjdGlvbiBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTwqPj59IFByb21pc2UgZm9yIHRoZSBhY3Rpb24gaGFuZGxpbmcgcmVzdWx0LlxuICovXG5TdG9yZURpc3BhdGNoZXIucHJvdG90eXBlLnNlbmRCcm9hZGNhc3RBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uTmFtZSwgYXJnKSB7XG5cdHZhciBwcm9taXNlcyA9IFtdLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdHN0b3Jlc0J5TmFtZXMgPSB0aGlzLl9zdG9yZUxvYWRlci5nZXRTdG9yZXNCeU5hbWVzKCksXG5cdFx0bWV0aG9kTmFtZSA9IG1vZHVsZUhlbHBlci5nZXRDYW1lbENhc2VOYW1lKCdoYW5kbGUnLCBhY3Rpb25OYW1lKTtcblx0T2JqZWN0LmtleXMoc3RvcmVzQnlOYW1lcylcblx0XHQuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG5cdFx0XHR2YXIgc3RvcmUgPSBzdG9yZXNCeU5hbWVzW3N0b3JlTmFtZV0sXG5cdFx0XHRcdHByb3RvTWV0aG9kID0gc3RvcmUuY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuXHRcdFx0aWYgKHR5cGVvZiAocHJvdG9NZXRob2QpICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBzZW5kQWN0aW9uUHJvbWlzZSA9IHNlbGYuc2VuZEFjdGlvbihcblx0XHRcdFx0c3RvcmUubmFtZSwgYWN0aW9uTmFtZSwgYXJnXG5cdFx0XHQpO1xuXHRcdFx0cHJvbWlzZXMucHVzaChzZW5kQWN0aW9uUHJvbWlzZSk7XG5cdFx0fSk7XG5cdHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuXG4vKipcbiAqIFNldHMgbmV3IHN0YXRlIHRvIHN0b3JlIGRpc3BhdGNoZXIgYW5kIGludm9rZXMgXCJjaGFuZ2VkXCIgbWV0aG9kIGZvciBhbGxcbiAqIHN0b3JlcyB3aGljaCBzdGF0ZSBoYXZlIGJlZW4gY2hhbmdlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIE1hcCBvZiBuZXcgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBiYXNpY0NvbnRleHQgQmFzaWMgY29udGV4dCBmb3IgYWxsIHN0b3Jlcy5cbiAqIEByZXR1cm5zIHtBcnJheTxzdHJpbmc+fSBOYW1lcyBvZiBzdG9yZXMgdGhhdCBoYXZlIGJlZW4gY2hhbmdlZC5cbiAqL1xuU3RvcmVEaXNwYXRjaGVyLnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzLCBiYXNpY0NvbnRleHQpIHtcblx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0aWYgKCF0aGlzLl9sYXN0U3RhdGUpIHtcblx0XHR0aGlzLl9jdXJyZW50QmFzaWNDb250ZXh0ID0gYmFzaWNDb250ZXh0O1xuXHRcdHRoaXMuX2xhc3RTdGF0ZSA9IHBhcmFtZXRlcnM7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0Ly8gc29tZSBzdG9yZSdzIHBhcmFtZXRlcnMgY2FuIGJlIHJlbW92ZWQgc2luY2UgbGFzdCB0aW1lXG5cdHZhciBzZWxmID0gdGhpcyxcblx0XHRjaGFuZ2VkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRPYmplY3Qua2V5cyh0aGlzLl9sYXN0U3RhdGUpXG5cdFx0LmZpbHRlcihmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG5cdFx0XHRyZXR1cm4gIShzdG9yZU5hbWUgaW4gcGFyYW1ldGVycyk7XG5cdFx0fSlcblx0XHQuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0Y2hhbmdlZFtuYW1lXSA9IHRydWU7XG5cdFx0fSk7XG5cblx0T2JqZWN0LmtleXMocGFyYW1ldGVycylcblx0XHQuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG5cdFx0XHQvLyBuZXcgcGFyYW1ldGVycyB3ZXJlIHNldCBmb3Igc3RvcmVcblx0XHRcdGlmICghKHN0b3JlTmFtZSBpbiBzZWxmLl9sYXN0U3RhdGUpKSB7XG5cdFx0XHRcdGNoYW5nZWRbc3RvcmVOYW1lXSA9IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbmV3IGFuZCBsYXN0IHBhcmFtZXRlcnMgaGFzIGRpZmZlcmVudCB2YWx1ZXNcblx0XHRcdHZhciBsYXN0UGFyYW1ldGVyTmFtZXMgPVxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKHNlbGYuX2xhc3RTdGF0ZVtzdG9yZU5hbWVdKSxcblx0XHRcdFx0Y3VycmVudFBhcmFtZXRlck5hbWVzID1cblx0XHRcdFx0XHRPYmplY3Qua2V5cyhwYXJhbWV0ZXJzW3N0b3JlTmFtZV0pO1xuXG5cdFx0XHRpZiAoY3VycmVudFBhcmFtZXRlck5hbWVzLmxlbmd0aCAhPT1cblx0XHRcdFx0bGFzdFBhcmFtZXRlck5hbWVzLmxlbmd0aCkge1xuXHRcdFx0XHRjaGFuZ2VkW3N0b3JlTmFtZV0gPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRQYXJhbWV0ZXJOYW1lcy5ldmVyeShmdW5jdGlvbiAocGFyYW1ldGVyTmFtZSkge1xuXHRcdFx0XHRpZiAocGFyYW1ldGVyc1tzdG9yZU5hbWVdW3BhcmFtZXRlck5hbWVdICE9PVxuXHRcdFx0XHRcdHNlbGYuX2xhc3RTdGF0ZVtzdG9yZU5hbWVdW3BhcmFtZXRlck5hbWVdKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZFtzdG9yZU5hbWVdID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHR0aGlzLl9sYXN0U3RhdGUgPSBwYXJhbWV0ZXJzO1xuXHRpZiAodGhpcy5fY3VycmVudEJhc2ljQ29udGV4dCAhPT0gYmFzaWNDb250ZXh0KSB7XG5cdFx0dGhpcy5fY3VycmVudEJhc2ljQ29udGV4dCA9IGJhc2ljQ29udGV4dDtcblx0XHRPYmplY3Qua2V5cyh0aGlzLl9zdG9yZUluc3RhbmNlcylcblx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0XHRcdFx0c2VsZi5fc3RvcmVJbnN0YW5jZXNbc3RvcmVOYW1lXS4kY29udGV4dCA9XG5cdFx0XHRcdFx0c2VsZi5fZ2V0U3RvcmVDb250ZXh0KHN0b3JlTmFtZSk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHZhciBjaGFuZ2VkU3RvcmVOYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdE9iamVjdC5rZXlzKGNoYW5nZWQpXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuXHRcdFx0dmFyIHN0b3JlID0gc2VsZi5nZXRTdG9yZShzdG9yZU5hbWUpO1xuXHRcdFx0aWYgKCFzdG9yZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzdG9yZS4kY29udGV4dC5jaGFuZ2VkKClcblx0XHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0XHRjaGFuZ2VkU3RvcmVOYW1lc1tuYW1lXSA9IHRydWU7XG5cdFx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdHRoaXMuX2V2ZW50QnVzLmVtaXQoJ3N0YXRlQ2hhbmdlZCcsIHtcblx0XHRvbGRTdGF0ZTogdGhpcy5fbGFzdFN0YXRlLFxuXHRcdG5ld1N0YXRlOiBwYXJhbWV0ZXJzXG5cdH0pO1xuXHRyZXR1cm4gT2JqZWN0LmtleXMoY2hhbmdlZFN0b3JlTmFtZXMpO1xufTtcblxuLyoqXG4gKiBHZXRzIGNvbnRleHQgZm9yIHN0b3JlIHVzaW5nIGNvbXBvbmVudCdzIGNvbnRleHQgYXMgYSBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lIE5hbWUgb2Ygc3RvcmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBTdG9yZSBjb250ZXh0LlxuICogQHByaXZhdGVcbiAqL1xuU3RvcmVEaXNwYXRjaGVyLnByb3RvdHlwZS5fZ2V0U3RvcmVDb250ZXh0ID0gZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuXHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0c3RvcmVDb250ZXh0ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9jdXJyZW50QmFzaWNDb250ZXh0KTtcblx0c3RvcmVDb250ZXh0Lm5hbWUgPSBzdG9yZU5hbWU7XG5cdHN0b3JlQ29udGV4dC5zdGF0ZSA9IHRoaXMuX2xhc3RTdGF0ZVtzdG9yZU5hbWVdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdHN0b3JlQ29udGV4dC5jaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB3YWxrZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuXHRcdFx0Y3VycmVudCxcblx0XHRcdHRvQ2hhbmdlID0gW3N0b3JlTmFtZV07XG5cblx0XHR3aGlsZSAodG9DaGFuZ2UubGVuZ3RoID4gMCkge1xuXHRcdFx0Y3VycmVudCA9IHRvQ2hhbmdlLnNoaWZ0KCk7XG5cdFx0XHRpZiAoY3VycmVudCBpbiB3YWxrZWQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHR3YWxrZWRbY3VycmVudF0gPSB0cnVlO1xuXHRcdFx0aWYgKGN1cnJlbnQgaW4gc2VsZi5fZGVwZW5kYW50cykge1xuXHRcdFx0XHR0b0NoYW5nZSA9IHRvQ2hhbmdlLmNvbmNhdChcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhzZWxmLl9kZXBlbmRhbnRzW2N1cnJlbnRdKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIHNlbGYuX2xhc3REYXRhW2N1cnJlbnRdO1xuXHRcdFx0c2VsZi5fZXZlbnRCdXMuZW1pdCgnc3RvcmVDaGFuZ2VkJywgY3VycmVudCk7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3Qua2V5cyh3YWxrZWQpO1xuXHR9O1xuXHRzdG9yZUNvbnRleHQuZ2V0U3RvcmVEYXRhID0gZnVuY3Rpb24gKHNvdXJjZVN0b3JlTmFtZSkge1xuXHRcdGlmIChzb3VyY2VTdG9yZU5hbWUgPT09IHN0b3JlTmFtZSkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcblx0XHR9XG5cdFx0cmV0dXJuIHNlbGYuZ2V0U3RvcmVEYXRhKHNvdXJjZVN0b3JlTmFtZSk7XG5cdH07XG5cdHN0b3JlQ29udGV4dC5zZXREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAoIShuYW1lIGluIHNlbGYuX2RlcGVuZGFudHMpKSB7XG5cdFx0XHRzZWxmLl9kZXBlbmRhbnRzW25hbWVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR9XG5cdFx0c2VsZi5fZGVwZW5kYW50c1tuYW1lXVtzdG9yZU5hbWVdID0gdHJ1ZTtcblx0fTtcblx0c3RvcmVDb250ZXh0LnVuc2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0aWYgKCEobmFtZSBpbiBzZWxmLl9kZXBlbmRhbnRzKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRkZWxldGUgc2VsZi5fZGVwZW5kYW50c1tuYW1lXVtzdG9yZU5hbWVdO1xuXHR9O1xuXHRzdG9yZUNvbnRleHQuc2VuZEFjdGlvbiA9IGZ1bmN0aW9uIChzdG9yZU5hbWUsIG5hbWUsIGFyZ3MpIHtcblx0XHRyZXR1cm4gc2VsZi5zZW5kQWN0aW9uKHN0b3JlTmFtZSwgbmFtZSwgYXJncyk7XG5cdH07XG5cdHN0b3JlQ29udGV4dC5zZW5kQnJvYWRjYXN0QWN0aW9uID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcblx0XHRyZXR1cm4gc2VsZi5zZW5kQnJvYWRjYXN0QWN0aW9uKG5hbWUsIGFyZ3MpO1xuXHR9O1xuXG5cdHJldHVybiBzdG9yZUNvbnRleHQ7XG59O1xuXG4vKipcbiAqIEdldHMgc3RvcmUgaW5zdGFuY2UgYW5kIGNyZWF0ZXMgaXQgaWYgcmVxdWlyZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RvcmVOYW1lIE5hbWUgb2Ygc3RvcmUuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBQcm9taXNlIGZvciBzdG9yZS5cbiAqL1xuU3RvcmVEaXNwYXRjaGVyLnByb3RvdHlwZS5nZXRTdG9yZSA9IGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0aWYgKCFzdG9yZU5hbWUpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR2YXIgc3RvcmUgPSB0aGlzLl9zdG9yZUluc3RhbmNlc1tzdG9yZU5hbWVdO1xuXHRpZiAoc3RvcmUpIHtcblx0XHRyZXR1cm4gc3RvcmU7XG5cdH1cblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdHZhciBzdG9yZXMgPSBzZWxmLl9zdG9yZUxvYWRlci5nZXRTdG9yZXNCeU5hbWVzKCksXG5cdFx0Y29uZmlnID0gc2VsZi5fc2VydmljZUxvY2F0b3IucmVzb2x2ZSgnY29uZmlnJyk7XG5cdGlmICghKHN0b3JlTmFtZSBpbiBzdG9yZXMpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgY29uc3RydWN0b3IgPSBzdG9yZXNbc3RvcmVOYW1lXS5jb25zdHJ1Y3Rvcjtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlLiRjb250ZXh0ID0gc2VsZi5fZ2V0U3RvcmVDb250ZXh0KHN0b3JlTmFtZSk7XG5cdHNlbGYuX3N0b3JlSW5zdGFuY2VzW3N0b3JlTmFtZV0gPSBzZWxmLl9zZXJ2aWNlTG9jYXRvclxuXHRcdC5yZXNvbHZlSW5zdGFuY2UoY29uc3RydWN0b3IsIGNvbmZpZyk7XG5cdHNlbGYuX3N0b3JlSW5zdGFuY2VzW3N0b3JlTmFtZV0uJGNvbnRleHQgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuJGNvbnRleHQ7XG5cblx0c2VsZi5fc2VyaWFsV3JhcHBlci5hZGQoc3RvcmVOYW1lLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGxvYWRNZXRob2QgPSBtb2R1bGVIZWxwZXIuZ2V0TWV0aG9kVG9JbnZva2UoXG5cdFx0XHRzZWxmLl9zdG9yZUluc3RhbmNlc1tzdG9yZU5hbWVdLCAnbG9hZCdcblx0XHQpO1xuXHRcdHJldHVybiBtb2R1bGVIZWxwZXIuZ2V0U2FmZVByb21pc2UobG9hZE1ldGhvZCk7XG5cdH0pO1xuXHRyZXR1cm4gc2VsZi5fc3RvcmVJbnN0YW5jZXNbc3RvcmVOYW1lXTtcbn07IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQm9vdHN0cmFwcGVyQmFzZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG5cdG1vZHVsZUhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbW9kdWxlSGVscGVyJyksXG5cdGhyVGltZUhlbHBlciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaHJUaW1lSGVscGVyJyksXG5cdHVociA9IHJlcXVpcmUoJ2NhdGJlcnJ5LXVocicpLFxuXHRQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZScpLFxuXHRTdGF0ZVByb3ZpZGVyID0gcmVxdWlyZSgnLi4vcHJvdmlkZXJzL1N0YXRlUHJvdmlkZXInKSxcblx0U3RvcmVMb2FkZXIgPSByZXF1aXJlKCcuLi9sb2FkZXJzL1N0b3JlTG9hZGVyJyksXG5cdENvbXBvbmVudExvYWRlciA9IHJlcXVpcmUoJy4uL2xvYWRlcnMvQ29tcG9uZW50TG9hZGVyJyksXG5cdERvY3VtZW50UmVuZGVyZXIgPSByZXF1aXJlKCcuLi9Eb2N1bWVudFJlbmRlcmVyJyksXG5cdFJlcXVlc3RSb3V0ZXIgPSByZXF1aXJlKCcuLi9SZXF1ZXN0Um91dGVyJyksXG5cdE1vZHVsZUFwaVByb3ZpZGVyQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UvTW9kdWxlQXBpUHJvdmlkZXJCYXNlJyksXG5cdENvbnRleHRGYWN0b3J5ID0gcmVxdWlyZSgnLi4vQ29udGV4dEZhY3RvcnknKSxcblx0RXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgSU5GT19DT01QT05FTlRfTE9BREVEID0gJ0NvbXBvbmVudCBcIiVzXCIgbG9hZGVkJyxcblx0SU5GT19TVE9SRV9MT0FERUQgPSAnU3RvcmUgXCIlc1wiIGxvYWRlZCcsXG5cdElORk9fQUxMX1NUT1JFU19MT0FERUQgPSAnQWxsIHN0b3JlcyBsb2FkZWQnLFxuXHRJTkZPX0FMTF9DT01QT05FTlRTX0xPQURFRCA9ICdBbGwgY29tcG9uZW50cyBsb2FkZWQnLFxuXHRERUJVR19ET0NVTUVOVF9SRU5ERVJFRCA9ICdEb2N1bWVudCByZW5kZXJlZCBmb3IgVVJJICVzJyxcblx0REVCVUdfUkVOREVSX0NPTVBPTkVOVCA9ICdDb21wb25lbnQgXCIlcyVzXCIgaXMgYmVpbmcgcmVuZGVyZWQuLi4nLFxuXHRERUJVR19DT01QT05FTlRfUkVOREVSRUQgPSAnQ29tcG9uZW50IFwiJXMlc1wiIHJlbmRlcmVkJXMnO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIGJhc2UgQ2F0YmVycnkgYm9vdHN0cmFwcGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2F0YmVycnlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvclxuICogb2YgdGhlIENhdGJlcnJ5J3MgbWFpbiBtb2R1bGUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQm9vdHN0cmFwcGVyQmFzZShjYXRiZXJyeUNvbnN0cnVjdG9yKSB7XG5cdHRoaXMuX2NhdGJlcnJ5Q29uc3RydWN0b3IgPSBjYXRiZXJyeUNvbnN0cnVjdG9yO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgY29uc3RydWN0b3Igb2YgdGhlIENhdGJlcnJ5J3MgbWFpbiBtb2R1bGUuXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5Cb290c3RyYXBwZXJCYXNlLnByb3RvdHlwZS5fY2F0YmVycnlDb25zdHJ1Y3RvciA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgZnVsbC1jb25maWd1cmVkIGluc3RhbmNlIG9mIHRoZSBDYXRiZXJyeSBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0P30gY29uZmlnT2JqZWN0IENvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge0NhdGJlcnJ5fSBDYXRiZXJyeSBhcHBsaWNhdGlvbiBpbnN0YW5jZS5cbiAqL1xuQm9vdHN0cmFwcGVyQmFzZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNvbmZpZ09iamVjdCkge1xuXHR2YXIgY3VycmVudENvbmZpZyA9IGNvbmZpZ09iamVjdCB8fCB7fSxcblx0XHRjYXRiZXJyeSA9IG5ldyB0aGlzLl9jYXRiZXJyeUNvbnN0cnVjdG9yKCk7XG5cblx0dGhpcy5jb25maWd1cmUoY3VycmVudENvbmZpZywgY2F0YmVycnkubG9jYXRvcik7XG5cdGNhdGJlcnJ5LmV2ZW50cyA9IGNhdGJlcnJ5LmxvY2F0b3IucmVzb2x2ZUluc3RhbmNlKE1vZHVsZUFwaVByb3ZpZGVyQmFzZSk7XG5cdHJldHVybiBjYXRiZXJyeTtcbn07XG5cbi8qKlxuICogQ29uZmlndXJlcyBsb2NhdG9yIHdpdGggYWxsIHJlcXVpcmVkIHR5cGUgcmVnaXN0cmF0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdPYmplY3QgQ29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge1NlcnZpY2VMb2NhdG9yfSBsb2NhdG9yIFNlcnZpY2UgbG9jYXRvciB0byBjb25maWd1cmUuXG4gKi9cbkJvb3RzdHJhcHBlckJhc2UucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChjb25maWdPYmplY3QsIGxvY2F0b3IpIHtcblx0dmFyIGV2ZW50QnVzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRldmVudEJ1cy5zZXRNYXhMaXN0ZW5lcnMoMCk7XG5cdGxvY2F0b3IucmVnaXN0ZXJJbnN0YW5jZSgncHJvbWlzZScsIFByb21pc2UpO1xuXHRsb2NhdG9yLnJlZ2lzdGVySW5zdGFuY2UoJ2V2ZW50QnVzJywgZXZlbnRCdXMpO1xuXHRsb2NhdG9yLnJlZ2lzdGVySW5zdGFuY2UoJ2NvbmZpZycsIGNvbmZpZ09iamVjdCk7XG5cdGxvY2F0b3IucmVnaXN0ZXIoJ3N0YXRlUHJvdmlkZXInLCBTdGF0ZVByb3ZpZGVyLCBjb25maWdPYmplY3QsIHRydWUpO1xuXHRsb2NhdG9yLnJlZ2lzdGVyKCdjb250ZXh0RmFjdG9yeScsIENvbnRleHRGYWN0b3J5LCBjb25maWdPYmplY3QsIHRydWUpO1xuXHRsb2NhdG9yLnJlZ2lzdGVyKCdzdG9yZUxvYWRlcicsIFN0b3JlTG9hZGVyLCBjb25maWdPYmplY3QsIHRydWUpO1xuXHRsb2NhdG9yLnJlZ2lzdGVyKCdjb21wb25lbnRMb2FkZXInLCBDb21wb25lbnRMb2FkZXIsIGNvbmZpZ09iamVjdCwgdHJ1ZSk7XG5cdGxvY2F0b3IucmVnaXN0ZXIoJ2RvY3VtZW50UmVuZGVyZXInLCBEb2N1bWVudFJlbmRlcmVyLCBjb25maWdPYmplY3QsIHRydWUpO1xuXHRsb2NhdG9yLnJlZ2lzdGVyKCdyZXF1ZXN0Um91dGVyJywgUmVxdWVzdFJvdXRlciwgY29uZmlnT2JqZWN0LCB0cnVlKTtcblxuXHR1aHIucmVnaXN0ZXIobG9jYXRvcik7XG59O1xuXG4vKipcbiAqIFdyYXBzIGV2ZW50IGJ1cyB3aXRoIGxvZyBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQXBwbGljYXRpb24gY29uZmlnLlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGV2ZW50QnVzIEV2ZW50IGVtaXR0ZXIgdGhhdCBpbXBsZW1lbnRzIGV2ZW50IGJ1cy5cbiAqIEBwYXJhbSB7TG9nZ2VyfSBsb2dnZXIgTG9nZ2VyIHRvIHdyaXRlIG1lc3NhZ2VzLlxuICogQHByb3RlY3RlZFxuICovXG5Cb290c3RyYXBwZXJCYXNlLnByb3RvdHlwZS5fd3JhcEV2ZW50c1dpdGhMb2dnZXIgPVxuXHRmdW5jdGlvbiAoY29uZmlnLCBldmVudEJ1cywgbG9nZ2VyKSB7XG5cdFx0dmFyIGlzUmVsZWFzZSA9IEJvb2xlYW4oY29uZmlnLmlzUmVsZWFzZSk7XG5cdFx0ZXZlbnRCdXNcblx0XHRcdC5vbignY29tcG9uZW50TG9hZGVkJywgZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0bG9nZ2VyLmluZm8odXRpbC5mb3JtYXQoSU5GT19DT01QT05FTlRfTE9BREVELCBhcmdzLm5hbWUpKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ3N0b3JlTG9hZGVkJywgZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0bG9nZ2VyLmluZm8odXRpbC5mb3JtYXQoSU5GT19TVE9SRV9MT0FERUQsIGFyZ3MubmFtZSkpO1xuXHRcdFx0fSlcblx0XHRcdC5vbignYWxsU3RvcmVzTG9hZGVkJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRsb2dnZXIuaW5mbyhJTkZPX0FMTF9TVE9SRVNfTE9BREVEKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2FsbENvbXBvbmVudHNMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGxvZ2dlci5pbmZvKElORk9fQUxMX0NPTVBPTkVOVFNfTE9BREVEKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcihlcnJvcik7XG5cdFx0XHR9KTtcblxuXHRcdGlmIChpc1JlbGVhc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZXZlbnRCdXNcblx0XHRcdC5vbignY29tcG9uZW50UmVuZGVyJywgZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0dmFyIGlkID0gYXJncy5jb250ZXh0LmF0dHJpYnV0ZXNbbW9kdWxlSGVscGVyLkFUVFJJQlVURV9JRF07XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyh1dGlsLmZvcm1hdChERUJVR19SRU5ERVJfQ09NUE9ORU5ULFxuXHRcdFx0XHRcdG1vZHVsZUhlbHBlci5nZXRUYWdOYW1lRm9yQ29tcG9uZW50TmFtZShhcmdzLm5hbWUpLFxuXHRcdFx0XHRcdGlkID8gJyMnICsgaWQgOiAnJ1xuXHRcdFx0XHQpKTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ2NvbXBvbmVudFJlbmRlcmVkJywgZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0dmFyIGlkID0gYXJncy5jb250ZXh0LmF0dHJpYnV0ZXNbbW9kdWxlSGVscGVyLkFUVFJJQlVURV9JRF07XG5cdFx0XHRcdGxvZ2dlci5kZWJ1Zyh1dGlsLmZvcm1hdChcblx0XHRcdFx0XHRERUJVR19DT01QT05FTlRfUkVOREVSRUQsXG5cdFx0XHRcdFx0bW9kdWxlSGVscGVyLmdldFRhZ05hbWVGb3JDb21wb25lbnROYW1lKGFyZ3MubmFtZSksXG5cdFx0XHRcdFx0aWQgPyAnIycgKyBpZCA6ICcnLFxuXHRcdFx0XHRcdHV0aWwuaXNBcnJheShhcmdzLmhyVGltZSkgP1xuXHRcdFx0XHRcdFx0JyAoJyArIGhyVGltZUhlbHBlci50b01lc3NhZ2UoYXJncy5oclRpbWUpICsgJyknIDogJydcblx0XHRcdFx0KSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdkb2N1bWVudFJlbmRlcmVkJywgZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKHV0aWwuZm9ybWF0KFxuXHRcdFx0XHRcdERFQlVHX0RPQ1VNRU5UX1JFTkRFUkVELCBhcmdzLmxvY2F0aW9uLnRvU3RyaW5nKClcblx0XHRcdFx0KSk7XG5cdFx0XHR9KTtcblx0fTsiLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBDYXRiZXJyeUJhc2U7XG5cbnZhciBTZXJ2aWNlTG9jYXRvciA9IHJlcXVpcmUoJ2NhdGJlcnJ5LWxvY2F0b3InKTtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgYmFzaWMgQ2F0YmVycnkgYXBwbGljYXRpb24gbW9kdWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENhdGJlcnJ5QmFzZSgpIHtcblx0dGhpcy5sb2NhdG9yID0gbmV3IFNlcnZpY2VMb2NhdG9yKCk7XG5cdHRoaXMubG9jYXRvci5yZWdpc3Rlckluc3RhbmNlKCdzZXJ2aWNlTG9jYXRvcicsIHRoaXMubG9jYXRvcik7XG5cdHRoaXMubG9jYXRvci5yZWdpc3Rlckluc3RhbmNlKCdjYXRiZXJyeScsIHRoaXMpO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgdmVyc2lvbiBvZiBjYXRiZXJyeS5cbiAqL1xuQ2F0YmVycnlCYXNlLnByb3RvdHlwZS52ZXJzaW9uID0gJzcuMC4zJztcblxuLyoqXG4gKiBDdXJyZW50IG9iamVjdCB3aXRoIGV2ZW50cy5cbiAqIEB0eXBlIHtNb2R1bGVBcGlQcm92aWRlcn1cbiAqL1xuQ2F0YmVycnlCYXNlLnByb3RvdHlwZS5ldmVudHMgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgc2VydmljZSBsb2NhdG9yLlxuICogQHR5cGUge1NlcnZpY2VMb2NhdG9yfVxuICovXG5DYXRiZXJyeUJhc2UucHJvdG90eXBlLmxvY2F0b3IgPSBudWxsOyIsIi8qXG4gKiBjYXRiZXJyeVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBEZW5pcyBSZWNoa3Vub3YgYW5kIHByb2plY3QgY29udHJpYnV0b3JzLlxuICpcbiAqIGNhdGJlcnJ5J3MgbGljZW5zZSBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgbGljZW5zZSBhcHBsaWVzIHRvIGFsbCBwYXJ0cyBvZiBjYXRiZXJyeSB0aGF0IGFyZSBub3QgZXh0ZXJuYWxseVxuICogbWFpbnRhaW5lZCBsaWJyYXJpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvb2tpZVdyYXBwZXJCYXNlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgYmFzaWMgY29va2llIHdyYXBwZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29va2llV3JhcHBlckJhc2UoKSB7XG59XG5cbi8qKlxuICogR2V0cyBtYXAgb2YgY29va2llIHZhbHVlcyBieSBuYW1lLlxuICogQHJldHVybnMge09iamVjdH0gQ29va2llcyBtYXAgYnkgbmFtZXMuXG4gKi9cbkNvb2tpZVdyYXBwZXJCYXNlLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzdHJpbmcgPSB0aGlzLmdldENvb2tpZVN0cmluZygpO1xuXHRyZXR1cm4gdGhpcy5fcGFyc2VDb29raWVTdHJpbmcoc3RyaW5nKTtcbn07XG5cbi8qKlxuICogR2V0cyBjb29raWUgdmFsdWUgYnkgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENvb2tpZSBuYW1lLlxuICogQHJldHVybnMge3N0cmluZ30gQ29va2llIHZhbHVlLlxuICovXG5Db29raWVXcmFwcGVyQmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0aWYgKHR5cGVvZiAobmFtZSkgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuZ2V0QWxsKClbbmFtZV0gfHwgJyc7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBjb29raWUgc3RyaW5nIGludG8gbWFwIG9mIGNvb2tpZSBrZXkvdmFsdWUgcGFpcnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIENvb2tpZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3Qgd2l0aCBjb29raWUgdmFsdWVzIGJ5IGtleXMuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvb2tpZVdyYXBwZXJCYXNlLnByb3RvdHlwZS5fcGFyc2VDb29raWVTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdHZhciBjb29raWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGlmICh0eXBlb2YgKHN0cmluZykgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIGNvb2tpZTtcblx0fVxuXHRzdHJpbmdcblx0XHQuc3BsaXQoLzsgKi8pXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKGNvb2tpZVBhaXIpIHtcblx0XHRcdHZhciBlcXVhbHNJbmRleCA9IGNvb2tpZVBhaXIuaW5kZXhPZignPScpO1xuXHRcdFx0aWYgKGVxdWFsc0luZGV4IDwgMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrZXkgPSBjb29raWVQYWlyLnN1YnN0cigwLCBlcXVhbHNJbmRleCkudHJpbSgpLFxuXHRcdFx0XHR2YWx1ZSA9IGNvb2tpZVBhaXIuc3Vic3RyKFxuXHRcdFx0XHRcdGVxdWFsc0luZGV4ICsgMSwgY29va2llUGFpci5sZW5ndGhcblx0XHRcdFx0KS50cmltKCk7XG5cblx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXlwifFwiJC9nLCAnJyk7XG5cdFx0XHRjb29raWVba2V5XSA9IHZhbHVlO1xuXHRcdH0pO1xuXG5cdHJldHVybiBjb29raWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGNvb2tpZSBzZXR1cCBvYmplY3QgdG8gY29va2llIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29raWVTZXR1cCBDb29raWUgc2V0dXAgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGNvb2tpZVNldHVwLmtleSBDb29raWUga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9IGNvb2tpZVNldHVwLnZhbHVlIENvb2tpZSB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyP30gY29va2llU2V0dXAubWF4QWdlIE1heCBjb29raWUgYWdlIGluIHNlY29uZHMuXG4gKiBAcGFyYW0ge0RhdGU/fSBjb29raWVTZXR1cC5leHBpcmVzIEV4cGlyZSBkYXRlLlxuICogQHBhcmFtIHtzdHJpbmc/fSBjb29raWVTZXR1cC5wYXRoIFVSSSBwYXRoIGZvciBjb29raWUuXG4gKiBAcGFyYW0ge3N0cmluZz99IGNvb2tpZVNldHVwLmRvbWFpbiBDb29raWUgZG9tYWluLlxuICogQHBhcmFtIHtib29sZWFuP30gY29va2llU2V0dXAuc2VjdXJlIElzIGNvb2tpZSBzZWN1cmVkLlxuICogQHBhcmFtIHtib29sZWFuP30gY29va2llU2V0dXAuaHR0cE9ubHkgSXMgY29va2llIEhUVFAgb25seS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvb2tpZSBzdHJpbmcuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvb2tpZVdyYXBwZXJCYXNlLnByb3RvdHlwZS5fY29udmVydFRvQ29va2llU2V0dXAgPSBmdW5jdGlvbiAoY29va2llU2V0dXApIHtcblx0aWYgKHR5cGVvZiAoY29va2llU2V0dXAua2V5KSAhPT0gJ3N0cmluZycgfHxcblx0XHR0eXBlb2YgKGNvb2tpZVNldHVwLnZhbHVlKSAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGtleSBvciB2YWx1ZScpO1xuXHR9XG5cblx0dmFyIGNvb2tpZSA9IGNvb2tpZVNldHVwLmtleSArICc9JyArIGNvb2tpZVNldHVwLnZhbHVlO1xuXG5cdC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYyNjUjc2VjdGlvbi00LjEuMVxuXHRpZiAodHlwZW9mIChjb29raWVTZXR1cC5tYXhBZ2UpID09PSAnbnVtYmVyJykge1xuXHRcdGNvb2tpZSArPSAnOyBNYXgtQWdlPScgKyBjb29raWVTZXR1cC5tYXhBZ2UudG9GaXhlZCgpO1xuXHRcdGlmICghY29va2llU2V0dXAuZXhwaXJlcykge1xuXHRcdFx0Ly8gYnkgZGVmYXVsdCBleHBpcmUgZGF0ZSA9IGN1cnJlbnQgZGF0ZSArIG1heC1hZ2UgaW4gc2Vjb25kc1xuXHRcdFx0Y29va2llU2V0dXAuZXhwaXJlcyA9IG5ldyBEYXRlKERhdGUubm93KCkgK1xuXHRcdFx0XHRjb29raWVTZXR1cC5tYXhBZ2UgKiAxMDAwKTtcblx0XHR9XG5cdH1cblx0aWYgKGNvb2tpZVNldHVwLmV4cGlyZXMgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0Y29va2llICs9ICc7IEV4cGlyZXM9JyArIGNvb2tpZVNldHVwLmV4cGlyZXMudG9VVENTdHJpbmcoKTtcblx0fVxuXHRpZiAodHlwZW9mIChjb29raWVTZXR1cC5wYXRoKSA9PT0gJ3N0cmluZycpIHtcblx0XHRjb29raWUgKz0gJzsgUGF0aD0nICsgY29va2llU2V0dXAucGF0aDtcblx0fVxuXHRpZiAodHlwZW9mIChjb29raWVTZXR1cC5kb21haW4pID09PSAnc3RyaW5nJykge1xuXHRcdGNvb2tpZSArPSAnOyBEb21haW49JyArIGNvb2tpZVNldHVwLmRvbWFpbjtcblx0fVxuXHRpZiAodHlwZW9mIChjb29raWVTZXR1cC5zZWN1cmUpID09PSAnYm9vbGVhbicgJiZcblx0XHRjb29raWVTZXR1cC5zZWN1cmUpIHtcblx0XHRjb29raWUgKz0gJzsgU2VjdXJlJztcblx0fVxuXHRpZiAodHlwZW9mIChjb29raWVTZXR1cC5odHRwT25seSkgPT09ICdib29sZWFuJyAmJlxuXHRcdGNvb2tpZVNldHVwLmh0dHBPbmx5KSB7XG5cdFx0Y29va2llICs9ICc7IEh0dHBPbmx5Jztcblx0fVxuXG5cdHJldHVybiBjb29raWU7XG59OyIsIi8qXG4gKiBjYXRiZXJyeVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBEZW5pcyBSZWNoa3Vub3YgYW5kIHByb2plY3QgY29udHJpYnV0b3JzLlxuICpcbiAqIGNhdGJlcnJ5J3MgbGljZW5zZSBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgbGljZW5zZSBhcHBsaWVzIHRvIGFsbCBwYXJ0cyBvZiBjYXRiZXJyeSB0aGF0IGFyZSBub3QgZXh0ZXJuYWxseVxuICogbWFpbnRhaW5lZCBsaWJyYXJpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50UmVuZGVyZXJCYXNlO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHRoZSBiYXNpYyBkb2N1bWVudCByZW5kZXJlci5cbiAqIEBwYXJhbSB7U2VydmljZUxvY2F0b3J9ICRzZXJ2aWNlTG9jYXRvciBMb2NhdG9yIHRvIHJlc29sdmUgZGVwZW5kZW5jaWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERvY3VtZW50UmVuZGVyZXJCYXNlKCRzZXJ2aWNlTG9jYXRvcikge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHRoaXMuX3NlcnZpY2VMb2NhdG9yID0gJHNlcnZpY2VMb2NhdG9yO1xuXHR0aGlzLl9jb250ZXh0RmFjdG9yeSA9ICRzZXJ2aWNlTG9jYXRvci5yZXNvbHZlKCdjb250ZXh0RmFjdG9yeScpO1xuXHR0aGlzLl9jb21wb25lbnRMb2FkZXIgPSAkc2VydmljZUxvY2F0b3IucmVzb2x2ZSgnY29tcG9uZW50TG9hZGVyJyk7XG5cdHRoaXMuX2V2ZW50QnVzID0gJHNlcnZpY2VMb2NhdG9yLnJlc29sdmUoJ2V2ZW50QnVzJyk7XG5cblx0dmFyIHN0b3JlTG9hZGVyID0gJHNlcnZpY2VMb2NhdG9yLnJlc29sdmUoJ3N0b3JlTG9hZGVyJyk7XG5cdHRoaXMuX2xvYWRpbmcgPSBQcm9taXNlLmFsbChbXG5cdFx0dGhpcy5fY29tcG9uZW50TG9hZGVyLmxvYWQoKSxcblx0XHRzdG9yZUxvYWRlci5sb2FkKClcblx0XSlcblx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLl9sb2FkaW5nID0gbnVsbDtcblx0XHRcdHNlbGYuX2V2ZW50QnVzLmVtaXQoJ3JlYWR5Jyk7XG5cdFx0fSlcblx0XHQuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0c2VsZi5fZXZlbnRCdXMuZW1pdCgnZXJyb3InLCByZWFzb24pO1xuXHRcdH0pO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgc2VydmljZSBsb2NhdG9yLlxuICogQHR5cGUge1NlcnZpY2VMb2NhdG9yfVxuICogQHByb3RlY3RlZFxuICovXG5Eb2N1bWVudFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuX3NlcnZpY2VMb2NhdG9yID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IGNvbXBvbmVudCBsb2FkZXIuXG4gKiBAdHlwZSB7Q29tcG9uZW50TG9hZGVyfVxuICogQHByb3RlY3RlZFxuICovXG5Eb2N1bWVudFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuX2NvbXBvbmVudExvYWRlciA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBtb2R1bGUgbG9hZGluZyBwcm9taXNlLlxuICogQHR5cGUge1Byb21pc2V9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbkRvY3VtZW50UmVuZGVyZXJCYXNlLnByb3RvdHlwZS5fbG9hZGluZyA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBjb250ZXh0IGZhY3RvcnkuXG4gKiBAdHlwZSB7Q29udGV4dEZhY3Rvcnl9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbkRvY3VtZW50UmVuZGVyZXJCYXNlLnByb3RvdHlwZS5fY29udGV4dEZhY3RvcnkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgcHJvbWlzZSBmb3IgcmVhZHkgc3RhdGUgd2hlbiBpdCB3aWxsIGJlIGFibGUgaGFuZGxlIHJlcXVlc3RzLlxuICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgZm9yIG5vdGhpbmcuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkRvY3VtZW50UmVuZGVyZXJCYXNlLnByb3RvdHlwZS5fZ2V0UHJvbWlzZUZvclJlYWR5U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLl9sb2FkaW5nID9cblx0XHR0aGlzLl9sb2FkaW5nIDpcblx0XHRQcm9taXNlLnJlc29sdmUoKTtcbn07IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyQmFzZTtcblxuLyoqXG4gKiBDcmVhdGUgYmFzaWMgaW1wbGVtZW50YXRpb24gb2YgYSBtb2R1bGUgbG9hZGVyLlxuICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBBcnJheSBvZiBtb2R1bGUgdHJhbnNmb3JtYXRpb25zLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvYWRlckJhc2UodHJhbnNmb3Jtcykge1xuXHR0aGlzLl90cmFuc2Zvcm1zID0gdHJhbnNmb3Jtcztcbn1cblxuLyoqXG4gKiBDdXJyZW50IGxpc3Qgb2YgY29tcG9uZW50IHRyYW5zZm9ybXMuXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5Mb2FkZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtcyA9IG51bGw7XG5cbi8qKlxuICogQXBwbGllcyBhbGwgdHJhbnNmb3JtYXRpb25zIHJlZ2lzdGVyZWQgaW4gU2VydmljZSBMb2NhdG9yLlxuICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSBMb2FkZWQgbW9kdWxlLlxuICogQHBhcmFtIHtudW1iZXI/fSBpbmRleCBUcmFuc2Zvcm1hdGlvbiBpbmRleCBpbiBhIGxpc3QuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBUcmFuc2Zvcm1lZCBtb2R1bGUuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkxvYWRlckJhc2UucHJvdG90eXBlLl9hcHBseVRyYW5zZm9ybXMgPSBmdW5jdGlvbiAobW9kdWxlLCBpbmRleCkge1xuXHRpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHRoZSBsaXN0IGlzIGEgc3RhY2ssIHdlIHNob3VsZCByZXZlcnNlIGl0XG5cdFx0aW5kZXggPSB0aGlzLl90cmFuc2Zvcm1zLmxlbmd0aCAtIDE7XG5cdH1cblxuXHRpZiAoaW5kZXggPCAwKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShtb2R1bGUpO1xuXHR9XG5cblx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdHRyYW5zZm9ybWF0aW9uID0gdGhpcy5fdHJhbnNmb3Jtc1tpbmRleF07XG5cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG5cdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRyYW5zZm9ybWF0aW9uLnRyYW5zZm9ybShtb2R1bGUpO1xuXHRcdH0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKHRyYW5zZm9ybWVkTW9kdWxlKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fYXBwbHlUcmFuc2Zvcm1zKHRyYW5zZm9ybWVkTW9kdWxlLCBpbmRleCAtIDEpO1xuXHRcdH0pO1xufTsiLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGVBcGlQcm92aWRlckJhc2U7XG5cbnZhciBFUlJPUl9FVkVOVF9OQU1FID0gJ0V2ZW50IG5hbWUgc2hvdWxkIGJlIGEgc3RyaW5nJyxcblx0RVJST1JfRVZFTlRfSEFORExFUiA9ICdFdmVudCBoYW5kbGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiB0aGUgYmFzaWMgQVBJIHByb3ZpZGVyLlxuICogQHBhcmFtIHtTZXJ2aWNlTG9jYXRvcn0gJHNlcnZpY2VMb2NhdG9yIFNlcnZpY2UgbG9jYXRvclxuICogdG8gcmVzb2x2ZSBkZXBlbmRlbmNpZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTW9kdWxlQXBpUHJvdmlkZXJCYXNlKCRzZXJ2aWNlTG9jYXRvcikge1xuXHR0aGlzLmxvY2F0b3IgPSAkc2VydmljZUxvY2F0b3I7XG5cdHRoaXMuY29va2llID0gJHNlcnZpY2VMb2NhdG9yLnJlc29sdmUoJ2Nvb2tpZVdyYXBwZXInKTtcblx0dGhpcy5fZXZlbnRCdXMgPSAkc2VydmljZUxvY2F0b3IucmVzb2x2ZSgnZXZlbnRCdXMnKTtcbn1cblxuLyoqXG4gKiBDdXJyZW50IGNvb2tpZSBwcm92aWRlci5cbiAqIEB0eXBlIHtDb29raWVXcmFwcGVyfVxuICovXG5Nb2R1bGVBcGlQcm92aWRlckJhc2UucHJvdG90eXBlLmNvb2tpZSA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBzZXJ2aWNlIGxvY2F0b3IuXG4gKiBAdHlwZSB7U2VydmljZUxvY2F0b3J9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbk1vZHVsZUFwaVByb3ZpZGVyQmFzZS5wcm90b3R5cGUubG9jYXRvciA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBldmVudCBidXMuXG4gKiBAdHlwZSB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuTW9kdWxlQXBpUHJvdmlkZXJCYXNlLnByb3RvdHlwZS5fZXZlbnRCdXMgPSBudWxsO1xuXG4vKipcbiAqIFN1YnNjcmliZXMgb24gdGhlIHNwZWNpZmllZCBldmVudCBpbiBDYXRiZXJyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXIuXG4gKiBAcmV0dXJucyB7TW9kdWxlQXBpUHJvdmlkZXJCYXNlfSBUaGlzIG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gKi9cbk1vZHVsZUFwaVByb3ZpZGVyQmFzZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XG5cdGNoZWNrRXZlbnROYW1lQW5kSGFuZGxlcihldmVudE5hbWUsIGhhbmRsZXIpO1xuXHR0aGlzLl9ldmVudEJ1cy5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyBvbiB0aGUgc3BlY2lmaWVkIGV2ZW50IGluIENhdGJlcnJ5IHRvIGhhbmRsZSBvbmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlci5cbiAqIEByZXR1cm5zIHtNb2R1bGVBcGlQcm92aWRlckJhc2V9IFRoaXMgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAqL1xuTW9kdWxlQXBpUHJvdmlkZXJCYXNlLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuXHRjaGVja0V2ZW50TmFtZUFuZEhhbmRsZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcblx0dGhpcy5fZXZlbnRCdXMub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGhhbmRsZXIgZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgRXZlbnQgaGFuZGxlci5cbiAqIEByZXR1cm5zIHtNb2R1bGVBcGlQcm92aWRlckJhc2V9IFRoaXMgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAqL1xuTW9kdWxlQXBpUHJvdmlkZXJCYXNlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcblx0Y2hlY2tFdmVudE5hbWVBbmRIYW5kbGVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG5cdHRoaXMuX2V2ZW50QnVzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG5cdHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBoYW5kbGVycyBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQgaW4gQ2F0YmVycnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgdGhlIGV2ZW50LlxuICogQHJldHVybnMge01vZHVsZUFwaVByb3ZpZGVyQmFzZX0gVGhpcyBvYmplY3QgZm9yIGNoYWluaW5nLlxuICovXG5Nb2R1bGVBcGlQcm92aWRlckJhc2UucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0Y2hlY2tFdmVudE5hbWVBbmRIYW5kbGVyKGV2ZW50TmFtZSwgZHVtbXkpO1xuXHR0aGlzLl9ldmVudEJ1cy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBldmVudCBuYW1lIGlzIGEgc3RyaW5nIGFuZCBoYW5kbGVyIGlzIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGV2ZW50TmFtZSBOYW1lIG9mIHRoZSBldmVudCB0byBjaGVjay5cbiAqIEBwYXJhbSB7Kn0gaGFuZGxlciBUaGUgZXZlbnQgaGFuZGxlciB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFdmVudE5hbWVBbmRIYW5kbGVyKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuXHRpZiAodHlwZW9mIChldmVudE5hbWUpICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihFUlJPUl9FVkVOVF9OQU1FKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgKGhhbmRsZXIpICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKEVSUk9SX0VWRU5UX0hBTkRMRVIpO1xuXHR9XG59XG5cbi8qKlxuICogRG9lcyBub3RoaW5nLiBJdCBpcyB1c2VkIGFzIGEgZGVmYXVsdCBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZHVtbXkoKSB7fVxuIiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgVElUTEUgPSAnQ2F0YmVycnlANy4wLjMgKCcgK1xuXHRcdCc8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2lzc3Vlc1wiICcgK1xuXHRcdCd0YXJnZXQ9XCJfYmxhbmtcIj4nICtcblx0XHQncmVwb3J0IGFuIGlzc3VlJyArXG5cdFx0JzwvYT4nICtcblx0XHQnKScsXG5cdEFNUCA9IC8mL2csXG5cdExUID0gLzwvZyxcblx0R1QgPSAvPi9nLFxuXHRRVU9UID0gL1xcXCIvZyxcblx0U0lOR0xFX1FVT1QgPSAvXFwnL2csXG5cdEVSUk9SX01FU1NBR0VfUkVHRVhQID0gL14oPzpbXFx3JF0rKTogKD86LispXFxyP1xcbi9pLFxuXHRFUlJPUl9NRVNTQUdFX0ZPUk1BVCA9ICc8c3BhbiAnICtcblx0XHQnc3R5bGU9XCJjb2xvcjogcmVkOyBmb250LXNpemU6IDE2cHQ7IGZvbnQtd2VpZ2h0OiBib2xkO1wiPicgK1xuXHRcdCclcyVzJyArXG5cdFx0Jzwvc3Bhbj4nLFxuXHRORVdfTElORSA9IC9cXHI/XFxuL2c7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHQvKipcblx0ICogUHJpbnRzIGVycm9yIHdpdGggcHJldHR5IGZvcm1hdHRpbmcuXG5cdCAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIEVycm9yIHRvIHByaW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXNlckFnZW50IFVzZXIgYWdlbnQgaW5mb3JtYXRpb24uXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEhUTUwgd2l0aCBhbGwgaW5mb3JtYXRpb24gYWJvdXQgZXJyb3IuXG5cdCAqL1xuXHRwcmV0dHlQcmludDogZnVuY3Rpb24gKGVycm9yLCB1c2VyQWdlbnQpIHtcblx0XHRpZiAoIWVycm9yIHx8IHR5cGVvZiAoZXJyb3IpICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHR2YXIgZGF0ZVN0cmluZyA9IChuZXcgRGF0ZSgpKS50b1VUQ1N0cmluZygpICsgJzs8YnIvPicsXG5cdFx0XHR1c2VyQWdlbnRTdHJpbmcgPSAodXNlckFnZW50ID8gKHVzZXJBZ2VudCArICc7PGJyLz4nKSA6ICcnKSxcblx0XHRcdG5hbWUgPSAodHlwZW9mIChlcnJvci5uYW1lKSA9PT0gJ3N0cmluZycgPyBlcnJvci5uYW1lICsgJzogJyA6ICcnKSxcblx0XHRcdG1lc3NhZ2UgPSBTdHJpbmcoZXJyb3IubWVzc2FnZSB8fCAnJyksXG5cdFx0XHRzdGFjayA9IFN0cmluZyhlcnJvci5zdGFjayB8fCAnJykucmVwbGFjZShFUlJPUl9NRVNTQUdFX1JFR0VYUCwgJycpLFxuXHRcdFx0ZnVsbE1lc3NhZ2UgPSB1dGlsLmZvcm1hdChcblx0XHRcdFx0RVJST1JfTUVTU0FHRV9GT1JNQVQsIGVzY2FwZShuYW1lKSwgZXNjYXBlKG1lc3NhZ2UpXG5cdFx0XHQpO1xuXG5cdFx0cmV0dXJuICc8ZGl2IHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IGZvbnQtc2l6ZTogMTJwdDtcIj4nICtcblx0XHRcdGRhdGVTdHJpbmcgK1xuXHRcdFx0dXNlckFnZW50U3RyaW5nICtcblx0XHRcdFRJVExFICsgJzxici8+PGJyLz4nICtcblx0XHRcdGZ1bGxNZXNzYWdlICsgJzxici8+PGJyLz4nICtcblx0XHRcdGVzY2FwZShzdGFjaykgK1xuXHRcdFx0JzwvZGl2Pic7XG5cdH1cbn07XG5cbi8qKlxuICogRXNjYXBlcyBlcnJvciB0ZXh0LlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIEVycm9yIHRleHQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBlc2NhcGVkIGFuZCBmb3JtYXR0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlXG5cdFx0LnJlcGxhY2UoQU1QLCAnJmFtcDsnKVxuXHRcdC5yZXBsYWNlKExULCAnJmx0OycpXG5cdFx0LnJlcGxhY2UoR1QsICcmZ3Q7Jylcblx0XHQucmVwbGFjZShRVU9ULCAnJnF1b3Q7Jylcblx0XHQucmVwbGFjZShTSU5HTEVfUVVPVCwgJyYjMzk7Jylcblx0XHQucmVwbGFjZShORVdfTElORSwgJzxici8+Jyk7XG59IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoZWxwZXIgPSB7XG5cdENPTVBPTkVOVF9QUkVGSVg6ICdjYXQtJyxcblx0Q09NUE9ORU5UX1BSRUZJWF9SRUdFWFA6IC9eY2F0LS9pLFxuXHRDT01QT05FTlRfRVJST1JfVEVNUExBVEVfUE9TVEZJWDogJy0tZXJyb3InLFxuXHRET0NVTUVOVF9DT01QT05FTlRfTkFNRTogJ2RvY3VtZW50Jyxcblx0RE9DVU1FTlRfRUxFTUVOVF9OQU1FOiAnaHRtbCcsXG5cdEhFQURfQ09NUE9ORU5UX05BTUU6ICdoZWFkJyxcblx0QVRUUklCVVRFX0lEOiAnaWQnLFxuXHRBVFRSSUJVVEVfU1RPUkU6ICdjYXQtc3RvcmUnLFxuXHRERUZBVUxUX0xPR0lDX0ZJTEVOQU1FOiAnaW5kZXguanMnLFxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIG5hbWUgZm9yIGVycm9yIHRlbXBsYXRlIG9mIGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgbmFtZSBvZiBjb21wb25lbnQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IE5hbWUgb2YgZXJyb3IgdGVtcGxhdGUgb2YgdGhlIGNvbXBvbmVudC5cblx0ICovXG5cdGdldE5hbWVGb3JFcnJvclRlbXBsYXRlOiBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSkge1xuXHRcdGlmICh0eXBlb2YgKGNvbXBvbmVudE5hbWUpICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHRyZXR1cm4gY29tcG9uZW50TmFtZSArIGhlbHBlci5DT01QT05FTlRfRVJST1JfVEVNUExBVEVfUE9TVEZJWDtcblx0fSxcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiBzcGVjaWZpZWQgY29tcG9uZW50IG5hbWUgaXMgdGhlIFwiZG9jdW1lbnRcIiBjb21wb25lbnQgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBzcGVjaWZpZWQgY29tcG9uZW50IGlzIHRoZSBcImRvY3VtZW50XCIgY29tcG9uZW50LlxuXHQgKi9cblx0aXNEb2N1bWVudENvbXBvbmVudDogZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUpIHtcblx0XHRyZXR1cm4gY29tcG9uZW50TmFtZS50b0xvd2VyQ2FzZSgpID09PSBoZWxwZXIuRE9DVU1FTlRfQ09NUE9ORU5UX05BTUU7XG5cdH0sXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHNwZWNpZmllZCBjb21wb25lbnQgbmFtZSBpcyB0aGUgXCJoZWFkXCIgY29tcG9uZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgc3BlY2lmaWVkIGNvbXBvbmVudCBpcyB0aGUgXCJoZWFkXCIgY29tcG9uZW50LlxuXHQgKi9cblx0aXNIZWFkQ29tcG9uZW50OiBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSkge1xuXHRcdHJldHVybiBjb21wb25lbnROYW1lLnRvTG93ZXJDYXNlKCkgPT09IGhlbHBlci5IRUFEX0NPTVBPTkVOVF9OQU1FO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBvcmlnaW5hbCBjb21wb25lbnQgbmFtZSB3aXRob3V0IHByZWZpeC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZ1bGxDb21wb25lbnROYW1lIEZ1bGwgY29tcG9uZW50IG5hbWUgKHRhZyBuYW1lKS5cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIG9yaWdpbmFsIGNvbXBvbmVudCBuYW1lIHdpdGhvdXQgcHJlZml4LlxuXHQgKi9cblx0Z2V0T3JpZ2luYWxDb21wb25lbnROYW1lOiBmdW5jdGlvbiAoZnVsbENvbXBvbmVudE5hbWUpIHtcblx0XHRpZiAodHlwZW9mIChmdWxsQ29tcG9uZW50TmFtZSkgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdGZ1bGxDb21wb25lbnROYW1lID0gZnVsbENvbXBvbmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAoZnVsbENvbXBvbmVudE5hbWUgPT09IGhlbHBlci5IRUFEX0NPTVBPTkVOVF9OQU1FKSB7XG5cdFx0XHRyZXR1cm4gZnVsbENvbXBvbmVudE5hbWU7XG5cdFx0fVxuXHRcdGlmIChmdWxsQ29tcG9uZW50TmFtZSA9PT0gaGVscGVyLkRPQ1VNRU5UX0NPTVBPTkVOVF9OQU1FIHx8XG5cdFx0XHRmdWxsQ29tcG9uZW50TmFtZSA9PT0gaGVscGVyLkRPQ1VNRU5UX0VMRU1FTlRfTkFNRSkge1xuXHRcdFx0cmV0dXJuIGhlbHBlci5ET0NVTUVOVF9DT01QT05FTlRfTkFNRTtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bGxDb21wb25lbnROYW1lLnJlcGxhY2UoaGVscGVyLkNPTVBPTkVOVF9QUkVGSVhfUkVHRVhQLCAnJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldHMgdmFsaWQgdGFnIG5hbWUgZm9yIGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBOYW1lIG9mIHRoZSB0YWcuXG5cdCAqL1xuXHRnZXRUYWdOYW1lRm9yQ29tcG9uZW50TmFtZTogZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUpIHtcblx0XHRpZiAodHlwZW9mIChjb21wb25lbnROYW1lKSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0dmFyIHVwcGVyQ29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUudG9VcHBlckNhc2UoKTtcblx0XHRpZiAoY29tcG9uZW50TmFtZSA9PT0gaGVscGVyLkhFQURfQ09NUE9ORU5UX05BTUUpIHtcblx0XHRcdHJldHVybiB1cHBlckNvbXBvbmVudE5hbWU7XG5cdFx0fVxuXHRcdGlmIChjb21wb25lbnROYW1lID09PSBoZWxwZXIuRE9DVU1FTlRfQ09NUE9ORU5UX05BTUUpIHtcblx0XHRcdHJldHVybiBoZWxwZXIuRE9DVU1FTlRfRUxFTUVOVF9OQU1FLnRvVXBwZXJDYXNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBoZWxwZXIuQ09NUE9ORU5UX1BSRUZJWC50b1VwcGVyQ2FzZSgpICsgdXBwZXJDb21wb25lbnROYW1lO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIG1ldGhvZCBvZiB0aGUgbW9kdWxlIHRoYXQgY2FuIGJlIGludm9rZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgTW9kdWxlIGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IE1ldGhvZCBwcmVmaXggKGkuZS4gaGFuZGxlKS5cblx0ICogQHBhcmFtIHtzdHJpbmc/fSBuYW1lIE5hbWUgb2YgdGhlIGVudGl0eSB0byBpbnZva2UgbWV0aG9kIGZvclxuXHQgKiAod2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWwgY2FzaW5nKS5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBNZXRob2QgdG8gaW52b2tlLlxuXHQgKi9cblx0Z2V0TWV0aG9kVG9JbnZva2U6IGZ1bmN0aW9uIChtb2R1bGUsIHByZWZpeCwgbmFtZSkge1xuXHRcdGlmICghbW9kdWxlIHx8IHR5cGVvZiAobW9kdWxlKSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiBkZWZhdWx0UHJvbWlzZU1ldGhvZDtcblx0XHR9XG5cdFx0dmFyIG1ldGhvZE5hbWUgPSBoZWxwZXIuZ2V0Q2FtZWxDYXNlTmFtZShwcmVmaXgsIG5hbWUpO1xuXHRcdGlmICh0eXBlb2YgKG1vZHVsZVttZXRob2ROYW1lXSkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBtb2R1bGVbbWV0aG9kTmFtZV0uYmluZChtb2R1bGUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIChtb2R1bGVbcHJlZml4XSkgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBtb2R1bGVbcHJlZml4XS5iaW5kKG1vZHVsZSwgbmFtZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlZmF1bHRQcm9taXNlTWV0aG9kO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIG5hbWUgaW4gY2FtZWwgY2FzaW5nIGZvciBldmVyeXRoaW5nLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFByZWZpeCBmb3IgdGhlIG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gY29udmVydC5cblx0ICovXG5cdGdldENhbWVsQ2FzZU5hbWU6IGZ1bmN0aW9uIChwcmVmaXgsIG5hbWUpIHtcblx0XHRpZiAoIW5hbWUpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvW15hLXowLTldL2kpLFxuXHRcdFx0Y2FtZWxDYXNlTmFtZSA9IFN0cmluZyhwcmVmaXggfHwgJycpO1xuXG5cdFx0cGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuXHRcdFx0aWYgKCFwYXJ0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gZmlyc3QgY2hhcmFjdGVyIGluIG1ldGhvZCBuYW1lIG11c3QgYmUgaW4gbG93ZXJjYXNlXG5cdFx0XHRjYW1lbENhc2VOYW1lICs9IGNhbWVsQ2FzZU5hbWUgP1xuXHRcdFx0XHRwYXJ0WzBdLnRvVXBwZXJDYXNlKCkgOlxuXHRcdFx0XHRwYXJ0WzBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRjYW1lbENhc2VOYW1lICs9IHBhcnQuc3Vic3RyaW5nKDEpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNhbWVsQ2FzZU5hbWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldHMgc2FmZSBwcm9taXNlIHJlc29sdmVkIGZyb20gYWN0aW9uLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY3Rpb24gQWN0aW9uIHRvIHdyYXAgd2l0aCBzYWZlIHByb21pc2UuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIGZvciBkb25lIGFjdGlvbi5cblx0ICovXG5cdGdldFNhZmVQcm9taXNlOiBmdW5jdGlvbiAoYWN0aW9uKSB7XG5cdFx0dmFyIHJlc3VsdDtcblx0XHR0cnkge1xuXHRcdFx0cmVzdWx0ID0gYWN0aW9uKCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuXHRcdH1cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGVscGVyO1xuXG4vKipcbiAqIEp1c3QgcmV0dXJucyByZXNvbHZlZCBwcm9taXNlLlxuICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgZm9yIG5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRQcm9taXNlTWV0aG9kKCkge1xuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHQvKipcblx0ICogRGVmaW5lcyByZWFkLW9ubHkgcHJvcGVydHkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGRlZmluZSBwcm9wZXJ0eSBpbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgUHJvcGVydHkgdmFsdWUuXG5cdCAqL1xuXHRkZWZpbmVSZWFkT25seTogZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHR3cml0YWJsZTogZmFsc2UsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9KTtcblx0fVxufTsiLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG5cdFVSSSA9IHJlcXVpcmUoJ2NhdGJlcnJ5LXVyaScpLlVSSTtcblxudmFyIFVSSV9QQVRIX1JFUExBQ0VNRU5UX1JFR19FWFBfU09VUkNFID0gJyhbXlxcXFwvXFxcXFxcXFxdKiknLFxuXHRVUklfUVVFUllfUkVQTEFDRU1FTlRfUkVHX0VYUF9TT1VSQ0UgPSAnKFteJj89XSopJztcblxudmFyIFBBVEhfRU5EX1NMQVNIX1JFR19FWFAgPSAvKC4rKVxcLygkfFxcP3wjKS8sXG5cdEVYUFJFU1NJT05fRVNDQVBFX1JFR19FWFAgPSAvW1xcLVxcW1xcXVxce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csXG5cdElERU5USUZJRVJfUkVHX0VYUF9TT1VSQ0UgPSAnWyRBLVpfXVtcXFxcZEEtWl8kXSonLFxuXHRTVE9SRV9MSVNUX1JFR19FWFBfU09VUkNFID0gJyg/Oig/OlxcXFxcXFxcW1sgXSonICtcblx0XHQnW15cXFxcW1xcXFxdLF0rJyArXG5cdFx0JyhbIF0qLFsgXSonICtcblx0XHQnW15cXFxcW1xcXFxdLF0rJyArXG5cdFx0JykqWyBdKlxcXFxcXFxcXSl8KD86XFxcXFxcXFxbWyBdKlxcXFxcXFxcXSkpPycsXG5cdFBBUkFNRVRFUl9SRUdfRVhQID0gbmV3IFJlZ0V4cChcblx0XHRcdCc6JyArXG5cdFx0XHRJREVOVElGSUVSX1JFR19FWFBfU09VUkNFICtcblx0XHRcdFNUT1JFX0xJU1RfUkVHX0VYUF9TT1VSQ0UsICdnaScpLFxuXHRTTEFTSEVEX0JSQUNLRVRTX1JFR19FWFAgPSAvXFxcXFxcW3xcXFxcXFxdLyxcblx0U1RPUkVfTElTVF9TRVBBUkFUT1IgPSAnLCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHQvKipcblx0ICogUmVtb3ZlcyBzbGFzaCBmcm9tIHRoZSBlbmQgb2YgVVJJIHBhdGguXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmlQYXRoIFVSSSBwYXRoIHRvIHByb2Nlc3MuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFVSSSB3aXRob3V0IGVuZCBzbGFzaC5cblx0ICovXG5cdHJlbW92ZUVuZFNsYXNoOiBmdW5jdGlvbiAodXJpUGF0aCkge1xuXHRcdGlmICghdXJpUGF0aCB8fCB0eXBlb2YgKHVyaVBhdGgpICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHRpZiAodXJpUGF0aCA9PT0gJy8nKSB7XG5cdFx0XHRyZXR1cm4gdXJpUGF0aDtcblx0XHR9XG5cdFx0cmV0dXJuIHVyaVBhdGgucmVwbGFjZShQQVRIX0VORF9TTEFTSF9SRUdfRVhQLCAnJDEkMicpO1xuXHR9LFxuXHQvKipcblx0ICogR2V0cyBVUkkgbWFwcGVyIGZyb20gdGhlIHJvdXRlIGV4cHJlc3Npb24gbGlrZVxuXHQgKiAvc29tZS86aWRbc3RvcmUxLCBzdG9yZTIsIHN0b3JlM10vZGV0YWlscz9maWx0ZXI9OmZpbHRlcltzdG9yZTNdLlxuXHQgKiBAcGFyYW0ge1VSSX0gcm91dGVVcmkgRXhwcmVzc2lvbiB0aGF0IGRlZmluZXMgcm91dGUuXG5cdCAqIEByZXR1cm5zIHt7ZXhwcmVzc2lvbjogUmVnRXhwLCBtYXA6IEZ1bmN0aW9ufT99IFVSSSBtYXBwZXIgb2JqZWN0LlxuXHQgKiBVUkkgbWFwcGVyIG9iamVjdC5cblx0ICovXG5cdGNvbXBpbGVSb3V0ZTogZnVuY3Rpb24gKHJvdXRlVXJpKSB7XG5cdFx0aWYgKCFyb3V0ZVVyaSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gZXNjYXBlIHJlZ3VsYXIgZXhwcmVzc2lvbiBjaGFyYWN0ZXJzXG5cdFx0dmFyIGVzY2FwZWQgPSByb3V0ZVVyaS5wYXRoLnJlcGxhY2UoXG5cdFx0XHRFWFBSRVNTSU9OX0VTQ0FQRV9SRUdfRVhQLCAnXFxcXCQmJ1xuXHRcdCk7XG5cblx0XHQvLyBnZXQgYWxsIG9jY3VycmVuY2VzIG9mIHJvdXRpbmcgcGFyYW1ldGVycyBpbiBVUkkgcGF0aFxuXHRcdHZhciByZWdFeHBTb3VyY2UgPSAnXicgKyBlc2NhcGVkLnJlcGxhY2UoXG5cdFx0XHRcdFx0UEFSQU1FVEVSX1JFR19FWFAsXG5cdFx0XHRcdFx0VVJJX1BBVEhfUkVQTEFDRU1FTlRfUkVHX0VYUF9TT1VSQ0UpICsgJyQnLFxuXHRcdFx0ZXhwcmVzc2lvbiA9IG5ldyBSZWdFeHAocmVnRXhwU291cmNlLCAnaScpLFxuXHRcdFx0cXVlcnlNYXBwZXIsXG5cdFx0XHRwYXRoTWFwcGVyLFxuXHRcdFx0cGF0aFBhcmFtZXRlck1hdGNoZXMgPSBlc2NhcGVkLm1hdGNoKFxuXHRcdFx0XHRQQVJBTUVURVJfUkVHX0VYUFxuXHRcdFx0KSxcblx0XHRcdHBhdGhQYXJhbWV0ZXJzID0gcGF0aFBhcmFtZXRlck1hdGNoZXMgP1xuXHRcdFx0XHRwYXRoUGFyYW1ldGVyTWF0Y2hlcy5tYXAoZ2V0UGFyYW1ldGVyRGVzY3JpcHRvcikgOiBudWxsO1xuXG5cdFx0aWYgKHBhdGhQYXJhbWV0ZXJzKSB7XG5cdFx0XHRwYXRoTWFwcGVyID0gY3JlYXRlVXJpUGF0aE1hcHBlcihleHByZXNzaW9uLCBwYXRoUGFyYW1ldGVycyk7XG5cdFx0fVxuXG5cdFx0aWYgKHJvdXRlVXJpLnF1ZXJ5KSB7XG5cdFx0XHR2YXIgcXVlcnlQYXJhbWV0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdE9iamVjdC5rZXlzKHJvdXRlVXJpLnF1ZXJ5LnZhbHVlcylcblx0XHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdFx0XHQvLyBhcnJheXMgaW4gcm91dGluZyBkZWZpbml0aW9ucyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdFx0XHRcdGlmICh1dGlsLmlzQXJyYXkocm91dGVVcmkucXVlcnkudmFsdWVzW25hbWVdKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGVzY2FwZSByZWd1bGFyIGV4cHJlc3Npb24gY2hhcmFjdGVyc1xuXHRcdFx0XHRcdHZhciBlc2NhcGVkID0gcm91dGVVcmkucXVlcnkudmFsdWVzW25hbWVdLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRFWFBSRVNTSU9OX0VTQ0FQRV9SRUdfRVhQLCAnXFxcXCQmJ1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBnZXQgYWxsIG9jY3VycmVuY2VzIG9mIHJvdXRpbmcgcGFyYW1ldGVycyBpbiBVUkkgcGF0aFxuXHRcdFx0XHRcdHZhciByZWdFeHBTb3VyY2UgPSAnXicgKyBlc2NhcGVkLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdFBBUkFNRVRFUl9SRUdfRVhQLFxuXHRcdFx0XHRcdFx0XHRVUklfUVVFUllfUkVQTEFDRU1FTlRfUkVHX0VYUF9TT1VSQ0UpICsgJyQnO1xuXHRcdFx0XHRcdHZhciBxdWVyeVBhcmFtZXRlck1hdGNoZXMgPSBlc2NhcGVkLm1hdGNoKFxuXHRcdFx0XHRcdFx0XHRQQVJBTUVURVJfUkVHX0VYUFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRpZiAoIXF1ZXJ5UGFyYW1ldGVyTWF0Y2hlcyB8fFxuXHRcdFx0XHRcdFx0cXVlcnlQYXJhbWV0ZXJNYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBwYXJhbWV0ZXIgPSBnZXRQYXJhbWV0ZXJEZXNjcmlwdG9yKFxuXHRcdFx0XHRcdFx0cXVlcnlQYXJhbWV0ZXJNYXRjaGVzW3F1ZXJ5UGFyYW1ldGVyTWF0Y2hlcy5sZW5ndGggLSAxXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0dmFyIGV4cHJlc3Npb24gPSBuZXcgUmVnRXhwKHJlZ0V4cFNvdXJjZSwgJ2knKTtcblx0XHRcdFx0XHRwYXJhbWV0ZXIubWFwID0gY3JlYXRlVXJpUXVlcnlWYWx1ZU1hcHBlcihleHByZXNzaW9uKTtcblx0XHRcdFx0XHRxdWVyeVBhcmFtZXRlcnNbbmFtZV0gPSBwYXJhbWV0ZXI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0cXVlcnlNYXBwZXIgPSBjcmVhdGVVcmlRdWVyeU1hcHBlcihxdWVyeVBhcmFtZXRlcnMpO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRleHByZXNzaW9uOiBleHByZXNzaW9uLFxuXHRcdFx0bWFwOiBmdW5jdGlvbiAodXJpKSB7XG5cdFx0XHRcdHZhciBzdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdGlmIChwYXRoTWFwcGVyKSB7XG5cdFx0XHRcdFx0cGF0aE1hcHBlcih1cmkucGF0aCwgc3RhdGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHF1ZXJ5TWFwcGVyICYmIHVyaS5xdWVyeSkge1xuXHRcdFx0XHRcdHF1ZXJ5TWFwcGVyKHVyaS5xdWVyeS52YWx1ZXMsIHN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IFVSSSBwYXRoLXRvLXN0YXRlIG9iamVjdCBtYXBwZXIuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gZXhwcmVzc2lvbiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggVVJJIHBhdGguXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbWV0ZXJzIExpc3Qgb2YgcGFyYW1ldGVyIGRlc2NyaXB0b3JzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBVUkkgbWFwcGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVVcmlQYXRoTWFwcGVyKGV4cHJlc3Npb24sIHBhcmFtZXRlcnMpIHtcblx0cmV0dXJuIGZ1bmN0aW9uICh1cmlQYXRoLCBzdGF0ZSkge1xuXHRcdHZhciBtYXRjaGVzID0gdXJpUGF0aC5tYXRjaChleHByZXNzaW9uKTtcblx0XHRpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5sZW5ndGggPCAyKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0fVxuXG5cdFx0Ly8gc3RhcnQgd2l0aCBzZWNvbmQgbWF0Y2ggYmVjYXVzZSBmaXJzdCBtYXRjaCBpcyBhbHdheXNcblx0XHQvLyB0aGUgd2hvbGUgVVJJIHBhdGhcblx0XHRtYXRjaGVzID0gbWF0Y2hlcy5zcGxpY2UoMSk7XG5cblx0XHRwYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtZXRlciwgaW5kZXgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IG1hdGNoZXNbaW5kZXhdO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBub3RoaW5nIHRvIGRvXG5cdFx0XHR9XG5cdFx0XHRwYXJhbWV0ZXIuc3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0XHRcdFx0aWYgKCFzdGF0ZVtzdG9yZU5hbWVdKSB7XG5cdFx0XHRcdFx0c3RhdGVbc3RvcmVOYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RhdGVbc3RvcmVOYW1lXVtwYXJhbWV0ZXIubmFtZV0gPSB2YWx1ZTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgbmV3IFVSSSBxdWVyeS10by1zdGF0ZSBvYmplY3QgbWFwcGVyLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgTGlzdCBvZiBwb3NzaWJsZSBxdWVyeSBwYXJhbWV0ZXIgZGVzY3JpcHRvcnMgYnlcbiAqIHF1ZXJ5IHBhcmFtZXRlciBuYW1lcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVVJJIG1hcHBlciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXJpUXVlcnlNYXBwZXIocGFyYW1ldGVycykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHF1ZXJ5VmFsdWVzLCBzdGF0ZSkge1xuXHRcdHF1ZXJ5VmFsdWVzID0gcXVlcnlWYWx1ZXMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRcdE9iamVjdC5rZXlzKHF1ZXJ5VmFsdWVzKVxuXHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5S2V5KSB7XG5cdFx0XHRcdHZhciBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzW3F1ZXJ5S2V5XTtcblx0XHRcdFx0aWYgKCFwYXJhbWV0ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmFsdWUgPSB1dGlsLmlzQXJyYXkocXVlcnlWYWx1ZXNbcXVlcnlLZXldKSA/XG5cdFx0XHRcdFx0XHRxdWVyeVZhbHVlc1txdWVyeUtleV1cblx0XHRcdFx0XHRcdFx0Lm1hcChwYXJhbWV0ZXIubWFwKVxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSAhPT0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdFx0cGFyYW1ldGVyLm1hcChxdWVyeVZhbHVlc1txdWVyeUtleV0pO1xuXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJhbWV0ZXIuc3RvcmVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0XHRcdFx0XHRpZiAoIXN0YXRlW3N0b3JlTmFtZV0pIHtcblx0XHRcdFx0XHRcdHN0YXRlW3N0b3JlTmFtZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGF0ZVtzdG9yZU5hbWVdW3BhcmFtZXRlci5uYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHR9O1xufVxuXG4vKipcbiAqIE1hcHMgcXVlcnkgcGFyYW1ldGVyIHZhbHVlIHVzaW5nIHRoZSBwYXJhbWV0ZXJzIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge1JlZ0V4cH0gZXhwcmVzc2lvbiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gZ2V0IHBhcmFtZXRlciB2YWx1ZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVVJJIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXIgdmFsdWUgbWFwcGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVVcmlRdWVyeVZhbHVlTWFwcGVyKGV4cHJlc3Npb24pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHZhbHVlID0gdmFsdWVcblx0XHRcdC50b1N0cmluZygpXG5cdFx0XHQvLyB3ZSBoYXZlIHRvIHRlbXBvcmFyeSBlbmNvZGUgdGhlc2UgY2hhcmFjdGVycyBmb3Igbm90IGJyZWFraW5nXG5cdFx0XHQvLyBleHByZXNzaW9uIHBhcnNpbmcsIGJlY2F1c2UgaXQncyB0ZXJtaW5hdGVkIGJ5IHF1ZXJ5IHNlcGFyYXRvclxuXHRcdFx0LnJlcGxhY2UoLz0vZywgJyUzRCcpXG5cdFx0XHQucmVwbGFjZSgvXFw/L2csICclM0YnKVxuXHRcdFx0LnJlcGxhY2UoLyYvZywgJyUyNicpO1xuXHRcdHZhciBtYXRjaGVzID0gdmFsdWUubWF0Y2goZXhwcmVzc2lvbik7XG5cdFx0aWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyB0aGUgdmFsdWUgaXMgdGhlIHNlY29uZCBpdGVtLCB0aGUgZmlyc3QgaXMgYSB3aG9sZSBzdHJpbmdcblx0XHR2YXIgbWFwcGVkVmFsdWUgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG5cdFx0dHJ5IHtcblx0XHRcdG1hcHBlZFZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hcHBlZFZhbHVlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBub3RoaW5nIHRvIGRvXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hcHBlZFZhbHVlO1xuXHR9O1xufVxuXG4vKipcbiAqIEdldHMgZGVzY3JpcHRpb24gb2YgcGFyYW1ldGVycyBmcm9tIGl0cyBleHByZXNzaW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlciBQYXJhbWV0ZXIgZXhwcmVzc2lvbi5cbiAqIEByZXR1cm5zIHt7bmFtZTogc3RyaW5nLCBzdG9yZU5hbWVzOiBBcnJheX19IFBhcmFtZXRlciBkZXNjcmlwdG9yLlxuICovXG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJEZXNjcmlwdG9yKHBhcmFtZXRlcikge1xuXHR2YXIgcGFydHMgPSBwYXJhbWV0ZXIuc3BsaXQoU0xBU0hFRF9CUkFDS0VUU19SRUdfRVhQKTtcblxuXHRyZXR1cm4ge1xuXHRcdG5hbWU6IHBhcnRzWzBdXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQuc3Vic3RyaW5nKDEpLFxuXHRcdHN0b3JlTmFtZXM6IChwYXJ0c1sxXSA/IHBhcnRzWzFdIDogJycpXG5cdFx0XHQuc3BsaXQoU1RPUkVfTElTVF9TRVBBUkFUT1IpXG5cdFx0XHQubWFwKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIHN0b3JlTmFtZS50cmltKCk7XG5cdFx0XHR9KVxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbiAoc3RvcmVOYW1lKSB7XG5cdFx0XHRcdHJldHVybiBzdG9yZU5hbWUubGVuZ3RoID4gMDtcblx0XHRcdH0pXG5cdH07XG59IiwiLypcbiAqIGNhdGJlcnJ5XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IERlbmlzIFJlY2hrdW5vdiBhbmQgcHJvamVjdCBjb250cmlidXRvcnMuXG4gKlxuICogY2F0YmVycnkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5IHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVQcm92aWRlcjtcblxudmFyIHJvdXRlSGVscGVyID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3JvdXRlSGVscGVyJyksXG5cdGNhdGJlcnJ5VXJpID0gcmVxdWlyZSgnY2F0YmVycnktdXJpJyksXG5cdFVSSSA9IGNhdGJlcnJ5VXJpLlVSSTtcblxuLyoqXG4gKiBDcmVhdGUgbmV3IGluc3RhbmNlIG9mIHRoZSBzdGF0ZSBwcm92aWRlci5cbiAqIEBwYXJhbSB7U2VydmljZUxvY2F0b3J9ICRzZXJ2aWNlTG9jYXRvciBTZXJ2aWNlIGxvY2F0b3JcbiAqIHRvIHJlc29sdmUgVVJJIG1hcHBlcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhdGVQcm92aWRlcigkc2VydmljZUxvY2F0b3IpIHtcblx0dGhpcy5fdXJpTWFwcGVycyA9IGdldFVyaU1hcHBlcnMoJHNlcnZpY2VMb2NhdG9yKTtcbn1cblxuLyoqXG4gKiBDdXJyZW50IGxpc3Qgb2YgVVJJIG1hcHBlcnMuXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5TdGF0ZVByb3ZpZGVyLnByb3RvdHlwZS5fdXJpTWFwcGVycyA9IG51bGw7XG5cbi8qKlxuICogR2V0cyBzdGF0ZSBieSBzcGVjaWZpZWQgbG9jYXRpb24gVVJJLlxuICogQHBhcmFtIHtVUkl9IGxvY2F0aW9uIFVSSSBsb2NhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3Q/fSBTdGF0ZSBvYmplY3QuXG4gKi9cblN0YXRlUHJvdmlkZXIucHJvdG90eXBlLmdldFN0YXRlQnlVcmkgPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcblx0aWYgKHRoaXMuX3VyaU1hcHBlcnMubGVuZ3RoID09PSAwKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRsb2NhdGlvbiA9IGxvY2F0aW9uLmNsb25lKCk7XG5cblx0bG9jYXRpb24ucGF0aCA9IHJvdXRlSGVscGVyLnJlbW92ZUVuZFNsYXNoKGxvY2F0aW9uLnBhdGgpO1xuXHR2YXIgc3RhdGUgPSBnZXRTdGF0ZSh0aGlzLl91cmlNYXBwZXJzLCBsb2NhdGlvbik7XG5cblx0aWYgKCFzdGF0ZSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gbWFrZSBzdGF0ZSBvYmplY3QgaW1tdXRhYmxlXG5cdE9iamVjdC5rZXlzKHN0YXRlKVxuXHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZU5hbWUpIHtcblx0XHRcdE9iamVjdC5mcmVlemUoc3RhdGVbc3RvcmVOYW1lXSk7XG5cdFx0fSk7XG5cdE9iamVjdC5mcmVlemUoc3RhdGUpO1xuXG5cdHJldHVybiBzdGF0ZTtcbn07XG5cbi8qKlxuICogR2V0cyBsaXN0IG9mIFVSSSBtYXBwZXJzLlxuICogQHBhcmFtIHtTZXJ2aWNlTG9jYXRvcn0gc2VydmljZUxvY2F0b3IgU2VydmljZSBsb2NhdG9yIHRvIGdldCByb3V0ZVxuICogZGVmaW5pdGlvbnMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IExpc3Qgb2YgVVJJIG1hcHBlcnMuXG4gKi9cbmZ1bmN0aW9uIGdldFVyaU1hcHBlcnMoc2VydmljZUxvY2F0b3IpIHtcblx0dmFyIHVyaU1hcHBlcnMgPSBbXTtcblxuXHRzZXJ2aWNlTG9jYXRvci5yZXNvbHZlQWxsKCdyb3V0ZURlZmluaXRpb24nKVxuXHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuXHRcdFx0Ly8ganVzdCBjb2xvbi1wYXJhbWV0cml6ZWQgc3RyaW5nXG5cdFx0XHRpZiAodHlwZW9mIChyb3V0ZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHZhciByb3V0ZVVyaSA9IG5ldyBVUkkocm91dGUpO1xuXHRcdFx0XHRyb3V0ZVVyaS5wYXRoID0gcm91dGVIZWxwZXIucmVtb3ZlRW5kU2xhc2gocm91dGVVcmkucGF0aCk7XG5cdFx0XHRcdHVyaU1hcHBlcnMucHVzaChyb3V0ZUhlbHBlci5jb21waWxlUm91dGUocm91dGVVcmkpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBleHRlbmRlZCBjb2xvbi1wYXJhbWV0cml6ZWQgbWFwcGVyXG5cdFx0XHRpZiAodHlwZW9mIChyb3V0ZSkgPT09ICdvYmplY3QnICYmXG5cdFx0XHRcdCh0eXBlb2YgKHJvdXRlLmV4cHJlc3Npb24pID09PSAnc3RyaW5nJykgJiZcblx0XHRcdFx0KHJvdXRlLm1hcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuXHRcdFx0XHR2YXIgbWFwcGVyVXJpID0gbmV3IFVSSShyb3V0ZS5leHByZXNzaW9uKTtcblx0XHRcdFx0bWFwcGVyVXJpLnBhdGggPSByb3V0ZUhlbHBlci5yZW1vdmVFbmRTbGFzaChtYXBwZXJVcmkucGF0aCk7XG5cdFx0XHRcdHZhciBtYXBwZXIgPSByb3V0ZUhlbHBlci5jb21waWxlUm91dGUobWFwcGVyVXJpKTtcblx0XHRcdFx0dXJpTWFwcGVycy5wdXNoKHtcblx0XHRcdFx0XHRleHByZXNzaW9uOiBtYXBwZXIuZXhwcmVzc2lvbixcblx0XHRcdFx0XHRtYXA6IGZ1bmN0aW9uICh1cmkpIHtcblx0XHRcdFx0XHRcdHZhciBzdGF0ZSA9IG1hcHBlci5tYXAodXJpKTtcblx0XHRcdFx0XHRcdHJldHVybiByb3V0ZS5tYXAoc3RhdGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVndWxhciBleHByZXNzaW9uIG1hcHBlclxuXHRcdFx0aWYgKHR5cGVvZiAocm91dGUpID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0XHQocm91dGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiZcblx0XHRcdFx0KHJvdXRlLm1hcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuXHRcdFx0XHR1cmlNYXBwZXJzLnB1c2gocm91dGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRyZXR1cm4gdXJpTWFwcGVycztcbn1cblxuLyoqXG4gKiBHZXRzIHN0YXRlLlxuICogQHBhcmFtIHtBcnJheX0gdXJpTWFwcGVycyBMaXN0IG9mIFVSSSBtYXBwZXJzLlxuICogQHBhcmFtIHtVUkl9IGxvY2F0aW9uIFVSSSB0aGF0IGRlc2NyaWJlcyB0aGUgc3RhdGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9IFRoZSBzdGF0ZSBmcm9tIFVSSS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGUodXJpTWFwcGVycywgbG9jYXRpb24pIHtcblx0dmFyIHN0YXRlID0gbnVsbDtcblxuXHR1cmlNYXBwZXJzLnNvbWUoZnVuY3Rpb24gKG1hcHBlcikge1xuXHRcdGlmIChtYXBwZXIuZXhwcmVzc2lvbi50ZXN0KGxvY2F0aW9uLnBhdGgpKSB7XG5cdFx0XHRzdGF0ZSA9IG1hcHBlci5tYXAobG9jYXRpb24pIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KTtcblxuXHRyZXR1cm4gc3RhdGU7XG59IiwibW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLmhydGltZSB8fCBocnRpbWVcblxuLy8gcG9seWZpbCBmb3Igd2luZG93LnBlcmZvcm1hbmNlLm5vd1xudmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IHt9XG52YXIgcGVyZm9ybWFuY2VOb3cgPVxuICBwZXJmb3JtYW5jZS5ub3cgICAgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm1vek5vdyAgICAgfHxcbiAgcGVyZm9ybWFuY2UubXNOb3cgICAgICB8fFxuICBwZXJmb3JtYW5jZS5vTm93ICAgICAgIHx8XG4gIHBlcmZvcm1hbmNlLndlYmtpdE5vdyAgfHxcbiAgZnVuY3Rpb24oKXsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgfVxuXG4vLyBnZW5lcmF0ZSB0aW1lc3RhbXAgb3IgZGVsdGFcbi8vIHNlZSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NfcHJvY2Vzc19ocnRpbWVcbmZ1bmN0aW9uIGhydGltZShwcmV2aW91c1RpbWVzdGFtcCl7XG4gIHZhciBjbG9ja3RpbWUgPSBwZXJmb3JtYW5jZU5vdy5jYWxsKHBlcmZvcm1hbmNlKSoxZS0zXG4gIHZhciBzZWNvbmRzID0gTWF0aC5mbG9vcihjbG9ja3RpbWUpXG4gIHZhciBuYW5vc2Vjb25kcyA9IE1hdGguZmxvb3IoKGNsb2NrdGltZSUxKSoxZTkpXG4gIGlmIChwcmV2aW91c1RpbWVzdGFtcCkge1xuICAgIHNlY29uZHMgPSBzZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMF1cbiAgICBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMV1cbiAgICBpZiAobmFub3NlY29uZHM8MCkge1xuICAgICAgc2Vjb25kcy0tXG4gICAgICBuYW5vc2Vjb25kcyArPSAxZTlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzZWNvbmRzLG5hbm9zZWNvbmRzXVxufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLypcbiAqIGNhdGJlcnJ5LWxvY2F0b3JcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeS1sb2NhdG9yJ3MgbGljZW5zZSBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgbGljZW5zZSBhcHBsaWVzIHRvIGFsbCBwYXJ0cyBvZiBjYXRiZXJyeS1sb2NhdG9yIHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uc3RydWN0b3JUb2tlbml6ZXI7XG5cbnZhciBTVEFURVMgPSB7XG5cdElMTEVHQUw6IC0xLFxuXHROTzogMCxcblx0SURFTlRJRklFUjogMSxcblx0RlVOQ1RJT046IDIsXG5cdFBBUkVOVEhFU0VTX09QRU46IDMsXG5cdFBBUkVOVEhFU0VTX0NMT1NFOiA0LFxuXHRDT01NQTogNSxcblx0RU5EOiA2XG59O1xuQ29uc3RydWN0b3JUb2tlbml6ZXIuU1RBVEVTID0gU1RBVEVTO1xuXG52YXIgS0VZV09SRFMgPSB7XG5cdEZVTkNUSU9OOiAnZnVuY3Rpb24nXG59O1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15cXHMkLyxcblx0SURFTlRJRklFUl9URVNUID0gL15bXFwkXFx3XSQvO1xuXG5mdW5jdGlvbiBDb25zdHJ1Y3RvclRva2VuaXplcihjb25zdHJ1Y3RvclNvdXJjZSkge1xuXHR0aGlzLl9zb3VyY2UgPSBTdHJpbmcoY29uc3RydWN0b3JTb3VyY2UgfHwgJycpO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgc291cmNlIGNvZGUgb2YgY29uc3RydWN0b3IuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuQ29uc3RydWN0b3JUb2tlbml6ZXIucHJvdG90eXBlLl9zb3VyY2UgPSAnJztcblxuLyoqXG4gKiBDdXJyZW50IGluZGV4IGluIHNvdXJjZSBjb2RlLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbkNvbnN0cnVjdG9yVG9rZW5pemVyLnByb3RvdHlwZS5fY3VycmVudEluZGV4ID0gMDtcblxuLyoqXG4gKiBDdXJyZW50IGluZGV4IGluIHNvdXJjZSBjb2RlLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbkNvbnN0cnVjdG9yVG9rZW5pemVyLnByb3RvdHlwZS5fY3VycmVudEVuZCA9IDA7XG5cbi8qKlxuICogQ3VycmVudCBzdGF0ZS5cbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5Db25zdHJ1Y3RvclRva2VuaXplci5wcm90b3R5cGUuX2N1cnJlbnRTdGF0ZSA9IFNUQVRFUy5OTztcblxuLyoqXG4gKiBHZXRzIG5leHQgdG9rZW4gaW4gc291cmNlLlxuICogQHJldHVybnMge3tzdGF0ZTogKG51bWJlciksIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyfX0gVG9rZW4gZGVzY3JpcHRvci5cbiAqL1xuQ29uc3RydWN0b3JUb2tlbml6ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzLl9jdXJyZW50U3RhdGUgPT09IFNUQVRFUy5JTExFR0FMIHx8XG5cdFx0dGhpcy5fY3VycmVudFN0YXRlID09PSBTVEFURVMuRU5EKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXRlOiB0aGlzLl9jdXJyZW50U3RhdGUsXG5cdFx0XHRzdGFydDogdGhpcy5fY3VycmVudEluZGV4LFxuXHRcdFx0ZW5kOiB0aGlzLl9jdXJyZW50SW5kZXggKyAxXG5cdFx0fTtcblx0fVxuXG5cdHZhciBzdGFydCA9IHRoaXMuX2N1cnJlbnRJbmRleCxcblx0XHRzdGF0ZSA9IHRoaXMuX2N1cnJlbnRTdGF0ZTtcblxuXHRzd2l0Y2ggKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xuXHRcdGNhc2UgU1RBVEVTLlBBUkVOVEhFU0VTX09QRU46XG5cdFx0XHR0aGlzLnBhcmVudGhlc2VzT3BlblN0YXRlKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFNUQVRFUy5QQVJFTlRIRVNFU19DTE9TRTpcblx0XHRcdHRoaXMucGFyZW50aGVzZXNDbG9zZVN0YXRlKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFNUQVRFUy5JREVOVElGSUVSOlxuXHRcdFx0dGhpcy5pZGVudGlmaWVyU3RhdGUoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgU1RBVEVTLkNPTU1BOlxuXHRcdFx0dGhpcy5jb21tYVN0YXRlKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIFNUQVRFUy5GVU5DVElPTjpcblx0XHRcdHRoaXMuZnVuY3Rpb25TdGF0ZSgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRoaXMuc2tpcFdoaXRlc3BhY2UoKTtcblx0XHRcdHZhciBleHBlY3RlZCA9IHRoaXMuX3NvdXJjZS5zdWJzdHIoXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnRJbmRleCwgS0VZV09SRFMuRlVOQ1RJT04ubGVuZ3RoXG5cdFx0XHQpO1xuXHRcdFx0aWYgKGV4cGVjdGVkID09PSBLRVlXT1JEUy5GVU5DVElPTikge1xuXHRcdFx0XHR0aGlzLl9jdXJyZW50U3RhdGUgPSBTVEFURVMuRlVOQ1RJT047XG5cdFx0XHRcdHJldHVybiB0aGlzLm5leHQoKTtcblx0XHRcdH1cblxuXHRcdFx0c3RhdGUgPSBTVEFURVMuSUxMRUdBTDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3RhdGU6IHN0YXRlLFxuXHRcdHN0YXJ0OiBzdGFydCxcblx0XHRlbmQ6IHRoaXMuX2N1cnJlbnRFbmRcblx0fTtcbn07XG5cbi8qKlxuICogU2tpcHMgYWxsIHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAqL1xuQ29uc3RydWN0b3JUb2tlbml6ZXIucHJvdG90eXBlLnNraXBXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKCkge1xuXHR3aGlsZSAoXG5cdFx0dGhpcy5fY3VycmVudEluZGV4IDwgdGhpcy5fc291cmNlLmxlbmd0aCAmJlxuXHRcdFdISVRFU1BBQ0VfVEVTVC50ZXN0KHRoaXMuX3NvdXJjZVt0aGlzLl9jdXJyZW50SW5kZXhdKSkge1xuXHRcdHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuXHR9XG59O1xuXG4vKipcbiAqIERlc2NyaWJlcyBQQVJFTlRIRVNFU19PUEVOIHN0YXRlIG9mIG1hY2hpbmUuXG4gKi9cbkNvbnN0cnVjdG9yVG9rZW5pemVyLnByb3RvdHlwZS5wYXJlbnRoZXNlc09wZW5TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5fY3VycmVudEluZGV4Kys7XG5cdHRoaXMuX2N1cnJlbnRFbmQgPSB0aGlzLl9jdXJyZW50SW5kZXg7XG5cblx0dGhpcy5za2lwV2hpdGVzcGFjZSgpO1xuXHRpZiAoSURFTlRJRklFUl9URVNULnRlc3QodGhpcy5fc291cmNlW3RoaXMuX2N1cnJlbnRJbmRleF0pKSB7XG5cdFx0dGhpcy5fY3VycmVudFN0YXRlID0gU1RBVEVTLklERU5USUZJRVI7XG5cdH0gZWxzZSBpZiAodGhpcy5fc291cmNlW3RoaXMuX2N1cnJlbnRJbmRleF0gPT09ICcpJykge1xuXHRcdHRoaXMuX2N1cnJlbnRTdGF0ZSA9IFNUQVRFUy5QQVJFTlRIRVNFU19DTE9TRTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9jdXJyZW50U3RhdGUgPSBTVEFURVMuSUxMRUdBTDtcblx0fVxufTtcblxuLyoqXG4gKiBEZXNjcmliZXMgUEFSRU5USEVTRVNfQ0xPU0Ugc3RhdGUgb2YgbWFjaGluZS5cbiAqL1xuQ29uc3RydWN0b3JUb2tlbml6ZXIucHJvdG90eXBlLnBhcmVudGhlc2VzQ2xvc2VTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5fY3VycmVudEluZGV4Kys7XG5cdHRoaXMuX2N1cnJlbnRFbmQgPSB0aGlzLl9jdXJyZW50SW5kZXg7XG5cdHRoaXMuX2N1cnJlbnRTdGF0ZSA9IFNUQVRFUy5FTkQ7XG59O1xuXG4vKipcbiAqIERlc2NyaWJlcyBGVU5DVElPTiBzdGF0ZSBvZiBtYWNoaW5lLlxuICovXG5Db25zdHJ1Y3RvclRva2VuaXplci5wcm90b3R5cGUuZnVuY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5fY3VycmVudEluZGV4ICs9IEtFWVdPUkRTLkZVTkNUSU9OLmxlbmd0aDtcblx0dGhpcy5fY3VycmVudEVuZCA9IHRoaXMuX2N1cnJlbnRJbmRleDtcblxuXHR0aGlzLnNraXBXaGl0ZXNwYWNlKCk7XG5cblx0aWYgKHRoaXMuX3NvdXJjZVt0aGlzLl9jdXJyZW50SW5kZXhdID09PSAnKCcpIHtcblx0XHR0aGlzLl9jdXJyZW50U3RhdGUgPSBTVEFURVMuUEFSRU5USEVTRVNfT1BFTjtcblx0fSBlbHNlIGlmIChJREVOVElGSUVSX1RFU1QudGVzdCh0aGlzLl9zb3VyY2VbdGhpcy5fY3VycmVudEluZGV4XSkpIHtcblx0XHR0aGlzLl9jdXJyZW50U3RhdGUgPSBTVEFURVMuSURFTlRJRklFUjtcblx0fSBlbHNlIHtcblx0XHR0aGlzLl9jdXJyZW50U3RhdGUgPSBTVEFURVMuSUxMRUdBTDtcblx0fVxufTtcblxuLyoqXG4gKiBEZXNjcmliZXMgSURFTlRJRklFUiBzdGF0ZSBvZiBtYWNoaW5lLlxuICovXG5Db25zdHJ1Y3RvclRva2VuaXplci5wcm90b3R5cGUuaWRlbnRpZmllclN0YXRlID0gZnVuY3Rpb24gKCkge1xuXHR3aGlsZSAoXG5cdFx0dGhpcy5fY3VycmVudEluZGV4IDwgdGhpcy5fc291cmNlLmxlbmd0aCAmJlxuXHRcdElERU5USUZJRVJfVEVTVC50ZXN0KHRoaXMuX3NvdXJjZVt0aGlzLl9jdXJyZW50SW5kZXhdKSkge1xuXHRcdHRoaXMuX2N1cnJlbnRJbmRleCsrO1xuXHR9XG5cblx0dGhpcy5fY3VycmVudEVuZCA9IHRoaXMuX2N1cnJlbnRJbmRleDtcblxuXHR0aGlzLnNraXBXaGl0ZXNwYWNlKCk7XG5cdGlmICh0aGlzLl9zb3VyY2VbdGhpcy5fY3VycmVudEluZGV4XSA9PT0gJygnKSB7XG5cdFx0dGhpcy5fY3VycmVudFN0YXRlID0gU1RBVEVTLlBBUkVOVEhFU0VTX09QRU47XG5cdH0gZWxzZSBpZiAodGhpcy5fc291cmNlW3RoaXMuX2N1cnJlbnRJbmRleF0gPT09ICcpJykge1xuXHRcdHRoaXMuX2N1cnJlbnRTdGF0ZSA9IFNUQVRFUy5QQVJFTlRIRVNFU19DTE9TRTtcblx0fSBlbHNlIGlmICh0aGlzLl9zb3VyY2VbdGhpcy5fY3VycmVudEluZGV4XSA9PT0gJywnKSB7XG5cdFx0dGhpcy5fY3VycmVudFN0YXRlID0gU1RBVEVTLkNPTU1BO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuX2N1cnJlbnRTdGF0ZSA9IFNUQVRFUy5JTExFR0FMO1xuXHR9XG59O1xuXG4vKipcbiAqIERlc2NyaWJlcyBDT01NQSBzdGF0ZSBvZiBtYWNoaW5lLlxuICovXG5Db25zdHJ1Y3RvclRva2VuaXplci5wcm90b3R5cGUuY29tbWFTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblx0dGhpcy5fY3VycmVudEluZGV4Kys7XG5cdHRoaXMuX2N1cnJlbnRFbmQgPSB0aGlzLl9jdXJyZW50SW5kZXg7XG5cblx0dGhpcy5za2lwV2hpdGVzcGFjZSgpO1xuXHRpZiAoSURFTlRJRklFUl9URVNULnRlc3QodGhpcy5fc291cmNlW3RoaXMuX2N1cnJlbnRJbmRleF0pKSB7XG5cdFx0dGhpcy5fY3VycmVudFN0YXRlID0gU1RBVEVTLklERU5USUZJRVI7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHRoaXMuX2N1cnJlbnRTdGF0ZSA9IFNUQVRFUy5JTExFR0FMO1xufTsiLCIvKlxuICogY2F0YmVycnktbG9jYXRvclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBEZW5pcyBSZWNoa3Vub3YgYW5kIHByb2plY3QgY29udHJpYnV0b3JzLlxuICpcbiAqIGNhdGJlcnJ5LWxvY2F0b3IncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5LWxvY2F0b3IgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlTG9jYXRvcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG5cdENvbnN0cnVjdG9yVG9rZW5pemVyID0gcmVxdWlyZSgnLi9Db25zdHJ1Y3RvclRva2VuaXplcicpO1xuXG52YXIgREVQRU5ERU5DWV9SRUdFWFAgPSAvXlxcJFxcdysvLFxuXHRFUlJPUl9DT05TVFJVQ1RPUl9TSE9VTERfQkVfRlVOQ1RJT04gPSAnQ29uc3RydWN0b3Igc2hvdWxkIGJlIGEgZnVuY3Rpb24nLFxuXHRFUlJPUl9UWVBFX05PVF9SRUdJU1RFUkVEID0gJ1R5cGUgXCIlc1wiIG5vdCByZWdpc3RlcmVkJyxcblx0RVJST1JfVFlQRV9TSE9VTERfQkVfU1RSSU5HID0gJ1R5cGUgbmFtZSBcIiVzXCIgc2hvdWxkIGJlIGEgc3RyaW5nJztcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBzZXJ2aWNlIGxvY2F0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU2VydmljZUxvY2F0b3IoKSB7XG5cdHRoaXMuX3JlZ2lzdHJhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIEN1cnJlbnQgdHlwZSByZWdpc3RyYXRpb25zLlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuU2VydmljZUxvY2F0b3IucHJvdG90eXBlLl9yZWdpc3RyYXRpb25zID0gbnVsbDtcblxuLyoqXG4gKiBSZWdpc3RlcnMgbmV3IHR5cGUgaW4gc2VydmljZSBsb2NhdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBuYW1lLCB3aGljaCB3aWxsIGJlIGFsaWFzIGluIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHdoaWNoXG4gKiBpbml0aWFsaXplcyBpbnN0YW5jZSBvZiBzcGVjaWZpZWQgdHlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0P30gcGFyYW1ldGVycyBTZXQgb2YgbmFtZWQgcGFyYW1ldGVyc1xuICogd2hpY2ggd2lsbCBiZSBhbHNvIGluamVjdGVkLlxuICogQHBhcmFtIHtib29sZWFuP30gaXNTaW5nbGV0b24gSWYgdHJ1ZSBldmVyeSByZXNvbHZlIHdpbGwgcmV0dXJuXG4gKiB0aGUgc2FtZSBpbnN0YW5jZS5cbiAqL1xuU2VydmljZUxvY2F0b3IucHJvdG90eXBlLnJlZ2lzdGVyID1cblx0ZnVuY3Rpb24gKHR5cGUsIGNvbnN0cnVjdG9yLCBwYXJhbWV0ZXJzLCBpc1NpbmdsZXRvbikge1xuXHRcdHRocm93SWZOb3RGdW5jdGlvbihjb25zdHJ1Y3Rvcik7XG5cdFx0dGhyb3dJZk5vdFN0cmluZyh0eXBlKTtcblxuXHRcdGluaXRpYWxpemVSZWdpc3RyYXRpb24odHlwZSwgdGhpcyk7XG5cdFx0dmFyIHBhcmFtZXRlck5hbWVzID0gZ2V0UGFyYW1ldGVyTmFtZXMoY29uc3RydWN0b3IpO1xuXG5cdFx0dGhpcy5fcmVnaXN0cmF0aW9uc1t0eXBlXS51bnNoaWZ0KHtcblx0XHRcdGNvbnN0cnVjdG9yOiBjb25zdHJ1Y3Rvcixcblx0XHRcdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMgfHwge30sXG5cdFx0XHRwYXJhbWV0ZXJOYW1lczogcGFyYW1ldGVyTmFtZXMsXG5cdFx0XHRpc1NpbmdsZXRvbjogQm9vbGVhbihpc1NpbmdsZXRvbiksXG5cdFx0XHRzaW5nbGVJbnN0YW5jZTogbnVsbFxuXHRcdH0pO1xuXHR9O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBzaW5nbGUgaW5zdGFuY2UgZm9yIHNwZWNpZmllZCB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBuYW1lLlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlIEluc3RhbmNlIHRvIHJlZ2lzdGVyLlxuICovXG5TZXJ2aWNlTG9jYXRvci5wcm90b3R5cGUucmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICh0eXBlLCBpbnN0YW5jZSkge1xuXHR0aHJvd0lmTm90U3RyaW5nKHR5cGUpO1xuXHRpbml0aWFsaXplUmVnaXN0cmF0aW9uKHR5cGUsIHRoaXMpO1xuXG5cdHRoaXMuX3JlZ2lzdHJhdGlvbnNbdHlwZV0udW5zaGlmdCh7XG5cdFx0Y29uc3RydWN0b3I6IGluc3RhbmNlLmNvbnN0cnVjdG9yLFxuXHRcdHBhcmFtZXRlcnM6IHt9LFxuXHRcdHBhcmFtZXRlck5hbWVzOiBbXSxcblx0XHRpc1NpbmdsZXRvbjogdHJ1ZSxcblx0XHRzaW5nbGVJbnN0YW5jZTogaW5zdGFuY2Vcblx0fSk7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIGxhc3QgcmVnaXN0ZXJlZCBpbXBsZW1lbnRhdGlvbiBieSB0eXBlIG5hbWVcbiAqIGluY2x1ZGluZyBhbGwgaXRzIGRlcGVuZGVuY2llcyByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUgbmFtZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEluc3RhbmNlIG9mIHNwZWNpZmllZCB0eXBlLlxuICovXG5TZXJ2aWNlTG9jYXRvci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdHRocm93SWZOb3RTdHJpbmcodHlwZSk7XG5cdHRocm93SWZOb1R5cGUodGhpcy5fcmVnaXN0cmF0aW9ucywgdHlwZSk7XG5cdHZhciBmaXJzdFJlZ2lzdHJhdGlvbiA9IHRoaXMuX3JlZ2lzdHJhdGlvbnNbdHlwZV1bMF07XG5cdHJldHVybiBjcmVhdGVJbnN0YW5jZShmaXJzdFJlZ2lzdHJhdGlvbiwgdGhpcyk7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIGFsbCByZWdpc3RlcmVkIGltcGxlbWVudGF0aW9ucyBieSB0eXBlIG5hbWVcbiAqIGluY2x1ZGluZyBhbGwgZGVwZW5kZW5jaWVzIHJlY3Vyc2l2ZWx5LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBpbnN0YW5jZXMgc3BlY2lmaWVkIHR5cGUuXG4gKi9cblNlcnZpY2VMb2NhdG9yLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gKHR5cGUpIHtcblx0dGhyb3dJZk5vdFN0cmluZyh0eXBlKTtcblx0dHJ5IHtcblx0XHR0aHJvd0lmTm9UeXBlKHRoaXMuX3JlZ2lzdHJhdGlvbnMsIHR5cGUpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdHJldHVybiB0aGlzLl9yZWdpc3RyYXRpb25zW3R5cGVdLm1hcChmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZUluc3RhbmNlKHJlZ2lzdHJhdGlvbiwgdGhpcyk7XG5cdH0sIHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyBpbnN0YW5jZSBvZiBzcGVjaWZpZWQgY29uc3RydWN0b3IgaW5jbHVkaW5nIGRlcGVuZGVuY2llcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIGZvciBpbnN0YW5jZSBjcmVhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0P30gcGFyYW1ldGVycyBTZXQgb2YgaXRzIHBhcmFtZXRlcnMgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gSW5zdGFuY2Ugb2Ygc3BlY2lmaWVkIGNvbnN0cnVjdG9yLlxuICovXG5TZXJ2aWNlTG9jYXRvci5wcm90b3R5cGUucmVzb2x2ZUluc3RhbmNlID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBjcmVhdGVJbnN0YW5jZSh7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMgfHwge30sXG5cdFx0cGFyYW1ldGVyTmFtZXM6IGdldFBhcmFtZXRlck5hbWVzKGNvbnN0cnVjdG9yKSxcblx0XHRpc1NpbmdsZXRvbjogZmFsc2UsXG5cdFx0c2luZ2xlSW5zdGFuY2U6IG51bGxcblx0fSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIFVucmVnaXN0ZXJzIGFsbCByZWdpc3RyYXRpb25zIG9mIHNwZWNpZmllZCB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBuYW1lLlxuICovXG5TZXJ2aWNlTG9jYXRvci5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uICh0eXBlKSB7XG5cdHRocm93SWZOb3RTdHJpbmcodHlwZSk7XG5cdGRlbGV0ZSB0aGlzLl9yZWdpc3RyYXRpb25zW3R5cGVdO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyByZWdpc3RyYXRpb24gYXJyYXkgZm9yIHNwZWNpZmllZCB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSBuYW1lLlxuICogQHBhcmFtIHtTZXJ2aWNlTG9jYXRvcn0gY29udGV4dCBDb250ZXh0IG9mIGV4ZWN1dGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlZ2lzdHJhdGlvbih0eXBlLCBjb250ZXh0KSB7XG5cdGlmICghKHR5cGUgaW4gY29udGV4dC5fcmVnaXN0cmF0aW9ucykpIHtcblx0XHRjb250ZXh0Ll9yZWdpc3RyYXRpb25zW3R5cGVdID0gW107XG5cdH1cbn1cblxuLyoqXG4gKiBUaHJvd3MgZXJyb3IgaWYgc3BlY2lmaWVkIHJlZ2lzdHJhdGlvbiBpcyBub3QgZm91bmQuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnaXN0cmF0aW9ucyBDdXJyZW50IHJlZ2lzdHJhdGlvbnMgc2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVHlwZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZk5vVHlwZShyZWdpc3RyYXRpb25zLCB0eXBlKSB7XG5cdGlmICghKHR5cGUgaW4gcmVnaXN0cmF0aW9ucykgfHwgcmVnaXN0cmF0aW9uc1t0eXBlXS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoRVJST1JfVFlQRV9OT1RfUkVHSVNURVJFRCwgdHlwZSkpO1xuXHR9XG59XG5cbi8qKlxuICogVGhyb3dzIGVycm9yIGlmIHNwZWNpZmllZCBjb25zdHJ1Y3RvciBpcyBub3QgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmTm90RnVuY3Rpb24oY29uc3RydWN0b3IpIHtcblx0aWYgKGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR0aHJvdyBuZXcgRXJyb3IoRVJST1JfQ09OU1RSVUNUT1JfU0hPVUxEX0JFX0ZVTkNUSU9OKTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgZXJyb3IgaWYgc3BlY2lmaWVkIHR5cGUgbmFtZSBpcyBub3QgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIG5hbWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZOb3RTdHJpbmcodHlwZSkge1xuXHRpZiAodHlwZW9mICh0eXBlKSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoRVJST1JfVFlQRV9TSE9VTERfQkVfU1RSSU5HLCB0eXBlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBpbnN0YW5jZSBvZiB0eXBlIHNwZWNpZmllZCBhbmQgcGFyYW1ldGVycyBpbiByZWdpc3RyYXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnaXN0cmF0aW9uIFNwZWNpZmllZCByZWdpc3RyYXRpb24gb2YgdHlwZS5cbiAqIEBwYXJhbSB7U2VydmljZUxvY2F0b3J9IGNvbnRleHQgQ29udGV4dCBvZiBleGVjdXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBJbnN0YW5jZSBvZiB0eXBlIHNwZWNpZmllZCBpbiByZWdpc3RyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHJlZ2lzdHJhdGlvbiwgY29udGV4dCkge1xuXHRpZiAocmVnaXN0cmF0aW9uLmlzU2luZ2xldG9uICYmIHJlZ2lzdHJhdGlvbi5zaW5nbGVJbnN0YW5jZSAhPT0gbnVsbCkge1xuXHRcdHJldHVybiByZWdpc3RyYXRpb24uc2luZ2xlSW5zdGFuY2U7XG5cdH1cblxuXHR2YXIgaW5zdGFuY2VQYXJhbWV0ZXJzID0gZ2V0UGFyYW1ldGVycyhyZWdpc3RyYXRpb24sIGNvbnRleHQpLFxuXHRcdGluc3RhbmNlID0gT2JqZWN0LmNyZWF0ZShyZWdpc3RyYXRpb24uY29uc3RydWN0b3IucHJvdG90eXBlKTtcblx0cmVnaXN0cmF0aW9uLmNvbnN0cnVjdG9yLmFwcGx5KGluc3RhbmNlLCBpbnN0YW5jZVBhcmFtZXRlcnMpO1xuXG5cdGlmIChyZWdpc3RyYXRpb24uaXNTaW5nbGV0b24pIHtcblx0XHRyZWdpc3RyYXRpb24uc2luZ2xlSW5zdGFuY2UgPSBpbnN0YW5jZTtcblx0fVxuXG5cdHJldHVybiBpbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBHZXRzIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgc3BlY2lmaWVkIGluIHR5cGUgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnaXN0cmF0aW9uIFR5cGUgcmVnaXN0cmF0aW9uLlxuICogQHBhcmFtIHtTZXJ2aWNlTG9jYXRvcn0gY29udGV4dCBDb250ZXh0IG9mIGV4ZWN1dGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgcmVzb2x2ZWQgZGVwZW5kZW5jaWVzIHRvIGluamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyhyZWdpc3RyYXRpb24sIGNvbnRleHQpIHtcblx0cmV0dXJuIHJlZ2lzdHJhdGlvbi5wYXJhbWV0ZXJOYW1lcy5tYXAoZnVuY3Rpb24gKHBhcmFtZXRlck5hbWUpIHtcblx0XHR2YXIgZGVwZW5kZW5jeU5hbWUgPSBnZXREZXBlbmRlbmN5TmFtZShwYXJhbWV0ZXJOYW1lKTtcblx0XHRyZXR1cm4gZGVwZW5kZW5jeU5hbWUgPT09IG51bGwgP1xuXHRcdFx0cmVnaXN0cmF0aW9uLnBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gOlxuXHRcdFx0dGhpcy5yZXNvbHZlKGRlcGVuZGVuY3lOYW1lKTtcblx0fSwgY29udGV4dCk7XG59XG5cbi8qKlxuICogR2V0cyBuYW1lIG9mIGRlcGVuZGVuY3kgdHlwZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJOYW1lIE5hbWUgb2YgY29uc3RydWN0b3IgcGFyYW1ldGVyLlxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBOYW1lIG9mIGRlcGVuZGVuY3kgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jeU5hbWUocGFyYW1ldGVyTmFtZSkge1xuXHRpZiAoIURFUEVOREVOQ1lfUkVHRVhQLnRlc3QocGFyYW1ldGVyTmFtZSkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBwYXJhbWV0ZXJOYW1lLnN1YnN0cigxLCBwYXJhbWV0ZXJOYW1lLmxlbmd0aCAtIDEpO1xufVxuXG4vKipcbiAqIEdldHMgYWxsIHBhcmFtZXRlciBuYW1lcyB1c2VkIGluIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gQXJyYXkgb2YgcGFyYW1ldGVyIG5hbWVzLlxuICovXG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJOYW1lcyhjb25zdHJ1Y3Rvcikge1xuXHR2YXIgc291cmNlID0gY29uc3RydWN0b3IudG9TdHJpbmcoKSxcblx0XHR0b2tlbml6ZXIgPSBuZXcgQ29uc3RydWN0b3JUb2tlbml6ZXIoc291cmNlKSxcblx0XHRyZXN1bHQgPSBbXSxcblx0XHR0b2tlbiA9IHtcblx0XHRcdHN0YXRlOiBDb25zdHJ1Y3RvclRva2VuaXplci5TVEFURVMuTk8sXG5cdFx0XHRzdGFydDogMCxcblx0XHRcdGVuZDogMFxuXHRcdH0sXG5cdFx0YXJlUGFyYW1ldGVyc1N0YXJ0ZWQgPSBmYWxzZTtcblxuXHR3aGlsZSAoXG5cdFx0dG9rZW4uc3RhdGUgIT09IENvbnN0cnVjdG9yVG9rZW5pemVyLlNUQVRFUy5FTkQgJiZcblx0XHR0b2tlbi5zdGF0ZSAhPT0gQ29uc3RydWN0b3JUb2tlbml6ZXIuU1RBVEVTLklMTEVHQUwpIHtcblx0XHR0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG5cdFx0aWYgKHRva2VuLnN0YXRlID09PSBDb25zdHJ1Y3RvclRva2VuaXplci5TVEFURVMuUEFSRU5USEVTRVNfT1BFTikge1xuXHRcdFx0YXJlUGFyYW1ldGVyc1N0YXJ0ZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChhcmVQYXJhbWV0ZXJzU3RhcnRlZCAmJlxuXHRcdFx0dG9rZW4uc3RhdGUgPT09IENvbnN0cnVjdG9yVG9rZW5pemVyLlNUQVRFUy5JREVOVElGSUVSKSB7XG5cdFx0XHRyZXN1bHQucHVzaChzb3VyY2Uuc3Vic3RyaW5nKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn0iLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBVSFI7XG5cbnZhciBVSFJCYXNlID0gcmVxdWlyZSgnLi4vbGliL1VIUkJhc2UnKSxcblx0UHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKSxcblx0VVJJID0gcmVxdWlyZSgnY2F0YmVycnktdXJpJykuVVJJLFxuXHR1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vLyBpZiBicm93c2VyIHN0aWxsIGRvZXMgbm90IGhhdmUgcHJvbWlzZXMgdGhlbiBhZGQgaXQuXG5pZiAoISgnUHJvbWlzZScgaW4gd2luZG93KSkge1xuXHR3aW5kb3cuUHJvbWlzZSA9IFByb21pc2U7XG59XG5cbnV0aWwuaW5oZXJpdHMoVUhSLCBVSFJCYXNlKTtcblxudmFyIE5PTl9TQUZFX0hFQURFUlMgPSB7XG5cdGNvb2tpZTogdHJ1ZSxcblx0J2FjY2VwdC1jaGFyc2V0JzogdHJ1ZVxufTtcblxudmFyIEVSUk9SX0NPTk5FQ1RJT04gPSAnQ29ubmVjdGlvbiBlcnJvcicsXG5cdEVSUk9SX1RJTUVPVVQgPSAnUmVxdWVzdCB0aW1lb3V0Jyxcblx0RVJST1JfQUJPUlRFRCA9ICdSZXF1ZXN0IGFib3J0ZWQnO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIGNsaWVudC1zaWRlIEhUVFAoUykgcmVxdWVzdCBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7V2luZG93fSAkd2luZG93IEN1cnJlbnQgd2luZG93IG9iamVjdC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVSFIoJHdpbmRvdykge1xuXHRVSFJCYXNlLmNhbGwodGhpcyk7XG5cdHRoaXMud2luZG93ID0gJHdpbmRvdztcbn1cblxuLyoqXG4gKiBDdXJyZW50IGluc3RhbmNlIG9mIHdpbmRvdy5cbiAqIEB0eXBlIHtXaW5kb3d9XG4gKi9cblVIUi5wcm90b3R5cGUud2luZG93ID0gbnVsbDtcblxuLyoqXG4gKiBEb2VzIHJlcXVlc3Qgd2l0aCBzcGVjaWZpZWQgcGFyYW1ldGVycyB1c2luZyBwcm90b2NvbCBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLm1ldGhvZCBIVFRQIG1ldGhvZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLnVybCBVUkwgZm9yIHJlcXVlc3QuXG4gKiBAcGFyYW0ge1VSSX0gcGFyYW1ldGVycy51cmkgVVJJIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzLmhlYWRlcnMgSFRUUCBoZWFkZXJzIHRvIHNlbmQuXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHBhcmFtZXRlcnMuZGF0YSBEYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1ldGVycy50aW1lb3V0IFJlcXVlc3QgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1ldGVycy51bnNhZmVIVFRQUyBJZiB0cnVlIHRoZW4gcmVxdWVzdHMgdG8gc2VydmVycyB3aXRoXG4gKiBpbnZhbGlkIEhUVFBTIGNlcnRpZmljYXRlcyBhcmUgYWxsb3dlZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgZm9yIHJlc3VsdCB3aXRoIHN0YXR1cyBvYmplY3QgYW5kIGNvbnRlbnQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblVIUi5wcm90b3R5cGUuX2RvUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblxuXHRPYmplY3Qua2V5cyhwYXJhbWV0ZXJzLmhlYWRlcnMpXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdGlmIChOT05fU0FGRV9IRUFERVJTLmhhc093blByb3BlcnR5KG5hbWUudG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0ZGVsZXRlIHBhcmFtZXRlcnMuaGVhZGVyc1tuYW1lXTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwsIHJlamVjdCkge1xuXHRcdHZhciByZXF1ZXN0RXJyb3IgPSBudWxsLFxuXHRcdFx0eGhyID0gbmV3IHNlbGYud2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cblx0XHR4aHIub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlcXVlc3RFcnJvciA9IG5ldyBFcnJvcihFUlJPUl9BQk9SVEVEKTtcblx0XHRcdHJlamVjdChyZXF1ZXN0RXJyb3IpO1xuXHRcdH07XG5cdFx0eGhyLm9udGltZW91dCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlcXVlc3RFcnJvciA9IG5ldyBFcnJvcihFUlJPUl9USU1FT1VUKTtcblx0XHRcdHJlamVjdChyZXF1ZXN0RXJyb3IpO1xuXHRcdH07XG5cdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXF1ZXN0RXJyb3IgPSBuZXcgRXJyb3IoeGhyLnN0YXR1c1RleHQgfHwgRVJST1JfQ09OTkVDVElPTik7XG5cdFx0XHRyZWplY3QocmVxdWVzdEVycm9yKTtcblx0XHR9O1xuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJlcXVlc3RFcnJvcikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgc3RhdHVzT2JqZWN0ID0gZ2V0U3RhdHVzT2JqZWN0KHhociksXG5cdFx0XHRcdGNvbnRlbnQgPSBzZWxmLmNvbnZlcnRSZXNwb25zZShcblx0XHRcdFx0XHRzdGF0dXNPYmplY3QuaGVhZGVycyxcblx0XHRcdFx0XHR4aHIucmVzcG9uc2VUZXh0XG5cdFx0XHRcdCk7XG5cdFx0XHRmdWxmaWxsKHtcblx0XHRcdFx0c3RhdHVzOiBzdGF0dXNPYmplY3QsXG5cdFx0XHRcdGNvbnRlbnQ6IGNvbnRlbnRcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHR2YXIgdXNlciA9IHBhcmFtZXRlcnMudXJpLmF1dGhvcml0eS51c2VySW5mbyA/XG5cdFx0XHRcdHBhcmFtZXRlcnMudXJpLmF1dGhvcml0eS51c2VySW5mby51c2VyIDogbnVsbCxcblx0XHRcdHBhc3N3b3JkID0gcGFyYW1ldGVycy51cmkuYXV0aG9yaXR5LnVzZXJJbmZvID9cblx0XHRcdFx0cGFyYW1ldGVycy51cmkuYXV0aG9yaXR5LnVzZXJJbmZvLnBhc3N3b3JkIDogbnVsbDtcblx0XHR4aHIub3Blbihcblx0XHRcdHBhcmFtZXRlcnMubWV0aG9kLCBwYXJhbWV0ZXJzLnVyaS50b1N0cmluZygpLCB0cnVlLFxuXHRcdFx0dXNlciB8fCB1bmRlZmluZWQsIHBhc3N3b3JkIHx8IHVuZGVmaW5lZFxuXHRcdCk7XG5cdFx0eGhyLnRpbWVvdXQgPSBwYXJhbWV0ZXJzLnRpbWVvdXQ7XG5cblx0XHRpZiAocGFyYW1ldGVycy53aXRoQ3JlZGVudGlhbHMpIHtcblx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXHRcdH1cblxuXHRcdE9iamVjdC5rZXlzKHBhcmFtZXRlcnMuaGVhZGVycylcblx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXJOYW1lKSB7XG5cdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XHRcdGhlYWRlck5hbWUsIHBhcmFtZXRlcnMuaGVhZGVyc1toZWFkZXJOYW1lXVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cblx0XHR4aHIuc2VuZChwYXJhbWV0ZXJzLmRhdGEpO1xuXHR9KTtcbn07XG5cbi8qKlxuICogR2V0cyBzdGF0ZSBvYmplY3QgZm9yIHNwZWNpZmllZCBqUXVlcnkgWEhSIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0P30geGhyIFhIUiBvYmplY3QuXG4gKiBAcmV0dXJucyB7e2NvZGU6IG51bWJlciwgdGV4dDogc3RyaW5nLCBoZWFkZXJzOiBPYmplY3R9fSBTdGF0dXMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRTdGF0dXNPYmplY3QoeGhyKSB7XG5cdHZhciBoZWFkZXJzID0ge307XG5cblx0aWYgKCF4aHIpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y29kZTogMCxcblx0XHRcdHRleHQ6ICcnLFxuXHRcdFx0aGVhZGVyczogaGVhZGVyc1xuXHRcdH07XG5cdH1cblxuXHR4aHJcblx0XHQuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHQuc3BsaXQoJ1xcbicpXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0dmFyIGRlbGltaXRlckluZGV4ID0gaGVhZGVyLmluZGV4T2YoJzonKTtcblx0XHRcdGlmIChkZWxpbWl0ZXJJbmRleCA8PSAwKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBoZWFkZXJOYW1lID0gaGVhZGVyXG5cdFx0XHRcdC5zdWJzdHJpbmcoMCwgZGVsaW1pdGVySW5kZXgpXG5cdFx0XHRcdC50cmltKClcblx0XHRcdFx0LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRoZWFkZXJzW2hlYWRlck5hbWVdID0gaGVhZGVyXG5cdFx0XHRcdC5zdWJzdHJpbmcoZGVsaW1pdGVySW5kZXggKyAxKVxuXHRcdFx0XHQudHJpbSgpO1xuXHRcdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0Ly8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9nb28uZ2wvaWRzcFNyXG5cdFx0Y29kZTogeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXMsXG5cdFx0dGV4dDogeGhyLnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHhoci5zdGF0dXNUZXh0LFxuXHRcdGhlYWRlcnM6IGhlYWRlcnNcblx0fTtcbn0iLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVIUiA9IHJlcXVpcmUoJy4vbGliL1VIUicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBVSFIgaW4gc2VydmVyLXNpZGUgc2VydmljZSBsb2NhdG9yLlxuXHQgKiBAcGFyYW0ge1NlcnZpY2VMb2NhdG9yfSBsb2NhdG9yIENhdGJlcnJ5J3Mgc2VydmljZSBsb2NhdG9yLlxuXHQgKi9cblx0cmVnaXN0ZXI6IGZ1bmN0aW9uIChsb2NhdG9yKSB7XG5cdFx0dmFyIGNvbmZpZyA9IGxvY2F0b3IucmVzb2x2ZSgnY29uZmlnJyk7XG5cdFx0bG9jYXRvci5yZWdpc3RlcigndWhyJywgVUhSLCBjb25maWcsIHRydWUpO1xuXHR9LFxuXHRVSFI6IFVIUlxufTsiLCIvKlxuICogY2F0YmVycnlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnkgdGhhdCBhcmUgbm90IGV4dGVybmFsbHlcbiAqIG1haW50YWluZWQgbGlicmFyaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBVSFJCYXNlO1xuXG52YXIgY2F0YmVycnlVcmkgPSByZXF1aXJlKCdjYXRiZXJyeS11cmknKSxcblx0UXVlcnkgPSBjYXRiZXJyeVVyaS5RdWVyeSxcblx0VVJJID0gY2F0YmVycnlVcmkuVVJJO1xuXG52YXIgRVJST1JfVU5TVVBQT1JURURfUFJPVE9DT0wgPSAnUHJvdG9jb2wgaXMgdW5zdXBwb3J0ZWQnLFxuXHRFUlJPUl9QQVJBTUVURVJTX1NIT1VMRF9CRV9PQkpFQ1QgPSAnUmVxdWVzdCBwYXJhbWV0ZXJzIHNob3VsZCBiZSBvYmplY3QnLFxuXHRFUlJPUl9VUkxfSVNfUkVRVUlSRUQgPSAnVVJMIGlzIHJlcXVpcmVkIHBhcmFtZXRlcicsXG5cdEVSUk9SX01FVEhPRF9JU19SRVFVSVJFRCA9ICdSZXF1ZXN0IG1ldGhvZCBpcyByZXF1aXJlZCBwYXJhbWV0ZXInLFxuXHRFUlJPUl9IT1NUX0lTX1JFUVVJUkVEID0gJ0hvc3QgaW4gVVJMIGlzIHJlcXVpcmVkJyxcblx0RVJST1JfU0NIRU1FX0lTX1JFUVVJUkVEID0gJ1NjaGVtZSBpbiBVUkwgaXMgcmVxdWlyZWQnLFxuXHRFUlJPUl9USU1FT1VUX1NIT1VMRF9CRV9OVU1CRVIgPSAnVGltZW91dCBzaG91bGQgYmUgYSBudW1iZXInLFxuXHRERUZBVUxUX1RJTUVPVVQgPSAzMDAwMCxcblx0SFRUUF9QUk9UT0NPTF9SRUdFWFAgPSAvXihodHRwKXM/JC9pO1xuXG52YXIgTUVUSE9EUyA9IHtcblx0R0VUOiAnR0VUJyxcblx0SEVBRDogJ0hFQUQnLFxuXHRQT1NUOiAnUE9TVCcsXG5cdFBVVDogJ1BVVCcsXG5cdFBBVENIOiAnUEFUQ0gnLFxuXHRERUxFVEU6ICdERUxFVEUnLFxuXHRPUFRJT05TOiAnT1BUSU9OUycsXG5cdFRSQUNFOiAnVFJBQ0UnLFxuXHRDT05ORUNUOiAnQ09OTkVDVCdcbn07XG5cblVIUkJhc2UuVFlQRVMgPSB7XG5cdFVSTF9FTkNPREVEOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcblx0SlNPTjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuXHRQTEFJTl9URVhUOiAndGV4dC9wbGFpbicsXG5cdEhUTUw6ICd0ZXh0L2h0bWwnXG59O1xuXG5VSFJCYXNlLkNIQVJTRVQgPSAnVVRGLTgnO1xuXG5VSFJCYXNlLkRFRkFVTFRfR0VORVJBTF9IRUFERVJTID0ge1xuXHRBY2NlcHQ6IFVIUkJhc2UuVFlQRVMuSlNPTiArICc7IHE9MC43LCAnICtcblx0XHRVSFJCYXNlLlRZUEVTLkhUTUwgKyAnOyBxPTAuMiwgJyArXG5cdFx0VUhSQmFzZS5UWVBFUy5QTEFJTl9URVhUICsgJzsgcT0wLjEnLFxuXHQnQWNjZXB0LUNoYXJzZXQnOiBVSFJCYXNlLkNIQVJTRVQgKyAnOyBxPTEnXG59O1xuXG5VSFJCYXNlLkNIQVJTRVRfUEFSQU1FVEVSID0gJzsgY2hhcnNldD0nICsgVUhSQmFzZS5DSEFSU0VUO1xuVUhSQmFzZS5VUkxfRU5DT0RFRF9FTlRJVFlfQ09OVEVOVF9UWVBFID0gVUhSQmFzZS5UWVBFUy5VUkxfRU5DT0RFRCArXG5cdFVIUkJhc2UuQ0hBUlNFVF9QQVJBTUVURVI7XG5cblVIUkJhc2UuSlNPTl9FTlRJVFlfQ09OVEVOVF9UWVBFID0gVUhSQmFzZS5UWVBFUy5KU09OICtcblx0VUhSQmFzZS5DSEFSU0VUX1BBUkFNRVRFUjtcblxuVUhSQmFzZS5QTEFJTl9URVhUX0VOVElUWV9DT05URU5UX1RZUEUgPSBVSFJCYXNlLlRZUEVTLlBMQUlOX1RFWFQgK1xuXHRVSFJCYXNlLkNIQVJTRVRfUEFSQU1FVEVSO1xuXG4vLyBUaGlzIG1vZHVsZSB3ZXJlIGRldmVsb3BlZCB1c2luZyBIVFRQLzEuMXYyIFJGQyAyNjE2XG4vLyAoaHR0cDovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvKVxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBCYXNpYyBVbml2ZXJzYWwgSFRUUChTKSBSZXF1ZXN0IGltcGxlbWVudGF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFVIUkJhc2UoKSB7IH1cblxuLyoqXG4gKiBEb2VzIEdFVCByZXF1ZXN0IHRvIEhUVFAgc2VydmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0P30gb3B0aW9ucyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge09iamVjdD99IG9wdGlvbnMuaGVhZGVycyBIVFRQIGhlYWRlcnMgdG8gc2VuZC5cbiAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpP30gb3B0aW9ucy5kYXRhIERhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyP30gb3B0aW9ucy50aW1lb3V0IFJlcXVlc3QgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj99IG9wdGlvbnMudW5zYWZlSFRUUFMgSWYgdHJ1ZSB0aGVuIHJlcXVlc3RzIHRvIHNlcnZlcnMgd2l0aFxuICogaW52YWxpZCBIVFRQUyBjZXJ0aWZpY2F0ZXMgYXJlIGFsbG93ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBQcm9taXNlIGZvciByZXN1bHQgd2l0aCBzdGF0dXMgb2JqZWN0IGFuZCBjb250ZW50LlxuICovXG5VSFJCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHR2YXIgcGFyYW1ldGVycyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyk7XG5cdHBhcmFtZXRlcnMubWV0aG9kID0gTUVUSE9EUy5HRVQ7XG5cdHBhcmFtZXRlcnMudXJsID0gdXJsO1xuXHRyZXR1cm4gdGhpcy5yZXF1ZXN0KHBhcmFtZXRlcnMpO1xufTtcblxuLyoqXG4gKiBEb2VzIFBPU1QgcmVxdWVzdCB0byBIVFRQIHNlcnZlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdD99IG9wdGlvbnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtPYmplY3Q/fSBvcHRpb25zLmhlYWRlcnMgSFRUUCBoZWFkZXJzIHRvIHNlbmQuXG4gKiBAcGFyYW0geyhzdHJpbmd8T2JqZWN0KT99IG9wdGlvbnMuZGF0YSBEYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge251bWJlcj99IG9wdGlvbnMudGltZW91dCBSZXF1ZXN0IHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBvcHRpb25zLnVuc2FmZUhUVFBTIElmIHRydWUgdGhlbiByZXF1ZXN0cyB0byBzZXJ2ZXJzIHdpdGhcbiAqIGludmFsaWQgSFRUUFMgY2VydGlmaWNhdGVzIGFyZSBhbGxvd2VkLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUHJvbWlzZSBmb3IgcmVzdWx0IHdpdGggc3RhdHVzIG9iamVjdCBhbmQgY29udGVudC5cbiAqL1xuVUhSQmFzZS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdHZhciBwYXJhbWV0ZXJzID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zKTtcblx0cGFyYW1ldGVycy5tZXRob2QgPSBNRVRIT0RTLlBPU1Q7XG5cdHBhcmFtZXRlcnMudXJsID0gdXJsO1xuXHRyZXR1cm4gdGhpcy5yZXF1ZXN0KHBhcmFtZXRlcnMpO1xufTtcblxuLyoqXG4gKiBEb2VzIFBVVCByZXF1ZXN0IHRvIEhUVFAgc2VydmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0P30gb3B0aW9ucyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge09iamVjdD99IG9wdGlvbnMuaGVhZGVycyBIVFRQIGhlYWRlcnMgdG8gc2VuZC5cbiAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpP30gb3B0aW9ucy5kYXRhIERhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyP30gb3B0aW9ucy50aW1lb3V0IFJlcXVlc3QgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj99IG9wdGlvbnMudW5zYWZlSFRUUFMgSWYgdHJ1ZSB0aGVuIHJlcXVlc3RzIHRvIHNlcnZlcnMgd2l0aFxuICogaW52YWxpZCBIVFRQUyBjZXJ0aWZpY2F0ZXMgYXJlIGFsbG93ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBQcm9taXNlIGZvciByZXN1bHQgd2l0aCBzdGF0dXMgb2JqZWN0IGFuZCBjb250ZW50LlxuICovXG5VSFJCYXNlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHR2YXIgcGFyYW1ldGVycyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyk7XG5cdHBhcmFtZXRlcnMubWV0aG9kID0gTUVUSE9EUy5QVVQ7XG5cdHBhcmFtZXRlcnMudXJsID0gdXJsO1xuXHRyZXR1cm4gdGhpcy5yZXF1ZXN0KHBhcmFtZXRlcnMpO1xufTtcblxuLyoqXG4gKiBEb2VzIFBBVENIIHJlcXVlc3QgdG8gSFRUUCBzZXJ2ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3Q/fSBvcHRpb25zIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0P30gb3B0aW9ucy5oZWFkZXJzIEhUVFAgaGVhZGVycyB0byBzZW5kLlxuICogQHBhcmFtIHsoc3RyaW5nfE9iamVjdCk/fSBvcHRpb25zLmRhdGEgRGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtudW1iZXI/fSBvcHRpb25zLnRpbWVvdXQgUmVxdWVzdCB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFuP30gb3B0aW9ucy51bnNhZmVIVFRQUyBJZiB0cnVlIHRoZW4gcmVxdWVzdHMgdG8gc2VydmVycyB3aXRoXG4gKiBpbnZhbGlkIEhUVFBTIGNlcnRpZmljYXRlcyBhcmUgYWxsb3dlZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgZm9yIHJlc3VsdCB3aXRoIHN0YXR1cyBvYmplY3QgYW5kIGNvbnRlbnQuXG4gKi9cblVIUkJhc2UucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0dmFyIHBhcmFtZXRlcnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMpO1xuXHRwYXJhbWV0ZXJzLm1ldGhvZCA9IE1FVEhPRFMuUEFUQ0g7XG5cdHBhcmFtZXRlcnMudXJsID0gdXJsO1xuXHRyZXR1cm4gdGhpcy5yZXF1ZXN0KHBhcmFtZXRlcnMpO1xufTtcblxuLyoqXG4gKiBEb2VzIERFTEVURSByZXF1ZXN0IHRvIEhUVFAgc2VydmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0P30gb3B0aW9ucyBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge09iamVjdD99IG9wdGlvbnMuaGVhZGVycyBIVFRQIGhlYWRlcnMgdG8gc2VuZC5cbiAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpP30gb3B0aW9ucy5kYXRhIERhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyP30gb3B0aW9ucy50aW1lb3V0IFJlcXVlc3QgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj99IG9wdGlvbnMudW5zYWZlSFRUUFMgSWYgdHJ1ZSB0aGVuIHJlcXVlc3RzIHRvIHNlcnZlcnMgd2l0aFxuICogaW52YWxpZCBIVFRQUyBjZXJ0aWZpY2F0ZXMgYXJlIGFsbG93ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBQcm9taXNlIGZvciByZXN1bHQgd2l0aCBzdGF0dXMgb2JqZWN0IGFuZCBjb250ZW50LlxuICovXG5VSFJCYXNlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG5cdHZhciBwYXJhbWV0ZXJzID0gT2JqZWN0LmNyZWF0ZShvcHRpb25zKTtcblx0cGFyYW1ldGVycy5tZXRob2QgPSBNRVRIT0RTLkRFTEVURTtcblx0cGFyYW1ldGVycy51cmwgPSB1cmw7XG5cdHJldHVybiB0aGlzLnJlcXVlc3QocGFyYW1ldGVycyk7XG59O1xuXG4vKipcbiAqIERvZXMgcmVxdWVzdCB3aXRoIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMubWV0aG9kIEhUVFAgbWV0aG9kLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMudXJsIFVSTCBmb3IgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0P30gcGFyYW1ldGVycy5oZWFkZXJzIEhUVFAgaGVhZGVycyB0byBzZW5kLlxuICogQHBhcmFtIHsoc3RyaW5nfE9iamVjdCk/fSBwYXJhbWV0ZXJzLmRhdGEgRGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtudW1iZXI/fSBwYXJhbWV0ZXJzLnRpbWVvdXQgUmVxdWVzdCB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFuP30gcGFyYW1ldGVycy51bnNhZmVIVFRQUyBJZiB0cnVlIHRoZW4gcmVxdWVzdHNcbiAqIHRvIHNlcnZlcnMgd2l0aCBpbnZhbGlkIEhUVFBTIGNlcnRpZmljYXRlcyBhcmUgYWxsb3dlZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgZm9yIHJlc3VsdCB3aXRoIHN0YXR1cyBvYmplY3QgYW5kIGNvbnRlbnQuXG4gKi9cblVIUkJhc2UucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHJldHVybiB0aGlzLl92YWxpZGF0ZVJlcXVlc3QocGFyYW1ldGVycylcblx0XHQudGhlbihmdW5jdGlvbiAodmFsaWRhdGVkKSB7XG5cdFx0XHRyZXR1cm4gc2VsZi5fZG9SZXF1ZXN0KHZhbGlkYXRlZCk7XG5cdFx0fSk7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBVSFIgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIFJlcXVlc3QgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLm1ldGhvZCBIVFRQIG1ldGhvZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbWV0ZXJzLnVybCBVUkwgZm9yIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdD99IHBhcmFtZXRlcnMuaGVhZGVycyBIVFRQIGhlYWRlcnMgdG8gc2VuZC5cbiAqIEBwYXJhbSB7KHN0cmluZ3xPYmplY3QpP30gcGFyYW1ldGVycy5kYXRhIERhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyP30gcGFyYW1ldGVycy50aW1lb3V0IFJlcXVlc3QgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj99IHBhcmFtZXRlcnMudW5zYWZlSFRUUFMgSWYgdHJ1ZSB0aGVuIHJlcXVlc3RzXG4gKiB0byBzZXJ2ZXJzIHdpdGggaW52YWxpZCBIVFRQUyBjZXJ0aWZpY2F0ZXMgYXJlIGFsbG93ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBmb3Igbm90aGluZy5cbiAqIEBwcml2YXRlXG4gKi9cbi8qanNoaW50IG1heGNvbXBsZXhpdHk6ZmFsc2UgKi9cblVIUkJhc2UucHJvdG90eXBlLl92YWxpZGF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuXHRpZiAoIXBhcmFtZXRlcnMgfHwgdHlwZW9mIChwYXJhbWV0ZXJzKSAhPT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKEVSUk9SX1BBUkFNRVRFUlNfU0hPVUxEX0JFX09CSkVDVCkpO1xuXHR9XG5cblx0dmFyIHZhbGlkYXRlZCA9IE9iamVjdC5jcmVhdGUocGFyYW1ldGVycyk7XG5cblx0aWYgKHR5cGVvZiAocGFyYW1ldGVycy51cmwpICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoRVJST1JfVVJMX0lTX1JFUVVJUkVEKSk7XG5cdH1cblx0dmFsaWRhdGVkLnVyaSA9IG5ldyBVUkkodmFsaWRhdGVkLnVybCk7XG5cdGlmICghdmFsaWRhdGVkLnVyaS5zY2hlbWUpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKEVSUk9SX1NDSEVNRV9JU19SRVFVSVJFRCkpO1xuXHR9XG5cdGlmICghSFRUUF9QUk9UT0NPTF9SRUdFWFAudGVzdCh2YWxpZGF0ZWQudXJpLnNjaGVtZSkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKEVSUk9SX1VOU1VQUE9SVEVEX1BST1RPQ09MKSk7XG5cdH1cblx0aWYgKCF2YWxpZGF0ZWQudXJpLmF1dGhvcml0eSB8fCAhdmFsaWRhdGVkLnVyaS5hdXRob3JpdHkuaG9zdCkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoRVJST1JfSE9TVF9JU19SRVFVSVJFRCkpO1xuXHR9XG5cdGlmICh0eXBlb2YgKHZhbGlkYXRlZC5tZXRob2QpICE9PSAnc3RyaW5nJyB8fFxuXHRcdCEodmFsaWRhdGVkLm1ldGhvZCBpbiBNRVRIT0RTKSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoRVJST1JfTUVUSE9EX0lTX1JFUVVJUkVEKSk7XG5cdH1cblxuXHR2YWxpZGF0ZWQudGltZW91dCA9IHZhbGlkYXRlZC50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVDtcblx0aWYgKHR5cGVvZiAodmFsaWRhdGVkLnRpbWVvdXQpICE9PSAnbnVtYmVyJykge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoRVJST1JfVElNRU9VVF9TSE9VTERfQkVfTlVNQkVSKSk7XG5cdH1cblxuXHR2YWxpZGF0ZWQuaGVhZGVycyA9IHRoaXMuX2NyZWF0ZUhlYWRlcnModmFsaWRhdGVkLmhlYWRlcnMpO1xuXG5cdGlmICghdGhpcy5faXNVcHN0cmVhbVJlcXVlc3QocGFyYW1ldGVycy5tZXRob2QpICYmXG5cdFx0dmFsaWRhdGVkLmRhdGEgJiYgdHlwZW9mICh2YWxpZGF0ZWQuZGF0YSkgPT09ICdvYmplY3QnKSB7XG5cblx0XHR2YXIgZGF0YUtleXMgPSBPYmplY3Qua2V5cyh2YWxpZGF0ZWQuZGF0YSk7XG5cblx0XHRpZiAoZGF0YUtleXMubGVuZ3RoID4gMCAmJiAhdmFsaWRhdGVkLnVyaS5xdWVyeSkge1xuXHRcdFx0dmFsaWRhdGVkLnVyaS5xdWVyeSA9IG5ldyBRdWVyeSgnJyk7XG5cdFx0fVxuXG5cdFx0ZGF0YUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR2YWxpZGF0ZWQudXJpLnF1ZXJ5LnZhbHVlc1trZXldID0gdmFsaWRhdGVkLmRhdGFba2V5XTtcblx0XHR9KTtcblx0XHR2YWxpZGF0ZWQuZGF0YSA9IG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGRhdGFBbmRIZWFkZXJzID0gdGhpcy5fZ2V0RGF0YVRvU2VuZChcblx0XHRcdHZhbGlkYXRlZC5oZWFkZXJzLCB2YWxpZGF0ZWQuZGF0YVxuXHRcdCk7XG5cdFx0dmFsaWRhdGVkLmhlYWRlcnMgPSBkYXRhQW5kSGVhZGVycy5oZWFkZXJzO1xuXHRcdHZhbGlkYXRlZC5kYXRhID0gZGF0YUFuZEhlYWRlcnMuZGF0YTtcblx0fVxuXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsaWRhdGVkKTtcbn07XG5cbi8qKlxuICogR2V0cyBkYXRhIGZvciBzZW5kaW5nIHZpYSBIVFRQIHJlcXVlc3QgdXNpbmcgQ29udGVudCBUeXBlIEhUVFAgaGVhZGVyLlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgSFRUUCBoZWFkZXJzLlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBkYXRhIERhdGEgdG8gc2VuZC5cbiAqIEByZXR1cm5zIHt7aGVhZGVyczogT2JqZWN0LCBkYXRhOiBPYmplY3R8c3RyaW5nfX0gRGF0YSBhbmQgaGVhZGVycyB0byBzZW5kLlxuICogQHByaXZhdGVcbiAqL1xuVUhSQmFzZS5wcm90b3R5cGUuX2dldERhdGFUb1NlbmQgPSBmdW5jdGlvbiAoaGVhZGVycywgZGF0YSkge1xuXHR2YXIgZm91bmQgPSBmaW5kQ29udGVudFR5cGUoaGVhZGVycyksXG5cdFx0Y29udGVudFR5cGVIZWFkZXIgPSBmb3VuZC5uYW1lLFxuXHRcdGNvbnRlbnRUeXBlID0gZm91bmQudHlwZTtcblxuXHRpZiAoIWRhdGEgfHwgdHlwZW9mIChkYXRhKSAhPT0gJ29iamVjdCcpIHtcblx0XHRkYXRhID0gZGF0YSA/IFN0cmluZyhkYXRhKSA6ICcnO1xuXHRcdGlmICghY29udGVudFR5cGUpIHtcblx0XHRcdGhlYWRlcnNbY29udGVudFR5cGVIZWFkZXJdID0gVUhSQmFzZS5QTEFJTl9URVhUX0VOVElUWV9DT05URU5UX1RZUEU7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzLFxuXHRcdFx0ZGF0YTogZGF0YVxuXHRcdH07XG5cdH1cblxuXHRpZiAoY29udGVudFR5cGUgPT09IFVIUkJhc2UuVFlQRVMuSlNPTikge1xuXHRcdHJldHVybiB7XG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzLFxuXHRcdFx0ZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcblx0XHR9O1xuXHR9XG5cblx0Ly8gb3RoZXJ3aXNlIG9iamVjdCB3aWxsIGJlIHNlbnQgd2l0aFxuXHQvLyBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcblx0aGVhZGVyc1tjb250ZW50VHlwZUhlYWRlcl0gPSBVSFJCYXNlLlVSTF9FTkNPREVEX0VOVElUWV9DT05URU5UX1RZUEU7XG5cblx0dmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG5cdHF1ZXJ5LnZhbHVlcyA9IGRhdGE7XG5cdHJldHVybiB7XG5cdFx0aGVhZGVyczogaGVhZGVycyxcblx0XHRkYXRhOiBxdWVyeS50b1N0cmluZygpXG5cdFx0XHQucmVwbGFjZSgvXFwrL2csICclMkInKVxuXHRcdFx0LnJlcGxhY2UoLyUyMC9nLCAnKycpXG5cdH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgSFRUUCBoZWFkZXJzIGZvciByZXF1ZXN0IHVzaW5nIGRlZmF1bHRzIGFuZCBjdXJyZW50IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1ldGVySGVhZGVycyBIVFRQIGhlYWRlcnMgb2YgVUhSLlxuICogQHByb3RlY3RlZFxuICovXG5VSFJCYXNlLnByb3RvdHlwZS5fY3JlYXRlSGVhZGVycyA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJIZWFkZXJzKSB7XG5cdGlmICghcGFyYW1ldGVySGVhZGVycyB8fCB0eXBlb2YgKHBhcmFtZXRlckhlYWRlcnMpICE9PSAnb2JqZWN0Jykge1xuXHRcdHBhcmFtZXRlckhlYWRlcnMgPSB7fTtcblx0fVxuXHR2YXIgaGVhZGVycyA9IHt9O1xuXG5cdE9iamVjdC5rZXlzKFVIUkJhc2UuREVGQVVMVF9HRU5FUkFMX0hFQURFUlMpXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKGhlYWRlck5hbWUpIHtcblx0XHRcdGhlYWRlcnNbaGVhZGVyTmFtZV0gPSBVSFJCYXNlLkRFRkFVTFRfR0VORVJBTF9IRUFERVJTW2hlYWRlck5hbWVdO1xuXHRcdH0pO1xuXG5cdE9iamVjdC5rZXlzKHBhcmFtZXRlckhlYWRlcnMpXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKGhlYWRlck5hbWUpIHtcblx0XHRcdGlmIChwYXJhbWV0ZXJIZWFkZXJzW2hlYWRlck5hbWVdID09PSBudWxsIHx8XG5cdFx0XHRcdHBhcmFtZXRlckhlYWRlcnNbaGVhZGVyTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRkZWxldGUgaGVhZGVyc1toZWFkZXJOYW1lXTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aGVhZGVyc1toZWFkZXJOYW1lXSA9IHBhcmFtZXRlckhlYWRlcnNbaGVhZGVyTmFtZV07XG5cdFx0fSk7XG5cblx0cmV0dXJuIGhlYWRlcnM7XG59O1xuXG4vKipcbiAqIERvZXMgcmVxdWVzdCB3aXRoIHNwZWNpZmllZCBwYXJhbWV0ZXJzIHVzaW5nIHByb3RvY29sIGltcGxlbWVudGF0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMgUmVxdWVzdCBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMubWV0aG9kIEhUVFAgbWV0aG9kLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlcnMudXJsIFVSTCBmb3IgcmVxdWVzdC5cbiAqIEBwYXJhbSB7VVJJfSBwYXJhbWV0ZXJzLnVyaSBVUkkgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtZXRlcnMuaGVhZGVycyBIVFRQIGhlYWRlcnMgdG8gc2VuZC5cbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gcGFyYW1ldGVycy5kYXRhIERhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbWV0ZXJzLnRpbWVvdXQgUmVxdWVzdCB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBwYXJhbWV0ZXJzLnVuc2FmZUhUVFBTIElmIHRydWUgdGhlbiByZXF1ZXN0cyB0byBzZXJ2ZXJzIHdpdGhcbiAqIGludmFsaWQgSFRUUFMgY2VydGlmaWNhdGVzIGFyZSBhbGxvd2VkLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUHJvbWlzZSBmb3IgcmVzdWx0IHdpdGggc3RhdHVzIG9iamVjdCBhbmQgY29udGVudC5cbiAqIEBwcm90ZWN0ZWRcbiAqIEBhYnN0cmFjdFxuICovXG4vLyBqc2NzOmRpc2FibGUgZGlzYWxsb3dVbnVzZWRQYXJhbXNcblVIUkJhc2UucHJvdG90eXBlLl9kb1JlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1ldGVycykgeyB9O1xuXG4vKipcbiAqIENvbnZlcnRzIHJlc3BvbnNlIGRhdGEgYWNjb3JkaW5nIGNvbnRlbnQgdHlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIEhUVFAgaGVhZGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZURhdGEgRGF0YSBmcm9tIHJlc3BvbnNlLlxuICogQHJldHVybnMge3N0cmluZ3xPYmplY3R9IENvbnZlcnRlZCBkYXRhLlxuICovXG5VSFJCYXNlLnByb3RvdHlwZS5jb252ZXJ0UmVzcG9uc2UgPSBmdW5jdGlvbiAoaGVhZGVycywgcmVzcG9uc2VEYXRhKSB7XG5cdGlmICh0eXBlb2YgKHJlc3BvbnNlRGF0YSkgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmVzcG9uc2VEYXRhID0gJyc7XG5cdH1cblx0dmFyIGZvdW5kID0gZmluZENvbnRlbnRUeXBlKGhlYWRlcnMpLFxuXHRcdGNvbnRlbnRUeXBlID0gZm91bmQudHlwZSB8fCBVSFJCYXNlLlRZUEVTLlBMQUlOX1RFWFQ7XG5cblx0c3dpdGNoIChjb250ZW50VHlwZSkge1xuXHRcdGNhc2UgVUhSQmFzZS5UWVBFUy5KU09OOlxuXHRcdFx0dmFyIGpzb247XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZURhdGEpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBub3RoaW5nIHRvIGRvXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ganNvbiB8fCB7fTtcblx0XHRjYXNlIFVIUkJhc2UuVFlQRVMuVVJMX0VOQ09ERUQ6XG5cdFx0XHR2YXIgb2JqZWN0O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHJlc3BvbnNlRGF0YS5yZXBsYWNlKCcrJywgJyUyMCcpKTtcblx0XHRcdFx0b2JqZWN0ID0gcXVlcnkudmFsdWVzO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBub3RoaW5nIHRvIGRvXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqZWN0IHx8IHt9O1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VEYXRhO1xuXHR9XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaXMgY3VycmVudCBxdWVyeSBuZWVkcyB0byB1c2UgdXBzdHJlYW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIEhUVFAgbWV0aG9kLlxuICogQHJldHVybnMge2Jvb2xlYW59IElzIGN1cnJlbnQgSFRUUCBtZXRob2QgbWVhbnMgdXBzdHJlYW0gdXNhZ2UuXG4gKiBAcHJvdGVjdGVkXG4gKi9cblVIUkJhc2UucHJvdG90eXBlLl9pc1Vwc3RyZWFtUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcblx0cmV0dXJuIChcblx0XHRtZXRob2QgPT09IE1FVEhPRFMuUE9TVCB8fFxuXHRcdG1ldGhvZCA9PT0gTUVUSE9EUy5QVVQgfHxcblx0XHRtZXRob2QgPT09IE1FVEhPRFMuUEFUQ0hcblx0XHQpO1xufTtcblxuLyoqXG4gKiBGaW5kcyBjb250ZW50IHR5cGUgaGVhZGVyIGluIGhlYWRlcnMgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgSFRUUCBoZWFkZXJzLlxuICogQHJldHVybnMge3tuYW1lOiBzdHJpbmcsIHR5cGU6IHN0cmluZ319IE5hbWUgb2YgaGVhZGVyIGFuZCBjb250ZW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRDb250ZW50VHlwZShoZWFkZXJzKSB7XG5cdHZhciBjb250ZW50VHlwZVN0cmluZyA9ICcnLFxuXHRcdGNvbnRlbnRUeXBlSGVhZGVyID0gJ0NvbnRlbnQtVHlwZSc7XG5cblx0T2JqZWN0LmtleXMoaGVhZGVycylcblx0XHQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRpZiAoa2V5LnRvTG93ZXJDYXNlKCkgIT09ICdjb250ZW50LXR5cGUnKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbnRlbnRUeXBlSGVhZGVyID0ga2V5O1xuXHRcdFx0Y29udGVudFR5cGVTdHJpbmcgPSBoZWFkZXJzW2tleV07XG5cdFx0fSk7XG5cblx0dmFyIHR5cGVBbmRQYXJhbWV0ZXJzID0gY29udGVudFR5cGVTdHJpbmcuc3BsaXQoJzsnKSxcblx0XHRjb250ZW50VHlwZSA9IHR5cGVBbmRQYXJhbWV0ZXJzWzBdLnRvTG93ZXJDYXNlKCk7XG5cdHJldHVybiB7XG5cdFx0bmFtZTogY29udGVudFR5cGVIZWFkZXIsXG5cdFx0dHlwZTogY29udGVudFR5cGVcblx0fTtcbn1cbiIsIi8qXG4gKiBjYXRiZXJyeVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBEZW5pcyBSZWNoa3Vub3YgYW5kIHByb2plY3QgY29udHJpYnV0b3JzLlxuICpcbiAqIGNhdGJlcnJ5J3MgbGljZW5zZSBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgbGljZW5zZSBhcHBsaWVzIHRvIGFsbCBwYXJ0cyBvZiBjYXRiZXJyeSB0aGF0IGFyZSBub3QgZXh0ZXJuYWxseVxuICogbWFpbnRhaW5lZCBsaWJyYXJpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0VVJJOiByZXF1aXJlKCcuL2xpYi9VUkknKSxcblx0QXV0aG9yaXR5OiByZXF1aXJlKCcuL2xpYi9BdXRob3JpdHknKSxcblx0VXNlckluZm86IHJlcXVpcmUoJy4vbGliL1VzZXJJbmZvJyksXG5cdFF1ZXJ5OiByZXF1aXJlKCcuL2xpYi9RdWVyeScpXG59OyIsIi8qXG4gKiBjYXRiZXJyeS11cmlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeS11cmkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5LXVyaSB0aGF0IGFyZSBub3QgZXh0ZXJuYWxseVxuICogbWFpbnRhaW5lZCBsaWJyYXJpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhvcml0eTtcblxudmFyIFVzZXJJbmZvID0gcmVxdWlyZSgnLi9Vc2VySW5mbycpLFxuXHRwZXJjZW50RW5jb2RpbmdIZWxwZXIgPSByZXF1aXJlKCcuL3BlcmNlbnRFbmNvZGluZ0hlbHBlcicpO1xuXG52YXIgUE9SVF9SRUdFWFAgPSAvXlxcZCskLyxcblx0RVJST1JfUE9SVCA9ICdVUkkgYXV0aG9yaXR5IHBvcnQgbXVzdCBzYXRpc2Z5IGV4cHJlc3Npb24gJyArXG5cdFx0UE9SVF9SRUdFWFAudG9TdHJpbmcoKTtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBVUkkgYXV0aG9yaXR5IGNvbXBvbmVudCBwYXJzZXIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMlxuICogQHBhcmFtIHtzdHJpbmc/fSBhdXRob3JpdHlTdHJpbmcgVVJJIGF1dGhvcml0eSBjb21wb25lbnQgc3RyaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF1dGhvcml0eShhdXRob3JpdHlTdHJpbmcpIHtcblx0aWYgKHR5cGVvZiAoYXV0aG9yaXR5U3RyaW5nKSA9PT0gJ3N0cmluZycgJiYgYXV0aG9yaXR5U3RyaW5nLmxlbmd0aCA+IDApIHtcblx0XHR2YXIgZmlyc3RBdEluZGV4ID0gYXV0aG9yaXR5U3RyaW5nLmluZGV4T2YoJ0AnKTtcblx0XHRpZiAoZmlyc3RBdEluZGV4ICE9PSAtMSkge1xuXHRcdFx0dmFyIHVzZXJJbmZvU3RyaW5nID0gYXV0aG9yaXR5U3RyaW5nLnN1YnN0cmluZygwLCBmaXJzdEF0SW5kZXgpO1xuXHRcdFx0dGhpcy51c2VySW5mbyA9IG5ldyBVc2VySW5mbyh1c2VySW5mb1N0cmluZyk7XG5cdFx0XHRhdXRob3JpdHlTdHJpbmcgPSBhdXRob3JpdHlTdHJpbmcuc3Vic3RyaW5nKGZpcnN0QXRJbmRleCArIDEpO1xuXHRcdH1cblxuXHRcdHZhciBsYXN0Q29sb25JbmRleCA9IGF1dGhvcml0eVN0cmluZy5sYXN0SW5kZXhPZignOicpO1xuXHRcdGlmIChsYXN0Q29sb25JbmRleCAhPT0gLTEpIHtcblx0XHRcdHZhciBwb3J0U3RyaW5nID0gYXV0aG9yaXR5U3RyaW5nLnN1YnN0cmluZyhsYXN0Q29sb25JbmRleCArIDEpO1xuXHRcdFx0aWYgKGxhc3RDb2xvbkluZGV4ID09PSBhdXRob3JpdHlTdHJpbmcubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHR0aGlzLnBvcnQgPSAnJztcblx0XHRcdFx0YXV0aG9yaXR5U3RyaW5nID0gYXV0aG9yaXR5U3RyaW5nLnN1YnN0cmluZygwLCBsYXN0Q29sb25JbmRleCk7XG5cdFx0XHR9IGVsc2UgaWYgKFBPUlRfUkVHRVhQLnRlc3QocG9ydFN0cmluZykpIHtcblx0XHRcdFx0dGhpcy5wb3J0ID0gcG9ydFN0cmluZztcblx0XHRcdFx0YXV0aG9yaXR5U3RyaW5nID0gYXV0aG9yaXR5U3RyaW5nLnN1YnN0cmluZygwLCBsYXN0Q29sb25JbmRleCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5ob3N0ID0gcGVyY2VudEVuY29kaW5nSGVscGVyLmRlY29kZShhdXRob3JpdHlTdHJpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQ3VycmVudCB1c2VyIGluZm9ybWF0aW9uLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjIuMVxuICogQHR5cGUge1VzZXJJbmZvfVxuICovXG5BdXRob3JpdHkucHJvdG90eXBlLnVzZXJJbmZvID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IGhvc3QuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMi4yXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5BdXRob3JpdHkucHJvdG90eXBlLmhvc3QgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgcG9ydC5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4yLjNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbkF1dGhvcml0eS5wcm90b3R5cGUucG9ydCA9IG51bGw7XG5cbi8qKlxuICogQ2xvbmVzIGN1cnJlbnQgYXV0aG9yaXR5LlxuICogQHJldHVybnMge0F1dGhvcml0eX0gTmV3IGNsb25lIG9mIGN1cnJlbnQgb2JqZWN0LlxuICovXG5BdXRob3JpdHkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgYXV0aG9yaXR5ID0gbmV3IEF1dGhvcml0eSgpO1xuXHRpZiAodGhpcy51c2VySW5mbykge1xuXHRcdGF1dGhvcml0eS51c2VySW5mbyA9IHRoaXMudXNlckluZm8uY2xvbmUoKTtcblx0fVxuXHRpZiAodHlwZW9mICh0aGlzLmhvc3QpID09PSAnc3RyaW5nJykge1xuXHRcdGF1dGhvcml0eS5ob3N0ID0gdGhpcy5ob3N0O1xuXHR9XG5cdGlmICh0eXBlb2YgKHRoaXMucG9ydCkgPT09ICdzdHJpbmcnKSB7XG5cdFx0YXV0aG9yaXR5LnBvcnQgPSB0aGlzLnBvcnQ7XG5cdH1cblx0cmV0dXJuIGF1dGhvcml0eTtcbn07XG5cbi8qKlxuICogUmVjb21iaW5lIGFsbCBhdXRob3JpdHkgY29tcG9uZW50cyBpbnRvIGF1dGhvcml0eSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBdXRob3JpdHkgY29tcG9uZW50IHN0cmluZy5cbiAqL1xuQXV0aG9yaXR5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHJlc3VsdCA9ICcnO1xuXHRpZiAodGhpcy51c2VySW5mbykge1xuXHRcdHJlc3VsdCArPSB0aGlzLnVzZXJJbmZvLnRvU3RyaW5nKCkgKyAnQCc7XG5cdH1cblx0aWYgKHRoaXMuaG9zdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaG9zdCAhPT0gbnVsbCkge1xuXHRcdHZhciBob3N0ID0gU3RyaW5nKHRoaXMuaG9zdCk7XG5cdFx0cmVzdWx0ICs9IHBlcmNlbnRFbmNvZGluZ0hlbHBlci5lbmNvZGVIb3N0KGhvc3QpO1xuXHR9XG5cdGlmICh0aGlzLnBvcnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnBvcnQgIT09IG51bGwpIHtcblx0XHR2YXIgcG9ydCA9IFN0cmluZyh0aGlzLnBvcnQpO1xuXHRcdGlmIChwb3J0Lmxlbmd0aCA+IDAgJiYgIVBPUlRfUkVHRVhQLnRlc3QocG9ydCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJPUl9QT1JUKTtcblx0XHR9XG5cdFx0cmVzdWx0ICs9ICc6JyArIHBvcnQ7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07IiwiLypcbiAqIGNhdGJlcnJ5LXVyaVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBEZW5pcyBSZWNoa3Vub3YgYW5kIHByb2plY3QgY29udHJpYnV0b3JzLlxuICpcbiAqIGNhdGJlcnJ5LXVyaSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnktdXJpIHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5cbnZhciBwZXJjZW50RW5jb2RpbmdIZWxwZXIgPSByZXF1aXJlKCcuL3BlcmNlbnRFbmNvZGluZ0hlbHBlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFVSSSBxdWVyeSBjb21wb25lbnQgcGFyc2VyLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjRcbiAqIEBwYXJhbSB7c3RyaW5nP30gcXVlcnlTdHJpbmcgVVJJIHF1ZXJ5IGNvbXBvbmVudCBzdHJpbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUXVlcnkocXVlcnlTdHJpbmcpIHtcblx0aWYgKHR5cGVvZiAocXVlcnlTdHJpbmcpID09PSAnc3RyaW5nJykge1xuXHRcdHRoaXMudmFsdWVzID0ge307XG5cblx0XHRxdWVyeVN0cmluZ1xuXHRcdFx0LnNwbGl0KCcmJylcblx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IHBhaXIuc3BsaXQoJz0nKSxcblx0XHRcdFx0XHRrZXkgPSBwZXJjZW50RW5jb2RpbmdIZWxwZXIuZGVjb2RlKHBhcnRzWzBdKTtcblx0XHRcdFx0aWYgKCFrZXkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGtleSBpbiB0aGlzLnZhbHVlcyAmJlxuXHRcdFx0XHRcdCEodGhpcy52YWx1ZXNba2V5XSBpbnN0YW5jZW9mIEFycmF5KSkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzW2tleV0gPSBbdGhpcy52YWx1ZXNba2V5XV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmFsdWUgPSB0eXBlb2YgKHBhcnRzWzFdKSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdHBlcmNlbnRFbmNvZGluZ0hlbHBlci5kZWNvZGUocGFydHNbMV0pIDogbnVsbDtcblxuXHRcdFx0XHRpZiAodGhpcy52YWx1ZXNba2V5XSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZXNba2V5XS5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpO1xuXHR9XG59XG5cbi8qKlxuICogQ3VycmVudCBzZXQgb2YgdmFsdWVzIG9mIHF1ZXJ5LlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnZhbHVlcyA9IG51bGw7XG5cbi8qKlxuICogQ2xvbmVzIGN1cnJlbnQgcXVlcnkgdG8gYSBuZXcgb2JqZWN0LlxuICogQHJldHVybnMge1F1ZXJ5fSBOZXcgY2xvbmUgb2YgY3VycmVudCBvYmplY3QuXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG5cdGlmICh0aGlzLnZhbHVlcykge1xuXHRcdHF1ZXJ5LnZhbHVlcyA9IHt9O1xuXHRcdE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKVxuXHRcdFx0LmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRxdWVyeS52YWx1ZXNba2V5XSA9IHRoaXMudmFsdWVzW2tleV07XG5cdFx0XHR9LCB0aGlzKTtcblx0fVxuXHRyZXR1cm4gcXVlcnk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGN1cnJlbnQgc2V0IG9mIHF1ZXJ5IHZhbHVlcyB0byBzdHJpbmcuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBRdWVyeSBjb21wb25lbnQgc3RyaW5nLlxuICovXG5RdWVyeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICghdGhpcy52YWx1ZXMpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHR2YXIgcXVlcnlTdHJpbmcgPSAnJztcblx0T2JqZWN0LmtleXModGhpcy52YWx1ZXMpXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzW2tleV0gaW5zdGFuY2VvZiBBcnJheSA/XG5cdFx0XHRcdHRoaXMudmFsdWVzW2tleV0gOiBbdGhpcy52YWx1ZXNba2V5XV07XG5cblx0XHRcdHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdFx0XHRxdWVyeVN0cmluZyArPSAnJicgKyBwZXJjZW50RW5jb2RpbmdIZWxwZXJcblx0XHRcdFx0XHQuZW5jb2RlUXVlcnlTdWJDb21wb25lbnQoa2V5KTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXHRcdFx0XHRxdWVyeVN0cmluZyArPSAnPScgK1xuXHRcdFx0XHRcdHBlcmNlbnRFbmNvZGluZ0hlbHBlci5lbmNvZGVRdWVyeVN1YkNvbXBvbmVudCh2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHR9LCB0aGlzKTtcblxuXHRyZXR1cm4gcXVlcnlTdHJpbmcucmVwbGFjZSgvXiYvLCAnJyk7XG59OyIsIi8qXG4gKiBjYXRiZXJyeVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBEZW5pcyBSZWNoa3Vub3YgYW5kIHByb2plY3QgY29udHJpYnV0b3JzLlxuICpcbiAqIGNhdGJlcnJ5J3MgbGljZW5zZSBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgbGljZW5zZSBhcHBsaWVzIHRvIGFsbCBwYXJ0cyBvZiBjYXRiZXJyeSB0aGF0IGFyZSBub3QgZXh0ZXJuYWxseVxuICogbWFpbnRhaW5lZCBsaWJyYXJpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVSSTtcblxudmFyIEF1dGhvcml0eSA9IHJlcXVpcmUoJy4vQXV0aG9yaXR5JyksXG5cdHBlcmNlbnRFbmNvZGluZ0hlbHBlciA9IHJlcXVpcmUoJy4vcGVyY2VudEVuY29kaW5nSGVscGVyJyksXG5cdFF1ZXJ5ID0gcmVxdWlyZSgnLi9RdWVyeScpO1xuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1CXG52YXIgVVJJX1BBUlNFX1JFR0VYUCA9IG5ldyBSZWdFeHAoXG5cdFx0J14oKFteOi8/I10rKTopPygvLyhbXi8/I10qKSk/KFtePyNdKikoXFxcXD8oW14jXSopKT8oIyguKikpPydcblx0KSxcblx0Ly8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjFcblx0U0NIRU1FX1JFR0VYUCA9IC9eW2Etel0rW2EtelxcZFxcK1xcLi1dKiQvaSxcblx0RVJST1JfU0NIRU1FID0gJ1VSSSBzY2hlbWUgbXVzdCBzYXRpc2Z5IGV4cHJlc3Npb24gJyArXG5cdFx0U0NIRU1FX1JFR0VYUC50b1N0cmluZygpLFxuXHRFUlJPUl9CQVNFX1NDSEVNRSA9ICdTY2hlbWUgY29tcG9uZW50IGlzIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgJyArXG5cdFx0J2luIGEgYmFzZSBVUkknO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIFVSSSBhY2NvcmRpbmcgdG8gUkZDIDM5ODYuXG4gKiBAcGFyYW0ge3N0cmluZz99IHVyaVN0cmluZyBVUkkgc3RyaW5nIHRvIHBhcnNlIGNvbXBvbmVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVVJJKHVyaVN0cmluZykge1xuXHRpZiAodHlwZW9mICh1cmlTdHJpbmcpICE9PSAnc3RyaW5nJykge1xuXHRcdHVyaVN0cmluZyA9ICcnO1xuXHR9XG5cblx0Ly8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQlxuXHR2YXIgbWF0Y2hlcyA9IHVyaVN0cmluZy5tYXRjaChVUklfUEFSU0VfUkVHRVhQKTtcblxuXHRpZiAobWF0Y2hlcykge1xuXHRcdGlmICh0eXBlb2YgKG1hdGNoZXNbMl0pID09PSAnc3RyaW5nJykge1xuXHRcdFx0dGhpcy5zY2hlbWUgPSBwZXJjZW50RW5jb2RpbmdIZWxwZXIuZGVjb2RlKG1hdGNoZXNbMl0pO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIChtYXRjaGVzWzRdKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRoaXMuYXV0aG9yaXR5ID0gbmV3IEF1dGhvcml0eShtYXRjaGVzWzRdKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiAobWF0Y2hlc1s1XSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aGlzLnBhdGggPSBwZXJjZW50RW5jb2RpbmdIZWxwZXIuZGVjb2RlUGF0aChtYXRjaGVzWzVdKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiAobWF0Y2hlc1s3XSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR0aGlzLnF1ZXJ5ID0gbmV3IFF1ZXJ5KG1hdGNoZXNbN10pO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIChtYXRjaGVzWzldKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBwZXJjZW50RW5jb2RpbmdIZWxwZXIuZGVjb2RlKG1hdGNoZXNbOV0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEN1cnJlbnQgVVJJIHNjaGVtZS5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5VUkkucHJvdG90eXBlLnNjaGVtZSA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBVUkkgYXV0aG9yaXR5LlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjJcbiAqIEB0eXBlIHtBdXRob3JpdHl9XG4gKi9cblVSSS5wcm90b3R5cGUuYXV0aG9yaXR5ID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IFVSSSBwYXRoLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblVSSS5wcm90b3R5cGUucGF0aCA9IG51bGw7XG5cbi8qKlxuICogQ3VycmVudCBVUkkgcXVlcnkuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuNFxuICogQHR5cGUge1F1ZXJ5fVxuICovXG5VUkkucHJvdG90eXBlLnF1ZXJ5ID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IFVSSSBmcmFnbWVudC5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy41XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5VUkkucHJvdG90eXBlLmZyYWdtZW50ID0gbnVsbDtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFVSSSByZWZlcmVuY2UgdGhhdCBtaWdodCBiZSByZWxhdGl2ZSB0byBhIGdpdmVuIGJhc2UgVVJJXG4gKiBpbnRvIHRoZSByZWZlcmVuY2UncyB0YXJnZXQgVVJJLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjJcbiAqIEBwYXJhbSB7VVJJfSBiYXNlVXJpIEJhc2UgVVJJLlxuICogQHJldHVybnMge1VSSX0gUmVzb2x2ZWQgVVJJLlxuICovXG5VUkkucHJvdG90eXBlLnJlc29sdmVSZWxhdGl2ZSA9IGZ1bmN0aW9uIChiYXNlVXJpKSB7XG5cdGlmICghYmFzZVVyaS5zY2hlbWUpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoRVJST1JfQkFTRV9TQ0hFTUUpO1xuXHR9XG5cblx0cmV0dXJuIHRyYW5zZm9ybVJlZmVyZW5jZShiYXNlVXJpLCB0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvbmVzIGN1cnJlbnQgVVJJIHRvIGEgbmV3IG9iamVjdC5cbiAqIEByZXR1cm5zIHtVUkl9IE5ldyBjbG9uZSBvZiBjdXJyZW50IG9iamVjdC5cbiAqL1xuVVJJLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHVyaSA9IG5ldyBVUkkoKTtcblxuXHRpZiAodHlwZW9mICh0aGlzLnNjaGVtZSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0dXJpLnNjaGVtZSA9IHRoaXMuc2NoZW1lO1xuXHR9XG5cblx0aWYgKHRoaXMuYXV0aG9yaXR5KSB7XG5cdFx0dXJpLmF1dGhvcml0eSA9IHRoaXMuYXV0aG9yaXR5LmNsb25lKCk7XG5cdH1cblxuXHRpZiAodHlwZW9mICh0aGlzLnBhdGgpID09PSAnc3RyaW5nJykge1xuXHRcdHVyaS5wYXRoID0gdGhpcy5wYXRoO1xuXHR9XG5cblx0aWYgKHRoaXMucXVlcnkpIHtcblx0XHR1cmkucXVlcnkgPSB0aGlzLnF1ZXJ5LmNsb25lKCk7XG5cdH1cblxuXHRpZiAodHlwZW9mICh0aGlzLmZyYWdtZW50KSA9PT0gJ3N0cmluZycpIHtcblx0XHR1cmkuZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xuXHR9XG5cblx0cmV0dXJuIHVyaTtcbn07XG5cbi8qKlxuICogUmVjb21wb3NlcyBVUkkgY29tcG9uZW50cyB0byBVUkkgc3RyaW5nLFxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjNcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVSSSBzdHJpbmcuXG4gKi9cblVSSS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciByZXN1bHQgPSAnJztcblxuXHRpZiAodGhpcy5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNjaGVtZSAhPT0gbnVsbCkge1xuXHRcdHZhciBzY2hlbWUgPSBTdHJpbmcodGhpcy5zY2hlbWUpO1xuXHRcdGlmICghU0NIRU1FX1JFR0VYUC50ZXN0KHNjaGVtZSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihFUlJPUl9TQ0hFTUUpO1xuXHRcdH1cblx0XHRyZXN1bHQgKz0gc2NoZW1lICsgJzonO1xuXHR9XG5cblx0aWYgKHRoaXMuYXV0aG9yaXR5KSB7XG5cdFx0cmVzdWx0ICs9ICcvLycgKyB0aGlzLmF1dGhvcml0eS50b1N0cmluZygpO1xuXHR9XG5cblx0dmFyIHBhdGggPSB0aGlzLnBhdGggPT09IHVuZGVmaW5lZCB8fCB0aGlzLnBhdGggPT09IG51bGwgP1xuXHRcdCcnIDogU3RyaW5nKHRoaXMucGF0aCk7XG5cdHJlc3VsdCArPSBwZXJjZW50RW5jb2RpbmdIZWxwZXIuZW5jb2RlUGF0aChwYXRoKTtcblxuXHRpZiAodGhpcy5xdWVyeSkge1xuXHRcdHJlc3VsdCArPSAnPycgKyB0aGlzLnF1ZXJ5LnRvU3RyaW5nKCk7XG5cdH1cblxuXHRpZiAodGhpcy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSBTdHJpbmcodGhpcy5mcmFnbWVudCk7XG5cdFx0cmVzdWx0ICs9ICcjJyArIHBlcmNlbnRFbmNvZGluZ0hlbHBlci5lbmNvZGVGcmFnbWVudChmcmFnbWVudCk7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHJlZmVyZW5jZSBmb3IgcmVsYXRpdmUgcmVzb2x1dGlvbi5cbiAqIFdob2xlIGFsZ29yaXRobSBoYXMgYmVlbiB0YWtlbiBmcm9tXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi4yXG4gKiBAcGFyYW0ge1VSSX0gYmFzZVVyaSBCYXNlIFVSSSBmb3IgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7VVJJfSByZWZlcmVuY2VVcmkgUmVmZXJlbmNlIFVSSSB0byByZXNvbHZlLlxuICogQHJldHVybnMge1VSSX0gQ29tcG9uZW50cyBvZiB0YXJnZXQgVVJJLlxuICovXG4vKmpzaGludCBtYXhkZXB0aDpmYWxzZSAqL1xuLypqc2hpbnQgbWF4Y29tcGxleGl0eTpmYWxzZSAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtUmVmZXJlbmNlKGJhc2VVcmksIHJlZmVyZW5jZVVyaSkge1xuXHR2YXIgdGFyZ2V0VXJpID0gbmV3IFVSSSgnJyk7XG5cblx0aWYgKHJlZmVyZW5jZVVyaS5zY2hlbWUpIHtcblx0XHR0YXJnZXRVcmkuc2NoZW1lID0gcmVmZXJlbmNlVXJpLnNjaGVtZTtcblx0XHR0YXJnZXRVcmkuYXV0aG9yaXR5ID0gcmVmZXJlbmNlVXJpLmF1dGhvcml0eSA/XG5cdFx0XHRyZWZlcmVuY2VVcmkuYXV0aG9yaXR5LmNsb25lKCkgOiByZWZlcmVuY2VVcmkuYXV0aG9yaXR5O1xuXHRcdHRhcmdldFVyaS5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVmZXJlbmNlVXJpLnBhdGgpO1xuXHRcdHRhcmdldFVyaS5xdWVyeSA9IHJlZmVyZW5jZVVyaS5xdWVyeSA/XG5cdFx0XHRyZWZlcmVuY2VVcmkucXVlcnkuY2xvbmUoKSA6IHJlZmVyZW5jZVVyaS5xdWVyeTtcblx0fSBlbHNlIHtcblx0XHRpZiAocmVmZXJlbmNlVXJpLmF1dGhvcml0eSkge1xuXHRcdFx0dGFyZ2V0VXJpLmF1dGhvcml0eSA9IHJlZmVyZW5jZVVyaS5hdXRob3JpdHkgP1xuXHRcdFx0XHRyZWZlcmVuY2VVcmkuYXV0aG9yaXR5LmNsb25lKCkgOiByZWZlcmVuY2VVcmkuYXV0aG9yaXR5O1xuXHRcdFx0dGFyZ2V0VXJpLnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWZlcmVuY2VVcmkucGF0aCk7XG5cdFx0XHR0YXJnZXRVcmkucXVlcnkgPSByZWZlcmVuY2VVcmkucXVlcnkgP1xuXHRcdFx0XHRyZWZlcmVuY2VVcmkucXVlcnkuY2xvbmUoKSA6IHJlZmVyZW5jZVVyaS5xdWVyeTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHJlZmVyZW5jZVVyaS5wYXRoID09PSAnJykge1xuXHRcdFx0XHR0YXJnZXRVcmkucGF0aCA9IGJhc2VVcmkucGF0aDtcblx0XHRcdFx0aWYgKHJlZmVyZW5jZVVyaS5xdWVyeSkge1xuXHRcdFx0XHRcdHRhcmdldFVyaS5xdWVyeSA9IHJlZmVyZW5jZVVyaS5xdWVyeS5jbG9uZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFVyaS5xdWVyeSA9IGJhc2VVcmkucXVlcnkgP1xuXHRcdFx0XHRcdFx0YmFzZVVyaS5xdWVyeS5jbG9uZSgpIDogYmFzZVVyaS5xdWVyeTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlZmVyZW5jZVVyaS5wYXRoWzBdID09PSAnLycpIHtcblx0XHRcdFx0XHR0YXJnZXRVcmkucGF0aCA9XG5cdFx0XHRcdFx0XHRyZW1vdmVEb3RTZWdtZW50cyhyZWZlcmVuY2VVcmkucGF0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0VXJpLnBhdGggPVxuXHRcdFx0XHRcdFx0bWVyZ2UoYmFzZVVyaSwgcmVmZXJlbmNlVXJpKTtcblx0XHRcdFx0XHR0YXJnZXRVcmkucGF0aCA9XG5cdFx0XHRcdFx0XHRyZW1vdmVEb3RTZWdtZW50cyh0YXJnZXRVcmkucGF0aCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGFyZ2V0VXJpLnF1ZXJ5ID0gcmVmZXJlbmNlVXJpLnF1ZXJ5ID9cblx0XHRcdFx0XHRyZWZlcmVuY2VVcmkucXVlcnkuY2xvbmUoKSA6IHJlZmVyZW5jZVVyaS5xdWVyeTtcblx0XHRcdH1cblx0XHRcdHRhcmdldFVyaS5hdXRob3JpdHkgPSBiYXNlVXJpLmF1dGhvcml0eSA/XG5cdFx0XHRcdGJhc2VVcmkuYXV0aG9yaXR5LmNsb25lKCkgOiBiYXNlVXJpLmF1dGhvcml0eTtcblx0XHR9XG5cdFx0dGFyZ2V0VXJpLnNjaGVtZSA9IGJhc2VVcmkuc2NoZW1lO1xuXHR9XG5cblx0dGFyZ2V0VXJpLmZyYWdtZW50ID0gcmVmZXJlbmNlVXJpLmZyYWdtZW50O1xuXHRyZXR1cm4gdGFyZ2V0VXJpO1xufVxuXG4vKipcbiAqIE1lcmdlcyBhIHJlbGF0aXZlLXBhdGggcmVmZXJlbmNlIHdpdGggdGhlIHBhdGggb2YgdGhlIGJhc2UgVVJJLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjIuM1xuICogQHBhcmFtIHtVUkl9IGJhc2VVcmkgQ29tcG9uZW50cyBvZiBiYXNlIFVSSS5cbiAqIEBwYXJhbSB7VVJJfSByZWZlcmVuY2VVcmkgQ29tcG9uZW50cyBvZiByZWZlcmVuY2UgVVJJLlxuICogQHJldHVybnMge3N0cmluZ30gTWVyZ2VkIHBhdGguXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGJhc2VVcmksIHJlZmVyZW5jZVVyaSkge1xuXHRpZiAoYmFzZVVyaS5hdXRob3JpdHkgJiYgYmFzZVVyaS5wYXRoID09PSAnJykge1xuXHRcdHJldHVybiAnLycgKyByZWZlcmVuY2VVcmkucGF0aDtcblx0fVxuXG5cdHZhciBzZWdtZW50c1N0cmluZyA9IGJhc2VVcmkucGF0aC5pbmRleE9mKCcvJykgIT09IC0xID9cblx0XHRiYXNlVXJpLnBhdGgucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnLycpIDogJyc7XG5cblx0cmV0dXJuIHNlZ21lbnRzU3RyaW5nICsgcmVmZXJlbmNlVXJpLnBhdGg7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBkb3RzIHNlZ21lbnRzIGZyb20gVVJJIHBhdGguXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi40XG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpUGF0aCBVUkkgcGF0aCB3aXRoIHBvc3NpYmxlIGRvdCBzZWdtZW50cy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVSSSBwYXRoIHdpdGhvdXQgZG90IHNlZ21lbnRzLlxuICovXG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyh1cmlQYXRoKSB7XG5cdGlmICghdXJpUGF0aCkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdHZhciBpbnB1dEJ1ZmZlciA9IHVyaVBhdGgsXG5cdFx0bmV3QnVmZmVyID0gJycsXG5cdFx0bmV4dFNlZ21lbnQgPSAnJyxcblx0XHRvdXRwdXRCdWZmZXIgPSAnJztcblxuXHR3aGlsZSAoaW5wdXRCdWZmZXIubGVuZ3RoICE9PSAwKSB7XG5cblx0XHQvLyBJZiB0aGUgaW5wdXQgYnVmZmVyIGJlZ2lucyB3aXRoIGEgcHJlZml4IG9mIFwiLi4vXCIgb3IgXCIuL1wiLFxuXHRcdC8vIHRoZW4gcmVtb3ZlIHRoYXQgcHJlZml4IGZyb20gdGhlIGlucHV0IGJ1ZmZlclxuXHRcdG5ld0J1ZmZlciA9IGlucHV0QnVmZmVyLnJlcGxhY2UoL15cXC4/XFwuXFwvLywgJycpO1xuXHRcdGlmIChuZXdCdWZmZXIgIT09IGlucHV0QnVmZmVyKSB7XG5cdFx0XHRpbnB1dEJ1ZmZlciA9IG5ld0J1ZmZlcjtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdC8vIGlmIHRoZSBpbnB1dCBidWZmZXIgYmVnaW5zIHdpdGggYSBwcmVmaXggb2YgXCIvLi9cIiBvciBcIi8uXCIsXG5cdFx0Ly8gd2hlcmUgXCIuXCIgaXMgYSBjb21wbGV0ZSBwYXRoIHNlZ21lbnQsIHRoZW4gcmVwbGFjZSB0aGF0XG5cdFx0Ly8gcHJlZml4IHdpdGggXCIvXCIgaW4gdGhlIGlucHV0IGJ1ZmZlclxuXHRcdG5ld0J1ZmZlciA9IGlucHV0QnVmZmVyLnJlcGxhY2UoL14oKFxcL1xcLlxcLyl8KFxcL1xcLiQpKS8sICcvJyk7XG5cdFx0aWYgKG5ld0J1ZmZlciAhPT0gaW5wdXRCdWZmZXIpIHtcblx0XHRcdGlucHV0QnVmZmVyID0gbmV3QnVmZmVyO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIGlucHV0IGJ1ZmZlciBiZWdpbnMgd2l0aCBhIHByZWZpeCBvZiBcIi8uLi9cIiBvciBcIi8uLlwiLFxuXHRcdC8vIHdoZXJlIFwiLi5cIiBpcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCwgdGhlbiByZXBsYWNlIHRoYXRcblx0XHQvLyBwcmVmaXggd2l0aCBcIi9cIiBpbiB0aGUgaW5wdXQgYnVmZmVyIGFuZCByZW1vdmUgdGhlIGxhc3Rcblx0XHQvLyBzZWdtZW50IGFuZCBpdHMgcHJlY2VkaW5nIFwiL1wiIChpZiBhbnkpIGZyb20gdGhlIG91dHB1dFxuXHRcdC8vIGJ1ZmZlclxuXHRcdG5ld0J1ZmZlciA9IGlucHV0QnVmZmVyLnJlcGxhY2UoL14oKFxcL1xcLlxcLlxcLyl8KFxcL1xcLlxcLiQpKS8sICcvJyk7XG5cdFx0aWYgKG5ld0J1ZmZlciAhPT0gaW5wdXRCdWZmZXIpIHtcblx0XHRcdG91dHB1dEJ1ZmZlciA9IG91dHB1dEJ1ZmZlci5yZXBsYWNlKC9cXC9bXlxcL10rJC8sICcnKTtcblx0XHRcdGlucHV0QnVmZmVyID0gbmV3QnVmZmVyO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIGlucHV0IGJ1ZmZlciBjb25zaXN0cyBvbmx5IG9mIFwiLlwiIG9yIFwiLi5cIiwgdGhlbiByZW1vdmVcblx0XHQvLyB0aGF0IGZyb20gdGhlIGlucHV0IGJ1ZmZlclxuXHRcdGlmIChpbnB1dEJ1ZmZlciA9PT0gJy4nIHx8IGlucHV0QnVmZmVyID09PSAnLi4nKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHQvLyBtb3ZlIHRoZSBmaXJzdCBwYXRoIHNlZ21lbnQgaW4gdGhlIGlucHV0IGJ1ZmZlciB0byB0aGUgZW5kIG9mXG5cdFx0Ly8gdGhlIG91dHB1dCBidWZmZXIsIGluY2x1ZGluZyB0aGUgaW5pdGlhbCBcIi9cIiBjaGFyYWN0ZXIgKGlmXG5cdFx0Ly8gYW55KSBhbmQgYW55IHN1YnNlcXVlbnQgY2hhcmFjdGVycyB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsXG5cdFx0Ly8gdGhlIG5leHQgXCIvXCIgY2hhcmFjdGVyIG9yIHRoZSBlbmQgb2YgdGhlIGlucHV0IGJ1ZmZlclxuXHRcdG5leHRTZWdtZW50ID0gL15cXC8/W15cXC9dKihcXC98JCkvLmV4ZWMoaW5wdXRCdWZmZXIpWzBdO1xuXHRcdG5leHRTZWdtZW50ID0gbmV4dFNlZ21lbnQucmVwbGFjZSgvKFteXFwvXSkoXFwvJCkvLCAnJDEnKTtcblx0XHRpbnB1dEJ1ZmZlciA9IGlucHV0QnVmZmVyLnN1YnN0cmluZyhuZXh0U2VnbWVudC5sZW5ndGgpO1xuXHRcdG91dHB1dEJ1ZmZlciArPSBuZXh0U2VnbWVudDtcblx0fVxuXG5cdHJldHVybiBvdXRwdXRCdWZmZXI7XG59IiwiLypcbiAqIGNhdGJlcnJ5LXVyaVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBEZW5pcyBSZWNoa3Vub3YgYW5kIHByb2plY3QgY29udHJpYnV0b3JzLlxuICpcbiAqIGNhdGJlcnJ5LXVyaSdzIGxpY2Vuc2UgZm9sbG93czpcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4gKiBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKiBUaGlzIGxpY2Vuc2UgYXBwbGllcyB0byBhbGwgcGFydHMgb2YgY2F0YmVycnktdXJpIHRoYXQgYXJlIG5vdCBleHRlcm5hbGx5XG4gKiBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVXNlckluZm87XG5cbnZhciBwZXJjZW50RW5jb2RpbmdIZWxwZXIgPSByZXF1aXJlKCcuL3BlcmNlbnRFbmNvZGluZ0hlbHBlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgbmV3IGluc3RhbmNlIG9mIHVzZXIgaW5mb3JtYXRpb24gY29tcG9uZW50IHBhcnNlci5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4yLjFcbiAqIEBwYXJhbSB7c3RyaW5nP30gdXNlckluZm9TdHJpbmcgVXNlciBpbmZvcm1hdGlvbiBjb21wb25lbnQgc3RyaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFVzZXJJbmZvKHVzZXJJbmZvU3RyaW5nKSB7XG5cdGlmICh0eXBlb2YgKHVzZXJJbmZvU3RyaW5nKSA9PT0gJ3N0cmluZycgJiYgdXNlckluZm9TdHJpbmcubGVuZ3RoID4gMCkge1xuXHRcdHZhciBwYXJ0cyA9IHVzZXJJbmZvU3RyaW5nLnNwbGl0KCc6Jyk7XG5cdFx0aWYgKHR5cGVvZiAocGFydHNbMF0pID09PSAnc3RyaW5nJykge1xuXHRcdFx0dGhpcy51c2VyID0gcGVyY2VudEVuY29kaW5nSGVscGVyLmRlY29kZShwYXJ0c1swXSk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgKHBhcnRzWzFdKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRoaXMucGFzc3dvcmQgPSBwZXJjZW50RW5jb2RpbmdIZWxwZXIuZGVjb2RlKHBhcnRzWzFdKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBDdXJyZW50IHVzZXIgY29tcG9uZW50LlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuVXNlckluZm8ucHJvdG90eXBlLnVzZXIgPSBudWxsO1xuXG4vKipcbiAqIEN1cnJlbnQgcGFzc3dvcmQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5Vc2VySW5mby5wcm90b3R5cGUucGFzc3dvcmQgPSBudWxsO1xuXG4vKipcbiAqIENsb25lcyBjdXJyZW50IHVzZXIgaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJucyB7VXNlckluZm99IE5ldyBjbG9uZSBvZiBjdXJyZW50IG9iamVjdC5cbiAqL1xuVXNlckluZm8ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgdXNlckluZm8gPSBuZXcgVXNlckluZm8oKTtcblx0aWYgKHR5cGVvZiAodGhpcy51c2VyKSA9PT0gJ3N0cmluZycpIHtcblx0XHR1c2VySW5mby51c2VyID0gdGhpcy51c2VyO1xuXHR9XG5cdGlmICh0eXBlb2YgKHRoaXMucGFzc3dvcmQpID09PSAnc3RyaW5nJykge1xuXHRcdHVzZXJJbmZvLnBhc3N3b3JkID0gdGhpcy5wYXNzd29yZDtcblx0fVxuXHRyZXR1cm4gdXNlckluZm87XG59O1xuXG4vKipcbiAqIFJlY29tYmluZXMgdXNlciBpbmZvcm1hdGlvbiBjb21wb25lbnRzIHRvIHVzZXJJbmZvIHN0cmluZy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVzZXIgaW5mb3JtYXRpb24gY29tcG9uZW50IHN0cmluZy5cbiAqL1xuVXNlckluZm8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmVzdWx0ID0gJyc7XG5cdGlmICh0aGlzLnVzZXIgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnVzZXIgIT09IG51bGwpIHtcblx0XHR2YXIgdXNlciA9IFN0cmluZyh0aGlzLnVzZXIpO1xuXHRcdHJlc3VsdCArPSBwZXJjZW50RW5jb2RpbmdIZWxwZXJcblx0XHRcdC5lbmNvZGVVc2VySW5mb1N1YkNvbXBvbmVudCh1c2VyKTtcblx0fVxuXHRpZiAodGhpcy5wYXNzd29yZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucGFzc3dvcmQgIT09IG51bGwpIHtcblx0XHR2YXIgcGFzc3dvcmQgPSBTdHJpbmcodGhpcy5wYXNzd29yZCk7XG5cdFx0cmVzdWx0ICs9ICc6JyArIHBlcmNlbnRFbmNvZGluZ0hlbHBlclxuXHRcdFx0LmVuY29kZVVzZXJJbmZvU3ViQ29tcG9uZW50KHBhc3N3b3JkKTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59OyIsIi8qXG4gKiBjYXRiZXJyeS11cmlcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeS11cmkncyBsaWNlbnNlIGZvbGxvd3M6XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogVGhpcyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIGNhdGJlcnJ5LXVyaSB0aGF0IGFyZSBub3QgZXh0ZXJuYWxseVxuICogbWFpbnRhaW5lZCBsaWJyYXJpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTIuMVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Ly8gXFx1RDgwMC1cXHVEQkZGIFxcdURDMDAtXFx1REZGRlxuXHQvLyBzdXJyb2dhdGVzIHBhaXJzIGxpa2UgZW1vamkgd2Ugc2hvdWxkIGlnbm9yZVxuXHQvKipcblx0ICogRW5jb2RlcyBhdXRob3JpdHkgdXNlciBpbmZvcm1hdGlvbiBzdWItY29tcG9uZW50IGFjY29yZGluZyB0byBSRkMgMzk4Ni5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBDb21wb25lbnQgdG8gZW5jb2RlLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBFbmNvZGVkIGNvbXBvbmVudC5cblx0ICovXG5cdGVuY29kZVVzZXJJbmZvU3ViQ29tcG9uZW50OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKFxuXHRcdFx0Ly8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjIuMVxuXHRcdFx0L1teXFx3XFwuflxcLSFcXCQmJ1xcKFxcKVxcKlxcKyw7PVxcdUQ4MDAtXFx1REJGRlxcdURDMDAtXFx1REZGRl0vZyxcblx0XHRcdGVuY29kZVVSSUNvbXBvbmVudFxuXHRcdCk7XG5cdH0sXG5cdC8qKlxuXHQgKiBFbmNvZGVzIGF1dGhvcml0eSBob3N0IGNvbXBvbmVudCBhY2NvcmRpbmcgdG8gUkZDIDM5ODYuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQ29tcG9uZW50IHRvIGVuY29kZS5cblx0ICogQHJldHVybnMge3N0cmluZ30gRW5jb2RlZCBjb21wb25lbnQuXG5cdCAqL1xuXHRlbmNvZGVIb3N0OiBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKFxuXHRcdFx0Ly8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjIuMlxuXHRcdFx0L1teXFx3XFwuflxcLSFcXCQmJ1xcKFxcKVxcKlxcKyw7PTpcXFtcXF1cXHVEODAwLVxcdURCRkZcXHVEQzAwLVxcdURGRkZdL2csXG5cdFx0XHRlbmNvZGVVUklDb21wb25lbnRcblx0XHQpO1xuXHR9LFxuXHQvKipcblx0ICogRW5jb2RlcyBVUkkgcGF0aCBjb21wb25lbnQgYWNjb3JkaW5nIHRvIFJGQyAzOTg2LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIENvbXBvbmVudCB0byBlbmNvZGUuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEVuY29kZWQgY29tcG9uZW50LlxuXHQgKi9cblx0ZW5jb2RlUGF0aDogZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiBzdHJpbmcuc3BsaXQoLyUyZi9pKVxuXHRcdFx0Lm1hcChmdW5jdGlvbiAocGFydCkge1xuXHRcdFx0XHRyZXR1cm4gcGFydC5yZXBsYWNlKFxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4zXG5cdFx0XHRcdFx0L1teXFx3XFwuflxcLSFcXCQmJ1xcKFxcKVxcKlxcKyw7PTpAXFwvXFx1RDgwMC1cXHVEQkZGXFx1REMwMC1cXHVERkZGXS9nLFxuXHRcdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudFxuXHRcdFx0XHQpO1xuXHRcdFx0fSlcblx0XHRcdC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQpIHtcblx0XHRcdFx0aWYgKCFwcmV2KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1cnJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjdXJyZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByZXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByZXYgKyAnJTJGJyArIGN1cnJlbnQ7XG5cdFx0XHR9LCAnJyk7XG5cdH0sXG5cdC8qKlxuXHQgKiBFbmNvZGVzIHF1ZXJ5IHN1Yi1jb21wb25lbnQgYWNjb3JkaW5nIHRvIFJGQyAzOTg2LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIENvbXBvbmVudCB0byBlbmNvZGUuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEVuY29kZWQgY29tcG9uZW50LlxuXHQgKi9cblx0ZW5jb2RlUXVlcnlTdWJDb21wb25lbnQ6IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoXG5cdFx0XHQvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuNFxuXHRcdFx0L1teXFx3XFwuflxcLSFcXCQnXFwoXFwpXFwqXFwrLDs6QFxcL1xcP1xcdUQ4MDAtXFx1REJGRlxcdURDMDAtXFx1REZGRl0vZyxcblx0XHRcdGVuY29kZVVSSUNvbXBvbmVudFxuXHRcdCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEVuY29kZXMgVVJJIGZyYWdtZW50IGNvbXBvbmVudCBhY2NvcmRpbmcgdG8gUkZDIDM5ODYuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQ29tcG9uZW50IHRvIGVuY29kZS5cblx0ICogQHJldHVybnMge3N0cmluZ30gRW5jb2RlZCBjb21wb25lbnQuXG5cdCAqL1xuXHRlbmNvZGVGcmFnbWVudDogZnVuY3Rpb24gKHN0cmluZykge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZShcblx0XHRcdC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy41XG5cdFx0XHQvW15cXHdcXC5+XFwtIVxcJCYnXFwoXFwpXFwqXFwrLDs9OkBcXC9cXD9cXHVEODAwLVxcdURCRkZcXHVEQzAwLVxcdURGRkZdL2csXG5cdFx0XHRlbmNvZGVVUklDb21wb25lbnRcblx0XHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIHBlcmNlbnQgZW5jb2RlZCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQ29tcG9uZW50IHRvIGRlY29kZS5cblx0ICogQHJldHVybnMge3N0cmluZ30gRGVjb2RlZCBjb21wb25lbnQuXG5cdCAqL1xuXHRkZWNvZGU6IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0XHRyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cmluZyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlY29kZXMgcGVyY2VudCBlbmNvZGVkIHBhdGggY29tcG9uZW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIENvbXBvbmVudCB0byBkZWNvZGUuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IERlY29kZWQgcGF0aCBjb21wb25lbnQuXG5cdCAqL1xuXHRkZWNvZGVQYXRoOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5zcGxpdCgvJTJmL2kpXG5cdFx0XHQubWFwKGRlY29kZVVSSUNvbXBvbmVudClcblx0XHRcdC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cnJlbnQpIHtcblx0XHRcdFx0aWYgKCFwcmV2KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1cnJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFjdXJyZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByZXY7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByZXYgKyAnJTJGJyArIGN1cnJlbnQ7XG5cdFx0XHR9LCAnJyk7XG5cdH1cbn07IiwiLy8gQ3JlYXRlIGEgcmFuZ2Ugb2JqZWN0IGZvciBlZmZpY2VudGx5IHJlbmRlcmluZyBzdHJpbmdzIHRvIGVsZW1lbnRzLlxudmFyIHJhbmdlO1xuXG5mdW5jdGlvbiBlbXB0eShvKSB7XG4gICAgZm9yICh2YXIgayBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvRWxlbWVudChzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShkb2N1bWVudC5ib2R5KTtcbiAgICB9XG5cbiAgICB2YXIgZnJhZ21lbnQ7XG4gICAgaWYgKHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCkge1xuICAgICAgICBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYm9keScpO1xuICAgICAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBzdHI7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG52YXIgc3BlY2lhbEVsSGFuZGxlcnMgPSB7XG4gICAgLyoqXG4gICAgICogTmVlZGVkIGZvciBJRS4gQXBwYXJlbnRseSBJRSBkb2Vzbid0IHRoaW5rXG4gICAgICogdGhhdCBcInNlbGVjdGVkXCIgaXMgYW4gYXR0cmlidXRlIHdoZW4gcmVhZGluZ1xuICAgICAqIG92ZXIgdGhlIGF0dHJpYnV0ZXMgdXNpbmcgc2VsZWN0RWwuYXR0cmlidXRlc1xuICAgICAqL1xuICAgIE9QVElPTjogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGlmICgoZnJvbUVsLnNlbGVjdGVkID0gdG9FbC5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoZSBcInZhbHVlXCIgYXR0cmlidXRlIGlzIHNwZWNpYWwgZm9yIHRoZSA8aW5wdXQ+IGVsZW1lbnRcbiAgICAgKiBzaW5jZSBpdCBzZXRzIHRoZSBpbml0aWFsIHZhbHVlLiBDaGFuZ2luZyB0aGUgXCJ2YWx1ZVwiXG4gICAgICogYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlIFwidmFsdWVcIiBwcm9wZXJ0eSB3aWxsIGhhdmVcbiAgICAgKiBubyBlZmZlY3Qgc2luY2UgaXQgaXMgb25seSB1c2VkIHRvIHRoZSBzZXQgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogU2ltaWxhciBmb3IgdGhlIFwiY2hlY2tlZFwiIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBJTlBVVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGZyb21FbC5jaGVja2VkID0gdG9FbC5jaGVja2VkO1xuXG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT0gdG9FbC52YWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBURVhUQVJFQTogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb21FbC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBmcm9tRWwuZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vKipcbiAqIExvb3Agb3ZlciBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb24gdGhlIHRhcmdldCBub2RlIGFuZCBtYWtlIHN1cmUgdGhlXG4gKiBvcmlnaW5hbCBET00gbm9kZSBoYXMgdGhlIHNhbWUgYXR0cmlidXRlcy4gSWYgYW4gYXR0cmlidXRlXG4gKiBmb3VuZCBvbiB0aGUgb3JpZ2luYWwgbm9kZSBpcyBub3Qgb24gdGhlIG5ldyBub2RlIHRoZW4gcmVtb3ZlIGl0IGZyb21cbiAqIHRoZSBvcmlnaW5hbCBub2RlXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZnJvbU5vZGVcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSB0b05vZGVcbiAqL1xuZnVuY3Rpb24gbW9ycGhBdHRycyhmcm9tTm9kZSwgdG9Ob2RlKSB7XG4gICAgdmFyIGF0dHJzID0gdG9Ob2RlLmF0dHJpYnV0ZXM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGF0dHI7XG4gICAgdmFyIGF0dHJOYW1lO1xuICAgIHZhciBhdHRyVmFsdWU7XG4gICAgdmFyIGZvdW5kQXR0cnMgPSB7fTtcblxuICAgIGZvciAoaT1hdHRycy5sZW5ndGgtMTsgaT49MDsgaS0tKSB7XG4gICAgICAgIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgICAgaWYgKGF0dHIuc3BlY2lmaWVkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgICAgICBhdHRyVmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgZm91bmRBdHRyc1thdHRyTmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoZnJvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIGFueSBleHRyYSBhdHRyaWJ1dGVzIGZvdW5kIG9uIHRoZSBvcmlnaW5hbCBET00gZWxlbWVudCB0aGF0IHdlcmVuJ3RcbiAgICAvLyBmb3VuZCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgYXR0cnMgPSBmcm9tTm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yIChpPWF0dHJzLmxlbmd0aC0xOyBpPj0wOyBpLS0pIHtcbiAgICAgICAgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgICBpZiAoYXR0ci5zcGVjaWZpZWQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgICAgIGlmICghZm91bmRBdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIENvcGllcyB0aGUgY2hpbGRyZW4gb2Ygb25lIERPTSBlbGVtZW50IHRvIGFub3RoZXIgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgdG9FbC5hcHBlbmRDaGlsZChjdXJDaGlsZCk7XG4gICAgICAgIGN1ckNoaWxkID0gbmV4dENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdG9FbDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEdldE5vZGVLZXkobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlkO1xufVxuXG5mdW5jdGlvbiBtb3JwaGRvbShmcm9tTm9kZSwgdG9Ob2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRvTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9Ob2RlID0gdG9FbGVtZW50KHRvTm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIHNhdmVkRWxzID0ge307IC8vIFVzZWQgdG8gc2F2ZSBvZmYgRE9NIGVsZW1lbnRzIHdpdGggSURzXG4gICAgdmFyIHVubWF0Y2hlZEVscyA9IHt9O1xuICAgIHZhciBnZXROb2RlS2V5ID0gb3B0aW9ucy5nZXROb2RlS2V5IHx8IGRlZmF1bHRHZXROb2RlS2V5O1xuICAgIHZhciBvbk5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgIHZhciBvbkJlZm9yZU1vcnBoRWwgPSBvcHRpb25zLm9uQmVmb3JlTW9ycGhFbCB8fCBub29wO1xuICAgIHZhciBvbkJlZm9yZU1vcnBoRWxDaGlsZHJlbiA9IG9wdGlvbnMub25CZWZvcmVNb3JwaEVsQ2hpbGRyZW4gfHwgbm9vcDtcbiAgICB2YXIgb25CZWZvcmVOb2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICB2YXIgY2hpbGRyZW5Pbmx5ID0gb3B0aW9ucy5jaGlsZHJlbk9ubHkgPT09IHRydWU7XG4gICAgdmFyIG1vdmVkRWxzID0gW107XG5cbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlSGVscGVyKG5vZGUsIG5lc3RlZEluU2F2ZWRFbCkge1xuICAgICAgICB2YXIgaWQgPSBnZXROb2RlS2V5KG5vZGUpO1xuICAgICAgICAvLyBJZiB0aGUgbm9kZSBoYXMgYW4gSUQgdGhlbiBzYXZlIGl0IG9mZiBzaW5jZSB3ZSB3aWxsIHdhbnRcbiAgICAgICAgLy8gdG8gcmV1c2UgaXQgaW4gY2FzZSB0aGUgdGFyZ2V0IERPTSB0cmVlIGhhcyBhIERPTSBlbGVtZW50XG4gICAgICAgIC8vIHdpdGggdGhlIHNhbWUgSURcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBzYXZlZEVsc1tpZF0gPSBub2RlO1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXN0ZWRJblNhdmVkRWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBub3QgbmVzdGVkIGluIGEgc2F2ZWQgZWxlbWVudCB0aGVuIHdlIGtub3cgdGhhdCB0aGlzIG5vZGUgaGFzIGJlZW5cbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgZGlzY2FyZGVkIGFuZCB3aWxsIG5vdCBleGlzdCBpbiB0aGUgZmluYWwgRE9NLlxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZUhlbHBlcihjdXJDaGlsZCwgbmVzdGVkSW5TYXZlZEVsIHx8IGlkKTtcbiAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICAgICAgd2hpbGUoY3VyQ2hpbGQpIHtcblxuXG4gICAgICAgICAgICAgICAgaWYgKCFnZXROb2RlS2V5KGN1ckNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gaGFuZGxlIG5vZGVzIHRoYXQgZG9uJ3QgaGF2ZSBhbiBJRCB0byBhdm9pZCBkb3VibGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Fsa2luZyB0aGUgc2FtZSBzYXZlZCBlbGVtZW50LlxuXG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChjdXJDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2FsayByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2RlcyhjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSwgcGFyZW50Tm9kZSwgYWxyZWFkeVZpc2l0ZWQpIHtcbiAgICAgICAgaWYgKG9uQmVmb3JlTm9kZURpc2NhcmRlZChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIGlmIChhbHJlYWR5VmlzaXRlZCkge1xuICAgICAgICAgICAgaWYgKCFnZXROb2RlS2V5KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHdhbGtEaXNjYXJkZWRDaGlsZE5vZGVzKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZUhlbHBlcihub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vcnBoRWwoZnJvbUVsLCB0b0VsLCBhbHJlYWR5VmlzaXRlZCwgY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgIHZhciB0b0VsS2V5ID0gZ2V0Tm9kZUtleSh0b0VsKTtcbiAgICAgICAgaWYgKHRvRWxLZXkpIHtcbiAgICAgICAgICAgIC8vIElmIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBpcyBiZWluZyBtb3JwaGVkIHRoZW4gaXQgaXMgd2lsbCBiZSBpbiB0aGUgZmluYWxcbiAgICAgICAgICAgIC8vIERPTSBzbyBjbGVhciBpdCBvdXQgb2YgdGhlIHNhdmVkIGVsZW1lbnRzIGNvbGxlY3Rpb25cbiAgICAgICAgICAgIGRlbGV0ZSBzYXZlZEVsc1t0b0VsS2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICBpZiAob25CZWZvcmVNb3JwaEVsKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3JwaEF0dHJzKGZyb21FbCwgdG9FbCk7XG5cbiAgICAgICAgICAgIGlmIChvbkJlZm9yZU1vcnBoRWxDaGlsZHJlbihmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tRWwudGFnTmFtZSAhPSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgICB2YXIgY3VyVG9Ob2RlQ2hpbGQgPSB0b0VsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIGN1clRvTm9kZUlkO1xuXG4gICAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgdmFyIHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB2YXIgc2F2ZWRFbDtcbiAgICAgICAgICAgIHZhciB1bm1hdGNoZWRFbDtcblxuICAgICAgICAgICAgb3V0ZXI6IHdoaWxlKGN1clRvTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1clRvTm9kZUlkID0gZ2V0Tm9kZUtleShjdXJUb05vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZShjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZUlkID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFscmVhZHlWaXNpdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVJZCAmJiAodW5tYXRjaGVkRWwgPSB1bm1hdGNoZWRFbHNbY3VyRnJvbU5vZGVJZF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5tYXRjaGVkRWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY3VyRnJvbU5vZGVDaGlsZCwgdW5tYXRjaGVkRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoRWwoY3VyRnJvbU5vZGVDaGlsZCwgdW5tYXRjaGVkRWwsIGFscmVhZHlWaXNpdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlVHlwZSA9IGN1ckZyb21Ob2RlQ2hpbGQubm9kZVR5cGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0NvbXBhdGlibGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gMSkgeyAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlQ2hpbGQudGFnTmFtZSA9PT0gY3VyVG9Ob2RlQ2hpbGQudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGNvbXBhdGlibGUgRE9NIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUlkIHx8IGN1clRvTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBlaXRoZXIgRE9NIGVsZW1lbnQgaGFzIGFuIElEIHRoZW4gd2UgaGFuZGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aG9zZSBkaWZmZXJlbnRseSBzaW5jZSB3ZSB3YW50IHRvIG1hdGNoIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBJRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUlkID09PSBjdXJGcm9tTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGNvbXBhdGlibGUgRE9NIGVsZW1lbnRzIHNvIHRyYW5zZm9ybSB0aGUgY3VycmVudCBcImZyb21cIiBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIG1hdGNoIHRoZSBjdXJyZW50IHRhcmdldCBET00gbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCwgYWxyZWFkeVZpc2l0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSAzKSB7IC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbXBseSB1cGRhdGUgbm9kZVZhbHVlIG9uIHRoZSBvcmlnaW5hbCBub2RlIHRvIGNoYW5nZSB0aGUgdGV4dCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlID0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBObyBjb21wYXRpYmxlIG1hdGNoIHNvIHJlbW92ZSB0aGUgb2xkIG5vZGUgZnJvbSB0aGUgRE9NIGFuZCBjb250aW51ZSB0cnlpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gZmluZCBhIG1hdGNoIGluIHRoZSBvcmlnaW5hbCBET01cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIGFscmVhZHlWaXNpdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzYXZlZEVsID0gc2F2ZWRFbHNbY3VyVG9Ob2RlSWRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChzYXZlZEVsLCBjdXJUb05vZGVDaGlsZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHNhdmVkRWw7IC8vIFdlIHdhbnQgdG8gYXBwZW5kIHRoZSBzYXZlZCBlbGVtZW50IGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IERPTSBlbGVtZW50IGluIHRoZSB0YXJnZXQgdHJlZSBoYXMgYW4gSURcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBkaWQgbm90IGZpbmQgYSBtYXRjaCBpbiBhbnkgb2YgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpYmxpbmdzLiBXZSBqdXN0IHB1dCB0aGUgdGFyZ2V0IGVsZW1lbnQgaW4gdGhlIG9sZCBET00gdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGlmIHdlIGxhdGVyIGZpbmQgYW4gZWxlbWVudCBpbiB0aGUgb2xkIERPTSB0cmVlIHRoYXQgaGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIG1hdGNoaW5nIElEIHRoZW4gd2Ugd2lsbCByZXBsYWNlIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvbGQgZWxlbWVudCBhbmQgbW9ycGggdGhlIG9sZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWRFbHNbY3VyVG9Ob2RlSWRdID0gY3VyVG9Ob2RlQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiB3ZSBkaWQgbm90IGZpbmQgYSBjYW5kaWRhdGUgbWF0Y2ggZm9yIG91ciBcInRvIG5vZGVcIlxuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBleGhhdXN0ZWQgYWxsIG9mIHRoZSBjaGlsZHJlbiBcImZyb21cIiBub2Rlcy4gVGhlcmVmb3JlLCB3ZSB3aWxsIGp1c3RcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgdGhlIGN1cnJlbnQgXCJ0byBub2RlXCIgdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgIGZyb21FbC5hcHBlbmRDaGlsZChjdXJUb05vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQubm9kZVR5cGUgPT09IDEgJiYgKGN1clRvTm9kZUlkIHx8IGN1clRvTm9kZUNoaWxkLmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHRoYXQgd2FzIGp1c3QgYWRkZWQgdG8gdGhlIG9yaWdpbmFsIERPTSBtYXkgaGF2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBzb21lIG5lc3RlZCBlbGVtZW50cyB3aXRoIGEga2V5L0lEIHRoYXQgbmVlZHMgdG8gYmUgbWF0Y2hlZCB1cFxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIG90aGVyIGVsZW1lbnRzLiBXZSdsbCBhZGQgdGhlIGVsZW1lbnQgdG8gYSBsaXN0IHNvIHRoYXQgd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGxhdGVyIHByb2Nlc3MgdGhlIG5lc3RlZCBlbGVtZW50cyBpZiB0aGVyZSBhcmUgYW55IHVubWF0Y2hlZFxuICAgICAgICAgICAgICAgICAgICAvLyBrZXllZCBlbGVtZW50cyB0aGF0IHdlcmUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgICAgIG1vdmVkRWxzLnB1c2goY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgb2YgdGhlIFwidG8gbm9kZXNcIi4gSWYgY3VyRnJvbU5vZGVDaGlsZCBpcyBub24tbnVsbCB0aGVuXG4gICAgICAgICAgICAvLyB3ZSBzdGlsbCBoYXZlIHNvbWUgZnJvbSBub2RlcyBsZWZ0IG92ZXIgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIHdoaWxlKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCBhbHJlYWR5VmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcGVjaWFsRWxIYW5kbGVyID0gc3BlY2lhbEVsSGFuZGxlcnNbZnJvbUVsLnRhZ05hbWVdO1xuICAgICAgICBpZiAoc3BlY2lhbEVsSGFuZGxlcikge1xuICAgICAgICAgICAgc3BlY2lhbEVsSGFuZGxlcihmcm9tRWwsIHRvRWwpO1xuICAgICAgICB9XG4gICAgfSAvLyBFTkQ6IG1vcnBoRWwoLi4uKVxuXG4gICAgdmFyIG1vcnBoZWROb2RlID0gZnJvbU5vZGU7XG4gICAgdmFyIG1vcnBoZWROb2RlVHlwZSA9IG1vcnBoZWROb2RlLm5vZGVUeXBlO1xuICAgIHZhciB0b05vZGVUeXBlID0gdG9Ob2RlLm5vZGVUeXBlO1xuXG4gICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGFyZSBnaXZlbiB0d28gRE9NIG5vZGVzIHRoYXQgYXJlIG5vdFxuICAgICAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgICAgIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh0b05vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21Ob2RlLnRhZ05hbWUgIT09IHRvTm9kZS50YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRvTm9kZS50YWdOYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBHb2luZyBmcm9tIGFuIGVsZW1lbnQgbm9kZSB0byBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gMykgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICAgIGlmICh0b05vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgbW9ycGhlZE5vZGUubm9kZVZhbHVlID0gdG9Ob2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZSB0byBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gdG9Ob2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vcnBoZWROb2RlID09PSB0b05vZGUpIHtcbiAgICAgICAgLy8gVGhlIFwidG8gbm9kZVwiIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBcImZyb20gbm9kZVwiXG4gICAgICAgIC8vIHNvIHdlIGhhZCB0byB0b3NzIG91dCB0aGUgXCJmcm9tIG5vZGVcIiBhbmQgdXNlIHRoZSBcInRvIG5vZGVcIlxuICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1vcnBoRWwobW9ycGhlZE5vZGUsIHRvTm9kZSwgZmFsc2UsIGNoaWxkcmVuT25seSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoYXQgd2Ugd2lsbCBkbyBoZXJlIGlzIHdhbGsgdGhlIHRyZWUgZm9yIHRoZSBET00gZWxlbWVudFxuICAgICAgICAgKiB0aGF0IHdhcyBtb3ZlZCBmcm9tIHRoZSB0YXJnZXQgRE9NIHRyZWUgdG8gdGhlIG9yaWdpbmFsXG4gICAgICAgICAqIERPTSB0cmVlIGFuZCB3ZSB3aWxsIGxvb2sgZm9yIGtleWVkIGVsZW1lbnRzIHRoYXQgY291bGRcbiAgICAgICAgICogYmUgbWF0Y2hlZCB0byBrZXllZCBlbGVtZW50cyB0aGF0IHdlcmUgZWFybGllciBkaXNjYXJkZWQuXG4gICAgICAgICAqIElmIHdlIGZpbmQgYSBtYXRjaCB0aGVuIHdlIHdpbGwgbW92ZSB0aGUgc2F2ZWQgZWxlbWVudFxuICAgICAgICAgKiBpbnRvIHRoZSBmaW5hbCBET00gdHJlZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGhhbmRsZU1vdmVkRWwgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgdmFyIGN1ckNoaWxkID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2F2ZWRFbCA9IHNhdmVkRWxzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYXZlZEVsICYmIChjdXJDaGlsZC50YWdOYW1lID09PSBzYXZlZEVsLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzYXZlZEVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKHNhdmVkRWwsIGN1ckNoaWxkLCB0cnVlIC8qIGFscmVhZHkgdmlzaXRlZCB0aGUgc2F2ZWQgZWwgdHJlZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5KHNhdmVkRWxzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdmVkRWwoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGhlIGxvb3AgYmVsb3cgaXMgdXNlZCB0byBwb3NzaWJseSBtYXRjaCB1cCBhbnkgZGlzY2FyZGVkXG4gICAgICAgIC8vIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZSB3aXRoIGVsZW1lbmV0cyBmcm9tIHRoZVxuICAgICAgICAvLyB0YXJnZXQgdHJlZSB0aGF0IHdlcmUgbW92ZWQgb3ZlciB3aXRob3V0IHZpc2l0aW5nIHRoZWlyXG4gICAgICAgIC8vIGNoaWxkcmVuXG4gICAgICAgIGlmICghZW1wdHkoc2F2ZWRFbHMpKSB7XG4gICAgICAgICAgICBoYW5kbGVNb3ZlZEVsc0xvb3A6XG4gICAgICAgICAgICB3aGlsZSAobW92ZWRFbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVkRWxzVGVtcCA9IG1vdmVkRWxzO1xuICAgICAgICAgICAgICAgIG1vdmVkRWxzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPG1vdmVkRWxzVGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlTW92ZWRFbChtb3ZlZEVsc1RlbXBbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIG1vcmUgdW5tYXRjaGVkIGVsZW1lbnRzIHNvIGNvbXBsZXRlbHkgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgaGFuZGxlTW92ZWRFbHNMb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyZSB0aGUgXCJvbk5vZGVEaXNjYXJkZWRcIiBldmVudCBmb3IgYW55IHNhdmVkIGVsZW1lbnRzXG4gICAgICAgIC8vIHRoYXQgbmV2ZXIgZm91bmQgYSBuZXcgaG9tZSBpbiB0aGUgbW9ycGhlZCBET01cbiAgICAgICAgZm9yICh2YXIgc2F2ZWRFbElkIGluIHNhdmVkRWxzKSB7XG4gICAgICAgICAgICBpZiAoc2F2ZWRFbHMuaGFzT3duUHJvcGVydHkoc2F2ZWRFbElkKSkge1xuICAgICAgICAgICAgICAgIHZhciBzYXZlZEVsID0gc2F2ZWRFbHNbc2F2ZWRFbElkXTtcbiAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoc2F2ZWRFbCk7XG4gICAgICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMoc2F2ZWRFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkcmVuT25seSAmJiBtb3JwaGVkTm9kZSAhPT0gZnJvbU5vZGUgJiYgZnJvbU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBJZiB3ZSBoYWQgdG8gc3dhcCBvdXQgdGhlIGZyb20gbm9kZSB3aXRoIGEgbmV3IG5vZGUgYmVjYXVzZSB0aGUgb2xkXG4gICAgICAgIC8vIG5vZGUgd2FzIG5vdCBjb21wYXRpYmxlIHdpdGggdGhlIHRhcmdldCBub2RlIHRoZW4gd2UgbmVlZCB0b1xuICAgICAgICAvLyByZXBsYWNlIHRoZSBvbGQgRE9NIG5vZGUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLiBUaGlzIGlzIG9ubHlcbiAgICAgICAgLy8gcG9zc2libGUgaWYgdGhlIG9yaWdpbmFsIERPTSBub2RlIHdhcyBwYXJ0IG9mIGEgRE9NIHRyZWUgd2hpY2hcbiAgICAgICAgLy8gd2Uga25vdyBpcyB0aGUgY2FzZSBpZiBpdCBoYXMgYSBwYXJlbnQgbm9kZS5cbiAgICAgICAgZnJvbU5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobW9ycGhlZE5vZGUsIGZyb21Ob2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbW9ycGhkb207XG4iLCIvKmpzaGludCBub2RlOnRydWUgKi9cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyIG1pbmltYWxEZXNjID0gWydoJywgJ21pbicsICdzJywgJ21zJywgJ868cycsICducyddO1xyXG52YXIgdmVyYm9zZURlc2MgPSBbJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCcsICdtaWNyb3NlY29uZCcsICduYW5vc2Vjb25kJ107XHJcbnZhciBjb252ZXJ0ID0gWzYwKjYwLCA2MCwgMSwgMWU2LCAxZTMsIDFdO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRzKSB7XHJcblx0dmFyIHZlcmJvc2UsIHByZWNpc2UsIGksIHNwb3QsIHNvdXJjZUF0U3RlcCwgdmFsQXRTdGVwLCBkZWNpbWFscywgc3RyQXRTdGVwLCByZXN1bHRzO1xyXG5cclxuXHR2ZXJib3NlID0gZmFsc2U7XHJcblx0cHJlY2lzZSA9IGZhbHNlO1xyXG5cdGlmIChvcHRzKSB7XHJcblx0XHR2ZXJib3NlID0gb3B0cy52ZXJib3NlIHx8IGZhbHNlO1xyXG5cdFx0cHJlY2lzZSA9IG9wdHMucHJlY2lzZSB8fCBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGlmICghQXJyYXkuaXNBcnJheShzb3VyY2UpIHx8IHNvdXJjZS5sZW5ndGggIT09IDIpIHtcclxuXHRcdHJldHVybiAnJztcclxuXHR9XHJcblx0aWYgKHR5cGVvZiBzb3VyY2VbMF0gIT09ICdudW1iZXInIHx8IHR5cGVvZiBzb3VyY2VbMV0gIT09ICdudW1iZXInKSB7XHJcblx0XHRyZXR1cm4gJyc7XHJcblx0fVxyXG5cclxuXHRyZXN1bHRzID0gJyc7XHJcblxyXG5cdC8vIGZvcmVhY2ggdW5pdFxyXG5cdGZvciAoaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuXHRcdHNwb3QgPSBpIDwgMyA/IDAgOiAxOyAvLyBncmFiYmluZyBmaXJzdCBvciBzZWNvbmQgc3BvdCBpbiBzb3VyY2UgYXJyYXlcclxuXHRcdHNvdXJjZUF0U3RlcCA9IHNvdXJjZVtzcG90XTtcclxuXHRcdGlmIChpICE9PSAzICYmIGkgIT09IDApIHtcclxuXHRcdFx0c291cmNlQXRTdGVwID0gc291cmNlQXRTdGVwICUgY29udmVydFtpLTFdOyAvLyB0cmltIG9mZiBwcmV2aW91cyBwb3J0aW9uc1xyXG5cdFx0fVxyXG5cdFx0aWYgKGkgPT09IDIpIHtcclxuXHRcdFx0c291cmNlQXRTdGVwICs9IHNvdXJjZVsxXS8xZTk7IC8vIGdldCBwYXJ0aWFsIHNlY29uZHMgZnJvbSBvdGhlciBwb3J0aW9uIG9mIHRoZSBhcnJheVxyXG5cdFx0fVxyXG5cdFx0dmFsQXRTdGVwID0gc291cmNlQXRTdGVwIC8gY29udmVydFtpXTsgLy8gdmFsIGF0IHRoaXMgdW5pdFxyXG5cdFx0aWYgKHZhbEF0U3RlcCA+PSAxKSB7XHJcblx0XHRcdGlmICh2ZXJib3NlKSB7XHJcblx0XHRcdFx0dmFsQXRTdGVwID0gTWF0aC5mbG9vcih2YWxBdFN0ZXApOyAvLyBkZWFsIGluIHdob2xlIHVuaXRzLCBzdWJzZXF1ZW50IGxhcHMgd2lsbCBnZXQgdGhlIGRlY2ltYWwgcG9ydGlvblxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghcHJlY2lzZSkge1xyXG5cdFx0XHRcdC8vIGRvbid0IGZsaW5nIHRvbyBtYW55IGRlY2ltYWxzXHJcblx0XHRcdFx0ZGVjaW1hbHMgPSB2YWxBdFN0ZXAgPj0gMTAgPyAwIDogMjtcclxuXHRcdFx0XHRzdHJBdFN0ZXAgPSB2YWxBdFN0ZXAudG9GaXhlZChkZWNpbWFscyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RyQXRTdGVwID0gdmFsQXRTdGVwLnRvU3RyaW5nKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHN0ckF0U3RlcC5pbmRleE9mKCcuJykgPiAtMSAmJiBzdHJBdFN0ZXBbc3RyQXRTdGVwLmxlbmd0aC0xXSA9PT0gJzAnKSB7XHJcblx0XHRcdFx0c3RyQXRTdGVwID0gc3RyQXRTdGVwLnJlcGxhY2UoL1xcLj8wKyQvLCcnKTsgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9zXHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKHJlc3VsdHMpIHtcclxuXHRcdFx0XHRyZXN1bHRzICs9ICcgJzsgLy8gYXBwZW5kIHNwYWNlIGlmIHdlIGhhdmUgYSBwcmV2aW91cyB2YWx1ZVxyXG5cdFx0XHR9XHJcblx0XHRcdHJlc3VsdHMgKz0gc3RyQXRTdGVwOyAvLyBhcHBlbmQgdGhlIHZhbHVlXHJcblx0XHRcdC8vIGFwcGVuZCB1bml0c1xyXG5cdFx0XHRpZiAodmVyYm9zZSkge1xyXG5cdFx0XHRcdHJlc3VsdHMgKz0gJyAnK3ZlcmJvc2VEZXNjW2ldO1xyXG5cdFx0XHRcdGlmIChzdHJBdFN0ZXAgIT09ICcxJykge1xyXG5cdFx0XHRcdFx0cmVzdWx0cyArPSAncyc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdHMgKz0gJyAnK21pbmltYWxEZXNjW2ldO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghdmVyYm9zZSkge1xyXG5cdFx0XHRcdGJyZWFrOyAvLyB2ZXJib3NlIGdldHMgYXMgbWFueSBncm91cHMgYXMgbmVjZXNzYXJ5LCB0aGUgcmVzdCBnZXQgb25seSBvbmVcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdHM7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcC9yYXcnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFN0YXRlczpcbi8vXG4vLyAwIC0gcGVuZGluZ1xuLy8gMSAtIGZ1bGZpbGxlZCB3aXRoIF92YWx1ZVxuLy8gMiAtIHJlamVjdGVkIHdpdGggX3ZhbHVlXG4vLyAzIC0gYWRvcHRlZCB0aGUgc3RhdGUgb2YgYW5vdGhlciBwcm9taXNlLCBfdmFsdWVcbi8vXG4vLyBvbmNlIHRoZSBzdGF0ZSBpcyBubyBsb25nZXIgcGVuZGluZyAoMCkgaXQgaXMgaW1tdXRhYmxlXG5cbi8vIEFsbCBgX2AgcHJlZml4ZWQgcHJvcGVydGllcyB3aWxsIGJlIHJlZHVjZWQgdG8gYF97cmFuZG9tIG51bWJlcn1gXG4vLyBhdCBidWlsZCB0aW1lIHRvIG9iZnVzY2F0ZSB0aGVtIGFuZCBkaXNjb3VyYWdlIHRoZWlyIHVzZS5cbi8vIFdlIGRvbid0IHVzZSBzeW1ib2xzIG9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBmdWxseSBoaWRlIHRoZW1cbi8vIGJlY2F1c2UgdGhlIHBlcmZvcm1hbmNlIGlzbid0IGdvb2QgZW5vdWdoLlxuXG5cbi8vIHRvIGF2b2lkIHVzaW5nIHRyeS9jYXRjaCBpbnNpZGUgY3JpdGljYWwgZnVuY3Rpb25zLCB3ZVxuLy8gZXh0cmFjdCB0aGVtIHRvIGhlcmUuXG52YXIgTEFTVF9FUlJPUiA9IG51bGw7XG52YXIgSVNfRVJST1IgPSB7fTtcbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2FsbE9uZShmbiwgYSkge1xuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5mdW5jdGlvbiB0cnlDYWxsVHdvKGZuLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgZm4oYSwgYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICB9XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuXzQ1ID0gMDtcbiAgdGhpcy5fODEgPSAwO1xuICB0aGlzLl82NSA9IG51bGw7XG4gIHRoaXMuXzU0ID0gbnVsbDtcbiAgaWYgKGZuID09PSBub29wKSByZXR1cm47XG4gIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG59XG5Qcm9taXNlLl8xMCA9IG51bGw7XG5Qcm9taXNlLl85NyA9IG51bGw7XG5Qcm9taXNlLl82MSA9IG5vb3A7XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gUHJvbWlzZSkge1xuICAgIHJldHVybiBzYWZlVGhlbih0aGlzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKG5vb3ApO1xuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gc2FmZVRoZW4oc2VsZiwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIG5ldyBzZWxmLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICBoYW5kbGUoc2VsZiwgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgd2hpbGUgKHNlbGYuXzgxID09PSAzKSB7XG4gICAgc2VsZiA9IHNlbGYuXzY1O1xuICB9XG4gIGlmIChQcm9taXNlLl8xMCkge1xuICAgIFByb21pc2UuXzEwKHNlbGYpO1xuICB9XG4gIGlmIChzZWxmLl84MSA9PT0gMCkge1xuICAgIGlmIChzZWxmLl80NSA9PT0gMCkge1xuICAgICAgc2VsZi5fNDUgPSAxO1xuICAgICAgc2VsZi5fNTQgPSBkZWZlcnJlZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYuXzQ1ID09PSAxKSB7XG4gICAgICBzZWxmLl80NSA9IDI7XG4gICAgICBzZWxmLl81NCA9IFtzZWxmLl81NCwgZGVmZXJyZWRdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLl81NC5wdXNoKGRlZmVycmVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaGFuZGxlUmVzb2x2ZWQoc2VsZiwgZGVmZXJyZWQpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVSZXNvbHZlZChzZWxmLCBkZWZlcnJlZCkge1xuICBhc2FwKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYiA9IHNlbGYuXzgxID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgaWYgKHNlbGYuXzgxID09PSAxKSB7XG4gICAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fNjUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIHNlbGYuXzY1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhbGxPbmUoY2IsIHNlbGYuXzY1KTtcbiAgICBpZiAocmV0ID09PSBJU19FUlJPUikge1xuICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIExBU1RfRVJST1IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoc2VsZiwgbmV3VmFsdWUpIHtcbiAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB7XG4gICAgcmV0dXJuIHJlamVjdChcbiAgICAgIHNlbGYsXG4gICAgICBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAgbmV3VmFsdWUgJiZcbiAgICAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICkge1xuICAgIHZhciB0aGVuID0gZ2V0VGhlbihuZXdWYWx1ZSk7XG4gICAgaWYgKHRoZW4gPT09IElTX0VSUk9SKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHNlbGYsIExBU1RfRVJST1IpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICB0aGVuID09PSBzZWxmLnRoZW4gJiZcbiAgICAgIG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVxuICAgICkge1xuICAgICAgc2VsZi5fODEgPSAzO1xuICAgICAgc2VsZi5fNjUgPSBuZXdWYWx1ZTtcbiAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkb1Jlc29sdmUodGhlbi5iaW5kKG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHNlbGYuXzgxID0gMTtcbiAgc2VsZi5fNjUgPSBuZXdWYWx1ZTtcbiAgZmluYWxlKHNlbGYpO1xufVxuXG5mdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgc2VsZi5fODEgPSAyO1xuICBzZWxmLl82NSA9IG5ld1ZhbHVlO1xuICBpZiAoUHJvbWlzZS5fOTcpIHtcbiAgICBQcm9taXNlLl85NyhzZWxmLCBuZXdWYWx1ZSk7XG4gIH1cbiAgZmluYWxlKHNlbGYpO1xufVxuZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgaWYgKHNlbGYuXzQ1ID09PSAxKSB7XG4gICAgaGFuZGxlKHNlbGYsIHNlbGYuXzU0KTtcbiAgICBzZWxmLl81NCA9IG51bGw7XG4gIH1cbiAgaWYgKHNlbGYuXzQ1ID09PSAyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl81NC5sZW5ndGg7IGkrKykge1xuICAgICAgaGFuZGxlKHNlbGYsIHNlbGYuXzU0W2ldKTtcbiAgICB9XG4gICAgc2VsZi5fNTQgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2Upe1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgcHJvbWlzZSkge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgcmVzID0gdHJ5Q2FsbFR3byhmbiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIH0pXG4gIGlmICghZG9uZSAmJiByZXMgPT09IElTX0VSUk9SKSB7XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIExBU1RfRVJST1IpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzO1xuICBzZWxmLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0sIDApO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBFUzYgZXh0ZW5zaW9ucyB0byB0aGUgY29yZSBQcm9taXNlcy9BKyBBUElcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG4vKiBTdGF0aWMgRnVuY3Rpb25zICovXG5cbnZhciBUUlVFID0gdmFsdWVQcm9taXNlKHRydWUpO1xudmFyIEZBTFNFID0gdmFsdWVQcm9taXNlKGZhbHNlKTtcbnZhciBOVUxMID0gdmFsdWVQcm9taXNlKG51bGwpO1xudmFyIFVOREVGSU5FRCA9IHZhbHVlUHJvbWlzZSh1bmRlZmluZWQpO1xudmFyIFpFUk8gPSB2YWx1ZVByb21pc2UoMCk7XG52YXIgRU1QVFlTVFJJTkcgPSB2YWx1ZVByb21pc2UoJycpO1xuXG5mdW5jdGlvbiB2YWx1ZVByb21pc2UodmFsdWUpIHtcbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShQcm9taXNlLl82MSk7XG4gIHAuXzgxID0gMTtcbiAgcC5fNjUgPSB2YWx1ZTtcbiAgcmV0dXJuIHA7XG59XG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIE5VTEw7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gVU5ERUZJTkVEO1xuICBpZiAodmFsdWUgPT09IHRydWUpIHJldHVybiBUUlVFO1xuICBpZiAodmFsdWUgPT09IGZhbHNlKSByZXR1cm4gRkFMU0U7XG4gIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIFpFUk87XG4gIGlmICh2YWx1ZSA9PT0gJycpIHJldHVybiBFTVBUWVNUUklORztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoZW4gPSB2YWx1ZS50aGVuO1xuICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh0aGVuLmJpbmQodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVQcm9taXNlKHZhbHVlKTtcbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFByb21pc2UgJiYgdmFsLnRoZW4gPT09IFByb21pc2UucHJvdG90eXBlLnRoZW4pIHtcbiAgICAgICAgICB3aGlsZSAodmFsLl84MSA9PT0gMykge1xuICAgICAgICAgICAgdmFsID0gdmFsLl82NTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbC5fODEgPT09IDEpIHJldHVybiByZXMoaSwgdmFsLl82NSk7XG4gICAgICAgICAgaWYgKHZhbC5fODEgPT09IDIpIHJlamVjdCh2YWwuXzY1KTtcbiAgICAgICAgICB2YWwudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZSh0aGVuLmJpbmQodmFsKSk7XG4gICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdCh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qIFByb3RvdHlwZSBNZXRob2RzICovXG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10gPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZigpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZigpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xucmVxdWlyZSgnLi9kb25lLmpzJyk7XG5yZXF1aXJlKCcuL2ZpbmFsbHkuanMnKTtcbnJlcXVpcmUoJy4vZXM2LWV4dGVuc2lvbnMuanMnKTtcbnJlcXVpcmUoJy4vbm9kZS1leHRlbnNpb25zLmpzJyk7XG5yZXF1aXJlKCcuL3N5bmNocm9ub3VzLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBjb250YWlucyB0aGVuL3Byb21pc2Ugc3BlY2lmaWMgZXh0ZW5zaW9ucyB0aGF0IGFyZSBvbmx5IHVzZWZ1bFxuLy8gZm9yIG5vZGUuanMgaW50ZXJvcFxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG5Qcm9taXNlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChmbiwgYXJndW1lbnRDb3VudCkge1xuICBpZiAoXG4gICAgdHlwZW9mIGFyZ3VtZW50Q291bnQgPT09ICdudW1iZXInICYmIGFyZ3VtZW50Q291bnQgIT09IEluZmluaXR5XG4gICkge1xuICAgIHJldHVybiBkZW5vZGVpZnlXaXRoQ291bnQoZm4sIGFyZ3VtZW50Q291bnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZW5vZGVpZnlXaXRob3V0Q291bnQoZm4pO1xuICB9XG59XG5cbnZhciBjYWxsYmFja0ZuID0gKFxuICAnZnVuY3Rpb24gKGVyciwgcmVzKSB7JyArXG4gICdpZiAoZXJyKSB7IHJqKGVycik7IH0gZWxzZSB7IHJzKHJlcyk7IH0nICtcbiAgJ30nXG4pO1xuZnVuY3Rpb24gZGVub2RlaWZ5V2l0aENvdW50KGZuLCBhcmd1bWVudENvdW50KSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRDb3VudDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKCdhJyArIGkpO1xuICB9XG4gIHZhciBib2R5ID0gW1xuICAgICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBhcmdzLmpvaW4oJywnKSArICcpIHsnLFxuICAgICd2YXIgc2VsZiA9IHRoaXM7JyxcbiAgICAncmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChycywgcmopIHsnLFxuICAgICd2YXIgcmVzID0gZm4uY2FsbCgnLFxuICAgIFsnc2VsZiddLmNvbmNhdChhcmdzKS5jb25jYXQoW2NhbGxiYWNrRm5dKS5qb2luKCcsJyksXG4gICAgJyk7JyxcbiAgICAnaWYgKHJlcyAmJicsXG4gICAgJyh0eXBlb2YgcmVzID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiByZXMgPT09IFwiZnVuY3Rpb25cIikgJiYnLFxuICAgICd0eXBlb2YgcmVzLnRoZW4gPT09IFwiZnVuY3Rpb25cIicsXG4gICAgJykge3JzKHJlcyk7fScsXG4gICAgJ30pOycsXG4gICAgJ307J1xuICBdLmpvaW4oJycpO1xuICByZXR1cm4gRnVuY3Rpb24oWydQcm9taXNlJywgJ2ZuJ10sIGJvZHkpKFByb21pc2UsIGZuKTtcbn1cbmZ1bmN0aW9uIGRlbm9kZWlmeVdpdGhvdXRDb3VudChmbikge1xuICB2YXIgZm5MZW5ndGggPSBNYXRoLm1heChmbi5sZW5ndGggLSAxLCAzKTtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbkxlbmd0aDsgaSsrKSB7XG4gICAgYXJncy5wdXNoKCdhJyArIGkpO1xuICB9XG4gIHZhciBib2R5ID0gW1xuICAgICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBhcmdzLmpvaW4oJywnKSArICcpIHsnLFxuICAgICd2YXIgc2VsZiA9IHRoaXM7JyxcbiAgICAndmFyIGFyZ3M7JyxcbiAgICAndmFyIGFyZ0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7JyxcbiAgICAnaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAnICsgZm5MZW5ndGggKyAnKSB7JyxcbiAgICAnYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoICsgMSk7JyxcbiAgICAnZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsnLFxuICAgICdhcmdzW2ldID0gYXJndW1lbnRzW2ldOycsXG4gICAgJ30nLFxuICAgICd9JyxcbiAgICAncmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChycywgcmopIHsnLFxuICAgICd2YXIgY2IgPSAnICsgY2FsbGJhY2tGbiArICc7JyxcbiAgICAndmFyIHJlczsnLFxuICAgICdzd2l0Y2ggKGFyZ0xlbmd0aCkgeycsXG4gICAgYXJncy5jb25jYXQoWydleHRyYSddKS5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAnY2FzZSAnICsgKGluZGV4KSArICc6JyArXG4gICAgICAgICdyZXMgPSBmbi5jYWxsKCcgKyBbJ3NlbGYnXS5jb25jYXQoYXJncy5zbGljZSgwLCBpbmRleCkpLmNvbmNhdCgnY2InKS5qb2luKCcsJykgKyAnKTsnICtcbiAgICAgICAgJ2JyZWFrOydcbiAgICAgICk7XG4gICAgfSkuam9pbignJyksXG4gICAgJ2RlZmF1bHQ6JyxcbiAgICAnYXJnc1thcmdMZW5ndGhdID0gY2I7JyxcbiAgICAncmVzID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7JyxcbiAgICAnfScsXG4gICAgXG4gICAgJ2lmIChyZXMgJiYnLFxuICAgICcodHlwZW9mIHJlcyA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgcmVzID09PSBcImZ1bmN0aW9uXCIpICYmJyxcbiAgICAndHlwZW9mIHJlcy50aGVuID09PSBcImZ1bmN0aW9uXCInLFxuICAgICcpIHtycyhyZXMpO30nLFxuICAgICd9KTsnLFxuICAgICd9OydcbiAgXS5qb2luKCcnKTtcblxuICByZXR1cm4gRnVuY3Rpb24oXG4gICAgWydQcm9taXNlJywgJ2ZuJ10sXG4gICAgYm9keVxuICApKFByb21pc2UsIGZuKTtcbn1cblxuUHJvbWlzZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBjYWxsYmFjayA9XG4gICAgICB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nID8gYXJncy5wb3AoKSA6IG51bGw7XG4gICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLm5vZGVpZnkoY2FsbGJhY2ssIGN0eCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBleCk7XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBudWxsLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlcnIpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuUHJvbWlzZS5lbmFibGVTeW5jaHJvbm91cyA9IGZ1bmN0aW9uICgpIHtcbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKSA9PSAwO1xuICB9O1xuXG4gIFByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKSA9PSAxO1xuICB9O1xuXG4gIFByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpID09IDI7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuXzgxID09PSAzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fNjUuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNGdWxmaWxsZWQoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IGEgdmFsdWUgb2YgYW4gdW5mdWxmaWxsZWQgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fNjU7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0UmVhc29uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl84MSA9PT0gMykge1xuICAgICAgcmV0dXJuIHRoaXMuXzY1LmdldFJlYXNvbigpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1JlamVjdGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBhIHJlamVjdGlvbiByZWFzb24gb2YgYSBub24tcmVqZWN0ZWQgcHJvbWlzZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fNjU7XG4gIH07XG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuXzgxID09PSAzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fNjUuZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuXzgxID09PSAtMSB8fCB0aGlzLl84MSA9PT0gLTIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl84MTtcbiAgfTtcbn07XG5cblByb21pc2UuZGlzYWJsZVN5bmNocm9ub3VzID0gZnVuY3Rpb24oKSB7XG4gIFByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmdldFZhbHVlID0gdW5kZWZpbmVkO1xuICBQcm9taXNlLnByb3RvdHlwZS5nZXRSZWFzb24gPSB1bmRlZmluZWQ7XG4gIFByb21pc2UucHJvdG90eXBlLmdldFN0YXRlID0gdW5kZWZpbmVkO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyByYXdBc2FwIHByb3ZpZGVzIGV2ZXJ5dGhpbmcgd2UgbmVlZCBleGNlcHQgZXhjZXB0aW9uIG1hbmFnZW1lbnQuXG52YXIgcmF3QXNhcCA9IHJlcXVpcmUoXCIuL3Jhd1wiKTtcbi8vIFJhd1Rhc2tzIGFyZSByZWN5Y2xlZCB0byByZWR1Y2UgR0MgY2h1cm4uXG52YXIgZnJlZVRhc2tzID0gW107XG4vLyBXZSBxdWV1ZSBlcnJvcnMgdG8gZW5zdXJlIHRoZXkgYXJlIHRocm93biBpbiByaWdodCBvcmRlciAoRklGTykuXG4vLyBBcnJheS1hcy1xdWV1ZSBpcyBnb29kIGVub3VnaCBoZXJlLCBzaW5jZSB3ZSBhcmUganVzdCBkZWFsaW5nIHdpdGggZXhjZXB0aW9ucy5cbnZhciBwZW5kaW5nRXJyb3JzID0gW107XG52YXIgcmVxdWVzdEVycm9yVGhyb3cgPSByYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcih0aHJvd0ZpcnN0RXJyb3IpO1xuXG5mdW5jdGlvbiB0aHJvd0ZpcnN0RXJyb3IoKSB7XG4gICAgaWYgKHBlbmRpbmdFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHBlbmRpbmdFcnJvcnMuc2hpZnQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbHMgYSB0YXNrIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgcmV0dXJuaW5nLCBpbiBpdHMgb3duIGV2ZW50LCB3aXRoIHByaW9yaXR5XG4gKiBvdmVyIG90aGVyIGV2ZW50cyBsaWtlIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVwYWludC4gQW4gZXJyb3IgdGhyb3duIGZyb20gYW5cbiAqIGV2ZW50IHdpbGwgbm90IGludGVycnVwdCwgbm9yIGV2ZW4gc3Vic3RhbnRpYWxseSBzbG93IGRvd24gdGhlIHByb2Nlc3Npbmcgb2ZcbiAqIG90aGVyIGV2ZW50cywgYnV0IHdpbGwgYmUgcmF0aGVyIHBvc3Rwb25lZCB0byBhIGxvd2VyIHByaW9yaXR5IGV2ZW50LlxuICogQHBhcmFtIHt7Y2FsbH19IHRhc2sgQSBjYWxsYWJsZSBvYmplY3QsIHR5cGljYWxseSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhc2FwO1xuZnVuY3Rpb24gYXNhcCh0YXNrKSB7XG4gICAgdmFyIHJhd1Rhc2s7XG4gICAgaWYgKGZyZWVUYXNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmF3VGFzayA9IGZyZWVUYXNrcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYXdUYXNrID0gbmV3IFJhd1Rhc2soKTtcbiAgICB9XG4gICAgcmF3VGFzay50YXNrID0gdGFzaztcbiAgICByYXdBc2FwKHJhd1Rhc2spO1xufVxuXG4vLyBXZSB3cmFwIHRhc2tzIHdpdGggcmVjeWNsYWJsZSB0YXNrIG9iamVjdHMuICBBIHRhc2sgb2JqZWN0IGltcGxlbWVudHNcbi8vIGBjYWxsYCwganVzdCBsaWtlIGEgZnVuY3Rpb24uXG5mdW5jdGlvbiBSYXdUYXNrKCkge1xuICAgIHRoaXMudGFzayA9IG51bGw7XG59XG5cbi8vIFRoZSBzb2xlIHB1cnBvc2Ugb2Ygd3JhcHBpbmcgdGhlIHRhc2sgaXMgdG8gY2F0Y2ggdGhlIGV4Y2VwdGlvbiBhbmQgcmVjeWNsZVxuLy8gdGhlIHRhc2sgb2JqZWN0IGFmdGVyIGl0cyBzaW5nbGUgdXNlLlxuUmF3VGFzay5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnRhc2suY2FsbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChhc2FwLm9uZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaG9vayBleGlzdHMgcHVyZWx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAgICAgICAgLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0XG4gICAgICAgICAgICAvLyBkZXBlbmRzIG9uIGl0cyBleGlzdGVuY2UuXG4gICAgICAgICAgICBhc2FwLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gYSB3ZWIgYnJvd3NlciwgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLiBIb3dldmVyLCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gc2xvd2luZyBkb3duIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHRhc2tzLCB3ZSByZXRocm93IHRoZSBlcnJvciBpbiBhXG4gICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB0dXJuLlxuICAgICAgICAgICAgcGVuZGluZ0Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3RFcnJvclRocm93KCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICBmcmVlVGFza3NbZnJlZVRhc2tzLmxlbmd0aF0gPSB0aGlzO1xuICAgIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gVXNlIHRoZSBmYXN0ZXN0IG1lYW5zIHBvc3NpYmxlIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGl0cyBvd24gdHVybiwgd2l0aFxuLy8gcHJpb3JpdHkgb3ZlciBvdGhlciBldmVudHMgaW5jbHVkaW5nIElPLCBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlZHJhd1xuLy8gZXZlbnRzIGluIGJyb3dzZXJzLlxuLy9cbi8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gYnkgYSB0YXNrIHdpbGwgcGVybWFuZW50bHkgaW50ZXJydXB0IHRoZSBwcm9jZXNzaW5nIG9mXG4vLyBzdWJzZXF1ZW50IHRhc2tzLiBUaGUgaGlnaGVyIGxldmVsIGBhc2FwYCBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24gYnkgYSB0YXNrLCB0aGF0IHRoZSB0YXNrIHF1ZXVlIHdpbGwgY29udGludWUgZmx1c2hpbmcgYXNcbi8vIHNvb24gYXMgcG9zc2libGUsIGJ1dCBpZiB5b3UgdXNlIGByYXdBc2FwYCBkaXJlY3RseSwgeW91IGFyZSByZXNwb25zaWJsZSB0b1xuLy8gZWl0aGVyIGVuc3VyZSB0aGF0IG5vIGV4Y2VwdGlvbnMgYXJlIHRocm93biBmcm9tIHlvdXIgdGFzaywgb3IgdG8gbWFudWFsbHlcbi8vIGNhbGwgYHJhd0FzYXAucmVxdWVzdEZsdXNoYCBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxubW9kdWxlLmV4cG9ydHMgPSByYXdBc2FwO1xuZnVuY3Rpb24gcmF3QXNhcCh0YXNrKSB7XG4gICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRXF1aXZhbGVudCB0byBwdXNoLCBidXQgYXZvaWRzIGEgZnVuY3Rpb24gY2FsbC5cbiAgICBxdWV1ZVtxdWV1ZS5sZW5ndGhdID0gdGFzaztcbn1cblxudmFyIHF1ZXVlID0gW107XG4vLyBPbmNlIGEgZmx1c2ggaGFzIGJlZW4gcmVxdWVzdGVkLCBubyBmdXJ0aGVyIGNhbGxzIHRvIGByZXF1ZXN0Rmx1c2hgIGFyZVxuLy8gbmVjZXNzYXJ5IHVudGlsIHRoZSBuZXh0IGBmbHVzaGAgY29tcGxldGVzLlxudmFyIGZsdXNoaW5nID0gZmFsc2U7XG4vLyBgcmVxdWVzdEZsdXNoYCBpcyBhbiBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyBtZXRob2QgdGhhdCBhdHRlbXB0cyB0byBraWNrXG4vLyBvZmYgYSBgZmx1c2hgIGV2ZW50IGFzIHF1aWNrbHkgYXMgcG9zc2libGUuIGBmbHVzaGAgd2lsbCBhdHRlbXB0IHRvIGV4aGF1c3Rcbi8vIHRoZSBldmVudCBxdWV1ZSBiZWZvcmUgeWllbGRpbmcgdG8gdGhlIGJyb3dzZXIncyBvd24gZXZlbnQgbG9vcC5cbnZhciByZXF1ZXN0Rmx1c2g7XG4vLyBUaGUgcG9zaXRpb24gb2YgdGhlIG5leHQgdGFzayB0byBleGVjdXRlIGluIHRoZSB0YXNrIHF1ZXVlLiBUaGlzIGlzXG4vLyBwcmVzZXJ2ZWQgYmV0d2VlbiBjYWxscyB0byBgZmx1c2hgIHNvIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWQgaWZcbi8vIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLlxudmFyIGluZGV4ID0gMDtcbi8vIElmIGEgdGFzayBzY2hlZHVsZXMgYWRkaXRpb25hbCB0YXNrcyByZWN1cnNpdmVseSwgdGhlIHRhc2sgcXVldWUgY2FuIGdyb3dcbi8vIHVuYm91bmRlZC4gVG8gcHJldmVudCBtZW1vcnkgZXhoYXVzdGlvbiwgdGhlIHRhc2sgcXVldWUgd2lsbCBwZXJpb2RpY2FsbHlcbi8vIHRydW5jYXRlIGFscmVhZHktY29tcGxldGVkIHRhc2tzLlxudmFyIGNhcGFjaXR5ID0gMTAyNDtcblxuLy8gVGhlIGZsdXNoIGZ1bmN0aW9uIHByb2Nlc3NlcyBhbGwgdGFza3MgdGhhdCBoYXZlIGJlZW4gc2NoZWR1bGVkIHdpdGhcbi8vIGByYXdBc2FwYCB1bmxlc3MgYW5kIHVudGlsIG9uZSBvZiB0aG9zZSB0YXNrcyB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuLy8gSWYgYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24sIGBmbHVzaGAgZW5zdXJlcyB0aGF0IGl0cyBzdGF0ZSB3aWxsIHJlbWFpblxuLy8gY29uc2lzdGVudCBhbmQgd2lsbCByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYgd2hlbiBjYWxsZWQgYWdhaW4uXG4vLyBIb3dldmVyLCBgZmx1c2hgIGRvZXMgbm90IG1ha2UgYW55IGFycmFuZ2VtZW50cyB0byBiZSBjYWxsZWQgYWdhaW4gaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB3aGlsZSAoaW5kZXggPCBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAvLyBBZHZhbmNlIHRoZSBpbmRleCBiZWZvcmUgY2FsbGluZyB0aGUgdGFzay4gVGhpcyBlbnN1cmVzIHRoYXQgd2Ugd2lsbFxuICAgICAgICAvLyBiZWdpbiBmbHVzaGluZyBvbiB0aGUgbmV4dCB0YXNrIHRoZSB0YXNrIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHF1ZXVlW2N1cnJlbnRJbmRleF0uY2FsbCgpO1xuICAgICAgICAvLyBQcmV2ZW50IGxlYWtpbmcgbWVtb3J5IGZvciBsb25nIGNoYWlucyBvZiByZWN1cnNpdmUgY2FsbHMgdG8gYGFzYXBgLlxuICAgICAgICAvLyBJZiB3ZSBjYWxsIGBhc2FwYCB3aXRoaW4gdGFza3Mgc2NoZWR1bGVkIGJ5IGBhc2FwYCwgdGhlIHF1ZXVlIHdpbGxcbiAgICAgICAgLy8gZ3JvdywgYnV0IHRvIGF2b2lkIGFuIE8obikgd2FsayBmb3IgZXZlcnkgdGFzayB3ZSBleGVjdXRlLCB3ZSBkb24ndFxuICAgICAgICAvLyBzaGlmdCB0YXNrcyBvZmYgdGhlIHF1ZXVlIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBwZXJpb2RpY2FsbHkgc2hpZnQgMTAyNCB0YXNrcyBvZmYgdGhlIHF1ZXVlLlxuICAgICAgICBpZiAoaW5kZXggPiBjYXBhY2l0eSkge1xuICAgICAgICAgICAgLy8gTWFudWFsbHkgc2hpZnQgYWxsIHZhbHVlcyBzdGFydGluZyBhdCB0aGUgaW5kZXggYmFjayB0byB0aGVcbiAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGUgcXVldWUuXG4gICAgICAgICAgICBmb3IgKHZhciBzY2FuID0gMCwgbmV3TGVuZ3RoID0gcXVldWUubGVuZ3RoIC0gaW5kZXg7IHNjYW4gPCBuZXdMZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIHF1ZXVlW3NjYW5dID0gcXVldWVbc2NhbiArIGluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCAtPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGluZGV4ID0gMDtcbiAgICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBgcmVxdWVzdEZsdXNoYCBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHN0cmF0ZWd5IGJhc2VkIG9uIGRhdGEgY29sbGVjdGVkIGZyb21cbi8vIGV2ZXJ5IGF2YWlsYWJsZSBTYXVjZUxhYnMgU2VsZW5pdW0gd2ViIGRyaXZlciB3b3JrZXIgYXQgdGltZSBvZiB3cml0aW5nLlxuLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMW1HLTVVWUd1cDVxeEdkRU1Xa2hQNkJXQ3owNTNOVWIyRTFRb1VUVTE2dUEvZWRpdCNnaWQ9NzgzNzI0NTkzXG5cbi8vIFNhZmFyaSA2IGFuZCA2LjEgZm9yIGRlc2t0b3AsIGlQYWQsIGFuZCBpUGhvbmUgYXJlIHRoZSBvbmx5IGJyb3dzZXJzIHRoYXRcbi8vIGhhdmUgV2ViS2l0TXV0YXRpb25PYnNlcnZlciBidXQgbm90IHVuLXByZWZpeGVkIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXN0IHVzZSBgZ2xvYmFsYCBpbnN0ZWFkIG9mIGB3aW5kb3dgIHRvIHdvcmsgaW4gYm90aCBmcmFtZXMgYW5kIHdlYlxuLy8gd29ya2Vycy4gYGdsb2JhbGAgaXMgYSBwcm92aXNpb24gb2YgQnJvd3NlcmlmeSwgTXIsIE1ycywgb3IgTW9wLlxudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbi8vIE11dGF0aW9uT2JzZXJ2ZXJzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGhhdmUgaGlnaCBwcmlvcml0eSBhbmQgd29ya1xuLy8gcmVsaWFibHkgZXZlcnl3aGVyZSB0aGV5IGFyZSBpbXBsZW1lbnRlZC5cbi8vIFRoZXkgYXJlIGltcGxlbWVudGVkIGluIGFsbCBtb2Rlcm4gYnJvd3NlcnMuXG4vL1xuLy8gLSBBbmRyb2lkIDQtNC4zXG4vLyAtIENocm9tZSAyNi0zNFxuLy8gLSBGaXJlZm94IDE0LTI5XG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDExXG4vLyAtIGlQYWQgU2FmYXJpIDYtNy4xXG4vLyAtIGlQaG9uZSBTYWZhcmkgNy03LjFcbi8vIC0gU2FmYXJpIDYtN1xuaWYgKHR5cGVvZiBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuXG4vLyBNZXNzYWdlQ2hhbm5lbHMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgZ2l2ZSBkaXJlY3QgYWNjZXNzIHRvIHRoZSBIVE1MXG4vLyB0YXNrIHF1ZXVlLCBhcmUgaW1wbGVtZW50ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAsIFNhZmFyaSA1LjAtMSwgYW5kIE9wZXJhXG4vLyAxMS0xMiwgYW5kIGluIHdlYiB3b3JrZXJzIGluIG1hbnkgZW5naW5lcy5cbi8vIEFsdGhvdWdoIG1lc3NhZ2UgY2hhbm5lbHMgeWllbGQgdG8gYW55IHF1ZXVlZCByZW5kZXJpbmcgYW5kIElPIHRhc2tzLCB0aGV5XG4vLyB3b3VsZCBiZSBiZXR0ZXIgdGhhbiBpbXBvc2luZyB0aGUgNG1zIGRlbGF5IG9mIHRpbWVycy5cbi8vIEhvd2V2ZXIsIHRoZXkgZG8gbm90IHdvcmsgcmVsaWFibHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIgb3IgU2FmYXJpLlxuXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMCBpcyB0aGUgb25seSBicm93c2VyIHRoYXQgaGFzIHNldEltbWVkaWF0ZSBidXQgZG9lc1xuLy8gbm90IGhhdmUgTXV0YXRpb25PYnNlcnZlcnMuXG4vLyBBbHRob3VnaCBzZXRJbW1lZGlhdGUgeWllbGRzIHRvIHRoZSBicm93c2VyJ3MgcmVuZGVyZXIsIGl0IHdvdWxkIGJlXG4vLyBwcmVmZXJyYWJsZSB0byBmYWxsaW5nIGJhY2sgdG8gc2V0VGltZW91dCBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlXG4vLyB0aGUgbWluaW11bSA0bXMgcGVuYWx0eS5cbi8vIFVuZm9ydHVuYXRlbHkgdGhlcmUgYXBwZWFycyB0byBiZSBhIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCBNb2JpbGUgKGFuZFxuLy8gRGVza3RvcCB0byBhIGxlc3NlciBleHRlbnQpIHRoYXQgcmVuZGVycyBib3RoIHNldEltbWVkaWF0ZSBhbmRcbi8vIE1lc3NhZ2VDaGFubmVsIHVzZWxlc3MgZm9yIHRoZSBwdXJwb3NlcyBvZiBBU0FQLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL2lzc3Vlcy8zOTZcblxuLy8gVGltZXJzIGFyZSBpbXBsZW1lbnRlZCB1bml2ZXJzYWxseS5cbi8vIFdlIGZhbGwgYmFjayB0byB0aW1lcnMgaW4gd29ya2VycyBpbiBtb3N0IGVuZ2luZXMsIGFuZCBpbiBmb3JlZ3JvdW5kXG4vLyBjb250ZXh0cyBpbiB0aGUgZm9sbG93aW5nIGJyb3dzZXJzLlxuLy8gSG93ZXZlciwgbm90ZSB0aGF0IGV2ZW4gdGhpcyBzaW1wbGUgY2FzZSByZXF1aXJlcyBudWFuY2VzIHRvIG9wZXJhdGUgaW4gYVxuLy8gYnJvYWQgc3BlY3RydW0gb2YgYnJvd3NlcnMuXG4vL1xuLy8gLSBGaXJlZm94IDMtMTNcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgNi05XG4vLyAtIGlQYWQgU2FmYXJpIDQuM1xuLy8gLSBMeW54IDIuOC43XG59IGVsc2Uge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihmbHVzaCk7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIHJlcXVlc3RzIHRoYXQgdGhlIGhpZ2ggcHJpb3JpdHkgZXZlbnQgcXVldWUgYmUgZmx1c2hlZCBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZS5cbi8vIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYW4gZXJyb3IgdGhyb3duIGluIGEgdGFzayBmcm9tIHN0YWxsaW5nIHRoZSBldmVudFxuLy8gcXVldWUgaWYgdGhlIGV4Y2VwdGlvbiBoYW5kbGVkIGJ5IE5vZGUuanPigJlzXG4vLyBgcHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIpYCBvciBieSBhIGRvbWFpbi5cbnJhd0FzYXAucmVxdWVzdEZsdXNoID0gcmVxdWVzdEZsdXNoO1xuXG4vLyBUbyByZXF1ZXN0IGEgaGlnaCBwcmlvcml0eSBldmVudCwgd2UgaW5kdWNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgYnkgdG9nZ2xpbmdcbi8vIHRoZSB0ZXh0IG9mIGEgdGV4dCBub2RlIGJldHdlZW4gXCIxXCIgYW5kIFwiLTFcIi5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRvZ2dsZSA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIHRvZ2dsZSA9IC10b2dnbGU7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZTtcbiAgICB9O1xufVxuXG4vLyBUaGUgbWVzc2FnZSBjaGFubmVsIHRlY2huaXF1ZSB3YXMgZGlzY292ZXJlZCBieSBNYWx0ZSBVYmwgYW5kIHdhcyB0aGVcbi8vIG9yaWdpbmFsIGZvdW5kYXRpb24gZm9yIHRoaXMgbGlicmFyeS5cbi8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG5cbi8vIFNhZmFyaSA2LjAuNSAoYXQgbGVhc3QpIGludGVybWl0dGVudGx5IGZhaWxzIHRvIGNyZWF0ZSBtZXNzYWdlIHBvcnRzIG9uIGFcbi8vIHBhZ2UncyBmaXJzdCBsb2FkLiBUaGFua2Z1bGx5LCB0aGlzIHZlcnNpb24gb2YgU2FmYXJpIHN1cHBvcnRzXG4vLyBNdXRhdGlvbk9ic2VydmVycywgc28gd2UgZG9uJ3QgbmVlZCB0byBmYWxsIGJhY2sgaW4gdGhhdCBjYXNlLlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTWVzc2FnZUNoYW5uZWwoY2FsbGJhY2spIHtcbi8vICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuLy8gICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIEZvciByZWFzb25zIGV4cGxhaW5lZCBhYm92ZSwgd2UgYXJlIGFsc28gdW5hYmxlIHRvIHVzZSBgc2V0SW1tZWRpYXRlYFxuLy8gdW5kZXIgYW55IGNpcmN1bXN0YW5jZXMuXG4vLyBFdmVuIGlmIHdlIHdlcmUsIHRoZXJlIGlzIGFub3RoZXIgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuLy8gSXQgaXMgbm90IHN1ZmZpY2llbnQgdG8gYXNzaWduIGBzZXRJbW1lZGlhdGVgIHRvIGByZXF1ZXN0Rmx1c2hgIGJlY2F1c2Vcbi8vIGBzZXRJbW1lZGlhdGVgIG11c3QgYmUgY2FsbGVkICpieSBuYW1lKiBhbmQgdGhlcmVmb3JlIG11c3QgYmUgd3JhcHBlZCBpbiBhXG4vLyBjbG9zdXJlLlxuLy8gTmV2ZXIgZm9yZ2V0LlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tU2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIFNhZmFyaSA2LjAgaGFzIGEgcHJvYmxlbSB3aGVyZSB0aW1lcnMgd2lsbCBnZXQgbG9zdCB3aGlsZSB0aGUgdXNlciBpc1xuLy8gc2Nyb2xsaW5nLiBUaGlzIHByb2JsZW0gZG9lcyBub3QgaW1wYWN0IEFTQVAgYmVjYXVzZSBTYWZhcmkgNi4wIHN1cHBvcnRzXG4vLyBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHRoYXQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCBpbnN0ZWFkLlxuLy8gSG93ZXZlciwgaWYgd2UgZXZlciBlbGVjdCB0byB1c2UgdGltZXJzIGluIFNhZmFyaSwgdGhlIHByZXZhbGVudCB3b3JrLWFyb3VuZFxuLy8gaXMgdG8gYWRkIGEgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2FsbHMgZm9yIGEgZmx1c2guXG5cbi8vIGBzZXRUaW1lb3V0YCBkb2VzIG5vdCBjYWxsIHRoZSBwYXNzZWQgY2FsbGJhY2sgaWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhblxuLy8gYXBwcm94aW1hdGVseSA3IGluIHdlYiB3b3JrZXJzIGluIEZpcmVmb3ggOCB0aHJvdWdoIDE4LCBhbmQgc29tZXRpbWVzIG5vdFxuLy8gZXZlbiB0aGVuLlxuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIC8vIFdlIGRpc3BhdGNoIGEgdGltZW91dCB3aXRoIGEgc3BlY2lmaWVkIGRlbGF5IG9mIDAgZm9yIGVuZ2luZXMgdGhhdFxuICAgICAgICAvLyBjYW4gcmVsaWFibHkgYWNjb21tb2RhdGUgdGhhdCByZXF1ZXN0LiBUaGlzIHdpbGwgdXN1YWxseSBiZSBzbmFwcGVkXG4gICAgICAgIC8vIHRvIGEgNCBtaWxpc2Vjb25kIGRlbGF5LCBidXQgb25jZSB3ZSdyZSBmbHVzaGluZywgdGhlcmUncyBubyBkZWxheVxuICAgICAgICAvLyBiZXR3ZWVuIGV2ZW50cy5cbiAgICAgICAgdmFyIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVyLCAwKTtcbiAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhpcyB0aW1lciBnZXRzIGZyZXF1ZW50bHkgZHJvcHBlZCBpbiBGaXJlZm94XG4gICAgICAgIC8vIHdvcmtlcnMsIHdlIGVubGlzdCBhbiBpbnRlcnZhbCBoYW5kbGUgdGhhdCB3aWxsIHRyeSB0byBmaXJlXG4gICAgICAgIC8vIGFuIGV2ZW50IDIwIHRpbWVzIHBlciBzZWNvbmQgdW50aWwgaXQgc3VjY2VlZHMuXG4gICAgICAgIHZhciBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKGhhbmRsZVRpbWVyLCA1MCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBXaGljaGV2ZXIgdGltZXIgc3VjY2VlZHMgd2lsbCBjYW5jZWwgYm90aCB0aW1lcnMgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRoaXMgaXMgZm9yIGBhc2FwLmpzYCBvbmx5LlxuLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0IGRlcGVuZHMgb25cbi8vIGl0cyBleGlzdGVuY2UuXG5yYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lciA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcjtcblxuLy8gQVNBUCB3YXMgb3JpZ2luYWxseSBhIG5leHRUaWNrIHNoaW0gaW5jbHVkZWQgaW4gUS4gVGhpcyB3YXMgZmFjdG9yZWQgb3V0XG4vLyBpbnRvIHRoaXMgQVNBUCBwYWNrYWdlLiBJdCB3YXMgbGF0ZXIgYWRhcHRlZCB0byBSU1ZQIHdoaWNoIG1hZGUgZnVydGhlclxuLy8gYW1lbmRtZW50cy4gVGhlc2UgZGVjaXNpb25zLCBwYXJ0aWN1bGFybHkgdG8gbWFyZ2luYWxpemUgTWVzc2FnZUNoYW5uZWwgYW5kXG4vLyB0byBjYXB0dXJlIHRoZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIGluIGEgY2xvc3VyZSwgd2VyZSBpbnRlZ3JhdGVkXG4vLyBiYWNrIGludG8gQVNBUCBwcm9wZXIuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGlsZGVpby9yc3ZwLmpzL2Jsb2IvY2RkZjcyMzI1NDZhOWNmODU4NTI0Yjc1Y2RlNmY5ZWRmNzI2MjBhNy9saWIvcnN2cC9hc2FwLmpzXG4iLCIvKipcbiAqIGRpZ2l0cyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZGlnaXRzPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IEpvbiBTY2hsaW5rZXJ0XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYWQgPSByZXF1aXJlKCdwYWQtbGVmdCcpO1xudmFyIGxvbmdlc3QgPSByZXF1aXJlKCdsb25nZXN0Jyk7XG5cbi8qKlxuICogRXhwb3NlIGBkaWdpdHNgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkaWdpdHM7XG5cbi8qKlxuICogTGVmdCBwYWQgdGhlIGdpdmVuIGB2YWx1ZWAgd2l0aCB0aGUgc3BlY2lmaWVkIGBudW1iZXJgIG9mIHplcm9zXG4gKiBvciBhbHRlcm5hdGUgYGNoYXJhY3RlcmAuXG4gKlxuICogYGBganNcbiAqIGRpZ2l0cygnYWJjJywgMTApO1xuICogLy89PiAnMDAwMDAwMDAwMGFiYydcbiAqXG4gKiBkaWdpdHMoJ2FiYycsIDEwLCAnficpO1xuICogLy89PiAnfn5+fn5+fn5+fmFiYydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgdmFsdWVgXG4gKiBAcGFyYW0ge1N0cmluZ30gYG51bWJlcmBcbiAqIEByZXR1cm4ge1N0cmluZ30gYGNoYXJhY3RlcmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlnaXRzKHZhbCwgbnVtLCBjaCkge1xuICByZXR1cm4gcGFkKHZhbCwgbnVtIC0gdmFsLmxlbmd0aCwgY2gpO1xufVxuXG4vKipcbiAqIFBhZCBsZWZ0IHBhZCBlYWNoIHZhbHVlIGluIHRoZSBnaXZlbiBgYXJyYXlgIHRvIGFsaWduIHdpdGggdGhlXG4gKiBsb25nZXN0IGl0ZW0vbnVtYmVyIGluIHRoZSBhcnJheS4gWmVyb3MgYXJlIHVzZWQgYnkgZGVmYXVsdCwgYnV0XG4gKiBhIGN1c3RvbSBgY2hhcmFjdGVyYCBjYW4gYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gKlxuICogKipFeGFtcGxlKipcbiAqXG4gKiBgYGBqc1xuICogZGlnaXRzLmVhY2goWzEsIDEwMCwgMTAwMF0pXG4gKiAvLz0+IFsnMDAwMScsICcwMTAwJywgJzEwMDAnXVxuICpcbiAqIGRpZ2l0cy5lYWNoKFthLCBiYiwgY2NjXSwgJyAnKVxuICogLy89PiBbJyAgYScsICcgYmInLCAnY2NjJ11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBgYXJyYCBUaGUgYXJyYXkgb2YgdmFsdWVzIHRvIHBhZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBgbGVuYCBBbW91bnQgdG8gcGFkIHRoZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFBhZGRlZCBudW1iZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGlnaXRzLmVhY2ggPSBmdW5jdGlvbihhcnIsIGNoKSB7XG4gIHZhciBsZW4gPSBsb25nZXN0KGFycikubGVuZ3RoO1xuXG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uKGVsZSkge1xuICAgIHJldHVybiBkaWdpdHMoZWxlLCBsZW4sIGNoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFN0cmlwIGxlYWRpbmcgZGlnaXRzIGZyb20gYSBzdHJpbmdcbiAqXG4gKiBgYGBqc1xuICogZGlnaXRzLnN0cmlwbGVmdCgnMDEwZm9vLm1kJyk7XG4gKiAvLyA9PiBcImZvby5tZFwiXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZGlnaXRzLnN0cmlwbGVmdCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXGQrXFwtPy9nLCAnJyk7XG59O1xuXG4vKipcbiAqIFN0cmlwIHRyYWlsaW5nIGRpZ2l0cyBmcm9tIGEgc3RyaW5nXG4gKlxuICogYGBganNcbiAqIGRpZ2l0cy5zdHJpcHJpZ2h0KCdiYXIwMTAubWQnKTtcbiAqIC8vID0+IFwiYmFyLm1kXCJcbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbmRpZ2l0cy5zdHJpcHJpZ2h0ID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFwtP1xcZCskL2csICcnKTtcbn07XG5cbi8qKlxuICogQ291bnQgZGlnaXRzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgYSBzdHJpbmdcbiAqXG4gKiBgYGBqc1xuICogZGlnaXRzLmNvdW50bGVmdCgnMDAxLWZvby5tZCcpO1xuICogLy89PiAzXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZGlnaXRzLmNvdW50bGVmdCA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gU3RyaW5nKHN0ci5tYXRjaCgvXlxcZCsvZykpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ291bnQgZGlnaXRzIG9uIHRoZSByaWdodCBzaWRlIG9mIGEgc3RyaW5nXG4gKlxuICogYGBganNcbiAqIGRpZ2l0cy5jb3VudGxlZnQoJ2Zvby0wMDEubWQnKTtcbiAqIC8vPT4gM1xuICogYGBgXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZGlnaXRzLmNvdW50cmlnaHQgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHIubWF0Y2goL1xcZCskL2cpKS5sZW5ndGg7XG59O1xuIiwiLyoqXG4gKiBsb25nZXN0IGl0ZW0gaW4gYW4gYXJyYXlcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb24gU2NobGlua2VydCwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIpIHtcbiAgdmFyIGMgPSAwLFxuICAgIGxlbiA9IDAsXG4gICAgbCA9IDAsXG4gICAgaWR4ID0gYXJyLmxlbmd0aDtcbiAgaWYgKGlkeCkge1xuICAgIHdoaWxlIChpZHgtLSkge1xuICAgICAgbGVuID0gYXJyW2lkeF0ubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IGMpIHtcbiAgICAgICAgbCA9IGlkeDtcbiAgICAgICAgYyA9IGxlbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycltsXTtcbn07IiwiLyohXG4gKiBwYWQtbGVmdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvcGFkLWxlZnQ+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEpvbiBTY2hsaW5rZXJ0LCBjb250cmlidXRvcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVwZWF0ID0gcmVxdWlyZSgncmVwZWF0LXN0cmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhZExlZnQodmFsLCBudW0sIHN0cikge1xuICByZXR1cm4gcmVwZWF0KHN0ciB8fCAnMCcsIG51bSkgKyB2YWw7XG59O1xuIiwiLyohXG4gKiByZXBlYXQtc3RyaW5nIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9yZXBlYXQtc3RyaW5nPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb24gU2NobGlua2VydCwgY29udHJpYnV0b3JzLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlcGVhdC1zdHJpbmcgZXhwZWN0cyBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIGlmIChjb3VudCA8IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICBpZiAoY291bnQgJiAxKSB7XG4gICAgICByZXN1bHQgKz0gc3RyO1xuICAgIH1cbiAgICBjb3VudCA+Pj0gMTtcbiAgICBzdHIgKz0gc3RyO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBqc2NzOmRpc2FibGUgbWF4aW11bUxpbmVMZW5ndGhcbi8vIFRoaXMgZmlsZSBjb250YWlucyBkZWZpbml0aW9ucyBvZiBydWxlcyBob3cgbG9jYXRpb24gVVJMcyBhcmUgdHJhbnNsYXRlZFxuLy8gdG8gXCJyZW5kZXJcIiBtZXRob2RzIG9mIGNhdGJlcnJ5J3MgbW9kdWxlcy5cbi8vXG4vLyBGb3JtYXQ6XG4vLyAvc29tZS86cGFyYW1ldGVyW21vZHVsZTEsbW9kdWxlMixtb2R1bGUzXVxuLy9cbi8vIE1vcmUgZGV0YWlscyBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NhdGJlcnJ5L2NhdGJlcnJ5L2Jsb2IvbWFzdGVyL2RvY3MvaW5kZXgubWQjdXJsLXJvdXRlLWRlZmluaXRpb25cblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICAgJy86cGFnZVtQYWdlc10nLFxuICAgIC8vaWQg0LzQsNGB0YLQtdGA0LBcbiAgICB7XG4gICAgICAgIGV4cHJlc3Npb246IC9cXC8oW1xcL1xcZF0rKSQvaSxcbiAgICAgICAgbWFwOiBmdW5jdGlvbiAodXJsUGF0aCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB1cmxQYXRoLnBhdGgubWF0Y2goL1xcLyhbXFwvXFxkXSspJC9pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ21hc3Rlci9NYXN0ZXJJdGVtJzoge1xuICAgICAgICAgICAgICAgICAgICBpdGVtOiBtYXRjaGVzWzFdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBQYWdlczoge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiBcIm1hc3Rlci1wYWdlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8v0YHRgtCw0YLRjNGPINC80LDRgdGC0LXRgNCwXG4gICAge1xuICAgICAgICBleHByZXNzaW9uOiAnL1xcLyhbXFwvXFxkXSspXFwvYXJ0aWNsZVxcLyhbXFwvXFxkXSspJC9pJyxcbiAgICAgICAgbWFwOiBmdW5jdGlvbiAodXJsUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBQYWdlczoge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiBcIm1hc3Rlci1hcnRpY2xlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vINC/0YPRgtGMOiDRgNGD0LHRgNC40LrQsC/Qv9C+0LTRgNGD0LHRgNC40LrQsFxuICAgIC8vINC/0YPRgtGMOiDRgNGD0LHRgNC40LrQsC/Qv9C+0LTRgNGD0LHRgNC40LrQsC/RgtC10LNcbiAgICAvLyDQv9GD0YLRjDog0YDRg9Cx0YDQuNC60LAv0L/QvtC00YDRg9Cx0YDQuNC60LAv0YHQtdC60YbQuNGPXG4gICAgLy8g0L/Rg9GC0Yw6INGA0YPQsdGA0LjQutCwL9C/0L7QtNGA0YPQsdGA0LjQutCwL9GC0LXQsy/RgdC10LrRhtC40Y9cbiAgICB7XG4gICAgICAgIGV4cHJlc3Npb246IC9eXFwvKFteXFwvXFxkXSspXFwvKFteXFwvXFxkXSspXFwvPygoPyF2aWRlb3xzYWxlfHNvdmV0eXxjb21wYW55KVteXFwvXFxkXSspP1xcLz8odmlkZW98c2FsZXxzb3ZldHl8Y29tcGFueSk/JC9pLFxuICAgICAgICBtYXA6IGZ1bmN0aW9uICh1cmxQYXRoKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHVybFBhdGgucGF0aC5tYXRjaCgvXlxcLyhbXlxcL1xcZF0rKVxcLyhbXlxcL1xcZF0rKVxcLz8oKD8hdmlkZW98c2FsZXxzb3ZldHl8Y29tcGFueSlbXlxcL1xcZF0rKT9cXC8/KHZpZGVvfHNhbGV8c292ZXR5fGNvbXBhbnkpPyQvaSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICdydWJyaWthL1J1YnJpa2EnOiB7XG4gICAgICAgICAgICAgICAgICAgIHJ1YnJpa2E6IG1hdGNoZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBvZHJ1YnJpa2E6IG1hdGNoZXNbMl1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFRhZzoge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IG1hdGNoZXNbM10sXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb246IG1hdGNoZXNbNF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFBhZ2VzOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IFwibWFzdGVyLXJ1YnJpa2FcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8g0L/Rg9GC0Yw6IC9fXy9wYWdlLzppZFxuICAgIHtcbiAgICAgICAgZXhwcmVzc2lvbjogL15cXC8oW15cXC9cXGRdKylcXC9wYWdlXFwvKFxcZCspL2ksXG4gICAgICAgIG1hcDogZnVuY3Rpb24gKHVybFBhdGgpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdXJsUGF0aC5wYXRoLm1hdGNoKC9eXFwvKFteXFwvXFxkXSspXFwvcGFnZVxcLyhcXGQrKS9pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgUGFnZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogbWF0Y2hlc1sxXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgUGFnaW5hdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlOiBtYXRjaGVzWzJdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8g0L/Rg9GC0Yw6IC9zYWxlXG4gICAgLy8g0L/Rg9GC0Yw6IC9zb3ZldHlcbiAgICAvLyDQv9GD0YLRjDogL3ZpZGVvXG4gICAgLy8g0L/Rg9GC0Yw6IC9fXy9wYWdlLzppZFxuICAgIC8vINC/0YPRgtGMOiAvX18vY2F0ZWdvcnkvOmlkXG4gICAgLy8g0L/Rg9GC0Yw6IC9fXy9jYXRlZ29yeS86aWQvcGFnZS86aWRcbiAgICB7XG4gICAgICAgIGV4cHJlc3Npb246IC9eXFwvKHNhbGV8c292ZXR5fHZpZGVvKShcXC9jYXRhbG9nXFwvKFxcZCspKT8oXFwvcGFnZVxcLyhcXGQrKSk/JC9pLFxuICAgICAgICBtYXA6IGZ1bmN0aW9uICh1cmxQYXRoKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHVybFBhdGgucGF0aC5tYXRjaCgvXlxcLyhzYWxlfHNvdmV0eXx2aWRlbykoXFwvY2F0YWxvZ1xcLyhcXGQrKSk/KFxcL3BhZ2VcXC8oXFxkKykpPyQvaSk7XG4gICAgICAgICAgICB2YXIgbmFtZUNhcGl0YWxpemVGaXJzdExldHRlciA9IG1hdGNoZXNbMV0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBtYXRjaGVzWzFdLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0ge307XG5cbiAgICAgICAgICAgIHN0YXRlLlBhZ2VzID0ge1xuICAgICAgICAgICAgICAgIHBhZ2U6IG1hdGNoZXNbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdGF0ZVsncnVicmlrYS9SdWJyaWthdG9yJyArIG5hbWVDYXBpdGFsaXplRmlyc3RMZXR0ZXJdID0ge1xuICAgICAgICAgICAgICAgIGNhdGFsb2c6IG1hdGNoZXNbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdGF0ZS5QYWdpbmF0b3IgPSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2U6IG1hdGNoZXNbNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vINC/0YPRgtGMOiAvbmV3cy9pdGVtLzppZFxuICAgIC8vINC/0YPRgtGMOiAvdmFjYW5jeS9pdGVtLzppZFxuICAgIC8vINC/0YPRgtGMOiAva29ua3Vycy9pdGVtLzppZFxuICAgIHtcbiAgICAgICAgZXhwcmVzc2lvbjogL15cXC8obmV3c3x2YWNhbmN5fGtvbmt1cnMpXFwvaXRlbVxcLyhcXGQrKSQvaSxcbiAgICAgICAgbWFwOiBmdW5jdGlvbiAodXJsUGF0aCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB1cmxQYXRoLnBhdGgubWF0Y2goL15cXC8obmV3c3x2YWNhbmN5fGtvbmt1cnMpXFwvaXRlbVxcLyhcXGQrKSQvaSk7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB7fTtcblxuICAgICAgICAgICAgdmFyIHN0cmluZyA9IG1hdGNoZXNbMV07XG5cbiAgICAgICAgICAgIHN0YXRlLlBhZ2VzID0ge1xuICAgICAgICAgICAgICAgIHBhZ2U6IHN0cmluZyArIFwiLWl0ZW1cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0YXRlWydvdGhlci8nICsgc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpICsgXCJJdGVtXCJdID0ge1xuICAgICAgICAgICAgICAgIGl0ZW06IG1hdGNoZXNbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGlnaXRzID0gcmVxdWlyZSgnZGlnaXRzJyk7XG5cbnZhciBEYXRlcyA9IHJlcXVpcmUoJy4vdXRpbHMvZGF0ZXMnKTtcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSGFuZGxlYmFycykge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGVhdCAgaGVscGVyXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gbiAgICAgICBudW1iZXIgb2YgaXRlcmF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG9wdGlvbnMgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgcmVwZWF0OiBmdW5jdGlvbiAobiwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgX2RhdGEgPSB7fSxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gJycsXG4gICAgICAgICAgICAgICAgY291bnQgPSBuIC0gMTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuX2RhdGEpIHtcbiAgICAgICAgICAgICAgICBfZGF0YSA9IEhhbmRsZWJhcnMuY3JlYXRlRnJhbWUob3B0aW9ucy5fZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBfZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGRpZ2l0cy5wYWQoKGkgKyAxKSwge2F1dG86IG59KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBvcHRpb25zLmZuKHRoaXMsIHtkYXRhOiBfZGF0YX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIYW5kbGViYXJzLlNhZmVTdHJpbmcoY29udGVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGhlbHBlciB3aXRoIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGEgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBiICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gb3B0aW9ucyAgb3BlcmF0aW9uXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgaXM6IGZ1bmN0aW9uIChsZWZ0T3BlcmFuZCwgb3BlcmF0aW9uLCByaWdodE9wZXJhbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBhID0gbGVmdE9wZXJhbmQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgYiA9IHJpZ2h0T3BlcmFuZCB8fCBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiAmJiB0eXBlb2Ygb3BlcmF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHN0cmljdGx5IGVxdWFsXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmljdGx5IGVxdWFsXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYSA+IGIgY2hlY2tpbmdcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgPj0gYiBjaGVja2luZ1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA+PSBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAvLyBhIDwgYiBjaGVja2luZ1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYSA8PSBiIGNoZWNraW5nXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhIDw9IGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFjdGlvbiwgaWYgb3BlcmF0aW9uIGlzIHVua25vd25cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnT3BlcmF0aW9uIGlzIHVua25vd24hXFxuXCJpc1wiIGhlbHBlciBzdXBwb3J0cyBvbmx5OlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIj09XCIsXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiPT09XCIsXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiPlwiLFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIj49XCIsXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiPFwiLFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIjw9XCIsXFxuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIGhhdmUgdG8gYmUgcmVjaXZlZCBhbmQgaGF2ZSB0byBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0ciB0byBsb3dlciBjYXNlXG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gc3RyIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKi9cbiAgICAgICAgdG9Mb3dlckNhc2U6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3RyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyIHRvIHVwcGVyIGNhc2VcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzdHIgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICBbZGVzY3JpcHRpb25dXG4gICAgICAgICAqL1xuICAgICAgICB0b1VwcGVyQ2FzZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzdHIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXBpdGFsaXplIGZpcnN0IHN5bWJvbCBvZiBzdHJcbiAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSBzdHIgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICBbZGVzY3JpcHRpb25dXG4gICAgICAgICAqL1xuICAgICAgICBjYXBpdGFsaXplRmlyc3Q6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3RyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB3aGl0ZXNwYWNlcyBmcm9tIHJlY2l2ZWQgZGF0YSB0byBoZWxwZXJcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICovXG4gICAgICAgIHN0cmlwOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgIHZhciBfZGF0YSA9IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSAnJztcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuX2RhdGEpIHtcbiAgICAgICAgICAgICAgICBfZGF0YSA9IEhhbmRsZWJhcnMuY3JlYXRlRnJhbWUob3B0aW9ucy5fZGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBvcHRpb25zLmZuKHRoaXMsIHtkYXRhOiBfZGF0YX0pLnJlcGxhY2UoLz4oXFxzKyk8L2csICc+PCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEhhbmRsZWJhcnMuU2FmZVN0cmluZyhjb250ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpcFRhZ3M6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC88IS0tW15dKi0tPi9nLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzxcXC8/W14+XSs+L2dpLCAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RyaXBTdHlsZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8gc3R5bGU9XCJbXlwiXSpcIi9nLCAnJylcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICoge3tmb3JtYXREYXRhfX1cbiAgICAgICAgICogUG9ydCBvZiBmb3JtYXREYXRlLWpzIGxpYnJhcnkgKGh0dHA6Ly9iaXQubHkvMThlbzJ4dylcbiAgICAgICAgICogQHBhcmFtICB7W3R5cGVdfSBkYXRlICAgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcm1hdCBbZGVzY3JpcHRpb25dXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICovXG4gICAgICAgIGZvcm1hdERhdGU6IGZ1bmN0aW9uIChkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiBEYXRlcy5mb3JtYXQoZGF0ZSwgZm9ybWF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICoge3tub3d9fVxuICAgICAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcm1hdCBbZGVzY3JpcHRpb25dXG4gICAgICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgICAgICovXG4gICAgICAgIG5vdzogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzVW5kZWZpbmVkKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLmZvcm1hdChkYXRlLCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB7e2kxOG59fVxuICAgICAgICAgKiBAYXV0aG9yOiBMYXVyZW50IEdvZGVycmUgPGh0dHBzOi8vZ2l0aHViLmNvbS9MYXVyZW50R29kZXJycmU+XG4gICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAgICAgKiBAZXhhbXBsZTogPGh0dHBzOi8vZ2l0aHViLmNvbS9hc3NlbWJsZS9idXR0b25zPiAoU2VlIHRoZSBcImJ1dHRvbi1pMThuXCIgZXhhbXBsZSlcbiAgICAgICAgICovXG4gICAgICAgIGkxOG46IGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbGFuZ3VhZ2UgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnS2V5IG11c3QgYmUgb2YgdHlwZSBcXCdzdHJpbmdcXCcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYW5ndWFnZSA9ICh0eXBlb2Ygb3B0aW9ucy5oYXNoLmxhbmd1YWdlID09PSAnc3RyaW5nJyA/IG9wdGlvbnMuaGFzaC5sYW5ndWFnZSA6IHRoaXMubGFuZ3VhZ2UpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUaGUgXFwnbGFuZ3VhZ2VcXCcgcGFyYW1ldGVyIGlzIG5vdCBkZWZpbmVkJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2xhbmd1YWdlXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRocm93ICdObyBzdHJpbmdzIGZvdW5kIGZvciBsYW5ndWFnZSBcXCdcIiArIGxhbmd1YWdlICsgXCJcXCcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbbGFuZ3VhZ2VdW2NvbnRleHRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ05vIHN0cmluZyBmb3Iga2V5IFxcJ1wiICsgY29udGV4dCArIFwiXFwnIGZvciBsYW5ndWFnZSBcXCdcIiArIGxhbmd1YWdlICsgXCJcXCcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tsYW5ndWFnZV1bY29udGV4dF07XG4gICAgICAgIH0sXG4gICAgICAgIGljb246IGZ1bmN0aW9uIChuYW1lLCBzZWxlY3Rvciwgc3lzKSB7XG4gICAgICAgICAgICB2YXIgY2wgPSAnaWNvbiBpY29uXycgKyBuYW1lO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjbCArPSBcIiBcIiArIHNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEhhbmRsZWJhcnMuU2FmZVN0cmluZyhcbiAgICAgICAgICAgICAgICAnPHN2ZyByb2xlPVwiaW1nXCIgdGl0bGU9XCJpY29uXycgKyBuYW1lICsgJ1wiIGNsYXNzPVwiJyArIGNsICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgICc8dXNlIHhsaW5rOmhyZWY9XCIvaWNvbi1zdmcvc3ZnLXN5bWJvbHMuc3ZnI2ljb25fJyArIG5hbWUgKyAnXCIvPicgK1xuICAgICAgICAgICAgICAgICc8L3N2Zz4nXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBpbWdTcmM6IGZ1bmN0aW9uIChpbWdJZCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIGltZ1NyYyA9ICdodHRwOi8vYXBpLWZtLnByZXNlbnQtdGx0LnJ1L2ZpbGVzP2tleT0nICsgaW1nSWQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Yod2lkdGgpICE9IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mKHdpZHRoKSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaW1nU3JjID0gaW1nU3JjICsgJyZ3aWR0aD0nICsgd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mKGhlaWdodCkgIT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YoaGVpZ2h0KSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaW1nU3JjID0gaW1nU3JjICsgJyZoZWlnaHQ9JyArIGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaW1nU3JjKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGFuZGxlYmFycy5TYWZlU3RyaW5nKGltZ1NyYyk7XG4gICAgICAgIH1cbiAgICB9O1xufTsiLCIvKipcbiAqIEhhbmRsZWJhcnMgSGVscGVycyBVdGlsc1xuICogaHR0cDovL2dpdGh1Yi5jb20vYXNzZW1ibGUvaGFuZGxlYmFycy1oZWxwZXJzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgSm9uIFNjaGxpbmtlcnQsIEJyaWFuIFdvb2R3YXJkLCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0ZXMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5EYXRlcy5wYWROdW1iZXIgPSBmdW5jdGlvbiAobnVtLCBjb3VudCwgcGFkQ2hhcmFjdGVyKSB7XG5cbiAgICBpZiAodHlwZW9mIHBhZENoYXJhY3RlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFkQ2hhcmFjdGVyID0gJzAnO1xuICAgIH1cblxuICAgIHZhciBsZW5EaWZmID0gY291bnQgLSBTdHJpbmcobnVtKS5sZW5ndGg7XG4gICAgdmFyIHBhZGRpbmcgPSAnJztcblxuICAgIGlmIChsZW5EaWZmID4gMCkge1xuICAgICAgICB3aGlsZSAobGVuRGlmZi0tKSB7XG4gICAgICAgICAgICBwYWRkaW5nICs9IHBhZENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFkZGluZyArIG51bTtcbn07XG5cbkRhdGVzLmRheU9mWWVhciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgdmFyIG9uZUphbiA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG5cbiAgICByZXR1cm4gTWF0aC5jZWlsKChkYXRlIC0gb25lSmFuKSAvIDg2NDAwMDAwKTtcbn07XG5cbkRhdGVzLndlZWtPZlllYXIgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHZhciBvbmVKYW4gPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoKCgoZGF0ZSAtIG9uZUphbikgLyA4NjQwMDAwMCkgKyBvbmVKYW4uZ2V0RGF5KCkgKyAxKSAvIDcpO1xufTtcblxuRGF0ZXMuaXNvV2Vla09mWWVhciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgdmFyIHRhcmdldCA9IG5ldyBEYXRlKGRhdGUudmFsdWVPZigpKTtcbiAgICB2YXIgZGF5TnIgPSAoZGF0ZS5nZXREYXkoKSArIDYpICUgNztcbiAgICB0YXJnZXQuc2V0RGF0ZSh0YXJnZXQuZ2V0RGF0ZSgpIC0gZGF5TnIgKyAzKTtcbiAgICB2YXIgamFuNCA9IG5ldyBEYXRlKHRhcmdldC5nZXRGdWxsWWVhcigpLCAwLCA0KTtcbiAgICB2YXIgZGF5RGlmZiA9ICh0YXJnZXQgLSBqYW40KSAvIDg2NDAwMDAwO1xuXG4gICAgcmV0dXJuIDEgKyBNYXRoLmNlaWwoZGF5RGlmZiAvIDcpO1xufTtcblxuRGF0ZXMudHdlbGV2ZUhvdXIgPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIGlmIChkYXRlLmdldEhvdXJzKCkgPiAxMikge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRIb3VycygpIC0gMTI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKTtcbn07XG5cbkRhdGVzLnRpbWVab25lT2Zmc2V0ID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICB2YXIgaG91cnNEaWZmID0gLWRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDYwO1xuICAgIHZhciByZXN1bHQgPSBEYXRlcy5wYWROdW1iZXIoTWF0aC5hYnMoaG91cnNEaWZmKSwgNCk7XG5cbiAgICByZXR1cm4gKGhvdXJzRGlmZiA+IDAgPyAnKycgOiAnLScpICsgcmVzdWx0O1xufTtcblxuRGF0ZXMuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGUsIGZvcm1hdCkge1xuICAgIHZhciBtYXRjaCA9IG51bGw7XG4gICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKERhdGVzLmZvcm1hdHMsIGZ1bmN0aW9uIChtLCBwKSB7XG4gICAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLmFiYnJldmlhdGVkV2Vla2RheXNbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMuZnVsbFdlZWtkYXlzW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLmFiYnJldmlhdGVkTW9udGhzW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMuZ2V0RnVsbE1vdW50aChkYXRlLmdldE1vbnRoKCksIFwiUnVcIik7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGF0ZS5nZXRGdWxsWWVhcigpIC8gMTAwKTtcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlcy5wYWROdW1iZXIoZGF0ZS5nZXREYXRlKCksIDIpO1xuICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLmZvcm1hdChkYXRlLCAnJW0vJWQvJXknKTtcbiAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlcy5wYWROdW1iZXIoZGF0ZS5nZXREYXRlKCksIDIsICcgJyk7XG4gICAgICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMuZm9ybWF0KGRhdGUsICclWS0lbS0lZCcpO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLmZvcm1hdChkYXRlLCAnJWInKTtcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlcy5wYWROdW1iZXIoZGF0ZS5nZXRIb3VycygpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlcy5wYWROdW1iZXIoRGF0ZXMudHdlbGV2ZUhvdXIoZGF0ZSksIDIpO1xuICAgICAgICAgICAgY2FzZSAnaic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLnBhZE51bWJlcihEYXRlcy5kYXlPZlllYXIoZGF0ZSksIDMpO1xuICAgICAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLnBhZE51bWJlcihkYXRlLmdldEhvdXJzKCksIDIsICcgJyk7XG4gICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMucGFkTnVtYmVyKERhdGVzLnR3ZWxldmVIb3VyKGRhdGUpLCAyLCAnICcpO1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLnBhZE51bWJlcihkYXRlLmdldE1pbGxpc2Vjb25kcygpLCAzKTtcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlcy5wYWROdW1iZXIoZGF0ZS5nZXRNb250aCgpICsgMSwgMik7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMucGFkTnVtYmVyKGRhdGUuZ2V0TWludXRlcygpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFxuJztcbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgIGlmIChkYXRlLmdldEhvdXJzKCkgPiAxMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1BNJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0FNJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMuZm9ybWF0KGRhdGUsICclcCcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMuZm9ybWF0KGRhdGUsICclSTolTTolUyAlcCcpO1xuICAgICAgICAgICAgY2FzZSAnUic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLmZvcm1hdChkYXRlLCAnJUg6JU0nKTtcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMucGFkTnVtYmVyKGRhdGUuZ2V0U2Vjb25kcygpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnXFx0JztcbiAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlcy5mb3JtYXQoZGF0ZSwgJyVIOiVNOiVTJyk7XG4gICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZS5nZXREYXkoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMucGFkTnVtYmVyKERhdGVzLndlZWtPZlllYXIoZGF0ZSksIDIpO1xuICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLmZvcm1hdChkYXRlLCAnJWUtJWItJVknKTtcbiAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlcy5wYWROdW1iZXIoRGF0ZXMuaXNvV2Vla09mWWVhcihkYXRlKSwgMik7XG4gICAgICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZXMucGFkTnVtYmVyKERhdGVzLndlZWtPZlllYXIoZGF0ZSksIDIpO1xuICAgICAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVzLnBhZE51bWJlcihkYXRlLmdldERheSgpLCAyKTtcbiAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKGRhdGUuZ2V0RnVsbFllYXIoKSkuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlcy50aW1lWm9uZU9mZnNldChkYXRlKTtcbiAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlcy5mdWxsTW9udGhzUnVQW2RhdGUuZ2V0TW9udGgoKV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuRGF0ZXMuZm9ybWF0cyA9IC8lKGF8QXxifEJ8Y3xDfGR8RHxlfEV8RnxofEh8SXxqfGt8bHxMfG18TXxufHB8UHxyfFJ8c3xTfHR8VHx1fFV8dnxWfFd8d3x4fFh8eXxZfHp8WikvZztcblxuRGF0ZXMuYWJicmV2aWF0ZWRXZWVrZGF5cyA9IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodXInLCAnRnJpJywgJ1NhdCddO1xuRGF0ZXMuZnVsbFdlZWtkYXlzID0gWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddO1xuRGF0ZXMuYWJicmV2aWF0ZWRNb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5EYXRlcy5mdWxsTW9udGhzID0gWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ107XG5cbkRhdGVzLmZ1bGxNb250aHNSdVAgPSBbJ9Cv0L3QstCw0YDRjycsICfQpNC10LLRgNCw0LvRjycsICfQnNCw0YDRgtCwJywgJ9CQ0L/RgNC10LvRjycsICfQnNCw0Y8nLCAn0JjRjtC90Y8nLCAn0JjRjtC70Y8nLCAn0JDQstCz0YPRgdGC0LAnLCAn0KHQtdC90YLRj9Cx0YDRjycsICfQntC60YLRj9Cx0YDRjycsICfQndC+0Y/QsdGA0Y8nLCAn0JTQtdC60LDQsdGA0Y8nXTtcbkRhdGVzLmZ1bGxNb250aHNSdSA9IFsn0K/QvdCy0LDRgNGMJywgJ9Ck0LXQstGA0LDQu9GMJywgJ9Cc0LDRgNGCJywgJ9CQ0L/RgNC10LvRjCcsICfQnNCw0LknLCAn0JjRjtC90YwnLCAn0JjRjtC70YwnLCAn0JDQstCz0YPRgdGCJywgJ9Ch0LXQvdGC0Y/QsdGA0YwnLCAn0J7QutGC0Y/QsdGA0YwnLCAn0J3QvtGP0LHRgNGMJywgJ9CU0LXQutCw0LHRgNGMJ107XG5cbkRhdGVzLmdldEZ1bGxNb3VudGggPSBmdW5jdGlvbiAobnVtLCBsYW5nKSB7XG4gICAgaWYgKGxhbmcgPT0gXCJSdVwiKVxuICAgICAgICByZXR1cm4gRGF0ZXMuZnVsbE1vbnRoc1J1O1xuICAgIHJldHVybiBEYXRlcy5mdWxsTW9udGhzO1xufVxuXG4iLCIvKipcbiAqIEhhbmRsZWJhcnMgSGVscGVyczogVXRpbHNcbiAqIGh0dHA6Ly9naXRodWIuY29tL2Fzc2VtYmxlL2hhbmRsZWJhcnMtaGVscGVyc1xuICogQ29weXJpZ2h0IChjKSAyMDEzLCAyMDE0IEpvbiBTY2hsaW5rZXJ0LCBCcmlhbiBXb29kd2FyZCwgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCkuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZS50b1N0cmluZygpID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8ICh2YWx1ZS5oYXNoICE9IG51bGwpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYWxsIGhlbHBlcnMuXG4gICAgICogQHBhcmFtIHtTZXJ2aWNlTG9jYXRvcn0gbG9jYXRvciBDYXRiZXJyeSdzIHNlcnZpY2UgbG9jYXRvci5cbiAgICAgKi9cbiAgICByZWdpc3RlcjogZnVuY3Rpb24gKGxvY2F0b3IpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IGxvY2F0b3IucmVzb2x2ZSgnY29uZmlnJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlYmFycyA9IGxvY2F0b3IucmVzb2x2ZSgnaGFuZGxlYmFycycpO1xuICAgICAgICAgICAgdmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hhbmRsZWJhcnMtaGVscGVyJykoaGFuZGxlYmFycyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhlbHBlcnMpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcihuYW1lLCBoZWxwZXJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkby5cbiAgICAgICAgfVxuICAgIH1cbn07IiwiLypcbiAqIGNhdGJlcnJ5LWhhbmRsZWJhcnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeS1oYW5kbGViYXJzJ3MgbGljZW5zZSBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgbGljZW5zZSBhcHBsaWVzIHRvIGFsbCBwYXJ0cyBvZiBjYXRiZXJyeS1oYW5kbGViYXJzIHRoYXQgYXJlXG4gKiBub3QgZXh0ZXJuYWxseSBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVGVtcGxhdGVQcm92aWRlcjtcblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBpbnN0YW5jZSBvZiBIYW5kbGViYXJzIHRlbXBsYXRlIHByb3ZpZGVyLlxuICogQHBhcmFtIHtIYW5kbGViYXJzfSAkaGFuZGxlYmFycyBIYW5kbGViYXJzIGZhY3RvcnkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVGVtcGxhdGVQcm92aWRlcigkaGFuZGxlYmFycykge1xuXHR0aGlzLl9oYW5kbGViYXJzID0gJGhhbmRsZWJhcnM7XG5cdHRoaXMuX3RlbXBsYXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogQ3VycmVudCBIYW5kbGViYXJzIGZhY3RvcnkuXG4gKiBAdHlwZSB7SGFuZGxlYmFyc31cbiAqIEBwcml2YXRlXG4gKi9cblRlbXBsYXRlUHJvdmlkZXIucHJvdG90eXBlLl9oYW5kbGViYXJzID0gbnVsbDtcblxuLyoqXG4gKiBDdXJyZW50IHNldCBvZiByZWdpc3RlcmVkIHRlbXBsYXRlcy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5UZW1wbGF0ZVByb3ZpZGVyLnByb3RvdHlwZS5fdGVtcGxhdGVzID0gbnVsbDtcblxuLyoqXG4gKiBSZWdpc3RlcnMgY29tcGlsZWQgKHByZWNvbXBpbGVkKSBIYW5kbGViYXJzIHRlbXBsYXRlLlxuICogaHR0cDovL2hhbmRsZWJhcnNqcy5jb20vcmVmZXJlbmNlLmh0bWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRlbXBsYXRlIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcGlsZWQgQ29tcGlsZWQgdGVtcGxhdGUgc291cmNlLlxuICovXG5UZW1wbGF0ZVByb3ZpZGVyLnByb3RvdHlwZS5yZWdpc3RlckNvbXBpbGVkID0gZnVuY3Rpb24gKG5hbWUsIGNvbXBpbGVkKSB7XG5cdC8vIGpzaGludCBldmlsOnRydWVcblx0dmFyIHNwZWNzID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGNvbXBpbGVkICsgJzsnKTtcblx0dGhpcy5fdGVtcGxhdGVzW25hbWVdID0gdGhpcy5faGFuZGxlYmFycy50ZW1wbGF0ZShzcGVjcygpKTtcbn07XG5cbi8qKlxuICogUmVuZGVycyB0ZW1wbGF0ZSB3aXRoIHNwZWNpZmllZCBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgY29udGV4dCBmb3IgdGVtcGxhdGUuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQcm9taXNlIGZvciByZW5kZXJlZCBIVE1MLlxuICovXG5UZW1wbGF0ZVByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuXHRpZiAoIShuYW1lIGluIHRoaXMuX3RlbXBsYXRlcykpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdObyBzdWNoIHRlbXBsYXRlJykpO1xuXHR9XG5cblx0dmFyIHByb21pc2U7XG5cdHRyeSB7XG5cdFx0cHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aGlzLl90ZW1wbGF0ZXNbbmFtZV0oZGF0YSkpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cHJvbWlzZSA9IFByb21pc2UucmVqZWN0KGUpO1xuXHR9XG5cdHJldHVybiBwcm9taXNlO1xufTsiLCIvKiFcblxuIGhhbmRsZWJhcnMgdjIuMC4wXG5cbkNvcHlyaWdodCAoQykgMjAxMS0yMDE0IGJ5IFllaHVkYSBLYXR6XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuQGxpY2Vuc2VcbiovXG4vKiBleHBvcnRlZCBIYW5kbGViYXJzICovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5IYW5kbGViYXJzID0gcm9vdC5IYW5kbGViYXJzIHx8IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4vLyBoYW5kbGViYXJzL3NhZmUtc3RyaW5nLmpzXG52YXIgX19tb2R1bGUzX18gPSAoZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19leHBvcnRzX187XG4gIC8vIEJ1aWxkIG91dCBvdXIgYmFzaWMgU2FmZVN0cmluZyB0eXBlXG4gIGZ1bmN0aW9uIFNhZmVTdHJpbmcoc3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gIH1cblxuICBTYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlwiICsgdGhpcy5zdHJpbmc7XG4gIH07XG5cbiAgX19leHBvcnRzX18gPSBTYWZlU3RyaW5nO1xuICByZXR1cm4gX19leHBvcnRzX187XG59KSgpO1xuXG4vLyBoYW5kbGViYXJzL3V0aWxzLmpzXG52YXIgX19tb2R1bGUyX18gPSAoZnVuY3Rpb24oX19kZXBlbmRlbmN5MV9fKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19leHBvcnRzX18gPSB7fTtcbiAgLypqc2hpbnQgLVcwMDQgKi9cbiAgdmFyIFNhZmVTdHJpbmcgPSBfX2RlcGVuZGVuY3kxX187XG5cbiAgdmFyIGVzY2FwZSA9IHtcbiAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICBcIj5cIjogXCImZ3Q7XCIsXG4gICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICBcIidcIjogXCImI3gyNztcIixcbiAgICBcImBcIjogXCImI3g2MDtcIlxuICB9O1xuXG4gIHZhciBiYWRDaGFycyA9IC9bJjw+XCInYF0vZztcbiAgdmFyIHBvc3NpYmxlID0gL1smPD5cIidgXS87XG5cbiAgZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gZXNjYXBlW2Nocl07XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQob2JqIC8qICwgLi4uc291cmNlICovKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIF9fZXhwb3J0c19fLmV4dGVuZCA9IGV4dGVuZDt2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICBfX2V4cG9ydHNfXy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAvLyBTb3VyY2VkIGZyb20gbG9kYXNoXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcbiAgdmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gIH07XG4gIC8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoaXNGdW5jdGlvbigveC8pKSB7XG4gICAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH07XG4gIH1cbiAgdmFyIGlzRnVuY3Rpb247XG4gIF9fZXhwb3J0c19fLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgOiBmYWxzZTtcbiAgfTtcbiAgX19leHBvcnRzX18uaXNBcnJheSA9IGlzQXJyYXk7XG5cbiAgZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcbiAgICAvLyBkb24ndCBlc2NhcGUgU2FmZVN0cmluZ3MsIHNpbmNlIHRoZXkncmUgYWxyZWFkeSBzYWZlXG4gICAgaWYgKHN0cmluZyBpbnN0YW5jZW9mIFNhZmVTdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcudG9TdHJpbmcoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9IGVsc2UgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgKyAnJztcbiAgICB9XG5cbiAgICAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcbiAgICAvLyB0aGUgcmVnZXggdGVzdCB3aWxsIGRvIHRoaXMgdHJhbnNwYXJlbnRseSBiZWhpbmQgdGhlIHNjZW5lcywgY2F1c2luZyBpc3N1ZXMgaWZcbiAgICAvLyBhbiBvYmplY3QncyB0byBzdHJpbmcgaGFzIGVzY2FwZWQgY2hhcmFjdGVycyBpbiBpdC5cbiAgICBzdHJpbmcgPSBcIlwiICsgc3RyaW5nO1xuXG4gICAgaWYoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkgeyByZXR1cm4gc3RyaW5nOyB9XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbiAgfVxuXG4gIF9fZXhwb3J0c19fLmVzY2FwZUV4cHJlc3Npb24gPSBlc2NhcGVFeHByZXNzaW9uO2Z1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBfX2V4cG9ydHNfXy5pc0VtcHR5ID0gaXNFbXB0eTtmdW5jdGlvbiBhcHBlbmRDb250ZXh0UGF0aChjb250ZXh0UGF0aCwgaWQpIHtcbiAgICByZXR1cm4gKGNvbnRleHRQYXRoID8gY29udGV4dFBhdGggKyAnLicgOiAnJykgKyBpZDtcbiAgfVxuXG4gIF9fZXhwb3J0c19fLmFwcGVuZENvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGg7XG4gIHJldHVybiBfX2V4cG9ydHNfXztcbn0pKF9fbW9kdWxlM19fKTtcblxuLy8gaGFuZGxlYmFycy9leGNlcHRpb24uanNcbnZhciBfX21vZHVsZTRfXyA9IChmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG4gIHZhciBfX2V4cG9ydHNfXztcblxuICB2YXIgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbiAgZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UsIG5vZGUpIHtcbiAgICB2YXIgbGluZTtcbiAgICBpZiAobm9kZSAmJiBub2RlLmZpcnN0TGluZSkge1xuICAgICAgbGluZSA9IG5vZGUuZmlyc3RMaW5lO1xuXG4gICAgICBtZXNzYWdlICs9ICcgLSAnICsgbGluZSArICc6JyArIG5vZGUuZmlyc3RDb2x1bW47XG4gICAgfVxuXG4gICAgdmFyIHRtcCA9IEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBlcnJvcnMgYXJlIG5vdCBlbnVtZXJhYmxlIGluIENocm9tZSAoYXQgbGVhc3QpLCBzbyBgZm9yIHByb3AgaW4gdG1wYCBkb2Vzbid0IHdvcmsuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZXJyb3JQcm9wcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICB0aGlzW2Vycm9yUHJvcHNbaWR4XV0gPSB0bXBbZXJyb3JQcm9wc1tpZHhdXTtcbiAgICB9XG5cbiAgICBpZiAobGluZSkge1xuICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcbiAgICAgIHRoaXMuY29sdW1uID0gbm9kZS5maXJzdENvbHVtbjtcbiAgICB9XG4gIH1cblxuICBFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbiAgX19leHBvcnRzX18gPSBFeGNlcHRpb247XG4gIHJldHVybiBfX2V4cG9ydHNfXztcbn0pKCk7XG5cbi8vIGhhbmRsZWJhcnMvYmFzZS5qc1xudmFyIF9fbW9kdWxlMV9fID0gKGZ1bmN0aW9uKF9fZGVwZW5kZW5jeTFfXywgX19kZXBlbmRlbmN5Ml9fKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19leHBvcnRzX18gPSB7fTtcbiAgdmFyIFV0aWxzID0gX19kZXBlbmRlbmN5MV9fO1xuICB2YXIgRXhjZXB0aW9uID0gX19kZXBlbmRlbmN5Ml9fO1xuXG4gIHZhciBWRVJTSU9OID0gXCIyLjAuMFwiO1xuICBfX2V4cG9ydHNfXy5WRVJTSU9OID0gVkVSU0lPTjt2YXIgQ09NUElMRVJfUkVWSVNJT04gPSA2O1xuICBfX2V4cG9ydHNfXy5DT01QSUxFUl9SRVZJU0lPTiA9IENPTVBJTEVSX1JFVklTSU9OO1xuICB2YXIgUkVWSVNJT05fQ0hBTkdFUyA9IHtcbiAgICAxOiAnPD0gMS4wLnJjLjInLCAvLyAxLjAucmMuMiBpcyBhY3R1YWxseSByZXYyIGJ1dCBkb2Vzbid0IHJlcG9ydCBpdFxuICAgIDI6ICc9PSAxLjAuMC1yYy4zJyxcbiAgICAzOiAnPT0gMS4wLjAtcmMuNCcsXG4gICAgNDogJz09IDEueC54JyxcbiAgICA1OiAnPT0gMi4wLjAtYWxwaGEueCcsXG4gICAgNjogJz49IDIuMC4wLWJldGEuMSdcbiAgfTtcbiAgX19leHBvcnRzX18uUkVWSVNJT05fQ0hBTkdFUyA9IFJFVklTSU9OX0NIQU5HRVM7XG4gIHZhciBpc0FycmF5ID0gVXRpbHMuaXNBcnJheSxcbiAgICAgIGlzRnVuY3Rpb24gPSBVdGlscy5pc0Z1bmN0aW9uLFxuICAgICAgdG9TdHJpbmcgPSBVdGlscy50b1N0cmluZyxcbiAgICAgIG9iamVjdFR5cGUgPSAnW29iamVjdCBPYmplY3RdJztcblxuICBmdW5jdGlvbiBIYW5kbGViYXJzRW52aXJvbm1lbnQoaGVscGVycywgcGFydGlhbHMpIHtcbiAgICB0aGlzLmhlbHBlcnMgPSBoZWxwZXJzIHx8IHt9O1xuICAgIHRoaXMucGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcblxuICAgIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnModGhpcyk7XG4gIH1cblxuICBfX2V4cG9ydHNfXy5IYW5kbGViYXJzRW52aXJvbm1lbnQgPSBIYW5kbGViYXJzRW52aXJvbm1lbnQ7SGFuZGxlYmFyc0Vudmlyb25tZW50LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogSGFuZGxlYmFyc0Vudmlyb25tZW50LFxuXG4gICAgbG9nZ2VyOiBsb2dnZXIsXG4gICAgbG9nOiBsb2csXG5cbiAgICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICAgIGlmIChmbikgeyB0aHJvdyBuZXcgRXhjZXB0aW9uKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGhlbHBlcnMnKTsgfVxuICAgICAgICBVdGlscy5leHRlbmQodGhpcy5oZWxwZXJzLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVscGVyc1tuYW1lXSA9IGZuO1xuICAgICAgfVxuICAgIH0sXG4gICAgdW5yZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgZGVsZXRlIHRoaXMuaGVscGVyc1tuYW1lXTtcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbihuYW1lLCBwYXJ0aWFsKSB7XG4gICAgICBpZiAodG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xuICAgICAgICBVdGlscy5leHRlbmQodGhpcy5wYXJ0aWFscywgIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWw7XG4gICAgICB9XG4gICAgfSxcbiAgICB1bnJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgZGVsZXRlIHRoaXMucGFydGlhbHNbbmFtZV07XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMoaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKC8qIFthcmdzLCBdb3B0aW9ucyAqLykge1xuICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBBIG1pc3NpbmcgZmllbGQgaW4gYSB7e2Zvb319IGNvbnN0dWN0LlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU29tZW9uZSBpcyBhY3R1YWxseSB0cnlpbmcgdG8gY2FsbCBzb21ldGhpbmcsIGJsb3cgdXAuXG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJNaXNzaW5nIGhlbHBlcjogJ1wiICsgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0ubmFtZSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdibG9ja0hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgICBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICAgIGlmKGNvbnRleHQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGZuKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmKGNvbnRleHQgPT09IGZhbHNlIHx8IGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgICBpZihjb250ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaWRzID0gW29wdGlvbnMubmFtZV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnMuZWFjaChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICAgIHZhciBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gVXRpbHMuYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICAgIG9wdGlvbnMgPSB7ZGF0YTogZGF0YX07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdNdXN0IHBhc3MgaXRlcmF0b3IgdG8gI2VhY2gnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZuID0gb3B0aW9ucy5mbiwgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZTtcbiAgICAgIHZhciBpID0gMCwgcmV0ID0gXCJcIiwgZGF0YTtcblxuICAgICAgdmFyIGNvbnRleHRQYXRoO1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBjb250ZXh0UGF0aCA9IFV0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0KSkgeyBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpOyB9XG5cbiAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICAgICAgZm9yKHZhciBqID0gY29udGV4dC5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICBkYXRhLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgZGF0YS5maXJzdCA9IChpID09PSAwKTtcbiAgICAgICAgICAgICAgZGF0YS5sYXN0ICA9IChpID09PSAoY29udGV4dC5sZW5ndGgtMSkpO1xuXG4gICAgICAgICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbaV0sIHsgZGF0YTogZGF0YSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yKHZhciBrZXkgaW4gY29udGV4dCkge1xuICAgICAgICAgICAgaWYoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIGlmKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmtleSA9IGtleTtcbiAgICAgICAgICAgICAgICBkYXRhLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBkYXRhLmZpcnN0ID0gKGkgPT09IDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gY29udGV4dFBhdGggKyBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRba2V5XSwge2RhdGE6IGRhdGF9KTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZihpID09PSAwKXtcbiAgICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9KTtcblxuICAgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihjb25kaXRpb25hbCkpIHsgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5jYWxsKHRoaXMpOyB9XG5cbiAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmVuZGVyIHRoZSBwb3NpdGl2ZSBwYXRoIGlmIHRoZSB2YWx1ZSBpcyB0cnV0aHkgYW5kIG5vdCBlbXB0eS5cbiAgICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXG4gICAgICAvLyBiZWhhdmlvciBvZiBpc0VtcHR5LiBFZmZlY3RpdmVseSB0aGlzIGRldGVybWluZXMgaWYgMCBpcyBoYW5kbGVkIGJ5IHRoZSBwb3NpdGl2ZSBwYXRoIG9yIG5lZ2F0aXZlLlxuICAgICAgaWYgKCghb3B0aW9ucy5oYXNoLmluY2x1ZGVaZXJvICYmICFjb25kaXRpb25hbCkgfHwgVXRpbHMuaXNFbXB0eShjb25kaXRpb25hbCkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3VubGVzcycsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVyc1snaWYnXS5jYWxsKHRoaXMsIGNvbmRpdGlvbmFsLCB7Zm46IG9wdGlvbnMuaW52ZXJzZSwgaW52ZXJzZTogb3B0aW9ucy5mbiwgaGFzaDogb3B0aW9ucy5oYXNofSk7XG4gICAgfSk7XG5cbiAgICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignd2l0aCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgICAgdmFyIGZuID0gb3B0aW9ucy5mbjtcblxuICAgICAgaWYgKCFVdGlscy5pc0VtcHR5KGNvbnRleHQpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IFV0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xuICAgICAgICAgIG9wdGlvbnMgPSB7ZGF0YTpkYXRhfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9nJywgZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGxldmVsID0gb3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuZGF0YS5sZXZlbCAhPSBudWxsID8gcGFyc2VJbnQob3B0aW9ucy5kYXRhLmxldmVsLCAxMCkgOiAxO1xuICAgICAgaW5zdGFuY2UubG9nKGxldmVsLCBtZXNzYWdlKTtcbiAgICB9KTtcblxuICAgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb29rdXAnLCBmdW5jdGlvbihvYmosIGZpZWxkKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9ialtmaWVsZF07XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbG9nZ2VyID0ge1xuICAgIG1ldGhvZE1hcDogeyAwOiAnZGVidWcnLCAxOiAnaW5mbycsIDI6ICd3YXJuJywgMzogJ2Vycm9yJyB9LFxuXG4gICAgLy8gU3RhdGUgZW51bVxuICAgIERFQlVHOiAwLFxuICAgIElORk86IDEsXG4gICAgV0FSTjogMixcbiAgICBFUlJPUjogMyxcbiAgICBsZXZlbDogMyxcblxuICAgIC8vIGNhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG4gICAgbG9nOiBmdW5jdGlvbihsZXZlbCwgbWVzc2FnZSkge1xuICAgICAgaWYgKGxvZ2dlci5sZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICB2YXIgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZVttZXRob2RdKSB7XG4gICAgICAgICAgY29uc29sZVttZXRob2RdLmNhbGwoY29uc29sZSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIF9fZXhwb3J0c19fLmxvZ2dlciA9IGxvZ2dlcjtcbiAgdmFyIGxvZyA9IGxvZ2dlci5sb2c7XG4gIF9fZXhwb3J0c19fLmxvZyA9IGxvZztcbiAgdmFyIGNyZWF0ZUZyYW1lID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGZyYW1lID0gVXRpbHMuZXh0ZW5kKHt9LCBvYmplY3QpO1xuICAgIGZyYW1lLl9wYXJlbnQgPSBvYmplY3Q7XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9O1xuICBfX2V4cG9ydHNfXy5jcmVhdGVGcmFtZSA9IGNyZWF0ZUZyYW1lO1xuICByZXR1cm4gX19leHBvcnRzX187XG59KShfX21vZHVsZTJfXywgX19tb2R1bGU0X18pO1xuXG4vLyBoYW5kbGViYXJzL3J1bnRpbWUuanNcbnZhciBfX21vZHVsZTVfXyA9IChmdW5jdGlvbihfX2RlcGVuZGVuY3kxX18sIF9fZGVwZW5kZW5jeTJfXywgX19kZXBlbmRlbmN5M19fKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICB2YXIgX19leHBvcnRzX18gPSB7fTtcbiAgdmFyIFV0aWxzID0gX19kZXBlbmRlbmN5MV9fO1xuICB2YXIgRXhjZXB0aW9uID0gX19kZXBlbmRlbmN5Ml9fO1xuICB2YXIgQ09NUElMRVJfUkVWSVNJT04gPSBfX2RlcGVuZGVuY3kzX18uQ09NUElMRVJfUkVWSVNJT047XG4gIHZhciBSRVZJU0lPTl9DSEFOR0VTID0gX19kZXBlbmRlbmN5M19fLlJFVklTSU9OX0NIQU5HRVM7XG4gIHZhciBjcmVhdGVGcmFtZSA9IF9fZGVwZW5kZW5jeTNfXy5jcmVhdGVGcmFtZTtcblxuICBmdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICAgIHZhciBjb21waWxlclJldmlzaW9uID0gY29tcGlsZXJJbmZvICYmIGNvbXBpbGVySW5mb1swXSB8fCAxLFxuICAgICAgICBjdXJyZW50UmV2aXNpb24gPSBDT01QSUxFUl9SRVZJU0lPTjtcblxuICAgIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcbiAgICAgIGlmIChjb21waWxlclJldmlzaW9uIDwgY3VycmVudFJldmlzaW9uKSB7XG4gICAgICAgIHZhciBydW50aW1lVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2N1cnJlbnRSZXZpc2lvbl0sXG4gICAgICAgICAgICBjb21waWxlclZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjb21waWxlclJldmlzaW9uXTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIlRlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGFuIG9sZGVyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuIFwiK1xuICAgICAgICAgICAgICBcIlBsZWFzZSB1cGRhdGUgeW91ciBwcmVjb21waWxlciB0byBhIG5ld2VyIHZlcnNpb24gKFwiK3J1bnRpbWVWZXJzaW9ucytcIikgb3IgZG93bmdyYWRlIHlvdXIgcnVudGltZSB0byBhbiBvbGRlciB2ZXJzaW9uIChcIitjb21waWxlclZlcnNpb25zK1wiKS5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgdGhlIGVtYmVkZGVkIHZlcnNpb24gaW5mbyBzaW5jZSB0aGUgcnVudGltZSBkb2Vzbid0IGtub3cgYWJvdXQgdGhpcyByZXZpc2lvbiB5ZXRcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIlRlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gXCIrXG4gICAgICAgICAgICAgIFwiUGxlYXNlIHVwZGF0ZSB5b3VyIHJ1bnRpbWUgdG8gYSBuZXdlciB2ZXJzaW9uIChcIitjb21waWxlckluZm9bMV0rXCIpLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfX2V4cG9ydHNfXy5jaGVja1JldmlzaW9uID0gY2hlY2tSZXZpc2lvbjsvLyBUT0RPOiBSZW1vdmUgdGhpcyBsaW5lIGFuZCBicmVhayB1cCBjb21waWxlUGFydGlhbFxuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlKHRlbXBsYXRlU3BlYywgZW52KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIWVudikge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIk5vIGVudmlyb25tZW50IHBhc3NlZCB0byB0ZW1wbGF0ZVwiKTtcbiAgICB9XG4gICAgaWYgKCF0ZW1wbGF0ZVNwZWMgfHwgIXRlbXBsYXRlU3BlYy5tYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHRlbXBsYXRlIG9iamVjdDogJyArIHR5cGVvZiB0ZW1wbGF0ZVNwZWMpO1xuICAgIH1cblxuICAgIC8vIE5vdGU6IFVzaW5nIGVudi5WTSByZWZlcmVuY2VzIHJhdGhlciB0aGFuIGxvY2FsIHZhciByZWZlcmVuY2VzIHRocm91Z2hvdXQgdGhpcyBzZWN0aW9uIHRvIGFsbG93XG4gICAgLy8gZm9yIGV4dGVybmFsIHVzZXJzIHRvIG92ZXJyaWRlIHRoZXNlIGFzIHBzdWVkby1zdXBwb3J0ZWQgQVBJcy5cbiAgICBlbnYuVk0uY2hlY2tSZXZpc2lvbih0ZW1wbGF0ZVNwZWMuY29tcGlsZXIpO1xuXG4gICAgdmFyIGludm9rZVBhcnRpYWxXcmFwcGVyID0gZnVuY3Rpb24ocGFydGlhbCwgaW5kZW50LCBuYW1lLCBjb250ZXh0LCBoYXNoLCBoZWxwZXJzLCBwYXJ0aWFscywgZGF0YSwgZGVwdGhzKSB7XG4gICAgICBpZiAoaGFzaCkge1xuICAgICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBoYXNoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGVudi5WTS5pbnZva2VQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgbmFtZSwgY29udGV4dCwgaGVscGVycywgcGFydGlhbHMsIGRhdGEsIGRlcHRocyk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBlbnYuY29tcGlsZSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHsgaGVscGVyczogaGVscGVycywgcGFydGlhbHM6IHBhcnRpYWxzLCBkYXRhOiBkYXRhLCBkZXB0aHM6IGRlcHRocyB9O1xuICAgICAgICBwYXJ0aWFsc1tuYW1lXSA9IGVudi5jb21waWxlKHBhcnRpYWwsIHsgZGF0YTogZGF0YSAhPT0gdW5kZWZpbmVkLCBjb21wYXQ6IHRlbXBsYXRlU3BlYy5jb21wYXQgfSwgZW52KTtcbiAgICAgICAgcmVzdWx0ID0gcGFydGlhbHNbbmFtZV0oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGluZGVudCkge1xuICAgICAgICAgIHZhciBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghbGluZXNbaV0gJiYgaSArIDEgPT09IGwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVzW2ldID0gaW5kZW50ICsgbGluZXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiVGhlIHBhcnRpYWwgXCIgKyBuYW1lICsgXCIgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZVwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSnVzdCBhZGQgd2F0ZXJcbiAgICB2YXIgY29udGFpbmVyID0ge1xuICAgICAgbG9va3VwOiBmdW5jdGlvbihkZXB0aHMsIG5hbWUpIHtcbiAgICAgICAgdmFyIGxlbiA9IGRlcHRocy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoZGVwdGhzW2ldICYmIGRlcHRoc1tpXVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVwdGhzW2ldW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxhbWJkYTogZnVuY3Rpb24oY3VycmVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGN1cnJlbnQgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50LmNhbGwoY29udGV4dCkgOiBjdXJyZW50O1xuICAgICAgfSxcblxuICAgICAgZXNjYXBlRXhwcmVzc2lvbjogVXRpbHMuZXNjYXBlRXhwcmVzc2lvbixcbiAgICAgIGludm9rZVBhcnRpYWw6IGludm9rZVBhcnRpYWxXcmFwcGVyLFxuXG4gICAgICBmbjogZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVTcGVjW2ldO1xuICAgICAgfSxcblxuICAgICAgcHJvZ3JhbXM6IFtdLFxuICAgICAgcHJvZ3JhbTogZnVuY3Rpb24oaSwgZGF0YSwgZGVwdGhzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0sXG4gICAgICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XG4gICAgICAgIGlmIChkYXRhIHx8IGRlcHRocykge1xuICAgICAgICAgIHByb2dyYW1XcmFwcGVyID0gcHJvZ3JhbSh0aGlzLCBpLCBmbiwgZGF0YSwgZGVwdGhzKTtcbiAgICAgICAgfSBlbHNlIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcbiAgICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSBwcm9ncmFtKHRoaXMsIGksIGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZ3JhbVdyYXBwZXI7XG4gICAgICB9LFxuXG4gICAgICBkYXRhOiBmdW5jdGlvbihkYXRhLCBkZXB0aCkge1xuICAgICAgICB3aGlsZSAoZGF0YSAmJiBkZXB0aC0tKSB7XG4gICAgICAgICAgZGF0YSA9IGRhdGEuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0sXG4gICAgICBtZXJnZTogZnVuY3Rpb24ocGFyYW0sIGNvbW1vbikge1xuICAgICAgICB2YXIgcmV0ID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgKHBhcmFtICE9PSBjb21tb24pKSB7XG4gICAgICAgICAgcmV0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb21tb24sIHBhcmFtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuXG4gICAgICBub29wOiBlbnYuVk0ubm9vcCxcbiAgICAgIGNvbXBpbGVySW5mbzogdGVtcGxhdGVTcGVjLmNvbXBpbGVyXG4gICAgfTtcblxuICAgIHZhciByZXQgPSBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gICAgICByZXQuX3NldHVwKG9wdGlvbnMpO1xuICAgICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcbiAgICAgICAgZGF0YSA9IGluaXREYXRhKGNvbnRleHQsIGRhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIGRlcHRocztcbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzKSB7XG4gICAgICAgIGRlcHRocyA9IG9wdGlvbnMuZGVwdGhzID8gW2NvbnRleHRdLmNvbmNhdChvcHRpb25zLmRlcHRocykgOiBbY29udGV4dF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZW1wbGF0ZVNwZWMubWFpbi5jYWxsKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgZGF0YSwgZGVwdGhzKTtcbiAgICB9O1xuICAgIHJldC5pc1RvcCA9IHRydWU7XG5cbiAgICByZXQuX3NldHVwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcbiAgICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5oZWxwZXJzLCBlbnYuaGVscGVycyk7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsKSB7XG4gICAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMucGFydGlhbHMsIGVudi5wYXJ0aWFscyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gb3B0aW9ucy5oZWxwZXJzO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXQuX2NoaWxkID0gZnVuY3Rpb24oaSwgZGF0YSwgZGVwdGhzKSB7XG4gICAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocyAmJiAhZGVwdGhzKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBwYXJlbnQgZGVwdGhzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9ncmFtKGNvbnRhaW5lciwgaSwgdGVtcGxhdGVTcGVjW2ldLCBkYXRhLCBkZXB0aHMpO1xuICAgIH07XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIF9fZXhwb3J0c19fLnRlbXBsYXRlID0gdGVtcGxhdGU7ZnVuY3Rpb24gcHJvZ3JhbShjb250YWluZXIsIGksIGZuLCBkYXRhLCBkZXB0aHMpIHtcbiAgICB2YXIgcHJvZyA9IGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICByZXR1cm4gZm4uY2FsbChjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIG9wdGlvbnMuZGF0YSB8fCBkYXRhLCBkZXB0aHMgJiYgW2NvbnRleHRdLmNvbmNhdChkZXB0aHMpKTtcbiAgICB9O1xuICAgIHByb2cucHJvZ3JhbSA9IGk7XG4gICAgcHJvZy5kZXB0aCA9IGRlcHRocyA/IGRlcHRocy5sZW5ndGggOiAwO1xuICAgIHJldHVybiBwcm9nO1xuICB9XG5cbiAgX19leHBvcnRzX18ucHJvZ3JhbSA9IHByb2dyYW07ZnVuY3Rpb24gaW52b2tlUGFydGlhbChwYXJ0aWFsLCBuYW1lLCBjb250ZXh0LCBoZWxwZXJzLCBwYXJ0aWFscywgZGF0YSwgZGVwdGhzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7IHBhcnRpYWw6IHRydWUsIGhlbHBlcnM6IGhlbHBlcnMsIHBhcnRpYWxzOiBwYXJ0aWFscywgZGF0YTogZGF0YSwgZGVwdGhzOiBkZXB0aHMgfTtcblxuICAgIGlmKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIlRoZSBwYXJ0aWFsIFwiICsgbmFtZSArIFwiIGNvdWxkIG5vdCBiZSBmb3VuZFwiKTtcbiAgICB9IGVsc2UgaWYocGFydGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gcGFydGlhbChjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBfX2V4cG9ydHNfXy5pbnZva2VQYXJ0aWFsID0gaW52b2tlUGFydGlhbDtmdW5jdGlvbiBub29wKCkgeyByZXR1cm4gXCJcIjsgfVxuXG4gIF9fZXhwb3J0c19fLm5vb3AgPSBub29wO2Z1bmN0aW9uIGluaXREYXRhKGNvbnRleHQsIGRhdGEpIHtcbiAgICBpZiAoIWRhdGEgfHwgISgncm9vdCcgaW4gZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBkYXRhID8gY3JlYXRlRnJhbWUoZGF0YSkgOiB7fTtcbiAgICAgIGRhdGEucm9vdCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBfX2V4cG9ydHNfXztcbn0pKF9fbW9kdWxlMl9fLCBfX21vZHVsZTRfXywgX19tb2R1bGUxX18pO1xuXG4vLyBoYW5kbGViYXJzLnJ1bnRpbWUuanNcbnZhciBfX21vZHVsZTBfXyA9IChmdW5jdGlvbihfX2RlcGVuZGVuY3kxX18sIF9fZGVwZW5kZW5jeTJfXywgX19kZXBlbmRlbmN5M19fLCBfX2RlcGVuZGVuY3k0X18sIF9fZGVwZW5kZW5jeTVfXykge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIF9fZXhwb3J0c19fO1xuICAvKmdsb2JhbHMgSGFuZGxlYmFyczogdHJ1ZSAqL1xuICB2YXIgYmFzZSA9IF9fZGVwZW5kZW5jeTFfXztcblxuICAvLyBFYWNoIG9mIHRoZXNlIGF1Z21lbnQgdGhlIEhhbmRsZWJhcnMgb2JqZWN0LiBObyBuZWVkIHRvIHNldHVwIGhlcmUuXG4gIC8vIChUaGlzIGlzIGRvbmUgdG8gZWFzaWx5IHNoYXJlIGNvZGUgYmV0d2VlbiBjb21tb25qcyBhbmQgYnJvd3NlIGVudnMpXG4gIHZhciBTYWZlU3RyaW5nID0gX19kZXBlbmRlbmN5Ml9fO1xuICB2YXIgRXhjZXB0aW9uID0gX19kZXBlbmRlbmN5M19fO1xuICB2YXIgVXRpbHMgPSBfX2RlcGVuZGVuY3k0X187XG4gIHZhciBydW50aW1lID0gX19kZXBlbmRlbmN5NV9fO1xuXG4gIC8vIEZvciBjb21wYXRpYmlsaXR5IGFuZCB1c2FnZSBvdXRzaWRlIG9mIG1vZHVsZSBzeXN0ZW1zLCBtYWtlIHRoZSBIYW5kbGViYXJzIG9iamVjdCBhIG5hbWVzcGFjZVxuICB2YXIgY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgICBVdGlscy5leHRlbmQoaGIsIGJhc2UpO1xuICAgIGhiLlNhZmVTdHJpbmcgPSBTYWZlU3RyaW5nO1xuICAgIGhiLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgICBoYi5VdGlscyA9IFV0aWxzO1xuICAgIGhiLmVzY2FwZUV4cHJlc3Npb24gPSBVdGlscy5lc2NhcGVFeHByZXNzaW9uO1xuXG4gICAgaGIuVk0gPSBydW50aW1lO1xuICAgIGhiLnRlbXBsYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgICAgcmV0dXJuIHJ1bnRpbWUudGVtcGxhdGUoc3BlYywgaGIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaGI7XG4gIH07XG5cbiAgdmFyIEhhbmRsZWJhcnMgPSBjcmVhdGUoKTtcbiAgSGFuZGxlYmFycy5jcmVhdGUgPSBjcmVhdGU7XG5cbiAgSGFuZGxlYmFyc1snZGVmYXVsdCddID0gSGFuZGxlYmFycztcblxuICBfX2V4cG9ydHNfXyA9IEhhbmRsZWJhcnM7XG4gIHJldHVybiBfX2V4cG9ydHNfXztcbn0pKF9fbW9kdWxlMV9fLCBfX21vZHVsZTNfXywgX19tb2R1bGU0X18sIF9fbW9kdWxlMl9fLCBfX21vZHVsZTVfXyk7XG5cbiAgcmV0dXJuIF9fbW9kdWxlMF9fO1xufSkpO1xuIiwiLypcbiAqIGNhdGJlcnJ5LWhhbmRsZWJhcnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgRGVuaXMgUmVjaGt1bm92IGFuZCBwcm9qZWN0IGNvbnRyaWJ1dG9ycy5cbiAqXG4gKiBjYXRiZXJyeS1oYW5kbGViYXJzJ3MgbGljZW5zZSBmb2xsb3dzOlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcbiAqIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgbGljZW5zZSBhcHBsaWVzIHRvIGFsbCBwYXJ0cyBvZiBjYXRiZXJyeS1oYW5kbGViYXJzIHRoYXRcbiAqIGFyZSBub3QgZXh0ZXJuYWxseSBtYWludGFpbmVkIGxpYnJhcmllcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBIYW5kbGViYXJzID0gcmVxdWlyZSgnLi9saWIvdmVuZG9ycy9oYW5kbGViYXJzJyksXG4gICAgVGVtcGxhdGVQcm92aWRlciA9IHJlcXVpcmUoJy4vbGliL1RlbXBsYXRlUHJvdmlkZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChsb2NhdG9yLCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgICAgICBsb2NhdG9yLnJlZ2lzdGVySW5zdGFuY2UoJ2hhbmRsZWJhcnMnLCBIYW5kbGViYXJzKTtcbiAgICAgICAgbG9jYXRvci5yZWdpc3RlcigndGVtcGxhdGVQcm92aWRlcicsIFRlbXBsYXRlUHJvdmlkZXIsIGNvbmZpZywgdHJ1ZSk7XG4gICAgfSxcbiAgICBIYW5kbGViYXJzOiBIYW5kbGViYXJzLFxuICAgIFRlbXBsYXRlUHJvdmlkZXI6IFRlbXBsYXRlUHJvdmlkZXJcbn07XG4iXX0=
